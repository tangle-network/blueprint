#![allow(clippy::all)]

#[doc = "\n\nGenerated by the following Solidity interface...\n```solidity\ninterface IncredibleSquaringTaskManager {\n    struct CheckSignaturesIndices {\n        uint32[] nonSignerQuorumBitmapIndices;\n        uint32[] quorumApkIndices;\n        uint32[] totalStakeIndices;\n        uint32[][] nonSignerStakeIndices;\n    }\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n    struct NonSignerStakesAndSignature {\n        uint32[] nonSignerQuorumBitmapIndices;\n        G1Point[] nonSignerPubkeys;\n        G1Point[] quorumApks;\n        G2Point apkG2;\n        G1Point sigma;\n        uint32[] quorumApkIndices;\n        uint32[] totalStakeIndices;\n        uint32[][] nonSignerStakeIndices;\n    }\n    struct Operator {\n        address operator;\n        bytes32 operatorId;\n        uint96 stake;\n    }\n    struct QuorumStakeTotals {\n        uint96[] signedStakeForQuorum;\n        uint96[] totalStakeForQuorum;\n    }\n    struct Task {\n        uint256 numberToBeSquared;\n        uint32 taskCreatedBlock;\n        bytes quorumNumbers;\n        uint32 quorumThresholdPercentage;\n    }\n    struct TaskResponse {\n        uint32 referenceTaskIndex;\n        uint256 numberSquared;\n    }\n    struct TaskResponseMetadata {\n        uint32 taskResponsedBlock;\n        bytes32 hashOfNonSigners;\n    }\n\n    event Initialized(uint8 version);\n    event NewTaskCreated(uint32 indexed taskIndex, Task task);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Paused(address indexed account, uint256 newPausedStatus);\n    event PauserRegistrySet(address pauserRegistry, address newPauserRegistry);\n    event StaleStakesForbiddenUpdate(bool value);\n    event TaskChallengedSuccessfully(uint32 indexed taskIndex, address indexed challenger);\n    event TaskChallengedUnsuccessfully(uint32 indexed taskIndex, address indexed challenger);\n    event TaskCompleted(uint32 indexed taskIndex);\n    event TaskResponded(TaskResponse taskResponse, TaskResponseMetadata taskResponseMetadata);\n    event Unpaused(address indexed account, uint256 newPausedStatus);\n\n    constructor(address _registryCoordinator, uint32 _taskResponseWindowBlock);\n\n    function TASK_CHALLENGE_WINDOW_BLOCK() external view returns (uint32);\n    function TASK_RESPONSE_WINDOW_BLOCK() external view returns (uint32);\n    function aggregator() external view returns (address);\n    function allTaskHashes(uint32) external view returns (bytes32);\n    function allTaskResponses(uint32) external view returns (bytes32);\n    function blsApkRegistry() external view returns (address);\n    function checkSignatures(bytes32 msgHash, bytes memory quorumNumbers, uint32 referenceBlockNumber, NonSignerStakesAndSignature memory params) external view returns (QuorumStakeTotals memory, bytes32);\n    function createNewTask(uint256 numberToBeSquared, uint32 quorumThresholdPercentage, bytes memory quorumNumbers) external;\n    function delegation() external view returns (address);\n    function generator() external view returns (address);\n    function getCheckSignaturesIndices(address registryCoordinator, uint32 referenceBlockNumber, bytes memory quorumNumbers, bytes32[] memory nonSignerOperatorIds) external view returns (CheckSignaturesIndices memory);\n    function getOperatorState(address registryCoordinator, bytes memory quorumNumbers, uint32 blockNumber) external view returns (Operator[][] memory);\n    function getOperatorState(address registryCoordinator, bytes32 operatorId, uint32 blockNumber) external view returns (uint256, Operator[][] memory);\n    function getQuorumBitmapsAtBlockNumber(address registryCoordinator, bytes32[] memory operatorIds, uint32 blockNumber) external view returns (uint256[] memory);\n    function getTaskResponseWindowBlock() external view returns (uint32);\n    function initialize(address _pauserRegistry, address initialOwner, address _aggregator, address _generator) external;\n    function latestTaskNum() external view returns (uint32);\n    function owner() external view returns (address);\n    function pause(uint256 newPausedStatus) external;\n    function pauseAll() external;\n    function paused(uint8 index) external view returns (bool);\n    function paused() external view returns (uint256);\n    function pauserRegistry() external view returns (address);\n    function raiseAndResolveChallenge(Task memory task, TaskResponse memory taskResponse, TaskResponseMetadata memory taskResponseMetadata, G1Point[] memory pubkeysOfNonSigningOperators) external;\n    function registryCoordinator() external view returns (address);\n    function renounceOwnership() external;\n    function respondToTask(Task memory task, TaskResponse memory taskResponse, NonSignerStakesAndSignature memory nonSignerStakesAndSignature) external;\n    function setPauserRegistry(address newPauserRegistry) external;\n    function setStaleStakesForbidden(bool value) external;\n    function stakeRegistry() external view returns (address);\n    function staleStakesForbidden() external view returns (bool);\n    function taskNumber() external view returns (uint32);\n    function taskSuccesfullyChallenged(uint32) external view returns (bool);\n    function transferOwnership(address newOwner) external;\n    function trySignatureAndApkVerification(bytes32 msgHash, G1Point memory apk, G2Point memory apkG2, G1Point memory sigma) external view returns (bool pairingSuccessful, bool siganatureIsValid);\n    function unpause(uint256 newPausedStatus) external;\n}\n```\n\n...which was generated by the following JSON ABI:\n```json\n[\n  {\n    \"type\": \"constructor\",\n    \"inputs\": [\n      {\n        \"name\": \"_registryCoordinator\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IRegistryCoordinator\"\n      },\n      {\n        \"name\": \"_taskResponseWindowBlock\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"TASK_CHALLENGE_WINDOW_BLOCK\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"TASK_RESPONSE_WINDOW_BLOCK\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"aggregator\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"allTaskHashes\",\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"allTaskResponses\",\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"blsApkRegistry\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IBLSApkRegistry\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"checkSignatures\",\n    \"inputs\": [\n      {\n        \"name\": \"msgHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      },\n      {\n        \"name\": \"referenceBlockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"params\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IBLSSignatureChecker.NonSignerStakesAndSignature\",\n        \"components\": [\n          {\n            \"name\": \"nonSignerQuorumBitmapIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"nonSignerPubkeys\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct BN254.G1Point[]\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"quorumApks\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct BN254.G1Point[]\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"apkG2\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G2Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256[2]\",\n                \"internalType\": \"uint256[2]\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256[2]\",\n                \"internalType\": \"uint256[2]\"\n              }\n            ]\n          },\n          {\n            \"name\": \"sigma\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G1Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"quorumApkIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"totalStakeIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"nonSignerStakeIndices\",\n            \"type\": \"uint32[][]\",\n            \"internalType\": \"uint32[][]\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IBLSSignatureChecker.QuorumStakeTotals\",\n        \"components\": [\n          {\n            \"name\": \"signedStakeForQuorum\",\n            \"type\": \"uint96[]\",\n            \"internalType\": \"uint96[]\"\n          },\n          {\n            \"name\": \"totalStakeForQuorum\",\n            \"type\": \"uint96[]\",\n            \"internalType\": \"uint96[]\"\n          }\n        ]\n      },\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"createNewTask\",\n    \"inputs\": [\n      {\n        \"name\": \"numberToBeSquared\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"quorumThresholdPercentage\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"delegation\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IDelegationManager\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"generator\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getCheckSignaturesIndices\",\n    \"inputs\": [\n      {\n        \"name\": \"registryCoordinator\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IRegistryCoordinator\"\n      },\n      {\n        \"name\": \"referenceBlockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      },\n      {\n        \"name\": \"nonSignerOperatorIds\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct OperatorStateRetriever.CheckSignaturesIndices\",\n        \"components\": [\n          {\n            \"name\": \"nonSignerQuorumBitmapIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"quorumApkIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"totalStakeIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"nonSignerStakeIndices\",\n            \"type\": \"uint32[][]\",\n            \"internalType\": \"uint32[][]\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorState\",\n    \"inputs\": [\n      {\n        \"name\": \"registryCoordinator\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IRegistryCoordinator\"\n      },\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      },\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple[][]\",\n        \"internalType\": \"struct OperatorStateRetriever.Operator[][]\",\n        \"components\": [\n          {\n            \"name\": \"operator\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"operatorId\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"stake\",\n            \"type\": \"uint96\",\n            \"internalType\": \"uint96\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorState\",\n    \"inputs\": [\n      {\n        \"name\": \"registryCoordinator\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IRegistryCoordinator\"\n      },\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"\",\n        \"type\": \"tuple[][]\",\n        \"internalType\": \"struct OperatorStateRetriever.Operator[][]\",\n        \"components\": [\n          {\n            \"name\": \"operator\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          },\n          {\n            \"name\": \"operatorId\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"stake\",\n            \"type\": \"uint96\",\n            \"internalType\": \"uint96\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getQuorumBitmapsAtBlockNumber\",\n    \"inputs\": [\n      {\n        \"name\": \"registryCoordinator\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IRegistryCoordinator\"\n      },\n      {\n        \"name\": \"operatorIds\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      },\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256[]\",\n        \"internalType\": \"uint256[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getTaskResponseWindowBlock\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"initialize\",\n    \"inputs\": [\n      {\n        \"name\": \"_pauserRegistry\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IPauserRegistry\"\n      },\n      {\n        \"name\": \"initialOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_aggregator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_generator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"latestTaskNum\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"owner\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"pause\",\n    \"inputs\": [\n      {\n        \"name\": \"newPausedStatus\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"pauseAll\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"paused\",\n    \"inputs\": [\n      {\n        \"name\": \"index\",\n        \"type\": \"uint8\",\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"paused\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"pauserRegistry\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IPauserRegistry\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"raiseAndResolveChallenge\",\n    \"inputs\": [\n      {\n        \"name\": \"task\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IIncredibleSquaringTaskManager.Task\",\n        \"components\": [\n          {\n            \"name\": \"numberToBeSquared\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"taskCreatedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"quorumNumbers\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"quorumThresholdPercentage\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          }\n        ]\n      },\n      {\n        \"name\": \"taskResponse\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IIncredibleSquaringTaskManager.TaskResponse\",\n        \"components\": [\n          {\n            \"name\": \"referenceTaskIndex\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"numberSquared\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"taskResponseMetadata\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IIncredibleSquaringTaskManager.TaskResponseMetadata\",\n        \"components\": [\n          {\n            \"name\": \"taskResponsedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"hashOfNonSigners\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          }\n        ]\n      },\n      {\n        \"name\": \"pubkeysOfNonSigningOperators\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct BN254.G1Point[]\",\n        \"components\": [\n          {\n            \"name\": \"X\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"Y\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registryCoordinator\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IRegistryCoordinator\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"renounceOwnership\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"respondToTask\",\n    \"inputs\": [\n      {\n        \"name\": \"task\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IIncredibleSquaringTaskManager.Task\",\n        \"components\": [\n          {\n            \"name\": \"numberToBeSquared\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"taskCreatedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"quorumNumbers\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"quorumThresholdPercentage\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          }\n        ]\n      },\n      {\n        \"name\": \"taskResponse\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IIncredibleSquaringTaskManager.TaskResponse\",\n        \"components\": [\n          {\n            \"name\": \"referenceTaskIndex\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"numberSquared\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"nonSignerStakesAndSignature\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IBLSSignatureChecker.NonSignerStakesAndSignature\",\n        \"components\": [\n          {\n            \"name\": \"nonSignerQuorumBitmapIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"nonSignerPubkeys\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct BN254.G1Point[]\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"quorumApks\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct BN254.G1Point[]\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"apkG2\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G2Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256[2]\",\n                \"internalType\": \"uint256[2]\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256[2]\",\n                \"internalType\": \"uint256[2]\"\n              }\n            ]\n          },\n          {\n            \"name\": \"sigma\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G1Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"quorumApkIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"totalStakeIndices\",\n            \"type\": \"uint32[]\",\n            \"internalType\": \"uint32[]\"\n          },\n          {\n            \"name\": \"nonSignerStakeIndices\",\n            \"type\": \"uint32[][]\",\n            \"internalType\": \"uint32[][]\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setPauserRegistry\",\n    \"inputs\": [\n      {\n        \"name\": \"newPauserRegistry\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IPauserRegistry\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setStaleStakesForbidden\",\n    \"inputs\": [\n      {\n        \"name\": \"value\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"stakeRegistry\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IStakeRegistry\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"staleStakesForbidden\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"taskNumber\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"taskSuccesfullyChallenged\",\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"transferOwnership\",\n    \"inputs\": [\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"trySignatureAndApkVerification\",\n    \"inputs\": [\n      {\n        \"name\": \"msgHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"apk\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct BN254.G1Point\",\n        \"components\": [\n          {\n            \"name\": \"X\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"Y\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"apkG2\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct BN254.G2Point\",\n        \"components\": [\n          {\n            \"name\": \"X\",\n            \"type\": \"uint256[2]\",\n            \"internalType\": \"uint256[2]\"\n          },\n          {\n            \"name\": \"Y\",\n            \"type\": \"uint256[2]\",\n            \"internalType\": \"uint256[2]\"\n          }\n        ]\n      },\n      {\n        \"name\": \"sigma\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct BN254.G1Point\",\n        \"components\": [\n          {\n            \"name\": \"X\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"Y\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"pairingSuccessful\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      },\n      {\n        \"name\": \"siganatureIsValid\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"unpause\",\n    \"inputs\": [\n      {\n        \"name\": \"newPausedStatus\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Initialized\",\n    \"inputs\": [\n      {\n        \"name\": \"version\",\n        \"type\": \"uint8\",\n        \"indexed\": false,\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"NewTaskCreated\",\n    \"inputs\": [\n      {\n        \"name\": \"taskIndex\",\n        \"type\": \"uint32\",\n        \"indexed\": true,\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"task\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IIncredibleSquaringTaskManager.Task\",\n        \"components\": [\n          {\n            \"name\": \"numberToBeSquared\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"taskCreatedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"quorumNumbers\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"quorumThresholdPercentage\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          }\n        ]\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OwnershipTransferred\",\n    \"inputs\": [\n      {\n        \"name\": \"previousOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Paused\",\n    \"inputs\": [\n      {\n        \"name\": \"account\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newPausedStatus\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"PauserRegistrySet\",\n    \"inputs\": [\n      {\n        \"name\": \"pauserRegistry\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"contract IPauserRegistry\"\n      },\n      {\n        \"name\": \"newPauserRegistry\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"contract IPauserRegistry\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"StaleStakesForbiddenUpdate\",\n    \"inputs\": [\n      {\n        \"name\": \"value\",\n        \"type\": \"bool\",\n        \"indexed\": false,\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"TaskChallengedSuccessfully\",\n    \"inputs\": [\n      {\n        \"name\": \"taskIndex\",\n        \"type\": \"uint32\",\n        \"indexed\": true,\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"challenger\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"TaskChallengedUnsuccessfully\",\n    \"inputs\": [\n      {\n        \"name\": \"taskIndex\",\n        \"type\": \"uint32\",\n        \"indexed\": true,\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"challenger\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"TaskCompleted\",\n    \"inputs\": [\n      {\n        \"name\": \"taskIndex\",\n        \"type\": \"uint32\",\n        \"indexed\": true,\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"TaskResponded\",\n    \"inputs\": [\n      {\n        \"name\": \"taskResponse\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IIncredibleSquaringTaskManager.TaskResponse\",\n        \"components\": [\n          {\n            \"name\": \"referenceTaskIndex\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"numberSquared\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"taskResponseMetadata\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IIncredibleSquaringTaskManager.TaskResponseMetadata\",\n        \"components\": [\n          {\n            \"name\": \"taskResponsedBlock\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"hashOfNonSigners\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          }\n        ]\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Unpaused\",\n    \"inputs\": [\n      {\n        \"name\": \"account\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newPausedStatus\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  }\n]\n```"]
#[allow(missing_docs)]
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod IncredibleSquaringTaskManager {
    use super::*;
    use ::alloy_sol_types;
    use serde::{Deserialize, Serialize};
    #[doc = r" The creation / init bytecode of the contract."]
    #[doc = r""]
    #[doc = r" ```text"]
    #[doc = "0x6101206040523480156200001257600080fd5b5060405162005e4b38038062005e4b8339810160408190526200003591620001f7565b81806001600160a01b03166080816001600160a01b031681525050806001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200008f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000b591906200023e565b6001600160a01b031660a0816001600160a01b031681525050806001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200010d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200013391906200023e565b6001600160a01b031660c0816001600160a01b03168152505060a0516001600160a01b031663df5cf7236040518163ffffffff1660e01b8152600401602060405180830381865afa1580156200018d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001b391906200023e565b6001600160a01b031660e052506097805460ff1916600117905563ffffffff16610100525062000265565b6001600160a01b0381168114620001f457600080fd5b50565b600080604083850312156200020b57600080fd5b82516200021881620001de565b602084015190925063ffffffff811681146200023357600080fd5b809150509250929050565b6000602082840312156200025157600080fd5b81516200025e81620001de565b9392505050565b60805160a05160c05160e05161010051615b54620002f76000396000818161027d0152818161059c015261195e0152600081816105650152612bf201526000818161041e0152818161224d0152612dd401526000818161044501528181612faa015261316c01526000818161049201528181610e0b015281816128dc01528181612a550152612c8f0152615b546000f3fe608060405234801561001057600080fd5b506004361061021c5760003560e01c80636b532e9e116101255780638da5cb5b116100ad578063f2fde38b1161007c578063f2fde38b14610587578063f5c9899d1461059a578063f63c5bab146105c0578063f8c8765e146105c8578063fabc1cbc146105db57600080fd5b80638da5cb5b14610521578063b98d090814610532578063cefdc1d41461053f578063df5cf7231461056057600080fd5b8063715018a6116100f4578063715018a6146104d557806372d18e8d146104dd5780637afa1eed146104eb578063886f1195146104fe5780638b00ce7c1461051157600080fd5b80636b532e9e146104675780636b92787e1461047a5780636d14a9871461048d5780636efb4636146104b457600080fd5b80634f739f74116101a85780635c155662116101775780635c155662146103ce5780635c975abb146103ee5780635decc3f5146103f65780635df4594614610419578063683048351461044057600080fd5b80634f739f7414610360578063595c6a67146103805780635ac86ab7146103885780635baec9a0146103bb57600080fd5b8063245a7bfc116101ef578063245a7bfc146102b45780632cb223d5146102df5780632d89f6fc1461030d5780633563b0d11461032d578063416c7e5e1461034d57600080fd5b806310d67a2f14610221578063136439dd14610236578063171f1d5b146102495780631ad4318914610278575b600080fd5b61023461022f3660046146c2565b6105ee565b005b6102346102443660046146df565b6106aa565b61025c610257366004614849565b6107e9565b6040805192151583529015156020830152015b60405180910390f35b61029f7f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff909116815260200161026f565b60cd546102c7906001600160a01b031681565b6040516001600160a01b03909116815260200161026f565b6102ff6102ed3660046148b7565b60cb6020526000908152604090205481565b60405190815260200161026f565b6102ff61031b3660046148b7565b60ca6020526000908152604090205481565b61034061033b3660046148d4565b610973565b60405161026f9190614a2f565b61023461035b366004614a57565b610e09565b61037361036e366004614abc565b610f7e565b60405161026f9190614bc0565b6102346116a6565b6103ab610396366004614c8a565b606654600160ff9092169190911b9081161490565b604051901515815260200161026f565b6102346103c9366004614f75565b61176d565b6103e16103dc366004614fe9565b611bec565b60405161026f9190615095565b6066546102ff565b6103ab6104043660046148b7565b60cc6020526000908152604090205460ff1681565b6102c77f000000000000000000000000000000000000000000000000000000000000000081565b6102c77f000000000000000000000000000000000000000000000000000000000000000081565b6102346104753660046150d9565b611db4565b61023461048836600461515f565b612386565b6102c77f000000000000000000000000000000000000000000000000000000000000000081565b6104c76104c23660046151ba565b612527565b60405161026f92919061527a565b610234613421565b60c95463ffffffff1661029f565b60ce546102c7906001600160a01b031681565b6065546102c7906001600160a01b031681565b60c95461029f9063ffffffff1681565b6033546001600160a01b03166102c7565b6097546103ab9060ff1681565b61055261054d3660046152c3565b613435565b60405161026f929190615305565b6102c77f000000000000000000000000000000000000000000000000000000000000000081565b6102346105953660046146c2565b6135c7565b7f000000000000000000000000000000000000000000000000000000000000000061029f565b61029f606481565b6102346105d6366004615326565b61363d565b6102346105e93660046146df565b61378e565b606560009054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610641573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106659190615382565b6001600160a01b0316336001600160a01b03161461069e5760405162461bcd60e51b81526004016106959061539f565b60405180910390fd5b6106a7816138ea565b50565b60655460405163237dfb4760e11b81523360048201526001600160a01b03909116906346fbf68e90602401602060405180830381865afa1580156106f2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061071691906153e9565b6107325760405162461bcd60e51b815260040161069590615406565b606654818116146107ab5760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e70617573653a20696e76616c696420617474656d70742060448201527f746f20756e70617573652066756e6374696f6e616c69747900000000000000006064820152608401610695565b606681905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d906020015b60405180910390a250565b60008060007f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001878760000151886020015188600001516000600281106108315761083161544e565b60200201518951600160200201518a602001516000600281106108565761085661544e565b60200201518b602001516001600281106108725761087261544e565b602090810291909101518c518d8301516040516108cf9a99989796959401988952602089019790975260408801959095526060870193909352608086019190915260a085015260c084015260e08301526101008201526101200190565b6040516020818303038152906040528051906020012060001c6108f29190615464565b905061096561090b61090488846139e1565b8690613a72565b610913613b07565b61095b61094c85610946604080518082018252600080825260209182015281518083019092526001825260029082015290565b906139e1565b6109558c613bc7565b90613a72565b886201d4c0613c56565b909890975095505050505050565b60606000846001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d99190615382565b90506000856001600160a01b0316639e9923c26040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a3f9190615382565b90506000866001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa59190615382565b9050600086516001600160401b03811115610ac257610ac26146f8565b604051908082528060200260200182016040528015610af557816020015b6060815260200190600190039081610ae05790505b50905060005b8751811015610dfd576000888281518110610b1857610b1861544e565b0160200151604051638902624560e01b815260f89190911c6004820181905263ffffffff8a16602483015291506000906001600160a01b03871690638902624590604401600060405180830381865afa158015610b79573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610ba19190810190615486565b905080516001600160401b03811115610bbc57610bbc6146f8565b604051908082528060200260200182016040528015610c0757816020015b6040805160608101825260008082526020808301829052928201528252600019909201910181610bda5790505b50848481518110610c1a57610c1a61544e565b602002602001018190525060005b8151811015610de7576040518060600160405280876001600160a01b03166347b314e8858581518110610c5d57610c5d61544e565b60200260200101516040518263ffffffff1660e01b8152600401610c8391815260200190565b602060405180830381865afa158015610ca0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cc49190615382565b6001600160a01b03168152602001838381518110610ce457610ce461544e565b60200260200101518152602001896001600160a01b031663fa28c627858581518110610d1257610d1261544e565b60209081029190910101516040516001600160e01b031960e084901b168152600481019190915260ff8816602482015263ffffffff8f166044820152606401602060405180830381865afa158015610d6e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d929190615516565b6001600160601b0316815250858581518110610db057610db061544e565b60200260200101518281518110610dc957610dc961544e565b60200260200101819052508080610ddf90615555565b915050610c28565b5050508080610df590615555565b915050610afb565b50979650505050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e67573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8b9190615382565b6001600160a01b0316336001600160a01b031614610f375760405162461bcd60e51b815260206004820152605c60248201527f424c535369676e6174757265436865636b65722e6f6e6c79436f6f7264696e6160448201527f746f724f776e65723a2063616c6c6572206973206e6f7420746865206f776e6560648201527f72206f6620746865207265676973747279436f6f7264696e61746f7200000000608482015260a401610695565b6097805460ff19168215159081179091556040519081527f40e4ed880a29e0f6ddce307457fb75cddf4feef7d3ecb0301bfdf4976a0e2dfc9060200160405180910390a150565b610fa96040518060800160405280606081526020016060815260200160608152602001606081525090565b6000876001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa158015610fe9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061100d9190615382565b905061103a6040518060800160405280606081526020016060815260200160608152602001606081525090565b6040516361c8a12f60e11b81526001600160a01b038a169063c391425e9061106a908b908990899060040161556e565b600060405180830381865afa158015611087573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526110af91908101906155b5565b81526040516340e03a8160e11b81526001600160a01b038316906381c07502906110e1908b908b908b9060040161566c565b600060405180830381865afa1580156110fe573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261112691908101906155b5565b6040820152856001600160401b03811115611143576111436146f8565b60405190808252806020026020018201604052801561117657816020015b60608152602001906001900390816111615790505b50606082015260005b60ff81168711156115b7576000856001600160401b038111156111a4576111a46146f8565b6040519080825280602002602001820160405280156111cd578160200160208202803683370190505b5083606001518360ff16815181106111e7576111e761544e565b602002602001018190525060005b868110156114b75760008c6001600160a01b03166304ec63518a8a858181106112205761122061544e565b905060200201358e8860000151868151811061123e5761123e61544e565b60200260200101516040518463ffffffff1660e01b815260040161127b9392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015611298573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112bc9190615695565b9050806001600160c01b03166000036113635760405162461bcd60e51b815260206004820152605c60248201527f4f70657261746f7253746174655265747269657665722e676574436865636b5360448201527f69676e617475726573496e64696365733a206f70657261746f72206d7573742060648201527f6265207265676973746572656420617420626c6f636b6e756d62657200000000608482015260a401610695565b8a8a8560ff168181106113785761137861544e565b60016001600160c01b038516919093013560f81c1c821690910390506114a457856001600160a01b031663dd9846b98a8a858181106113b9576113b961544e565b905060200201358d8d8860ff168181106113d5576113d561544e565b6040516001600160e01b031960e087901b1681526004810194909452919091013560f81c60248301525063ffffffff8f166044820152606401602060405180830381865afa15801561142b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061144f91906156be565b85606001518560ff16815181106114685761146861544e565b602002602001015184815181106114815761148161544e565b63ffffffff90921660209283029190910190910152826114a081615555565b9350505b50806114af81615555565b9150506111f5565b506000816001600160401b038111156114d2576114d26146f8565b6040519080825280602002602001820160405280156114fb578160200160208202803683370190505b50905060005b8281101561157c5784606001518460ff16815181106115225761152261544e565b6020026020010151818151811061153b5761153b61544e565b60200260200101518282815181106115555761155561544e565b63ffffffff909216602092830291909101909101528061157481615555565b915050611501565b508084606001518460ff16815181106115975761159761544e565b6020026020010181905250505080806115af906156db565b91505061117f565b506000896001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa1580156115f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161c9190615382565b60405163354952a360e21b81529091506001600160a01b0382169063d5254a8c9061164f908b908b908e906004016156fa565b600060405180830381865afa15801561166c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261169491908101906155b5565b60208301525098975050505050505050565b60655460405163237dfb4760e11b81523360048201526001600160a01b03909116906346fbf68e90602401602060405180830381865afa1580156116ee573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061171291906153e9565b61172e5760405162461bcd60e51b815260040161069590615406565b600019606681905560405190815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2565b60cd546001600160a01b031633146117c75760405162461bcd60e51b815260206004820152601d60248201527f41676772656761746f72206d757374206265207468652063616c6c65720000006044820152606401610695565b60006117d960408501602086016148b7565b90503660006117eb6040870187615724565b9092509050600061180260808801606089016148b7565b905060ca600061181560208901896148b7565b63ffffffff1663ffffffff1681526020019081526020016000205487604051602001611841919061576a565b60405160208183030381529060405280519060200120146118ca5760405162461bcd60e51b815260206004820152603d60248201527f737570706c696564207461736b20646f6573206e6f74206d617463682074686560448201527f206f6e65207265636f7264656420696e2074686520636f6e74726163740000006064820152608401610695565b600060cb816118dc60208a018a6148b7565b63ffffffff1663ffffffff16815260200190815260200160002054146119595760405162461bcd60e51b815260206004820152602c60248201527f41676772656761746f722068617320616c726561647920726573706f6e64656460448201526b20746f20746865207461736b60a01b6064820152608401610695565b6119837f00000000000000000000000000000000000000000000000000000000000000008561580c565b63ffffffff164363ffffffff1611156119f45760405162461bcd60e51b815260206004820152602d60248201527f41676772656761746f722068617320726573706f6e64656420746f207468652060448201526c7461736b20746f6f206c61746560981b6064820152608401610695565b600086604051602001611a07919061584e565b604051602081830303815290604052805190602001209050600080611a2f8387878a8c612527565b9150915060005b85811015611b2e578460ff1683602001518281518110611a5857611a5861544e565b6020026020010151611a6a919061585c565b6001600160601b0316606484600001518381518110611a8b57611a8b61544e565b60200260200101516001600160601b0316611aa6919061587f565b1015611b1c576040805162461bcd60e51b81526020600482015260248101919091527f5369676e61746f7269657320646f206e6f74206f776e206174206c656173742060448201527f7468726573686f6c642070657263656e74616765206f6620612071756f72756d6064820152608401610695565b80611b2681615555565b915050611a36565b5060408051808201825263ffffffff43168152602080820184905291519091611b5b918c91849101615896565b6040516020818303038152906040528051906020012060cb60008c6000016020810190611b8891906148b7565b63ffffffff1663ffffffff168152602001908152602001600020819055507f349c1ee60e4e8972ee9dba642c1774543d5c4136879b7f4caaf04bf81a487a2a8a82604051611bd7929190615896565b60405180910390a15050505050505050505050565b60606000846001600160a01b031663c391425e84866040518363ffffffff1660e01b8152600401611c1e9291906158c2565b600060405180830381865afa158015611c3b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611c6391908101906155b5565b9050600084516001600160401b03811115611c8057611c806146f8565b604051908082528060200260200182016040528015611ca9578160200160208202803683370190505b50905060005b8551811015611daa57866001600160a01b03166304ec6351878381518110611cd957611cd961544e565b602002602001015187868581518110611cf457611cf461544e565b60200260200101516040518463ffffffff1660e01b8152600401611d319392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015611d4e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d729190615695565b6001600160c01b0316828281518110611d8d57611d8d61544e565b602090810291909101015280611da281615555565b915050611caf565b5095945050505050565b6000611dc360208501856148b7565b63ffffffff8116600090815260cb6020526040902054909150853590611e355760405162461bcd60e51b815260206004820152602160248201527f5461736b206861736e2774206265656e20726573706f6e64656420746f2079656044820152601d60fa1b6064820152608401610695565b8484604051602001611e48929190615916565b60408051601f19818403018152918152815160209283012063ffffffff8516600090815260cb90935291205414611ee75760405162461bcd60e51b815260206004820152603d60248201527f5461736b20726573706f6e736520646f6573206e6f74206d617463682074686560448201527f206f6e65207265636f7264656420696e2074686520636f6e74726163740000006064820152608401610695565b63ffffffff8216600090815260cc602052604090205460ff1615611f7f5760405162461bcd60e51b815260206004820152604360248201527f54686520726573706f6e736520746f2074686973207461736b2068617320616c60448201527f7265616479206265656e206368616c6c656e676564207375636365737366756c606482015262363c9760e91b608482015260a401610695565b6064611f8e60208601866148b7565b611f98919061580c565b63ffffffff164363ffffffff1611156120195760405162461bcd60e51b815260206004820152603760248201527f546865206368616c6c656e676520706572696f6420666f72207468697320746160448201527f736b2068617320616c726561647920657870697265642e0000000000000000006064820152608401610695565b6000612025828061587f565b905060208601358114600181900361207357604051339063ffffffff8616907ffd3e26beeb5967fc5a57a0446914eabc45b4aa474c67a51b4b5160cac60ddb0590600090a350505050612380565b600085516001600160401b0381111561208e5761208e6146f8565b6040519080825280602002602001820160405280156120b7578160200160208202803683370190505b50905060005b8651811015612129576120fa8782815181106120db576120db61544e565b6020026020010151805160009081526020918201519091526040902090565b82828151811061210c5761210c61544e565b60209081029190910101528061212181615555565b9150506120bd565b50600061213c60408b0160208c016148b7565b8260405160200161214e92919061594c565b604051602081830303815290604052805190602001209050876020013581146121f85760405162461bcd60e51b815260206004820152605060248201527f546865207075626b657973206f66206e6f6e2d7369676e696e67206f7065726160448201527f746f727320737570706c69656420627920746865206368616c6c656e6765722060648201526f30b932903737ba1031b7b93932b1ba1760811b608482015260a401610695565b600087516001600160401b03811115612213576122136146f8565b60405190808252806020026020018201604052801561223c578160200160208202803683370190505b50905060005b885181101561232f577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e8bb9ae685838151811061228c5761228c61544e565b60200260200101516040518263ffffffff1660e01b81526004016122b291815260200190565b602060405180830381865afa1580156122cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122f39190615382565b8282815181106123055761230561544e565b6001600160a01b03909216602092830291909101909101528061232781615555565b915050612242565b5063ffffffff8716600081815260cc6020526040808220805460ff19166001179055513392917fc20d1bb0f1623680306b83d4ff4bb99a2beb9d86d97832f3ca40fd13a29df1ec91a3505050505050505b50505050565b60ce546001600160a01b031633146123ea5760405162461bcd60e51b815260206004820152602160248201527f5461736b2067656e657261746f72206d757374206265207468652063616c6c656044820152603960f91b6064820152608401610695565b612421604051806080016040528060008152602001600063ffffffff16815260200160608152602001600063ffffffff1681525090565b84815263ffffffff438116602080840191909152908516606083015260408051601f850183900483028101830190915283815290849084908190840183828082843760009201919091525050505060408083019190915251612487908290602001615994565b60408051601f19818403018152828252805160209182012060c9805463ffffffff908116600090815260ca90945293909220555416907f1695b8d06ec800b4615e745cfb5bd00c1f2875615d42925c3b5afa543bb24c48906124ea908490615994565b60405180910390a260c9546125069063ffffffff16600161580c565b60c9805463ffffffff191663ffffffff929092169190911790555050505050565b604080518082019091526060808252602082015260008481036125a05760405162461bcd60e51b81526020600482015260376024820152600080516020615aff83398151915260448201527f7265733a20656d7074792071756f72756d20696e7075740000000000000000006064820152608401610695565b604083015151851480156125b8575060a08301515185145b80156125c8575060c08301515185145b80156125d8575060e08301515185145b6126425760405162461bcd60e51b81526020600482015260416024820152600080516020615aff83398151915260448201527f7265733a20696e7075742071756f72756d206c656e677468206d69736d6174636064820152600d60fb1b608482015260a401610695565b825151602084015151146126ba5760405162461bcd60e51b815260206004820152604460248201819052600080516020615aff833981519152908201527f7265733a20696e707574206e6f6e7369676e6572206c656e677468206d69736d6064820152630c2e8c6d60e31b608482015260a401610695565b4363ffffffff168463ffffffff16106127295760405162461bcd60e51b815260206004820152603c6024820152600080516020615aff83398151915260448201527f7265733a20696e76616c6964207265666572656e636520626c6f636b000000006064820152608401610695565b6040805180820182526000808252602080830191909152825180840190935260608084529083015290866001600160401b0381111561276a5761276a6146f8565b604051908082528060200260200182016040528015612793578160200160208202803683370190505b506020820152866001600160401b038111156127b1576127b16146f8565b6040519080825280602002602001820160405280156127da578160200160208202803683370190505b50815260408051808201909152606080825260208201528560200151516001600160401b0381111561280e5761280e6146f8565b604051908082528060200260200182016040528015612837578160200160208202803683370190505b5081526020860151516001600160401b03811115612857576128576146f8565b604051908082528060200260200182016040528015612880578160200160208202803683370190505b50816020018190525060006129528a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505060408051639aa1653d60e01b815290516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169350639aa1653d925060048083019260209291908290030181865afa158015612929573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061294d9190615a16565b613e7a565b905060005b876020015151811015612bce5761297d886020015182815181106120db576120db61544e565b836020015182815181106129935761299361544e565b60209081029190910101528015612a535760208301516129b4600183615a33565b815181106129c4576129c461544e565b602002602001015160001c836020015182815181106129e5576129e561544e565b602002602001015160001c11612a53576040805162461bcd60e51b8152602060048201526024810191909152600080516020615aff83398151915260448201527f7265733a206e6f6e5369676e65725075626b657973206e6f7420736f727465646064820152608401610695565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166304ec635184602001518381518110612a9857612a9861544e565b60200260200101518b8b600001518581518110612ab757612ab761544e565b60200260200101516040518463ffffffff1660e01b8152600401612af49392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015612b11573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b359190615695565b6001600160c01b031683600001518281518110612b5457612b5461544e565b602002602001018181525050612bba610904612b8e8486600001518581518110612b8057612b8061544e565b602002602001015116613f0d565b8a602001518481518110612ba457612ba461544e565b6020026020010151613f3890919063ffffffff16565b945080612bc681615555565b915050612957565b5050612bd98361401b565b60975490935060ff16600081612bf0576000612c72565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c448feb86040518163ffffffff1660e01b8152600401602060405180830381865afa158015612c4e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c729190615a46565b905060005b8a8110156132f0578215612dd2578963ffffffff16827f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663249a0c428f8f86818110612cce57612cce61544e565b60405160e085901b6001600160e01b031916815292013560f81c600483015250602401602060405180830381865afa158015612d0e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d329190615a46565b612d3c9190615a5f565b11612dd25760405162461bcd60e51b81526020600482015260666024820152600080516020615aff83398151915260448201527f7265733a205374616b6552656769737472792075706461746573206d7573742060648201527f62652077697468696e207769746864726177616c44656c6179426c6f636b732060848201526577696e646f7760d01b60a482015260c401610695565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166368bccaac8d8d84818110612e1357612e1361544e565b9050013560f81c60f81b60f81c8c8c60a001518581518110612e3757612e3761544e565b60209081029190910101516040516001600160e01b031960e086901b16815260ff909316600484015263ffffffff9182166024840152166044820152606401602060405180830381865afa158015612e93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612eb79190615a72565b6001600160401b031916612eda8a6040015183815181106120db576120db61544e565b67ffffffffffffffff191614612f765760405162461bcd60e51b81526020600482015260616024820152600080516020615aff83398151915260448201527f7265733a2071756f72756d41706b206861736820696e2073746f72616765206460648201527f6f6573206e6f74206d617463682070726f76696465642071756f72756d2061706084820152606b60f81b60a482015260c401610695565b612fa689604001518281518110612f8f57612f8f61544e565b602002602001015187613a7290919063ffffffff16565b95507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c8294c568d8d84818110612fe957612fe961544e565b9050013560f81c60f81b60f81c8c8c60c00151858151811061300d5761300d61544e565b60209081029190910101516040516001600160e01b031960e086901b16815260ff909316600484015263ffffffff9182166024840152166044820152606401602060405180830381865afa158015613069573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061308d9190615516565b856020015182815181106130a3576130a361544e565b6001600160601b039092166020928302919091018201528501518051829081106130cf576130cf61544e565b6020026020010151856000015182815181106130ed576130ed61544e565b60200260200101906001600160601b031690816001600160601b0316815250506000805b8a60200151518110156132db57613165866000015182815181106131375761313761544e565b60200260200101518f8f868181106131515761315161544e565b600192013560f81c9290921c811614919050565b156132c9577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f2be94ae8f8f868181106131ab576131ab61544e565b9050013560f81c60f81b60f81c8e896020015185815181106131cf576131cf61544e565b60200260200101518f60e0015188815181106131ed576131ed61544e565b602002602001015187815181106132065761320661544e565b60209081029190910101516040516001600160e01b031960e087901b16815260ff909416600485015263ffffffff92831660248501526044840191909152166064820152608401602060405180830381865afa15801561326a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061328e9190615516565b87518051859081106132a2576132a261544e565b602002602001018181516132b69190615a9d565b6001600160601b03169052506001909101905b806132d381615555565b915050613111565b505080806132e890615555565b915050612c77565b50505060008061330a8c868a606001518b608001516107e9565b915091508161337b5760405162461bcd60e51b81526020600482015260436024820152600080516020615aff83398151915260448201527f7265733a2070616972696e6720707265636f6d70696c652063616c6c206661696064820152621b195960ea1b608482015260a401610695565b806133dc5760405162461bcd60e51b81526020600482015260396024820152600080516020615aff83398151915260448201527f7265733a207369676e617475726520697320696e76616c6964000000000000006064820152608401610695565b505060008782602001516040516020016133f792919061594c565b60408051808303601f190181529190528051602090910120929b929a509198505050505050505050565b6134296140b6565b6134336000614110565b565b60408051600180825281830190925260009160609183916020808301908036833701905050905084816000815181106134705761347061544e565b60209081029190910101526040516361c8a12f60e11b81526000906001600160a01b0388169063c391425e906134ac90889086906004016158c2565b600060405180830381865afa1580156134c9573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526134f191908101906155b5565b6000815181106135035761350361544e565b60209081029190910101516040516304ec635160e01b81526004810188905263ffffffff87811660248301529091166044820181905291506000906001600160a01b038916906304ec635190606401602060405180830381865afa15801561356f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135939190615695565b6001600160c01b0316905060006135a982614162565b9050816135b78a838a610973565b9550955050505050935093915050565b6135cf6140b6565b6001600160a01b0381166136345760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610695565b6106a781614110565b600054610100900460ff161580801561365d5750600054600160ff909116105b806136775750303b158015613677575060005460ff166001145b6136da5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610695565b6000805460ff1916600117905580156136fd576000805461ff0019166101001790555b61370885600061422e565b61371184614110565b60cd80546001600160a01b038086166001600160a01b03199283161790925560ce8054928516929091169190911790558015613787576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b606560009054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156137e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138059190615382565b6001600160a01b0316336001600160a01b0316146138355760405162461bcd60e51b81526004016106959061539f565b6066541981196066541916146138b35760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e756e70617573653a20696e76616c696420617474656d7060448201527f7420746f2070617573652066756e6374696f6e616c69747900000000000000006064820152608401610695565b606681905560405181815233907f3582d1828e26bf56bd801502bc021ac0bc8afb57c826e4986b45593c8fad389c906020016107de565b6001600160a01b0381166139785760405162461bcd60e51b815260206004820152604960248201527f5061757361626c652e5f73657450617573657252656769737472793a206e657760448201527f50617573657252656769737472792063616e6e6f7420626520746865207a65726064820152686f206164647265737360b81b608482015260a401610695565b606554604080516001600160a01b03928316815291831660208301527f6e9fcd539896fca60e8b0f01dd580233e48a6b0f7df013b89ba7f565869acdb6910160405180910390a1606580546001600160a01b0319166001600160a01b0392909216919091179055565b60408051808201909152600080825260208201526139fd6145d3565b835181526020808501519082015260408082018490526000908360608460076107d05a03fa90508080613a2c57fe5b5080613a6a5760405162461bcd60e51b815260206004820152600d60248201526c1958cb5b5d5b0b59985a5b1959609a1b6044820152606401610695565b505092915050565b6040805180820190915260008082526020820152613a8e6145f1565b835181526020808501518183015283516040808401919091529084015160608301526000908360808460066107d05a03fa90508080613ac957fe5b5080613a6a5760405162461bcd60e51b815260206004820152600d60248201526c1958cb5859190b59985a5b1959609a1b6044820152606401610695565b613b0f61460f565b50604080516080810182527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c28183019081527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6060830152815281518083019092527f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec82527f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d60208381019190915281019190915290565b604080518082019091526000808252602082015260008080613bf7600080516020615adf83398151915286615464565b90505b613c0381614318565b9093509150600080516020615adf8339815191528283098303613c3c576040805180820190915290815260208101919091529392505050565b600080516020615adf833981519152600182089050613bfa565b604080518082018252868152602080820186905282518084019093528683528201849052600091829190613c88614634565b60005b6002811015613e4d576000613ca182600661587f565b9050848260028110613cb557613cb561544e565b60200201515183613cc7836000615a5f565b600c8110613cd757613cd761544e565b6020020152848260028110613cee57613cee61544e565b60200201516020015183826001613d059190615a5f565b600c8110613d1557613d1561544e565b6020020152838260028110613d2c57613d2c61544e565b6020020151515183613d3f836002615a5f565b600c8110613d4f57613d4f61544e565b6020020152838260028110613d6657613d6661544e565b6020020151516001602002015183613d7f836003615a5f565b600c8110613d8f57613d8f61544e565b6020020152838260028110613da657613da661544e565b602002015160200151600060028110613dc157613dc161544e565b602002015183613dd2836004615a5f565b600c8110613de257613de261544e565b6020020152838260028110613df957613df961544e565b602002015160200151600160028110613e1457613e1461544e565b602002015183613e25836005615a5f565b600c8110613e3557613e3561544e565b60200201525080613e4581615555565b915050613c8b565b50613e56614653565b60006020826101808560088cfa9151919c9115159b50909950505050505050505050565b600080613e868461439a565b9050808360ff166001901b11613f045760405162461bcd60e51b815260206004820152603f60248201527f4269746d61705574696c732e6f72646572656442797465734172726179546f4260448201527f69746d61703a206269746d61702065786365656473206d61782076616c7565006064820152608401610695565b90505b92915050565b6000805b8215613f0757613f22600184615a33565b9092169180613f3081615abd565b915050613f11565b60408051808201909152600080825260208201526102008261ffff1610613f945760405162461bcd60e51b815260206004820152601060248201526f7363616c61722d746f6f2d6c6172676560801b6044820152606401610695565b8161ffff16600103613fa7575081613f07565b6040805180820190915260008082526020820181905284906001905b8161ffff168661ffff161061401057600161ffff871660ff83161c81169003613ff357613ff08484613a72565b93505b613ffd8384613a72565b92506201fffe600192831b169101613fc3565b509195945050505050565b6040805180820190915260008082526020820152815115801561404057506020820151155b1561405e575050604080518082019091526000808252602082015290565b604051806040016040528083600001518152602001600080516020615adf83398151915284602001516140919190615464565b6140a990600080516020615adf833981519152615a33565b905292915050565b919050565b6033546001600160a01b031633146134335760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610695565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b606060008061417084613f0d565b61ffff166001600160401b0381111561418b5761418b6146f8565b6040519080825280601f01601f1916602001820160405280156141b5576020820181803683370190505b5090506000805b8251821080156141cd575061010081105b15614224576001811b935085841615614214578060f81b8383815181106141f6576141f661544e565b60200101906001600160f81b031916908160001a9053508160010191505b61421d81615555565b90506141bc565b5090949350505050565b6065546001600160a01b031615801561424f57506001600160a01b03821615155b6142d15760405162461bcd60e51b815260206004820152604760248201527f5061757361626c652e5f696e697469616c697a655061757365723a205f696e6960448201527f7469616c697a6550617573657228292063616e206f6e6c792062652063616c6c6064820152666564206f6e636560c81b608482015260a401610695565b606681905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2614314826138ea565b5050565b60008080600080516020615adf8339815191526003600080516020615adf83398151915286600080516020615adf83398151915288890909089050600061438e827f0c19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52600080516020615adf83398151915261452a565b91959194509092505050565b6000610100825111156144235760405162461bcd60e51b8152602060048201526044602482018190527f4269746d61705574696c732e6f72646572656442797465734172726179546f42908201527f69746d61703a206f7264657265644279746573417272617920697320746f6f206064820152636c6f6e6760e01b608482015260a401610695565b815160000361443457506000919050565b6000808360008151811061444a5761444a61544e565b0160200151600160f89190911c81901b92505b8451811015614521578481815181106144785761447861544e565b0160200151600160f89190911c1b915082821161450d5760405162461bcd60e51b815260206004820152604760248201527f4269746d61705574696c732e6f72646572656442797465734172726179546f4260448201527f69746d61703a206f72646572656442797465734172726179206973206e6f74206064820152661bdc99195c995960ca1b608482015260a401610695565b9181179161451a81615555565b905061445d565b50909392505050565b600080614535614653565b61453d614671565b602080825281810181905260408201819052606082018890526080820187905260a082018690528260c08360056107d05a03fa9250828061457a57fe5b50826145c85760405162461bcd60e51b815260206004820152601a60248201527f424e3235342e6578704d6f643a2063616c6c206661696c7572650000000000006044820152606401610695565b505195945050505050565b60405180606001604052806003906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b604051806040016040528061462261468f565b815260200161462f61468f565b905290565b604051806101800160405280600c906020820280368337509192915050565b60405180602001604052806001906020820280368337509192915050565b6040518060c001604052806006906020820280368337509192915050565b60405180604001604052806002906020820280368337509192915050565b6001600160a01b03811681146106a757600080fd5b6000602082840312156146d457600080fd5b8135613f04816146ad565b6000602082840312156146f157600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b0381118282101715614730576147306146f8565b60405290565b60405161010081016001600160401b0381118282101715614730576147306146f8565b604051601f8201601f191681016001600160401b0381118282101715614781576147816146f8565b604052919050565b60006040828403121561479b57600080fd5b6147a361470e565b9050813581526020820135602082015292915050565b600082601f8301126147ca57600080fd5b6147d261470e565b8060408401858111156147e457600080fd5b845b818110156147fe5780358452602093840193016147e6565b509095945050505050565b60006080828403121561481b57600080fd5b61482361470e565b905061482f83836147b9565b815261483e83604084016147b9565b602082015292915050565b600080600080610120858703121561486057600080fd5b843593506148718660208701614789565b92506148808660608701614809565b915061488f8660e08701614789565b905092959194509250565b63ffffffff811681146106a757600080fd5b80356140b18161489a565b6000602082840312156148c957600080fd5b8135613f048161489a565b6000806000606084860312156148e957600080fd5b83356148f4816146ad565b92506020848101356001600160401b038082111561491157600080fd5b818701915087601f83011261492557600080fd5b813581811115614937576149376146f8565b614949601f8201601f19168501614759565b9150808252888482850101111561495f57600080fd5b8084840185840137600084828401015250809450505050614982604085016148ac565b90509250925092565b600081518084526020808501808196508360051b810191508286016000805b86811015614a21578385038a52825180518087529087019087870190845b81811015614a0c57835180516001600160a01b031684528a8101518b8501526040908101516001600160601b031690840152928901926060909201916001016149c8565b50509a87019a955050918501916001016149aa565b509298975050505050505050565b602081526000614a42602083018461498b565b9392505050565b80151581146106a757600080fd5b600060208284031215614a6957600080fd5b8135613f0481614a49565b60008083601f840112614a8657600080fd5b5081356001600160401b03811115614a9d57600080fd5b602083019150836020828501011115614ab557600080fd5b9250929050565b60008060008060008060808789031215614ad557600080fd5b8635614ae0816146ad565b95506020870135614af08161489a565b945060408701356001600160401b0380821115614b0c57600080fd5b614b188a838b01614a74565b90965094506060890135915080821115614b3157600080fd5b818901915089601f830112614b4557600080fd5b813581811115614b5457600080fd5b8a60208260051b8501011115614b6957600080fd5b6020830194508093505050509295509295509295565b600081518084526020808501945080840160005b83811015614bb557815163ffffffff1687529582019590820190600101614b93565b509495945050505050565b600060208083528351608082850152614bdc60a0850182614b7f565b905081850151601f1980868403016040870152614bf98383614b7f565b92506040870151915080868403016060870152614c168383614b7f565b60608801518782038301608089015280518083529194508501925084840190600581901b8501860160005b82811015614c6d5784878303018452614c5b828751614b7f565b95880195938801939150600101614c41565b509998505050505050505050565b60ff811681146106a757600080fd5b600060208284031215614c9c57600080fd5b8135613f0481614c7b565b600060808284031215614cb957600080fd5b50919050565b600060408284031215614cb957600080fd5b60006001600160401b03821115614cea57614cea6146f8565b5060051b60200190565b600082601f830112614d0557600080fd5b81356020614d1a614d1583614cd1565b614759565b82815260059290921b84018101918181019086841115614d3957600080fd5b8286015b84811015614d5d578035614d508161489a565b8352918301918301614d3d565b509695505050505050565b600082601f830112614d7957600080fd5b81356020614d89614d1583614cd1565b82815260069290921b84018101918181019086841115614da857600080fd5b8286015b84811015614d5d57614dbe8882614789565b835291830191604001614dac565b600082601f830112614ddd57600080fd5b81356020614ded614d1583614cd1565b82815260059290921b84018101918181019086841115614e0c57600080fd5b8286015b84811015614d5d5780356001600160401b03811115614e2f5760008081fd5b614e3d8986838b0101614cf4565b845250918301918301614e10565b60006101808284031215614e5e57600080fd5b614e66614736565b905081356001600160401b0380821115614e7f57600080fd5b614e8b85838601614cf4565b83526020840135915080821115614ea157600080fd5b614ead85838601614d68565b60208401526040840135915080821115614ec657600080fd5b614ed285838601614d68565b6040840152614ee48560608601614809565b6060840152614ef68560e08601614789565b6080840152610120840135915080821115614f1057600080fd5b614f1c85838601614cf4565b60a0840152610140840135915080821115614f3657600080fd5b614f4285838601614cf4565b60c0840152610160840135915080821115614f5c57600080fd5b50614f6984828501614dcc565b60e08301525092915050565b600080600060808486031215614f8a57600080fd5b83356001600160401b0380821115614fa157600080fd5b614fad87838801614ca7565b9450614fbc8760208801614cbf565b93506060860135915080821115614fd257600080fd5b50614fdf86828701614e4b565b9150509250925092565b600080600060608486031215614ffe57600080fd5b8335615009816146ad565b92506020848101356001600160401b0381111561502557600080fd5b8501601f8101871361503657600080fd5b8035615044614d1582614cd1565b81815260059190911b8201830190838101908983111561506357600080fd5b928401925b8284101561508157833582529284019290840190615068565b8096505050505050614982604085016148ac565b6020808252825182820181905260009190848201906040850190845b818110156150cd578351835292840192918401916001016150b1565b50909695505050505050565b60008060008060c085870312156150ef57600080fd5b84356001600160401b038082111561510657600080fd5b61511288838901614ca7565b95506151218860208901614cbf565b94506151308860608901614cbf565b935060a087013591508082111561514657600080fd5b5061515387828801614d68565b91505092959194509250565b6000806000806060858703121561517557600080fd5b8435935060208501356151878161489a565b925060408501356001600160401b038111156151a257600080fd5b6151ae87828801614a74565b95989497509550505050565b6000806000806000608086880312156151d257600080fd5b8535945060208601356001600160401b03808211156151f057600080fd5b6151fc89838a01614a74565b9096509450604088013591506152118261489a565b9092506060870135908082111561522757600080fd5b5061523488828901614e4b565b9150509295509295909350565b600081518084526020808501945080840160005b83811015614bb55781516001600160601b031687529582019590820190600101615255565b60408152600083516040808401526152956080840182615241565b90506020850151603f198483030160608501526152b28282615241565b925050508260208301529392505050565b6000806000606084860312156152d857600080fd5b83356152e3816146ad565b92506020840135915060408401356152fa8161489a565b809150509250925092565b82815260406020820152600061531e604083018461498b565b949350505050565b6000806000806080858703121561533c57600080fd5b8435615347816146ad565b93506020850135615357816146ad565b92506040850135615367816146ad565b91506060850135615377816146ad565b939692955090935050565b60006020828403121561539457600080fd5b8151613f04816146ad565b6020808252602a908201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160408201526939903ab73830bab9b2b960b11b606082015260800190565b6000602082840312156153fb57600080fd5b8151613f0481614a49565b60208082526028908201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160408201526739903830bab9b2b960c11b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b60008261548157634e487b7160e01b600052601260045260246000fd5b500690565b6000602080838503121561549957600080fd5b82516001600160401b038111156154af57600080fd5b8301601f810185136154c057600080fd5b80516154ce614d1582614cd1565b81815260059190911b820183019083810190878311156154ed57600080fd5b928401925b8284101561550b578351825292840192908401906154f2565b979650505050505050565b60006020828403121561552857600080fd5b81516001600160601b0381168114613f0457600080fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016155675761556761553f565b5060010190565b63ffffffff84168152604060208201819052810182905260006001600160fb1b0383111561559b57600080fd5b8260051b8085606085013791909101606001949350505050565b600060208083850312156155c857600080fd5b82516001600160401b038111156155de57600080fd5b8301601f810185136155ef57600080fd5b80516155fd614d1582614cd1565b81815260059190911b8201830190838101908783111561561c57600080fd5b928401925b8284101561550b5783516156348161489a565b82529284019290840190615621565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b63ffffffff8416815260406020820152600061568c604083018486615643565b95945050505050565b6000602082840312156156a757600080fd5b81516001600160c01b0381168114613f0457600080fd5b6000602082840312156156d057600080fd5b8151613f048161489a565b600060ff821660ff81036156f1576156f161553f565b60010192915050565b60408152600061570e604083018587615643565b905063ffffffff83166020830152949350505050565b6000808335601e1984360301811261573b57600080fd5b8301803591506001600160401b0382111561575557600080fd5b602001915036819003821315614ab557600080fd5b6020815281356020820152600060208301356157858161489a565b63ffffffff81166040840152506040830135601e198436030181126157a957600080fd5b83016020810190356001600160401b038111156157c557600080fd5b8036038213156157d457600080fd5b608060608501526157e960a085018284615643565b9150506157f8606085016148ac565b63ffffffff81166080850152509392505050565b63ffffffff8181168382160190808211156158295761582961553f565b5092915050565b803561583b8161489a565b63ffffffff168252602090810135910152565b60408101613f078284615830565b6001600160601b03818116838216028082169190828114613a6a57613a6a61553f565b8082028115828204841417613f0757613f0761553f565b608081016158a48285615830565b63ffffffff8351166040830152602083015160608301529392505050565b60006040820163ffffffff851683526020604081850152818551808452606086019150828701935060005b81811015615909578451835293830193918301916001016158ed565b5090979650505050505050565b608081016159248285615830565b823561592f8161489a565b63ffffffff16604083015260209290920135606090910152919050565b63ffffffff60e01b8360e01b1681526000600482018351602080860160005b838110156159875781518552938201939082019060010161596b565b5092979650505050505050565b6000602080835283518184015263ffffffff8185015116604084015260408401516080606085015280518060a086015260005b818110156159e35782810184015186820160c0015283016159c7565b50600085820160c00152606086015163ffffffff811660808701529250601f01601f19169390930160c001949350505050565b600060208284031215615a2857600080fd5b8151613f0481614c7b565b81810381811115613f0757613f0761553f565b600060208284031215615a5857600080fd5b5051919050565b80820180821115613f0757613f0761553f565b600060208284031215615a8457600080fd5b815167ffffffffffffffff1981168114613f0457600080fd5b6001600160601b038281168282160390808211156158295761582961553f565b600061ffff808316818103615ad457615ad461553f565b600101939250505056fe30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47424c535369676e6174757265436865636b65722e636865636b5369676e617475a2646970667358221220f9169804370da5b04ee262342505bca83f8241d9d4b0816633b1be3512165f1d64736f6c63430008140033"]
    #[doc = r" ```"]
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(b"a\x01 `@R4\x80\x15b\0\0\x12W`\0\x80\xfd[P`@Qb\0^K8\x03\x80b\0^K\x839\x81\x01`@\x81\x90Rb\0\05\x91b\0\x01\xf7V[\x81\x80`\x01`\x01`\xa0\x1b\x03\x16`\x80\x81`\x01`\x01`\xa0\x1b\x03\x16\x81RPP\x80`\x01`\x01`\xa0\x1b\x03\x16ch0H5`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15b\0\0\x8fW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90b\0\0\xb5\x91\x90b\0\x02>V[`\x01`\x01`\xa0\x1b\x03\x16`\xa0\x81`\x01`\x01`\xa0\x1b\x03\x16\x81RPP\x80`\x01`\x01`\xa0\x1b\x03\x16c]\xf4YF`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15b\0\x01\rW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90b\0\x013\x91\x90b\0\x02>V[`\x01`\x01`\xa0\x1b\x03\x16`\xc0\x81`\x01`\x01`\xa0\x1b\x03\x16\x81RPP`\xa0Q`\x01`\x01`\xa0\x1b\x03\x16c\xdf\\\xf7#`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15b\0\x01\x8dW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90b\0\x01\xb3\x91\x90b\0\x02>V[`\x01`\x01`\xa0\x1b\x03\x16`\xe0RP`\x97\x80T`\xff\x19\x16`\x01\x17\x90Uc\xff\xff\xff\xff\x16a\x01\0RPb\0\x02eV[`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x14b\0\x01\xf4W`\0\x80\xfd[PV[`\0\x80`@\x83\x85\x03\x12\x15b\0\x02\x0bW`\0\x80\xfd[\x82Qb\0\x02\x18\x81b\0\x01\xdeV[` \x84\x01Q\x90\x92Pc\xff\xff\xff\xff\x81\x16\x81\x14b\0\x023W`\0\x80\xfd[\x80\x91PP\x92P\x92\x90PV[`\0` \x82\x84\x03\x12\x15b\0\x02QW`\0\x80\xfd[\x81Qb\0\x02^\x81b\0\x01\xdeV[\x93\x92PPPV[`\x80Q`\xa0Q`\xc0Q`\xe0Qa\x01\0Qa[Tb\0\x02\xf7`\09`\0\x81\x81a\x02}\x01R\x81\x81a\x05\x9c\x01Ra\x19^\x01R`\0\x81\x81a\x05e\x01Ra+\xf2\x01R`\0\x81\x81a\x04\x1e\x01R\x81\x81a\"M\x01Ra-\xd4\x01R`\0\x81\x81a\x04E\x01R\x81\x81a/\xaa\x01Ra1l\x01R`\0\x81\x81a\x04\x92\x01R\x81\x81a\x0e\x0b\x01R\x81\x81a(\xdc\x01R\x81\x81a*U\x01Ra,\x8f\x01Ra[T`\0\xf3\xfe`\x80`@R4\x80\x15a\0\x10W`\0\x80\xfd[P`\x046\x10a\x02\x1cW`\05`\xe0\x1c\x80ckS.\x9e\x11a\x01%W\x80c\x8d\xa5\xcb[\x11a\0\xadW\x80c\xf2\xfd\xe3\x8b\x11a\0|W\x80c\xf2\xfd\xe3\x8b\x14a\x05\x87W\x80c\xf5\xc9\x89\x9d\x14a\x05\x9aW\x80c\xf6<[\xab\x14a\x05\xc0W\x80c\xf8\xc8v^\x14a\x05\xc8W\x80c\xfa\xbc\x1c\xbc\x14a\x05\xdbW`\0\x80\xfd[\x80c\x8d\xa5\xcb[\x14a\x05!W\x80c\xb9\x8d\t\x08\x14a\x052W\x80c\xce\xfd\xc1\xd4\x14a\x05?W\x80c\xdf\\\xf7#\x14a\x05`W`\0\x80\xfd[\x80cqP\x18\xa6\x11a\0\xf4W\x80cqP\x18\xa6\x14a\x04\xd5W\x80cr\xd1\x8e\x8d\x14a\x04\xddW\x80cz\xfa\x1e\xed\x14a\x04\xebW\x80c\x88o\x11\x95\x14a\x04\xfeW\x80c\x8b\0\xce|\x14a\x05\x11W`\0\x80\xfd[\x80ckS.\x9e\x14a\x04gW\x80ck\x92x~\x14a\x04zW\x80cm\x14\xa9\x87\x14a\x04\x8dW\x80cn\xfbF6\x14a\x04\xb4W`\0\x80\xfd[\x80cOs\x9ft\x11a\x01\xa8W\x80c\\\x15Vb\x11a\x01wW\x80c\\\x15Vb\x14a\x03\xceW\x80c\\\x97Z\xbb\x14a\x03\xeeW\x80c]\xec\xc3\xf5\x14a\x03\xf6W\x80c]\xf4YF\x14a\x04\x19W\x80ch0H5\x14a\x04@W`\0\x80\xfd[\x80cOs\x9ft\x14a\x03`W\x80cY\\jg\x14a\x03\x80W\x80cZ\xc8j\xb7\x14a\x03\x88W\x80c[\xae\xc9\xa0\x14a\x03\xbbW`\0\x80\xfd[\x80c$Z{\xfc\x11a\x01\xefW\x80c$Z{\xfc\x14a\x02\xb4W\x80c,\xb2#\xd5\x14a\x02\xdfW\x80c-\x89\xf6\xfc\x14a\x03\rW\x80c5c\xb0\xd1\x14a\x03-W\x80cAl~^\x14a\x03MW`\0\x80\xfd[\x80c\x10\xd6z/\x14a\x02!W\x80c\x13d9\xdd\x14a\x026W\x80c\x17\x1f\x1d[\x14a\x02IW\x80c\x1a\xd41\x89\x14a\x02xW[`\0\x80\xfd[a\x024a\x02/6`\x04aF\xc2V[a\x05\xeeV[\0[a\x024a\x02D6`\x04aF\xdfV[a\x06\xaaV[a\x02\\a\x02W6`\x04aHIV[a\x07\xe9V[`@\x80Q\x92\x15\x15\x83R\x90\x15\x15` \x83\x01R\x01[`@Q\x80\x91\x03\x90\xf3[a\x02\x9f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Qc\xff\xff\xff\xff\x90\x91\x16\x81R` \x01a\x02oV[`\xcdTa\x02\xc7\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[`@Q`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x81R` \x01a\x02oV[a\x02\xffa\x02\xed6`\x04aH\xb7V[`\xcb` R`\0\x90\x81R`@\x90 T\x81V[`@Q\x90\x81R` \x01a\x02oV[a\x02\xffa\x03\x1b6`\x04aH\xb7V[`\xca` R`\0\x90\x81R`@\x90 T\x81V[a\x03@a\x03;6`\x04aH\xd4V[a\tsV[`@Qa\x02o\x91\x90aJ/V[a\x024a\x03[6`\x04aJWV[a\x0e\tV[a\x03sa\x03n6`\x04aJ\xbcV[a\x0f~V[`@Qa\x02o\x91\x90aK\xc0V[a\x024a\x16\xa6V[a\x03\xaba\x03\x966`\x04aL\x8aV[`fT`\x01`\xff\x90\x92\x16\x91\x90\x91\x1b\x90\x81\x16\x14\x90V[`@Q\x90\x15\x15\x81R` \x01a\x02oV[a\x024a\x03\xc96`\x04aOuV[a\x17mV[a\x03\xe1a\x03\xdc6`\x04aO\xe9V[a\x1b\xecV[`@Qa\x02o\x91\x90aP\x95V[`fTa\x02\xffV[a\x03\xaba\x04\x046`\x04aH\xb7V[`\xcc` R`\0\x90\x81R`@\x90 T`\xff\x16\x81V[a\x02\xc7\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\xc7\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x024a\x04u6`\x04aP\xd9V[a\x1d\xb4V[a\x024a\x04\x886`\x04aQ_V[a#\x86V[a\x02\xc7\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x04\xc7a\x04\xc26`\x04aQ\xbaV[a%'V[`@Qa\x02o\x92\x91\x90aRzV[a\x024a4!V[`\xc9Tc\xff\xff\xff\xff\x16a\x02\x9fV[`\xceTa\x02\xc7\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[`eTa\x02\xc7\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[`\xc9Ta\x02\x9f\x90c\xff\xff\xff\xff\x16\x81V[`3T`\x01`\x01`\xa0\x1b\x03\x16a\x02\xc7V[`\x97Ta\x03\xab\x90`\xff\x16\x81V[a\x05Ra\x05M6`\x04aR\xc3V[a45V[`@Qa\x02o\x92\x91\x90aS\x05V[a\x02\xc7\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x024a\x05\x956`\x04aF\xc2V[a5\xc7V[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x02\x9fV[a\x02\x9f`d\x81V[a\x024a\x05\xd66`\x04aS&V[a6=V[a\x024a\x05\xe96`\x04aF\xdfV[a7\x8eV[`e`\0\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xa0\x1b\x03\x16`\x01`\x01`\xa0\x1b\x03\x16c\xea\xb6mz`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x06AW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06e\x91\x90aS\x82V[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a\x06\x9eW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x06\x95\x90aS\x9fV[`@Q\x80\x91\x03\x90\xfd[a\x06\xa7\x81a8\xeaV[PV[`eT`@Qc#}\xfbG`\xe1\x1b\x81R3`\x04\x82\x01R`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x90cF\xfb\xf6\x8e\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x06\xf2W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\x16\x91\x90aS\xe9V[a\x072W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x06\x95\x90aT\x06V[`fT\x81\x81\x16\x14a\x07\xabW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7fPausable.pause: invalid attempt `D\x82\x01R\x7fto unpause functionality\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`f\x81\x90U`@Q\x81\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01[`@Q\x80\x91\x03\x90\xa2PV[`\0\x80`\0\x7f0dNr\xe11\xa0)\xb8PE\xb6\x81\x81X](3\xe8Hy\xb9p\x91C\xe1\xf5\x93\xf0\0\0\x01\x87\x87`\0\x01Q\x88` \x01Q\x88`\0\x01Q`\0`\x02\x81\x10a\x081Wa\x081aTNV[` \x02\x01Q\x89Q`\x01` \x02\x01Q\x8a` \x01Q`\0`\x02\x81\x10a\x08VWa\x08VaTNV[` \x02\x01Q\x8b` \x01Q`\x01`\x02\x81\x10a\x08rWa\x08raTNV[` \x90\x81\x02\x91\x90\x91\x01Q\x8cQ\x8d\x83\x01Q`@Qa\x08\xcf\x9a\x99\x98\x97\x96\x95\x94\x01\x98\x89R` \x89\x01\x97\x90\x97R`@\x88\x01\x95\x90\x95R``\x87\x01\x93\x90\x93R`\x80\x86\x01\x91\x90\x91R`\xa0\x85\x01R`\xc0\x84\x01R`\xe0\x83\x01Ra\x01\0\x82\x01Ra\x01 \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `\0\x1ca\x08\xf2\x91\x90aTdV[\x90Pa\tea\t\x0ba\t\x04\x88\x84a9\xe1V[\x86\x90a:rV[a\t\x13a;\x07V[a\t[a\tL\x85a\tF`@\x80Q\x80\x82\x01\x82R`\0\x80\x82R` \x91\x82\x01R\x81Q\x80\x83\x01\x90\x92R`\x01\x82R`\x02\x90\x82\x01R\x90V[\x90a9\xe1V[a\tU\x8ca;\xc7V[\x90a:rV[\x88b\x01\xd4\xc0a<VV[\x90\x98\x90\x97P\x95PPPPPPV[```\0\x84`\x01`\x01`\xa0\x1b\x03\x16ch0H5`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\t\xb5W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xd9\x91\x90aS\x82V[\x90P`\0\x85`\x01`\x01`\xa0\x1b\x03\x16c\x9e\x99#\xc2`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\n\x1bW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n?\x91\x90aS\x82V[\x90P`\0\x86`\x01`\x01`\xa0\x1b\x03\x16c]\xf4YF`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\n\x81W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xa5\x91\x90aS\x82V[\x90P`\0\x86Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\n\xc2Wa\n\xc2aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\n\xf5W\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\n\xe0W\x90P[P\x90P`\0[\x87Q\x81\x10\x15a\r\xfdW`\0\x88\x82\x81Q\x81\x10a\x0b\x18Wa\x0b\x18aTNV[\x01` \x01Q`@Qc\x89\x02bE`\xe0\x1b\x81R`\xf8\x91\x90\x91\x1c`\x04\x82\x01\x81\x90Rc\xff\xff\xff\xff\x8a\x16`$\x83\x01R\x91P`\0\x90`\x01`\x01`\xa0\x1b\x03\x87\x16\x90c\x89\x02bE\x90`D\x01`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0byW=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x0b\xa1\x91\x90\x81\x01\x90aT\x86V[\x90P\x80Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\x0b\xbcWa\x0b\xbcaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0c\x07W\x81` \x01[`@\x80Q``\x81\x01\x82R`\0\x80\x82R` \x80\x83\x01\x82\x90R\x92\x82\x01R\x82R`\0\x19\x90\x92\x01\x91\x01\x81a\x0b\xdaW\x90P[P\x84\x84\x81Q\x81\x10a\x0c\x1aWa\x0c\x1aaTNV[` \x02` \x01\x01\x81\x90RP`\0[\x81Q\x81\x10\x15a\r\xe7W`@Q\x80``\x01`@R\x80\x87`\x01`\x01`\xa0\x1b\x03\x16cG\xb3\x14\xe8\x85\x85\x81Q\x81\x10a\x0c]Wa\x0c]aTNV[` \x02` \x01\x01Q`@Q\x82c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x0c\x83\x91\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0c\xa0W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0c\xc4\x91\x90aS\x82V[`\x01`\x01`\xa0\x1b\x03\x16\x81R` \x01\x83\x83\x81Q\x81\x10a\x0c\xe4Wa\x0c\xe4aTNV[` \x02` \x01\x01Q\x81R` \x01\x89`\x01`\x01`\xa0\x1b\x03\x16c\xfa(\xc6'\x85\x85\x81Q\x81\x10a\r\x12Wa\r\x12aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x84\x90\x1b\x16\x81R`\x04\x81\x01\x91\x90\x91R`\xff\x88\x16`$\x82\x01Rc\xff\xff\xff\xff\x8f\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\rnW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x92\x91\x90aU\x16V[`\x01`\x01``\x1b\x03\x16\x81RP\x85\x85\x81Q\x81\x10a\r\xb0Wa\r\xb0aTNV[` \x02` \x01\x01Q\x82\x81Q\x81\x10a\r\xc9Wa\r\xc9aTNV[` \x02` \x01\x01\x81\x90RP\x80\x80a\r\xdf\x90aUUV[\x91PPa\x0c(V[PPP\x80\x80a\r\xf5\x90aUUV[\x91PPa\n\xfbV[P\x97\x96PPPPPPPV[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\x8d\xa5\xcb[`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0egW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0e\x8b\x91\x90aS\x82V[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a\x0f7W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\\`$\x82\x01R\x7fBLSSignatureChecker.onlyCoordina`D\x82\x01R\x7ftorOwner: caller is not the owne`d\x82\x01R\x7fr of the registryCoordinator\0\0\0\0`\x84\x82\x01R`\xa4\x01a\x06\x95V[`\x97\x80T`\xff\x19\x16\x82\x15\x15\x90\x81\x17\x90\x91U`@Q\x90\x81R\x7f@\xe4\xed\x88\n)\xe0\xf6\xdd\xce0tW\xfbu\xcd\xdfO\xee\xf7\xd3\xec\xb00\x1b\xfd\xf4\x97j\x0e-\xfc\x90` \x01`@Q\x80\x91\x03\x90\xa1PV[a\x0f\xa9`@Q\x80`\x80\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`\0\x87`\x01`\x01`\xa0\x1b\x03\x16ch0H5`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0f\xe9W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\r\x91\x90aS\x82V[\x90Pa\x10:`@Q\x80`\x80\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Qca\xc8\xa1/`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x8a\x16\x90c\xc3\x91B^\x90a\x10j\x90\x8b\x90\x89\x90\x89\x90`\x04\x01aUnV[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x10\x87W=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x10\xaf\x91\x90\x81\x01\x90aU\xb5V[\x81R`@Qc@\xe0:\x81`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x83\x16\x90c\x81\xc0u\x02\x90a\x10\xe1\x90\x8b\x90\x8b\x90\x8b\x90`\x04\x01aVlV[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x10\xfeW=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x11&\x91\x90\x81\x01\x90aU\xb5V[`@\x82\x01R\x85`\x01`\x01`@\x1b\x03\x81\x11\x15a\x11CWa\x11CaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x11vW\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x11aW\x90P[P``\x82\x01R`\0[`\xff\x81\x16\x87\x11\x15a\x15\xb7W`\0\x85`\x01`\x01`@\x1b\x03\x81\x11\x15a\x11\xa4Wa\x11\xa4aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x11\xcdW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x83``\x01Q\x83`\xff\x16\x81Q\x81\x10a\x11\xe7Wa\x11\xe7aTNV[` \x02` \x01\x01\x81\x90RP`\0[\x86\x81\x10\x15a\x14\xb7W`\0\x8c`\x01`\x01`\xa0\x1b\x03\x16c\x04\xeccQ\x8a\x8a\x85\x81\x81\x10a\x12 Wa\x12 aTNV[\x90P` \x02\x015\x8e\x88`\0\x01Q\x86\x81Q\x81\x10a\x12>Wa\x12>aTNV[` \x02` \x01\x01Q`@Q\x84c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x12{\x93\x92\x91\x90\x92\x83Rc\xff\xff\xff\xff\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x12\x98W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x12\xbc\x91\x90aV\x95V[\x90P\x80`\x01`\x01`\xc0\x1b\x03\x16`\0\x03a\x13cW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\\`$\x82\x01R\x7fOperatorStateRetriever.getCheckS`D\x82\x01R\x7fignaturesIndices: operator must `d\x82\x01R\x7fbe registered at blocknumber\0\0\0\0`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x8a\x8a\x85`\xff\x16\x81\x81\x10a\x13xWa\x13xaTNV[`\x01`\x01`\x01`\xc0\x1b\x03\x85\x16\x91\x90\x93\x015`\xf8\x1c\x1c\x82\x16\x90\x91\x03\x90Pa\x14\xa4W\x85`\x01`\x01`\xa0\x1b\x03\x16c\xdd\x98F\xb9\x8a\x8a\x85\x81\x81\x10a\x13\xb9Wa\x13\xb9aTNV[\x90P` \x02\x015\x8d\x8d\x88`\xff\x16\x81\x81\x10a\x13\xd5Wa\x13\xd5aTNV[`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x87\x90\x1b\x16\x81R`\x04\x81\x01\x94\x90\x94R\x91\x90\x91\x015`\xf8\x1c`$\x83\x01RPc\xff\xff\xff\xff\x8f\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x14+W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14O\x91\x90aV\xbeV[\x85``\x01Q\x85`\xff\x16\x81Q\x81\x10a\x14hWa\x14haTNV[` \x02` \x01\x01Q\x84\x81Q\x81\x10a\x14\x81Wa\x14\x81aTNV[c\xff\xff\xff\xff\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x82a\x14\xa0\x81aUUV[\x93PP[P\x80a\x14\xaf\x81aUUV[\x91PPa\x11\xf5V[P`\0\x81`\x01`\x01`@\x1b\x03\x81\x11\x15a\x14\xd2Wa\x14\xd2aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x14\xfbW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x82\x81\x10\x15a\x15|W\x84``\x01Q\x84`\xff\x16\x81Q\x81\x10a\x15\"Wa\x15\"aTNV[` \x02` \x01\x01Q\x81\x81Q\x81\x10a\x15;Wa\x15;aTNV[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10a\x15UWa\x15UaTNV[c\xff\xff\xff\xff\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x80a\x15t\x81aUUV[\x91PPa\x15\x01V[P\x80\x84``\x01Q\x84`\xff\x16\x81Q\x81\x10a\x15\x97Wa\x15\x97aTNV[` \x02` \x01\x01\x81\x90RPPP\x80\x80a\x15\xaf\x90aV\xdbV[\x91PPa\x11\x7fV[P`\0\x89`\x01`\x01`\xa0\x1b\x03\x16c]\xf4YF`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x15\xf8W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16\x1c\x91\x90aS\x82V[`@Qc5IR\xa3`\xe2\x1b\x81R\x90\x91P`\x01`\x01`\xa0\x1b\x03\x82\x16\x90c\xd5%J\x8c\x90a\x16O\x90\x8b\x90\x8b\x90\x8e\x90`\x04\x01aV\xfaV[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x16lW=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x16\x94\x91\x90\x81\x01\x90aU\xb5V[` \x83\x01RP\x98\x97PPPPPPPPV[`eT`@Qc#}\xfbG`\xe1\x1b\x81R3`\x04\x82\x01R`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x90cF\xfb\xf6\x8e\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x16\xeeW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17\x12\x91\x90aS\xe9V[a\x17.W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x06\x95\x90aT\x06V[`\0\x19`f\x81\x90U`@Q\x90\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01`@Q\x80\x91\x03\x90\xa2V[`\xcdT`\x01`\x01`\xa0\x1b\x03\x163\x14a\x17\xc7W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x1d`$\x82\x01R\x7fAggregator must be the caller\0\0\0`D\x82\x01R`d\x01a\x06\x95V[`\0a\x17\xd9`@\x85\x01` \x86\x01aH\xb7V[\x90P6`\0a\x17\xeb`@\x87\x01\x87aW$V[\x90\x92P\x90P`\0a\x18\x02`\x80\x88\x01``\x89\x01aH\xb7V[\x90P`\xca`\0a\x18\x15` \x89\x01\x89aH\xb7V[c\xff\xff\xff\xff\x16c\xff\xff\xff\xff\x16\x81R` \x01\x90\x81R` \x01`\0 T\x87`@Q` \x01a\x18A\x91\x90aWjV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x14a\x18\xcaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`=`$\x82\x01R\x7fsupplied task does not match the`D\x82\x01R\x7f one recorded in the contract\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`\0`\xcb\x81a\x18\xdc` \x8a\x01\x8aaH\xb7V[c\xff\xff\xff\xff\x16c\xff\xff\xff\xff\x16\x81R` \x01\x90\x81R` \x01`\0 T\x14a\x19YW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7fAggregator has already responded`D\x82\x01Rk to the task`\xa0\x1b`d\x82\x01R`\x84\x01a\x06\x95V[a\x19\x83\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85aX\x0cV[c\xff\xff\xff\xff\x16Cc\xff\xff\xff\xff\x16\x11\x15a\x19\xf4W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7fAggregator has responded to the `D\x82\x01Rltask too late`\x98\x1b`d\x82\x01R`\x84\x01a\x06\x95V[`\0\x86`@Q` \x01a\x1a\x07\x91\x90aXNV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\0\x80a\x1a/\x83\x87\x87\x8a\x8ca%'V[\x91P\x91P`\0[\x85\x81\x10\x15a\x1b.W\x84`\xff\x16\x83` \x01Q\x82\x81Q\x81\x10a\x1aXWa\x1aXaTNV[` \x02` \x01\x01Qa\x1aj\x91\x90aX\\V[`\x01`\x01``\x1b\x03\x16`d\x84`\0\x01Q\x83\x81Q\x81\x10a\x1a\x8bWa\x1a\x8baTNV[` \x02` \x01\x01Q`\x01`\x01``\x1b\x03\x16a\x1a\xa6\x91\x90aX\x7fV[\x10\x15a\x1b\x1cW`@\x80QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`$\x81\x01\x91\x90\x91R\x7fSignatories do not own at least `D\x82\x01R\x7fthreshold percentage of a quorum`d\x82\x01R`\x84\x01a\x06\x95V[\x80a\x1b&\x81aUUV[\x91PPa\x1a6V[P`@\x80Q\x80\x82\x01\x82Rc\xff\xff\xff\xffC\x16\x81R` \x80\x82\x01\x84\x90R\x91Q\x90\x91a\x1b[\x91\x8c\x91\x84\x91\x01aX\x96V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `\xcb`\0\x8c`\0\x01` \x81\x01\x90a\x1b\x88\x91\x90aH\xb7V[c\xff\xff\xff\xff\x16c\xff\xff\xff\xff\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP\x7f4\x9c\x1e\xe6\x0eN\x89r\xee\x9d\xbad,\x17tT=\\A6\x87\x9b\x7fL\xaa\xf0K\xf8\x1aHz*\x8a\x82`@Qa\x1b\xd7\x92\x91\x90aX\x96V[`@Q\x80\x91\x03\x90\xa1PPPPPPPPPPPV[```\0\x84`\x01`\x01`\xa0\x1b\x03\x16c\xc3\x91B^\x84\x86`@Q\x83c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x1c\x1e\x92\x91\x90aX\xc2V[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x1c;W=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x1cc\x91\x90\x81\x01\x90aU\xb5V[\x90P`\0\x84Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\x1c\x80Wa\x1c\x80aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1c\xa9W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x85Q\x81\x10\x15a\x1d\xaaW\x86`\x01`\x01`\xa0\x1b\x03\x16c\x04\xeccQ\x87\x83\x81Q\x81\x10a\x1c\xd9Wa\x1c\xd9aTNV[` \x02` \x01\x01Q\x87\x86\x85\x81Q\x81\x10a\x1c\xf4Wa\x1c\xf4aTNV[` \x02` \x01\x01Q`@Q\x84c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x1d1\x93\x92\x91\x90\x92\x83Rc\xff\xff\xff\xff\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x1dNW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1dr\x91\x90aV\x95V[`\x01`\x01`\xc0\x1b\x03\x16\x82\x82\x81Q\x81\x10a\x1d\x8dWa\x1d\x8daTNV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x80a\x1d\xa2\x81aUUV[\x91PPa\x1c\xafV[P\x95\x94PPPPPV[`\0a\x1d\xc3` \x85\x01\x85aH\xb7V[c\xff\xff\xff\xff\x81\x16`\0\x90\x81R`\xcb` R`@\x90 T\x90\x91P\x855\x90a\x1e5W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7fTask hasn't been responded to ye`D\x82\x01R`\x1d`\xfa\x1b`d\x82\x01R`\x84\x01a\x06\x95V[\x84\x84`@Q` \x01a\x1eH\x92\x91\x90aY\x16V[`@\x80Q`\x1f\x19\x81\x84\x03\x01\x81R\x91\x81R\x81Q` \x92\x83\x01 c\xff\xff\xff\xff\x85\x16`\0\x90\x81R`\xcb\x90\x93R\x91 T\x14a\x1e\xe7W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`=`$\x82\x01R\x7fTask response does not match the`D\x82\x01R\x7f one recorded in the contract\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[c\xff\xff\xff\xff\x82\x16`\0\x90\x81R`\xcc` R`@\x90 T`\xff\x16\x15a\x1f\x7fW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`C`$\x82\x01R\x7fThe response to this task has al`D\x82\x01R\x7fready been challenged successful`d\x82\x01Rb6<\x97`\xe9\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[`da\x1f\x8e` \x86\x01\x86aH\xb7V[a\x1f\x98\x91\x90aX\x0cV[c\xff\xff\xff\xff\x16Cc\xff\xff\xff\xff\x16\x11\x15a \x19W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`7`$\x82\x01R\x7fThe challenge period for this ta`D\x82\x01R\x7fsk has already expired.\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`\0a %\x82\x80aX\x7fV[\x90P` \x86\x015\x81\x14`\x01\x81\x90\x03a sW`@Q3\x90c\xff\xff\xff\xff\x86\x16\x90\x7f\xfd>&\xbe\xebYg\xfcZW\xa0Di\x14\xea\xbcE\xb4\xaaGLg\xa5\x1bKQ`\xca\xc6\r\xdb\x05\x90`\0\x90\xa3PPPPa#\x80V[`\0\x85Q`\x01`\x01`@\x1b\x03\x81\x11\x15a \x8eWa \x8eaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a \xb7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x86Q\x81\x10\x15a!)Wa \xfa\x87\x82\x81Q\x81\x10a \xdbWa \xdbaTNV[` \x02` \x01\x01Q\x80Q`\0\x90\x81R` \x91\x82\x01Q\x90\x91R`@\x90 \x90V[\x82\x82\x81Q\x81\x10a!\x0cWa!\x0caTNV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x80a!!\x81aUUV[\x91PPa \xbdV[P`\0a!<`@\x8b\x01` \x8c\x01aH\xb7V[\x82`@Q` \x01a!N\x92\x91\x90aYLV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x87` \x015\x81\x14a!\xf8W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`P`$\x82\x01R\x7fThe pubkeys of non-signing opera`D\x82\x01R\x7ftors supplied by the challenger `d\x82\x01Ro0\xb92\x9077\xba\x101\xb7\xb992\xb1\xba\x17`\x81\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[`\0\x87Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\"\x13Wa\"\x13aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\"<W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x88Q\x81\x10\x15a#/W\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xe8\xbb\x9a\xe6\x85\x83\x81Q\x81\x10a\"\x8cWa\"\x8caTNV[` \x02` \x01\x01Q`@Q\x82c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\"\xb2\x91\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\"\xcfW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\"\xf3\x91\x90aS\x82V[\x82\x82\x81Q\x81\x10a#\x05Wa#\x05aTNV[`\x01`\x01`\xa0\x1b\x03\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x80a#'\x81aUUV[\x91PPa\"BV[Pc\xff\xff\xff\xff\x87\x16`\0\x81\x81R`\xcc` R`@\x80\x82 \x80T`\xff\x19\x16`\x01\x17\x90UQ3\x92\x91\x7f\xc2\r\x1b\xb0\xf1b6\x800k\x83\xd4\xffK\xb9\x9a+\xeb\x9d\x86\xd9x2\xf3\xca@\xfd\x13\xa2\x9d\xf1\xec\x91\xa3PPPPPPP[PPPPV[`\xceT`\x01`\x01`\xa0\x1b\x03\x163\x14a#\xeaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7fTask generator must be the calle`D\x82\x01R`9`\xf9\x1b`d\x82\x01R`\x84\x01a\x06\x95V[a$!`@Q\x80`\x80\x01`@R\x80`\0\x81R` \x01`\0c\xff\xff\xff\xff\x16\x81R` \x01``\x81R` \x01`\0c\xff\xff\xff\xff\x16\x81RP\x90V[\x84\x81Rc\xff\xff\xff\xffC\x81\x16` \x80\x84\x01\x91\x90\x91R\x90\x85\x16``\x83\x01R`@\x80Q`\x1f\x85\x01\x83\x90\x04\x83\x02\x81\x01\x83\x01\x90\x91R\x83\x81R\x90\x84\x90\x84\x90\x81\x90\x84\x01\x83\x82\x80\x82\x847`\0\x92\x01\x91\x90\x91RPPPP`@\x80\x83\x01\x91\x90\x91RQa$\x87\x90\x82\x90` \x01aY\x94V[`@\x80Q`\x1f\x19\x81\x84\x03\x01\x81R\x82\x82R\x80Q` \x91\x82\x01 `\xc9\x80Tc\xff\xff\xff\xff\x90\x81\x16`\0\x90\x81R`\xca\x90\x94R\x93\x90\x92 UT\x16\x90\x7f\x16\x95\xb8\xd0n\xc8\0\xb4a^t\\\xfb[\xd0\x0c\x1f(ua]B\x92\\;Z\xfaT;\xb2LH\x90a$\xea\x90\x84\x90aY\x94V[`@Q\x80\x91\x03\x90\xa2`\xc9Ta%\x06\x90c\xff\xff\xff\xff\x16`\x01aX\x0cV[`\xc9\x80Tc\xff\xff\xff\xff\x19\x16c\xff\xff\xff\xff\x92\x90\x92\x16\x91\x90\x91\x17\x90UPPPPPV[`@\x80Q\x80\x82\x01\x90\x91R``\x80\x82R` \x82\x01R`\0\x84\x81\x03a%\xa0W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`7`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: empty quorum input\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`@\x83\x01QQ\x85\x14\x80\x15a%\xb8WP`\xa0\x83\x01QQ\x85\x14[\x80\x15a%\xc8WP`\xc0\x83\x01QQ\x85\x14[\x80\x15a%\xd8WP`\xe0\x83\x01QQ\x85\x14[a&BW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`A`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: input quorum length mismatc`d\x82\x01R`\r`\xfb\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x82QQ` \x84\x01QQ\x14a&\xbaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R`\0\x80Q` aZ\xff\x839\x81Q\x91R\x90\x82\x01R\x7fres: input nonsigner length mism`d\x82\x01Rc\x0c.\x8cm`\xe3\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[Cc\xff\xff\xff\xff\x16\x84c\xff\xff\xff\xff\x16\x10a')W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`<`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: invalid reference block\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`@\x80Q\x80\x82\x01\x82R`\0\x80\x82R` \x80\x83\x01\x91\x90\x91R\x82Q\x80\x84\x01\x90\x93R``\x80\x84R\x90\x83\x01R\x90\x86`\x01`\x01`@\x1b\x03\x81\x11\x15a'jWa'jaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a'\x93W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P` \x82\x01R\x86`\x01`\x01`@\x1b\x03\x81\x11\x15a'\xb1Wa'\xb1aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a'\xdaW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x81R`@\x80Q\x80\x82\x01\x90\x91R``\x80\x82R` \x82\x01R\x85` \x01QQ`\x01`\x01`@\x1b\x03\x81\x11\x15a(\x0eWa(\x0eaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a(7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x81R` \x86\x01QQ`\x01`\x01`@\x1b\x03\x81\x11\x15a(WWa(WaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a(\x80W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x81` \x01\x81\x90RP`\0a)R\x8a\x8a\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPP`@\x80Qc\x9a\xa1e=`\xe0\x1b\x81R\x90Q`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x93Pc\x9a\xa1e=\x92P`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xfa\x15\x80\x15a))W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a)M\x91\x90aZ\x16V[a>zV[\x90P`\0[\x87` \x01QQ\x81\x10\x15a+\xceWa)}\x88` \x01Q\x82\x81Q\x81\x10a \xdbWa \xdbaTNV[\x83` \x01Q\x82\x81Q\x81\x10a)\x93Wa)\x93aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x80\x15a*SW` \x83\x01Qa)\xb4`\x01\x83aZ3V[\x81Q\x81\x10a)\xc4Wa)\xc4aTNV[` \x02` \x01\x01Q`\0\x1c\x83` \x01Q\x82\x81Q\x81\x10a)\xe5Wa)\xe5aTNV[` \x02` \x01\x01Q`\0\x1c\x11a*SW`@\x80QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`$\x81\x01\x91\x90\x91R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: nonSignerPubkeys not sorted`d\x82\x01R`\x84\x01a\x06\x95V[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\x04\xeccQ\x84` \x01Q\x83\x81Q\x81\x10a*\x98Wa*\x98aTNV[` \x02` \x01\x01Q\x8b\x8b`\0\x01Q\x85\x81Q\x81\x10a*\xb7Wa*\xb7aTNV[` \x02` \x01\x01Q`@Q\x84c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a*\xf4\x93\x92\x91\x90\x92\x83Rc\xff\xff\xff\xff\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a+\x11W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a+5\x91\x90aV\x95V[`\x01`\x01`\xc0\x1b\x03\x16\x83`\0\x01Q\x82\x81Q\x81\x10a+TWa+TaTNV[` \x02` \x01\x01\x81\x81RPPa+\xbaa\t\x04a+\x8e\x84\x86`\0\x01Q\x85\x81Q\x81\x10a+\x80Wa+\x80aTNV[` \x02` \x01\x01Q\x16a?\rV[\x8a` \x01Q\x84\x81Q\x81\x10a+\xa4Wa+\xa4aTNV[` \x02` \x01\x01Qa?8\x90\x91\x90c\xff\xff\xff\xff\x16V[\x94P\x80a+\xc6\x81aUUV[\x91PPa)WV[PPa+\xd9\x83a@\x1bV[`\x97T\x90\x93P`\xff\x16`\0\x81a+\xf0W`\0a,rV[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xc4H\xfe\xb8`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a,NW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a,r\x91\x90aZFV[\x90P`\0[\x8a\x81\x10\x15a2\xf0W\x82\x15a-\xd2W\x89c\xff\xff\xff\xff\x16\x82\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c$\x9a\x0cB\x8f\x8f\x86\x81\x81\x10a,\xceWa,\xceaTNV[`@Q`\xe0\x85\x90\x1b`\x01`\x01`\xe0\x1b\x03\x19\x16\x81R\x92\x015`\xf8\x1c`\x04\x83\x01RP`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a-\x0eW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a-2\x91\x90aZFV[a-<\x91\x90aZ_V[\x11a-\xd2W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`f`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: StakeRegistry updates must `d\x82\x01R\x7fbe within withdrawalDelayBlocks `\x84\x82\x01Rewindow`\xd0\x1b`\xa4\x82\x01R`\xc4\x01a\x06\x95V[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16ch\xbc\xca\xac\x8d\x8d\x84\x81\x81\x10a.\x13Wa.\x13aTNV[\x90P\x015`\xf8\x1c`\xf8\x1b`\xf8\x1c\x8c\x8c`\xa0\x01Q\x85\x81Q\x81\x10a.7Wa.7aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x86\x90\x1b\x16\x81R`\xff\x90\x93\x16`\x04\x84\x01Rc\xff\xff\xff\xff\x91\x82\x16`$\x84\x01R\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a.\x93W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a.\xb7\x91\x90aZrV[`\x01`\x01`@\x1b\x03\x19\x16a.\xda\x8a`@\x01Q\x83\x81Q\x81\x10a \xdbWa \xdbaTNV[g\xff\xff\xff\xff\xff\xff\xff\xff\x19\x16\x14a/vW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`a`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: quorumApk hash in storage d`d\x82\x01R\x7foes not match provided quorum ap`\x84\x82\x01R`k`\xf8\x1b`\xa4\x82\x01R`\xc4\x01a\x06\x95V[a/\xa6\x89`@\x01Q\x82\x81Q\x81\x10a/\x8fWa/\x8faTNV[` \x02` \x01\x01Q\x87a:r\x90\x91\x90c\xff\xff\xff\xff\x16V[\x95P\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xc8)LV\x8d\x8d\x84\x81\x81\x10a/\xe9Wa/\xe9aTNV[\x90P\x015`\xf8\x1c`\xf8\x1b`\xf8\x1c\x8c\x8c`\xc0\x01Q\x85\x81Q\x81\x10a0\rWa0\raTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x86\x90\x1b\x16\x81R`\xff\x90\x93\x16`\x04\x84\x01Rc\xff\xff\xff\xff\x91\x82\x16`$\x84\x01R\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a0iW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a0\x8d\x91\x90aU\x16V[\x85` \x01Q\x82\x81Q\x81\x10a0\xa3Wa0\xa3aTNV[`\x01`\x01``\x1b\x03\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x82\x01R\x85\x01Q\x80Q\x82\x90\x81\x10a0\xcfWa0\xcfaTNV[` \x02` \x01\x01Q\x85`\0\x01Q\x82\x81Q\x81\x10a0\xedWa0\xedaTNV[` \x02` \x01\x01\x90`\x01`\x01``\x1b\x03\x16\x90\x81`\x01`\x01``\x1b\x03\x16\x81RPP`\0\x80[\x8a` \x01QQ\x81\x10\x15a2\xdbWa1e\x86`\0\x01Q\x82\x81Q\x81\x10a17Wa17aTNV[` \x02` \x01\x01Q\x8f\x8f\x86\x81\x81\x10a1QWa1QaTNV[`\x01\x92\x015`\xf8\x1c\x92\x90\x92\x1c\x81\x16\x14\x91\x90PV[\x15a2\xc9W\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xf2\xbe\x94\xae\x8f\x8f\x86\x81\x81\x10a1\xabWa1\xabaTNV[\x90P\x015`\xf8\x1c`\xf8\x1b`\xf8\x1c\x8e\x89` \x01Q\x85\x81Q\x81\x10a1\xcfWa1\xcfaTNV[` \x02` \x01\x01Q\x8f`\xe0\x01Q\x88\x81Q\x81\x10a1\xedWa1\xedaTNV[` \x02` \x01\x01Q\x87\x81Q\x81\x10a2\x06Wa2\x06aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x87\x90\x1b\x16\x81R`\xff\x90\x94\x16`\x04\x85\x01Rc\xff\xff\xff\xff\x92\x83\x16`$\x85\x01R`D\x84\x01\x91\x90\x91R\x16`d\x82\x01R`\x84\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a2jW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a2\x8e\x91\x90aU\x16V[\x87Q\x80Q\x85\x90\x81\x10a2\xa2Wa2\xa2aTNV[` \x02` \x01\x01\x81\x81Qa2\xb6\x91\x90aZ\x9dV[`\x01`\x01``\x1b\x03\x16\x90RP`\x01\x90\x91\x01\x90[\x80a2\xd3\x81aUUV[\x91PPa1\x11V[PP\x80\x80a2\xe8\x90aUUV[\x91PPa,wV[PPP`\0\x80a3\n\x8c\x86\x8a``\x01Q\x8b`\x80\x01Qa\x07\xe9V[\x91P\x91P\x81a3{W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`C`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: pairing precompile call fai`d\x82\x01Rb\x1b\x19Y`\xea\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x80a3\xdcW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`9`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: signature is invalid\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[PP`\0\x87\x82` \x01Q`@Q` \x01a3\xf7\x92\x91\x90aYLV[`@\x80Q\x80\x83\x03`\x1f\x19\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x92\x9b\x92\x9aP\x91\x98PPPPPPPPPV[a4)a@\xb6V[a43`\0aA\x10V[V[`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R`\0\x91``\x91\x83\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x84\x81`\0\x81Q\x81\x10a4pWa4paTNV[` \x90\x81\x02\x91\x90\x91\x01\x01R`@Qca\xc8\xa1/`\xe1\x1b\x81R`\0\x90`\x01`\x01`\xa0\x1b\x03\x88\x16\x90c\xc3\x91B^\x90a4\xac\x90\x88\x90\x86\x90`\x04\x01aX\xc2V[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a4\xc9W=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra4\xf1\x91\x90\x81\x01\x90aU\xb5V[`\0\x81Q\x81\x10a5\x03Wa5\x03aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Qc\x04\xeccQ`\xe0\x1b\x81R`\x04\x81\x01\x88\x90Rc\xff\xff\xff\xff\x87\x81\x16`$\x83\x01R\x90\x91\x16`D\x82\x01\x81\x90R\x91P`\0\x90`\x01`\x01`\xa0\x1b\x03\x89\x16\x90c\x04\xeccQ\x90`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a5oW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a5\x93\x91\x90aV\x95V[`\x01`\x01`\xc0\x1b\x03\x16\x90P`\0a5\xa9\x82aAbV[\x90P\x81a5\xb7\x8a\x83\x8aa\tsV[\x95P\x95PPPPP\x93P\x93\x91PPV[a5\xcfa@\xb6V[`\x01`\x01`\xa0\x1b\x03\x81\x16a64W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7fOwnable: new owner is the zero a`D\x82\x01Reddress`\xd0\x1b`d\x82\x01R`\x84\x01a\x06\x95V[a\x06\xa7\x81aA\x10V[`\0Ta\x01\0\x90\x04`\xff\x16\x15\x80\x80\x15a6]WP`\0T`\x01`\xff\x90\x91\x16\x10[\x80a6wWP0;\x15\x80\x15a6wWP`\0T`\xff\x16`\x01\x14[a6\xdaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7fInitializable: contract is alrea`D\x82\x01Rm\x19\x1eH\x1a[\x9a]\x1aX[\x1a^\x99Y`\x92\x1b`d\x82\x01R`\x84\x01a\x06\x95V[`\0\x80T`\xff\x19\x16`\x01\x17\x90U\x80\x15a6\xfdW`\0\x80Ta\xff\0\x19\x16a\x01\0\x17\x90U[a7\x08\x85`\0aB.V[a7\x11\x84aA\x10V[`\xcd\x80T`\x01`\x01`\xa0\x1b\x03\x80\x86\x16`\x01`\x01`\xa0\x1b\x03\x19\x92\x83\x16\x17\x90\x92U`\xce\x80T\x92\x85\x16\x92\x90\x91\x16\x91\x90\x91\x17\x90U\x80\x15a7\x87W`\0\x80Ta\xff\0\x19\x16\x90U`@Q`\x01\x81R\x7f\x7f&\xb8?\xf9n\x1f+jh/\x138R\xf6y\x8a\t\xc4e\xda\x95\x92\x14`\xce\xfb8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xa1[PPPPPV[`e`\0\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xa0\x1b\x03\x16`\x01`\x01`\xa0\x1b\x03\x16c\xea\xb6mz`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a7\xe1W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a8\x05\x91\x90aS\x82V[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a85W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x06\x95\x90aS\x9fV[`fT\x19\x81\x19`fT\x19\x16\x14a8\xb3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7fPausable.unpause: invalid attemp`D\x82\x01R\x7ft to pause functionality\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`f\x81\x90U`@Q\x81\x81R3\x90\x7f5\x82\xd1\x82\x8e&\xbfV\xbd\x80\x15\x02\xbc\x02\x1a\xc0\xbc\x8a\xfbW\xc8&\xe4\x98kEY<\x8f\xad8\x9c\x90` \x01a\x07\xdeV[`\x01`\x01`\xa0\x1b\x03\x81\x16a9xW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`I`$\x82\x01R\x7fPausable._setPauserRegistry: new`D\x82\x01R\x7fPauserRegistry cannot be the zer`d\x82\x01Rho address`\xb8\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[`eT`@\x80Q`\x01`\x01`\xa0\x1b\x03\x92\x83\x16\x81R\x91\x83\x16` \x83\x01R\x7fn\x9f\xcdS\x98\x96\xfc\xa6\x0e\x8b\x0f\x01\xddX\x023\xe4\x8ak\x0f}\xf0\x13\xb8\x9b\xa7\xf5e\x86\x9a\xcd\xb6\x91\x01`@Q\x80\x91\x03\x90\xa1`e\x80T`\x01`\x01`\xa0\x1b\x03\x19\x16`\x01`\x01`\xa0\x1b\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01Ra9\xfdaE\xd3V[\x83Q\x81R` \x80\x85\x01Q\x90\x82\x01R`@\x80\x82\x01\x84\x90R`\0\x90\x83``\x84`\x07a\x07\xd0Z\x03\xfa\x90P\x80\x80a:,W\xfe[P\x80a:jW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\r`$\x82\x01Rl\x19X\xcb[][\x0bY\x98Z[\x19Y`\x9a\x1b`D\x82\x01R`d\x01a\x06\x95V[PP\x92\x91PPV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01Ra:\x8eaE\xf1V[\x83Q\x81R` \x80\x85\x01Q\x81\x83\x01R\x83Q`@\x80\x84\x01\x91\x90\x91R\x90\x84\x01Q``\x83\x01R`\0\x90\x83`\x80\x84`\x06a\x07\xd0Z\x03\xfa\x90P\x80\x80a:\xc9W\xfe[P\x80a:jW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\r`$\x82\x01Rl\x19X\xcbXY\x19\x0bY\x98Z[\x19Y`\x9a\x1b`D\x82\x01R`d\x01a\x06\x95V[a;\x0faF\x0fV[P`@\x80Q`\x80\x81\x01\x82R\x7f\x19\x8e\x93\x93\x92\rH:r`\xbf\xb71\xfb]%\xf1\xaaI35\xa9\xe7\x12\x97\xe4\x85\xb7\xae\xf3\x12\xc2\x81\x83\x01\x90\x81R\x7f\x18\0\xde\xef\x12\x1f\x1evBj\0f^\\DygC\"\xd4\xf7^\xda\xddF\xde\xbd\\\xd9\x92\xf6\xed``\x83\x01R\x81R\x81Q\x80\x83\x01\x90\x92R\x7f']\xc4\xa2\x88\xd1\xaf\xb3\xcb\xb1\xac\t\x18u$\xc7\xdb69]\xf7\xbe;\x99\xe6s\xb1:\x07Ze\xec\x82R\x7f\x1d\x9b\xef\xcd\x05\xa52>m\xa4\xd45\xf3\xb6\x17\xcd\xb3\xaf\x83(\\-\xf7\x11\xef9\xc0\x15q\x82\x7f\x9d` \x83\x81\x01\x91\x90\x91R\x81\x01\x91\x90\x91R\x90V[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R`\0\x80\x80a;\xf7`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x86aTdV[\x90P[a<\x03\x81aC\x18V[\x90\x93P\x91P`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x82\x83\t\x83\x03a<<W`@\x80Q\x80\x82\x01\x90\x91R\x90\x81R` \x81\x01\x91\x90\x91R\x93\x92PPPV[`\0\x80Q` aZ\xdf\x839\x81Q\x91R`\x01\x82\x08\x90Pa;\xfaV[`@\x80Q\x80\x82\x01\x82R\x86\x81R` \x80\x82\x01\x86\x90R\x82Q\x80\x84\x01\x90\x93R\x86\x83R\x82\x01\x84\x90R`\0\x91\x82\x91\x90a<\x88aF4V[`\0[`\x02\x81\x10\x15a>MW`\0a<\xa1\x82`\x06aX\x7fV[\x90P\x84\x82`\x02\x81\x10a<\xb5Wa<\xb5aTNV[` \x02\x01QQ\x83a<\xc7\x83`\0aZ_V[`\x0c\x81\x10a<\xd7Wa<\xd7aTNV[` \x02\x01R\x84\x82`\x02\x81\x10a<\xeeWa<\xeeaTNV[` \x02\x01Q` \x01Q\x83\x82`\x01a=\x05\x91\x90aZ_V[`\x0c\x81\x10a=\x15Wa=\x15aTNV[` \x02\x01R\x83\x82`\x02\x81\x10a=,Wa=,aTNV[` \x02\x01QQQ\x83a=?\x83`\x02aZ_V[`\x0c\x81\x10a=OWa=OaTNV[` \x02\x01R\x83\x82`\x02\x81\x10a=fWa=faTNV[` \x02\x01QQ`\x01` \x02\x01Q\x83a=\x7f\x83`\x03aZ_V[`\x0c\x81\x10a=\x8fWa=\x8faTNV[` \x02\x01R\x83\x82`\x02\x81\x10a=\xa6Wa=\xa6aTNV[` \x02\x01Q` \x01Q`\0`\x02\x81\x10a=\xc1Wa=\xc1aTNV[` \x02\x01Q\x83a=\xd2\x83`\x04aZ_V[`\x0c\x81\x10a=\xe2Wa=\xe2aTNV[` \x02\x01R\x83\x82`\x02\x81\x10a=\xf9Wa=\xf9aTNV[` \x02\x01Q` \x01Q`\x01`\x02\x81\x10a>\x14Wa>\x14aTNV[` \x02\x01Q\x83a>%\x83`\x05aZ_V[`\x0c\x81\x10a>5Wa>5aTNV[` \x02\x01RP\x80a>E\x81aUUV[\x91PPa<\x8bV[Pa>VaFSV[`\0` \x82a\x01\x80\x85`\x08\x8c\xfa\x91Q\x91\x9c\x91\x15\x15\x9bP\x90\x99PPPPPPPPPPV[`\0\x80a>\x86\x84aC\x9aV[\x90P\x80\x83`\xff\x16`\x01\x90\x1b\x11a?\x04W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`?`$\x82\x01R\x7fBitmapUtils.orderedBytesArrayToB`D\x82\x01R\x7fitmap: bitmap exceeds max value\0`d\x82\x01R`\x84\x01a\x06\x95V[\x90P[\x92\x91PPV[`\0\x80[\x82\x15a?\x07Wa?\"`\x01\x84aZ3V[\x90\x92\x16\x91\x80a?0\x81aZ\xbdV[\x91PPa?\x11V[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01Ra\x02\0\x82a\xff\xff\x16\x10a?\x94W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x10`$\x82\x01Roscalar-too-large`\x80\x1b`D\x82\x01R`d\x01a\x06\x95V[\x81a\xff\xff\x16`\x01\x03a?\xa7WP\x81a?\x07V[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01\x81\x90R\x84\x90`\x01\x90[\x81a\xff\xff\x16\x86a\xff\xff\x16\x10a@\x10W`\x01a\xff\xff\x87\x16`\xff\x83\x16\x1c\x81\x16\x90\x03a?\xf3Wa?\xf0\x84\x84a:rV[\x93P[a?\xfd\x83\x84a:rV[\x92Pb\x01\xff\xfe`\x01\x92\x83\x1b\x16\x91\x01a?\xc3V[P\x91\x95\x94PPPPPV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R\x81Q\x15\x80\x15a@@WP` \x82\x01Q\x15[\x15a@^WPP`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R\x90V[`@Q\x80`@\x01`@R\x80\x83`\0\x01Q\x81R` \x01`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x84` \x01Qa@\x91\x91\x90aTdV[a@\xa9\x90`\0\x80Q` aZ\xdf\x839\x81Q\x91RaZ3V[\x90R\x92\x91PPV[\x91\x90PV[`3T`\x01`\x01`\xa0\x1b\x03\x163\x14a43W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7fOwnable: caller is not the owner`D\x82\x01R`d\x01a\x06\x95V[`3\x80T`\x01`\x01`\xa0\x1b\x03\x83\x81\x16`\x01`\x01`\xa0\x1b\x03\x19\x83\x16\x81\x17\x90\x93U`@Q\x91\x16\x91\x90\x82\x90\x7f\x8b\xe0\x07\x9cS\x16Y\x14\x13D\xcd\x1f\xd0\xa4\xf2\x84\x19I\x7f\x97\"\xa3\xda\xaf\xe3\xb4\x18okdW\xe0\x90`\0\x90\xa3PPV[```\0\x80aAp\x84a?\rV[a\xff\xff\x16`\x01`\x01`@\x1b\x03\x81\x11\x15aA\x8bWaA\x8baF\xf8V[`@Q\x90\x80\x82R\x80`\x1f\x01`\x1f\x19\x16` \x01\x82\x01`@R\x80\x15aA\xb5W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\0\x80[\x82Q\x82\x10\x80\x15aA\xcdWPa\x01\0\x81\x10[\x15aB$W`\x01\x81\x1b\x93P\x85\x84\x16\x15aB\x14W\x80`\xf8\x1b\x83\x83\x81Q\x81\x10aA\xf6WaA\xf6aTNV[` \x01\x01\x90`\x01`\x01`\xf8\x1b\x03\x19\x16\x90\x81`\0\x1a\x90SP\x81`\x01\x01\x91P[aB\x1d\x81aUUV[\x90PaA\xbcV[P\x90\x94\x93PPPPV[`eT`\x01`\x01`\xa0\x1b\x03\x16\x15\x80\x15aBOWP`\x01`\x01`\xa0\x1b\x03\x82\x16\x15\x15[aB\xd1W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fPausable._initializePauser: _ini`D\x82\x01R\x7ftializePauser() can only be call`d\x82\x01Rfed once`\xc8\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[`f\x81\x90U`@Q\x81\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01`@Q\x80\x91\x03\x90\xa2aC\x14\x82a8\xeaV[PPV[`\0\x80\x80`\0\x80Q` aZ\xdf\x839\x81Q\x91R`\x03`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x86`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x88\x89\t\t\x08\x90P`\0aC\x8e\x82\x7f\x0c\x19\x13\x9c\xb8Lh\nn\x14\x11m\xa0`V\x17e\xe0Z\xa4Z\x1cr\xa3O\x08#\x05\xb6\x1f?R`\0\x80Q` aZ\xdf\x839\x81Q\x91RaE*V[\x91\x95\x91\x94P\x90\x92PPPV[`\0a\x01\0\x82Q\x11\x15aD#W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R\x7fBitmapUtils.orderedBytesArrayToB\x90\x82\x01R\x7fitmap: orderedBytesArray is too `d\x82\x01Rclong`\xe0\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x81Q`\0\x03aD4WP`\0\x91\x90PV[`\0\x80\x83`\0\x81Q\x81\x10aDJWaDJaTNV[\x01` \x01Q`\x01`\xf8\x91\x90\x91\x1c\x81\x90\x1b\x92P[\x84Q\x81\x10\x15aE!W\x84\x81\x81Q\x81\x10aDxWaDxaTNV[\x01` \x01Q`\x01`\xf8\x91\x90\x91\x1c\x1b\x91P\x82\x82\x11aE\rW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fBitmapUtils.orderedBytesArrayToB`D\x82\x01R\x7fitmap: orderedBytesArray is not `d\x82\x01Rf\x1b\xdc\x99\x19\\\x99Y`\xca\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x91\x81\x17\x91aE\x1a\x81aUUV[\x90PaD]V[P\x90\x93\x92PPPV[`\0\x80aE5aFSV[aE=aFqV[` \x80\x82R\x81\x81\x01\x81\x90R`@\x82\x01\x81\x90R``\x82\x01\x88\x90R`\x80\x82\x01\x87\x90R`\xa0\x82\x01\x86\x90R\x82`\xc0\x83`\x05a\x07\xd0Z\x03\xfa\x92P\x82\x80aEzW\xfe[P\x82aE\xc8W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x1a`$\x82\x01R\x7fBN254.expMod: call failure\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\x95V[PQ\x95\x94PPPPPV[`@Q\x80``\x01`@R\x80`\x03\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`\x80\x01`@R\x80`\x04\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`@\x01`@R\x80aF\"aF\x8fV[\x81R` \x01aF/aF\x8fV[\x90R\x90V[`@Q\x80a\x01\x80\x01`@R\x80`\x0c\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80` \x01`@R\x80`\x01\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`\xc0\x01`@R\x80`\x06\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x14a\x06\xa7W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aF\xd4W`\0\x80\xfd[\x815a?\x04\x81aF\xadV[`\0` \x82\x84\x03\x12\x15aF\xf1W`\0\x80\xfd[P5\x91\x90PV[cNH{q`\xe0\x1b`\0R`A`\x04R`$`\0\xfd[`@\x80Q\x90\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aG0WaG0aF\xf8V[`@R\x90V[`@Qa\x01\0\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aG0WaG0aF\xf8V[`@Q`\x1f\x82\x01`\x1f\x19\x16\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aG\x81WaG\x81aF\xf8V[`@R\x91\x90PV[`\0`@\x82\x84\x03\x12\x15aG\x9bW`\0\x80\xfd[aG\xa3aG\x0eV[\x90P\x815\x81R` \x82\x015` \x82\x01R\x92\x91PPV[`\0\x82`\x1f\x83\x01\x12aG\xcaW`\0\x80\xfd[aG\xd2aG\x0eV[\x80`@\x84\x01\x85\x81\x11\x15aG\xe4W`\0\x80\xfd[\x84[\x81\x81\x10\x15aG\xfeW\x805\x84R` \x93\x84\x01\x93\x01aG\xe6V[P\x90\x95\x94PPPPPV[`\0`\x80\x82\x84\x03\x12\x15aH\x1bW`\0\x80\xfd[aH#aG\x0eV[\x90PaH/\x83\x83aG\xb9V[\x81RaH>\x83`@\x84\x01aG\xb9V[` \x82\x01R\x92\x91PPV[`\0\x80`\0\x80a\x01 \x85\x87\x03\x12\x15aH`W`\0\x80\xfd[\x845\x93PaHq\x86` \x87\x01aG\x89V[\x92PaH\x80\x86``\x87\x01aH\tV[\x91PaH\x8f\x86`\xe0\x87\x01aG\x89V[\x90P\x92\x95\x91\x94P\x92PV[c\xff\xff\xff\xff\x81\x16\x81\x14a\x06\xa7W`\0\x80\xfd[\x805a@\xb1\x81aH\x9aV[`\0` \x82\x84\x03\x12\x15aH\xc9W`\0\x80\xfd[\x815a?\x04\x81aH\x9aV[`\0\x80`\0``\x84\x86\x03\x12\x15aH\xe9W`\0\x80\xfd[\x835aH\xf4\x81aF\xadV[\x92P` \x84\x81\x015`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aI\x11W`\0\x80\xfd[\x81\x87\x01\x91P\x87`\x1f\x83\x01\x12aI%W`\0\x80\xfd[\x815\x81\x81\x11\x15aI7WaI7aF\xf8V[aII`\x1f\x82\x01`\x1f\x19\x16\x85\x01aGYV[\x91P\x80\x82R\x88\x84\x82\x85\x01\x01\x11\x15aI_W`\0\x80\xfd[\x80\x84\x84\x01\x85\x84\x017`\0\x84\x82\x84\x01\x01RP\x80\x94PPPPaI\x82`@\x85\x01aH\xacV[\x90P\x92P\x92P\x92V[`\0\x81Q\x80\x84R` \x80\x85\x01\x80\x81\x96P\x83`\x05\x1b\x81\x01\x91P\x82\x86\x01`\0\x80[\x86\x81\x10\x15aJ!W\x83\x85\x03\x8aR\x82Q\x80Q\x80\x87R\x90\x87\x01\x90\x87\x87\x01\x90\x84[\x81\x81\x10\x15aJ\x0cW\x83Q\x80Q`\x01`\x01`\xa0\x1b\x03\x16\x84R\x8a\x81\x01Q\x8b\x85\x01R`@\x90\x81\x01Q`\x01`\x01``\x1b\x03\x16\x90\x84\x01R\x92\x89\x01\x92``\x90\x92\x01\x91`\x01\x01aI\xc8V[PP\x9a\x87\x01\x9a\x95PP\x91\x85\x01\x91`\x01\x01aI\xaaV[P\x92\x98\x97PPPPPPPPV[` \x81R`\0aJB` \x83\x01\x84aI\x8bV[\x93\x92PPPV[\x80\x15\x15\x81\x14a\x06\xa7W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aJiW`\0\x80\xfd[\x815a?\x04\x81aJIV[`\0\x80\x83`\x1f\x84\x01\x12aJ\x86W`\0\x80\xfd[P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aJ\x9dW`\0\x80\xfd[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15aJ\xb5W`\0\x80\xfd[\x92P\x92\x90PV[`\0\x80`\0\x80`\0\x80`\x80\x87\x89\x03\x12\x15aJ\xd5W`\0\x80\xfd[\x865aJ\xe0\x81aF\xadV[\x95P` \x87\x015aJ\xf0\x81aH\x9aV[\x94P`@\x87\x015`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aK\x0cW`\0\x80\xfd[aK\x18\x8a\x83\x8b\x01aJtV[\x90\x96P\x94P``\x89\x015\x91P\x80\x82\x11\x15aK1W`\0\x80\xfd[\x81\x89\x01\x91P\x89`\x1f\x83\x01\x12aKEW`\0\x80\xfd[\x815\x81\x81\x11\x15aKTW`\0\x80\xfd[\x8a` \x82`\x05\x1b\x85\x01\x01\x11\x15aKiW`\0\x80\xfd[` \x83\x01\x94P\x80\x93PPPP\x92\x95P\x92\x95P\x92\x95V[`\0\x81Q\x80\x84R` \x80\x85\x01\x94P\x80\x84\x01`\0[\x83\x81\x10\x15aK\xb5W\x81Qc\xff\xff\xff\xff\x16\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01aK\x93V[P\x94\x95\x94PPPPPV[`\0` \x80\x83R\x83Q`\x80\x82\x85\x01RaK\xdc`\xa0\x85\x01\x82aK\x7fV[\x90P\x81\x85\x01Q`\x1f\x19\x80\x86\x84\x03\x01`@\x87\x01RaK\xf9\x83\x83aK\x7fV[\x92P`@\x87\x01Q\x91P\x80\x86\x84\x03\x01``\x87\x01RaL\x16\x83\x83aK\x7fV[``\x88\x01Q\x87\x82\x03\x83\x01`\x80\x89\x01R\x80Q\x80\x83R\x91\x94P\x85\x01\x92P\x84\x84\x01\x90`\x05\x81\x90\x1b\x85\x01\x86\x01`\0[\x82\x81\x10\x15aLmW\x84\x87\x83\x03\x01\x84RaL[\x82\x87QaK\x7fV[\x95\x88\x01\x95\x93\x88\x01\x93\x91P`\x01\x01aLAV[P\x99\x98PPPPPPPPPV[`\xff\x81\x16\x81\x14a\x06\xa7W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aL\x9cW`\0\x80\xfd[\x815a?\x04\x81aL{V[`\0`\x80\x82\x84\x03\x12\x15aL\xb9W`\0\x80\xfd[P\x91\x90PV[`\0`@\x82\x84\x03\x12\x15aL\xb9W`\0\x80\xfd[`\0`\x01`\x01`@\x1b\x03\x82\x11\x15aL\xeaWaL\xeaaF\xf8V[P`\x05\x1b` \x01\x90V[`\0\x82`\x1f\x83\x01\x12aM\x05W`\0\x80\xfd[\x815` aM\x1aaM\x15\x83aL\xd1V[aGYV[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aM9W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aM]W\x805aMP\x81aH\x9aV[\x83R\x91\x83\x01\x91\x83\x01aM=V[P\x96\x95PPPPPPV[`\0\x82`\x1f\x83\x01\x12aMyW`\0\x80\xfd[\x815` aM\x89aM\x15\x83aL\xd1V[\x82\x81R`\x06\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aM\xa8W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aM]WaM\xbe\x88\x82aG\x89V[\x83R\x91\x83\x01\x91`@\x01aM\xacV[`\0\x82`\x1f\x83\x01\x12aM\xddW`\0\x80\xfd[\x815` aM\xedaM\x15\x83aL\xd1V[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aN\x0cW`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aM]W\x805`\x01`\x01`@\x1b\x03\x81\x11\x15aN/W`\0\x80\x81\xfd[aN=\x89\x86\x83\x8b\x01\x01aL\xf4V[\x84RP\x91\x83\x01\x91\x83\x01aN\x10V[`\0a\x01\x80\x82\x84\x03\x12\x15aN^W`\0\x80\xfd[aNfaG6V[\x90P\x815`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aN\x7fW`\0\x80\xfd[aN\x8b\x85\x83\x86\x01aL\xf4V[\x83R` \x84\x015\x91P\x80\x82\x11\x15aN\xa1W`\0\x80\xfd[aN\xad\x85\x83\x86\x01aMhV[` \x84\x01R`@\x84\x015\x91P\x80\x82\x11\x15aN\xc6W`\0\x80\xfd[aN\xd2\x85\x83\x86\x01aMhV[`@\x84\x01RaN\xe4\x85``\x86\x01aH\tV[``\x84\x01RaN\xf6\x85`\xe0\x86\x01aG\x89V[`\x80\x84\x01Ra\x01 \x84\x015\x91P\x80\x82\x11\x15aO\x10W`\0\x80\xfd[aO\x1c\x85\x83\x86\x01aL\xf4V[`\xa0\x84\x01Ra\x01@\x84\x015\x91P\x80\x82\x11\x15aO6W`\0\x80\xfd[aOB\x85\x83\x86\x01aL\xf4V[`\xc0\x84\x01Ra\x01`\x84\x015\x91P\x80\x82\x11\x15aO\\W`\0\x80\xfd[PaOi\x84\x82\x85\x01aM\xccV[`\xe0\x83\x01RP\x92\x91PPV[`\0\x80`\0`\x80\x84\x86\x03\x12\x15aO\x8aW`\0\x80\xfd[\x835`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aO\xa1W`\0\x80\xfd[aO\xad\x87\x83\x88\x01aL\xa7V[\x94PaO\xbc\x87` \x88\x01aL\xbfV[\x93P``\x86\x015\x91P\x80\x82\x11\x15aO\xd2W`\0\x80\xfd[PaO\xdf\x86\x82\x87\x01aNKV[\x91PP\x92P\x92P\x92V[`\0\x80`\0``\x84\x86\x03\x12\x15aO\xfeW`\0\x80\xfd[\x835aP\t\x81aF\xadV[\x92P` \x84\x81\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aP%W`\0\x80\xfd[\x85\x01`\x1f\x81\x01\x87\x13aP6W`\0\x80\xfd[\x805aPDaM\x15\x82aL\xd1V[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x89\x83\x11\x15aPcW`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15aP\x81W\x835\x82R\x92\x84\x01\x92\x90\x84\x01\x90aPhV[\x80\x96PPPPPPaI\x82`@\x85\x01aH\xacV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R`\0\x91\x90\x84\x82\x01\x90`@\x85\x01\x90\x84[\x81\x81\x10\x15aP\xcdW\x83Q\x83R\x92\x84\x01\x92\x91\x84\x01\x91`\x01\x01aP\xb1V[P\x90\x96\x95PPPPPPV[`\0\x80`\0\x80`\xc0\x85\x87\x03\x12\x15aP\xefW`\0\x80\xfd[\x845`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aQ\x06W`\0\x80\xfd[aQ\x12\x88\x83\x89\x01aL\xa7V[\x95PaQ!\x88` \x89\x01aL\xbfV[\x94PaQ0\x88``\x89\x01aL\xbfV[\x93P`\xa0\x87\x015\x91P\x80\x82\x11\x15aQFW`\0\x80\xfd[PaQS\x87\x82\x88\x01aMhV[\x91PP\x92\x95\x91\x94P\x92PV[`\0\x80`\0\x80``\x85\x87\x03\x12\x15aQuW`\0\x80\xfd[\x845\x93P` \x85\x015aQ\x87\x81aH\x9aV[\x92P`@\x85\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aQ\xa2W`\0\x80\xfd[aQ\xae\x87\x82\x88\x01aJtV[\x95\x98\x94\x97P\x95PPPPV[`\0\x80`\0\x80`\0`\x80\x86\x88\x03\x12\x15aQ\xd2W`\0\x80\xfd[\x855\x94P` \x86\x015`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aQ\xf0W`\0\x80\xfd[aQ\xfc\x89\x83\x8a\x01aJtV[\x90\x96P\x94P`@\x88\x015\x91PaR\x11\x82aH\x9aV[\x90\x92P``\x87\x015\x90\x80\x82\x11\x15aR'W`\0\x80\xfd[PaR4\x88\x82\x89\x01aNKV[\x91PP\x92\x95P\x92\x95\x90\x93PV[`\0\x81Q\x80\x84R` \x80\x85\x01\x94P\x80\x84\x01`\0[\x83\x81\x10\x15aK\xb5W\x81Q`\x01`\x01``\x1b\x03\x16\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01aRUV[`@\x81R`\0\x83Q`@\x80\x84\x01RaR\x95`\x80\x84\x01\x82aRAV[\x90P` \x85\x01Q`?\x19\x84\x83\x03\x01``\x85\x01RaR\xb2\x82\x82aRAV[\x92PPP\x82` \x83\x01R\x93\x92PPPV[`\0\x80`\0``\x84\x86\x03\x12\x15aR\xd8W`\0\x80\xfd[\x835aR\xe3\x81aF\xadV[\x92P` \x84\x015\x91P`@\x84\x015aR\xfa\x81aH\x9aV[\x80\x91PP\x92P\x92P\x92V[\x82\x81R`@` \x82\x01R`\0aS\x1e`@\x83\x01\x84aI\x8bV[\x94\x93PPPPV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15aS<W`\0\x80\xfd[\x845aSG\x81aF\xadV[\x93P` \x85\x015aSW\x81aF\xadV[\x92P`@\x85\x015aSg\x81aF\xadV[\x91P``\x85\x015aSw\x81aF\xadV[\x93\x96\x92\x95P\x90\x93PPV[`\0` \x82\x84\x03\x12\x15aS\x94W`\0\x80\xfd[\x81Qa?\x04\x81aF\xadV[` \x80\x82R`*\x90\x82\x01R\x7fmsg.sender is not permissioned a`@\x82\x01Ri9\x90:\xb780\xba\xb9\xb2\xb9`\xb1\x1b``\x82\x01R`\x80\x01\x90V[`\0` \x82\x84\x03\x12\x15aS\xfbW`\0\x80\xfd[\x81Qa?\x04\x81aJIV[` \x80\x82R`(\x90\x82\x01R\x7fmsg.sender is not permissioned a`@\x82\x01Rg9\x9080\xba\xb9\xb2\xb9`\xc1\x1b``\x82\x01R`\x80\x01\x90V[cNH{q`\xe0\x1b`\0R`2`\x04R`$`\0\xfd[`\0\x82aT\x81WcNH{q`\xe0\x1b`\0R`\x12`\x04R`$`\0\xfd[P\x06\x90V[`\0` \x80\x83\x85\x03\x12\x15aT\x99W`\0\x80\xfd[\x82Q`\x01`\x01`@\x1b\x03\x81\x11\x15aT\xafW`\0\x80\xfd[\x83\x01`\x1f\x81\x01\x85\x13aT\xc0W`\0\x80\xfd[\x80QaT\xceaM\x15\x82aL\xd1V[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15aT\xedW`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15aU\x0bW\x83Q\x82R\x92\x84\x01\x92\x90\x84\x01\x90aT\xf2V[\x97\x96PPPPPPPV[`\0` \x82\x84\x03\x12\x15aU(W`\0\x80\xfd[\x81Q`\x01`\x01``\x1b\x03\x81\x16\x81\x14a?\x04W`\0\x80\xfd[cNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[`\0`\x01\x82\x01aUgWaUgaU?V[P`\x01\x01\x90V[c\xff\xff\xff\xff\x84\x16\x81R`@` \x82\x01\x81\x90R\x81\x01\x82\x90R`\0`\x01`\x01`\xfb\x1b\x03\x83\x11\x15aU\x9bW`\0\x80\xfd[\x82`\x05\x1b\x80\x85``\x85\x017\x91\x90\x91\x01``\x01\x94\x93PPPPV[`\0` \x80\x83\x85\x03\x12\x15aU\xc8W`\0\x80\xfd[\x82Q`\x01`\x01`@\x1b\x03\x81\x11\x15aU\xdeW`\0\x80\xfd[\x83\x01`\x1f\x81\x01\x85\x13aU\xefW`\0\x80\xfd[\x80QaU\xfdaM\x15\x82aL\xd1V[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15aV\x1cW`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15aU\x0bW\x83QaV4\x81aH\x9aV[\x82R\x92\x84\x01\x92\x90\x84\x01\x90aV!V[\x81\x83R\x81\x81` \x85\x017P`\0\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1f\x90\x91\x01`\x1f\x19\x16\x90\x91\x01\x01\x90V[c\xff\xff\xff\xff\x84\x16\x81R`@` \x82\x01R`\0aV\x8c`@\x83\x01\x84\x86aVCV[\x95\x94PPPPPV[`\0` \x82\x84\x03\x12\x15aV\xa7W`\0\x80\xfd[\x81Q`\x01`\x01`\xc0\x1b\x03\x81\x16\x81\x14a?\x04W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aV\xd0W`\0\x80\xfd[\x81Qa?\x04\x81aH\x9aV[`\0`\xff\x82\x16`\xff\x81\x03aV\xf1WaV\xf1aU?V[`\x01\x01\x92\x91PPV[`@\x81R`\0aW\x0e`@\x83\x01\x85\x87aVCV[\x90Pc\xff\xff\xff\xff\x83\x16` \x83\x01R\x94\x93PPPPV[`\0\x80\x835`\x1e\x19\x846\x03\x01\x81\x12aW;W`\0\x80\xfd[\x83\x01\x805\x91P`\x01`\x01`@\x1b\x03\x82\x11\x15aWUW`\0\x80\xfd[` \x01\x91P6\x81\x90\x03\x82\x13\x15aJ\xb5W`\0\x80\xfd[` \x81R\x815` \x82\x01R`\0` \x83\x015aW\x85\x81aH\x9aV[c\xff\xff\xff\xff\x81\x16`@\x84\x01RP`@\x83\x015`\x1e\x19\x846\x03\x01\x81\x12aW\xa9W`\0\x80\xfd[\x83\x01` \x81\x01\x905`\x01`\x01`@\x1b\x03\x81\x11\x15aW\xc5W`\0\x80\xfd[\x806\x03\x82\x13\x15aW\xd4W`\0\x80\xfd[`\x80``\x85\x01RaW\xe9`\xa0\x85\x01\x82\x84aVCV[\x91PPaW\xf8``\x85\x01aH\xacV[c\xff\xff\xff\xff\x81\x16`\x80\x85\x01RP\x93\x92PPPV[c\xff\xff\xff\xff\x81\x81\x16\x83\x82\x16\x01\x90\x80\x82\x11\x15aX)WaX)aU?V[P\x92\x91PPV[\x805aX;\x81aH\x9aV[c\xff\xff\xff\xff\x16\x82R` \x90\x81\x015\x91\x01RV[`@\x81\x01a?\x07\x82\x84aX0V[`\x01`\x01``\x1b\x03\x81\x81\x16\x83\x82\x16\x02\x80\x82\x16\x91\x90\x82\x81\x14a:jWa:jaU?V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a?\x07Wa?\x07aU?V[`\x80\x81\x01aX\xa4\x82\x85aX0V[c\xff\xff\xff\xff\x83Q\x16`@\x83\x01R` \x83\x01Q``\x83\x01R\x93\x92PPPV[`\0`@\x82\x01c\xff\xff\xff\xff\x85\x16\x83R` `@\x81\x85\x01R\x81\x85Q\x80\x84R``\x86\x01\x91P\x82\x87\x01\x93P`\0[\x81\x81\x10\x15aY\tW\x84Q\x83R\x93\x83\x01\x93\x91\x83\x01\x91`\x01\x01aX\xedV[P\x90\x97\x96PPPPPPPV[`\x80\x81\x01aY$\x82\x85aX0V[\x825aY/\x81aH\x9aV[c\xff\xff\xff\xff\x16`@\x83\x01R` \x92\x90\x92\x015``\x90\x91\x01R\x91\x90PV[c\xff\xff\xff\xff`\xe0\x1b\x83`\xe0\x1b\x16\x81R`\0`\x04\x82\x01\x83Q` \x80\x86\x01`\0[\x83\x81\x10\x15aY\x87W\x81Q\x85R\x93\x82\x01\x93\x90\x82\x01\x90`\x01\x01aYkV[P\x92\x97\x96PPPPPPPV[`\0` \x80\x83R\x83Q\x81\x84\x01Rc\xff\xff\xff\xff\x81\x85\x01Q\x16`@\x84\x01R`@\x84\x01Q`\x80``\x85\x01R\x80Q\x80`\xa0\x86\x01R`\0[\x81\x81\x10\x15aY\xe3W\x82\x81\x01\x84\x01Q\x86\x82\x01`\xc0\x01R\x83\x01aY\xc7V[P`\0\x85\x82\x01`\xc0\x01R``\x86\x01Qc\xff\xff\xff\xff\x81\x16`\x80\x87\x01R\x92P`\x1f\x01`\x1f\x19\x16\x93\x90\x93\x01`\xc0\x01\x94\x93PPPPV[`\0` \x82\x84\x03\x12\x15aZ(W`\0\x80\xfd[\x81Qa?\x04\x81aL{V[\x81\x81\x03\x81\x81\x11\x15a?\x07Wa?\x07aU?V[`\0` \x82\x84\x03\x12\x15aZXW`\0\x80\xfd[PQ\x91\x90PV[\x80\x82\x01\x80\x82\x11\x15a?\x07Wa?\x07aU?V[`\0` \x82\x84\x03\x12\x15aZ\x84W`\0\x80\xfd[\x81Qg\xff\xff\xff\xff\xff\xff\xff\xff\x19\x81\x16\x81\x14a?\x04W`\0\x80\xfd[`\x01`\x01``\x1b\x03\x82\x81\x16\x82\x82\x16\x03\x90\x80\x82\x11\x15aX)WaX)aU?V[`\0a\xff\xff\x80\x83\x16\x81\x81\x03aZ\xd4WaZ\xd4aU?V[`\x01\x01\x93\x92PPPV\xfe0dNr\xe11\xa0)\xb8PE\xb6\x81\x81X]\x97\x81j\x91hq\xca\x8d< \x8c\x16\xd8|\xfdGBLSSignatureChecker.checkSignatu\xa2dipfsX\"\x12 \xf9\x16\x98\x047\r\xa5\xb0N\xe2b4%\x05\xbc\xa8?\x82A\xd9\xd4\xb0\x81f3\xb1\xbe5\x12\x16_\x1ddsolcC\0\x08\x14\03");
    #[doc = r" The runtime bytecode of the contract, as deployed on the network."]
    #[doc = r""]
    #[doc = r" ```text"]
    #[doc = "0x608060405234801561001057600080fd5b506004361061021c5760003560e01c80636b532e9e116101255780638da5cb5b116100ad578063f2fde38b1161007c578063f2fde38b14610587578063f5c9899d1461059a578063f63c5bab146105c0578063f8c8765e146105c8578063fabc1cbc146105db57600080fd5b80638da5cb5b14610521578063b98d090814610532578063cefdc1d41461053f578063df5cf7231461056057600080fd5b8063715018a6116100f4578063715018a6146104d557806372d18e8d146104dd5780637afa1eed146104eb578063886f1195146104fe5780638b00ce7c1461051157600080fd5b80636b532e9e146104675780636b92787e1461047a5780636d14a9871461048d5780636efb4636146104b457600080fd5b80634f739f74116101a85780635c155662116101775780635c155662146103ce5780635c975abb146103ee5780635decc3f5146103f65780635df4594614610419578063683048351461044057600080fd5b80634f739f7414610360578063595c6a67146103805780635ac86ab7146103885780635baec9a0146103bb57600080fd5b8063245a7bfc116101ef578063245a7bfc146102b45780632cb223d5146102df5780632d89f6fc1461030d5780633563b0d11461032d578063416c7e5e1461034d57600080fd5b806310d67a2f14610221578063136439dd14610236578063171f1d5b146102495780631ad4318914610278575b600080fd5b61023461022f3660046146c2565b6105ee565b005b6102346102443660046146df565b6106aa565b61025c610257366004614849565b6107e9565b6040805192151583529015156020830152015b60405180910390f35b61029f7f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff909116815260200161026f565b60cd546102c7906001600160a01b031681565b6040516001600160a01b03909116815260200161026f565b6102ff6102ed3660046148b7565b60cb6020526000908152604090205481565b60405190815260200161026f565b6102ff61031b3660046148b7565b60ca6020526000908152604090205481565b61034061033b3660046148d4565b610973565b60405161026f9190614a2f565b61023461035b366004614a57565b610e09565b61037361036e366004614abc565b610f7e565b60405161026f9190614bc0565b6102346116a6565b6103ab610396366004614c8a565b606654600160ff9092169190911b9081161490565b604051901515815260200161026f565b6102346103c9366004614f75565b61176d565b6103e16103dc366004614fe9565b611bec565b60405161026f9190615095565b6066546102ff565b6103ab6104043660046148b7565b60cc6020526000908152604090205460ff1681565b6102c77f000000000000000000000000000000000000000000000000000000000000000081565b6102c77f000000000000000000000000000000000000000000000000000000000000000081565b6102346104753660046150d9565b611db4565b61023461048836600461515f565b612386565b6102c77f000000000000000000000000000000000000000000000000000000000000000081565b6104c76104c23660046151ba565b612527565b60405161026f92919061527a565b610234613421565b60c95463ffffffff1661029f565b60ce546102c7906001600160a01b031681565b6065546102c7906001600160a01b031681565b60c95461029f9063ffffffff1681565b6033546001600160a01b03166102c7565b6097546103ab9060ff1681565b61055261054d3660046152c3565b613435565b60405161026f929190615305565b6102c77f000000000000000000000000000000000000000000000000000000000000000081565b6102346105953660046146c2565b6135c7565b7f000000000000000000000000000000000000000000000000000000000000000061029f565b61029f606481565b6102346105d6366004615326565b61363d565b6102346105e93660046146df565b61378e565b606560009054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610641573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106659190615382565b6001600160a01b0316336001600160a01b03161461069e5760405162461bcd60e51b81526004016106959061539f565b60405180910390fd5b6106a7816138ea565b50565b60655460405163237dfb4760e11b81523360048201526001600160a01b03909116906346fbf68e90602401602060405180830381865afa1580156106f2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061071691906153e9565b6107325760405162461bcd60e51b815260040161069590615406565b606654818116146107ab5760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e70617573653a20696e76616c696420617474656d70742060448201527f746f20756e70617573652066756e6374696f6e616c69747900000000000000006064820152608401610695565b606681905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d906020015b60405180910390a250565b60008060007f30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001878760000151886020015188600001516000600281106108315761083161544e565b60200201518951600160200201518a602001516000600281106108565761085661544e565b60200201518b602001516001600281106108725761087261544e565b602090810291909101518c518d8301516040516108cf9a99989796959401988952602089019790975260408801959095526060870193909352608086019190915260a085015260c084015260e08301526101008201526101200190565b6040516020818303038152906040528051906020012060001c6108f29190615464565b905061096561090b61090488846139e1565b8690613a72565b610913613b07565b61095b61094c85610946604080518082018252600080825260209182015281518083019092526001825260029082015290565b906139e1565b6109558c613bc7565b90613a72565b886201d4c0613c56565b909890975095505050505050565b60606000846001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109d99190615382565b90506000856001600160a01b0316639e9923c26040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a1b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a3f9190615382565b90506000866001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa158015610a81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610aa59190615382565b9050600086516001600160401b03811115610ac257610ac26146f8565b604051908082528060200260200182016040528015610af557816020015b6060815260200190600190039081610ae05790505b50905060005b8751811015610dfd576000888281518110610b1857610b1861544e565b0160200151604051638902624560e01b815260f89190911c6004820181905263ffffffff8a16602483015291506000906001600160a01b03871690638902624590604401600060405180830381865afa158015610b79573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610ba19190810190615486565b905080516001600160401b03811115610bbc57610bbc6146f8565b604051908082528060200260200182016040528015610c0757816020015b6040805160608101825260008082526020808301829052928201528252600019909201910181610bda5790505b50848481518110610c1a57610c1a61544e565b602002602001018190525060005b8151811015610de7576040518060600160405280876001600160a01b03166347b314e8858581518110610c5d57610c5d61544e565b60200260200101516040518263ffffffff1660e01b8152600401610c8391815260200190565b602060405180830381865afa158015610ca0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cc49190615382565b6001600160a01b03168152602001838381518110610ce457610ce461544e565b60200260200101518152602001896001600160a01b031663fa28c627858581518110610d1257610d1261544e565b60209081029190910101516040516001600160e01b031960e084901b168152600481019190915260ff8816602482015263ffffffff8f166044820152606401602060405180830381865afa158015610d6e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d929190615516565b6001600160601b0316815250858581518110610db057610db061544e565b60200260200101518281518110610dc957610dc961544e565b60200260200101819052508080610ddf90615555565b915050610c28565b5050508080610df590615555565b915050610afb565b50979650505050505050565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638da5cb5b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e67573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8b9190615382565b6001600160a01b0316336001600160a01b031614610f375760405162461bcd60e51b815260206004820152605c60248201527f424c535369676e6174757265436865636b65722e6f6e6c79436f6f7264696e6160448201527f746f724f776e65723a2063616c6c6572206973206e6f7420746865206f776e6560648201527f72206f6620746865207265676973747279436f6f7264696e61746f7200000000608482015260a401610695565b6097805460ff19168215159081179091556040519081527f40e4ed880a29e0f6ddce307457fb75cddf4feef7d3ecb0301bfdf4976a0e2dfc9060200160405180910390a150565b610fa96040518060800160405280606081526020016060815260200160608152602001606081525090565b6000876001600160a01b031663683048356040518163ffffffff1660e01b8152600401602060405180830381865afa158015610fe9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061100d9190615382565b905061103a6040518060800160405280606081526020016060815260200160608152602001606081525090565b6040516361c8a12f60e11b81526001600160a01b038a169063c391425e9061106a908b908990899060040161556e565b600060405180830381865afa158015611087573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526110af91908101906155b5565b81526040516340e03a8160e11b81526001600160a01b038316906381c07502906110e1908b908b908b9060040161566c565b600060405180830381865afa1580156110fe573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261112691908101906155b5565b6040820152856001600160401b03811115611143576111436146f8565b60405190808252806020026020018201604052801561117657816020015b60608152602001906001900390816111615790505b50606082015260005b60ff81168711156115b7576000856001600160401b038111156111a4576111a46146f8565b6040519080825280602002602001820160405280156111cd578160200160208202803683370190505b5083606001518360ff16815181106111e7576111e761544e565b602002602001018190525060005b868110156114b75760008c6001600160a01b03166304ec63518a8a858181106112205761122061544e565b905060200201358e8860000151868151811061123e5761123e61544e565b60200260200101516040518463ffffffff1660e01b815260040161127b9392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015611298573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112bc9190615695565b9050806001600160c01b03166000036113635760405162461bcd60e51b815260206004820152605c60248201527f4f70657261746f7253746174655265747269657665722e676574436865636b5360448201527f69676e617475726573496e64696365733a206f70657261746f72206d7573742060648201527f6265207265676973746572656420617420626c6f636b6e756d62657200000000608482015260a401610695565b8a8a8560ff168181106113785761137861544e565b60016001600160c01b038516919093013560f81c1c821690910390506114a457856001600160a01b031663dd9846b98a8a858181106113b9576113b961544e565b905060200201358d8d8860ff168181106113d5576113d561544e565b6040516001600160e01b031960e087901b1681526004810194909452919091013560f81c60248301525063ffffffff8f166044820152606401602060405180830381865afa15801561142b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061144f91906156be565b85606001518560ff16815181106114685761146861544e565b602002602001015184815181106114815761148161544e565b63ffffffff90921660209283029190910190910152826114a081615555565b9350505b50806114af81615555565b9150506111f5565b506000816001600160401b038111156114d2576114d26146f8565b6040519080825280602002602001820160405280156114fb578160200160208202803683370190505b50905060005b8281101561157c5784606001518460ff16815181106115225761152261544e565b6020026020010151818151811061153b5761153b61544e565b60200260200101518282815181106115555761155561544e565b63ffffffff909216602092830291909101909101528061157481615555565b915050611501565b508084606001518460ff16815181106115975761159761544e565b6020026020010181905250505080806115af906156db565b91505061117f565b506000896001600160a01b0316635df459466040518163ffffffff1660e01b8152600401602060405180830381865afa1580156115f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161c9190615382565b60405163354952a360e21b81529091506001600160a01b0382169063d5254a8c9061164f908b908b908e906004016156fa565b600060405180830381865afa15801561166c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261169491908101906155b5565b60208301525098975050505050505050565b60655460405163237dfb4760e11b81523360048201526001600160a01b03909116906346fbf68e90602401602060405180830381865afa1580156116ee573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061171291906153e9565b61172e5760405162461bcd60e51b815260040161069590615406565b600019606681905560405190815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2565b60cd546001600160a01b031633146117c75760405162461bcd60e51b815260206004820152601d60248201527f41676772656761746f72206d757374206265207468652063616c6c65720000006044820152606401610695565b60006117d960408501602086016148b7565b90503660006117eb6040870187615724565b9092509050600061180260808801606089016148b7565b905060ca600061181560208901896148b7565b63ffffffff1663ffffffff1681526020019081526020016000205487604051602001611841919061576a565b60405160208183030381529060405280519060200120146118ca5760405162461bcd60e51b815260206004820152603d60248201527f737570706c696564207461736b20646f6573206e6f74206d617463682074686560448201527f206f6e65207265636f7264656420696e2074686520636f6e74726163740000006064820152608401610695565b600060cb816118dc60208a018a6148b7565b63ffffffff1663ffffffff16815260200190815260200160002054146119595760405162461bcd60e51b815260206004820152602c60248201527f41676772656761746f722068617320616c726561647920726573706f6e64656460448201526b20746f20746865207461736b60a01b6064820152608401610695565b6119837f00000000000000000000000000000000000000000000000000000000000000008561580c565b63ffffffff164363ffffffff1611156119f45760405162461bcd60e51b815260206004820152602d60248201527f41676772656761746f722068617320726573706f6e64656420746f207468652060448201526c7461736b20746f6f206c61746560981b6064820152608401610695565b600086604051602001611a07919061584e565b604051602081830303815290604052805190602001209050600080611a2f8387878a8c612527565b9150915060005b85811015611b2e578460ff1683602001518281518110611a5857611a5861544e565b6020026020010151611a6a919061585c565b6001600160601b0316606484600001518381518110611a8b57611a8b61544e565b60200260200101516001600160601b0316611aa6919061587f565b1015611b1c576040805162461bcd60e51b81526020600482015260248101919091527f5369676e61746f7269657320646f206e6f74206f776e206174206c656173742060448201527f7468726573686f6c642070657263656e74616765206f6620612071756f72756d6064820152608401610695565b80611b2681615555565b915050611a36565b5060408051808201825263ffffffff43168152602080820184905291519091611b5b918c91849101615896565b6040516020818303038152906040528051906020012060cb60008c6000016020810190611b8891906148b7565b63ffffffff1663ffffffff168152602001908152602001600020819055507f349c1ee60e4e8972ee9dba642c1774543d5c4136879b7f4caaf04bf81a487a2a8a82604051611bd7929190615896565b60405180910390a15050505050505050505050565b60606000846001600160a01b031663c391425e84866040518363ffffffff1660e01b8152600401611c1e9291906158c2565b600060405180830381865afa158015611c3b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611c6391908101906155b5565b9050600084516001600160401b03811115611c8057611c806146f8565b604051908082528060200260200182016040528015611ca9578160200160208202803683370190505b50905060005b8551811015611daa57866001600160a01b03166304ec6351878381518110611cd957611cd961544e565b602002602001015187868581518110611cf457611cf461544e565b60200260200101516040518463ffffffff1660e01b8152600401611d319392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015611d4e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d729190615695565b6001600160c01b0316828281518110611d8d57611d8d61544e565b602090810291909101015280611da281615555565b915050611caf565b5095945050505050565b6000611dc360208501856148b7565b63ffffffff8116600090815260cb6020526040902054909150853590611e355760405162461bcd60e51b815260206004820152602160248201527f5461736b206861736e2774206265656e20726573706f6e64656420746f2079656044820152601d60fa1b6064820152608401610695565b8484604051602001611e48929190615916565b60408051601f19818403018152918152815160209283012063ffffffff8516600090815260cb90935291205414611ee75760405162461bcd60e51b815260206004820152603d60248201527f5461736b20726573706f6e736520646f6573206e6f74206d617463682074686560448201527f206f6e65207265636f7264656420696e2074686520636f6e74726163740000006064820152608401610695565b63ffffffff8216600090815260cc602052604090205460ff1615611f7f5760405162461bcd60e51b815260206004820152604360248201527f54686520726573706f6e736520746f2074686973207461736b2068617320616c60448201527f7265616479206265656e206368616c6c656e676564207375636365737366756c606482015262363c9760e91b608482015260a401610695565b6064611f8e60208601866148b7565b611f98919061580c565b63ffffffff164363ffffffff1611156120195760405162461bcd60e51b815260206004820152603760248201527f546865206368616c6c656e676520706572696f6420666f72207468697320746160448201527f736b2068617320616c726561647920657870697265642e0000000000000000006064820152608401610695565b6000612025828061587f565b905060208601358114600181900361207357604051339063ffffffff8616907ffd3e26beeb5967fc5a57a0446914eabc45b4aa474c67a51b4b5160cac60ddb0590600090a350505050612380565b600085516001600160401b0381111561208e5761208e6146f8565b6040519080825280602002602001820160405280156120b7578160200160208202803683370190505b50905060005b8651811015612129576120fa8782815181106120db576120db61544e565b6020026020010151805160009081526020918201519091526040902090565b82828151811061210c5761210c61544e565b60209081029190910101528061212181615555565b9150506120bd565b50600061213c60408b0160208c016148b7565b8260405160200161214e92919061594c565b604051602081830303815290604052805190602001209050876020013581146121f85760405162461bcd60e51b815260206004820152605060248201527f546865207075626b657973206f66206e6f6e2d7369676e696e67206f7065726160448201527f746f727320737570706c69656420627920746865206368616c6c656e6765722060648201526f30b932903737ba1031b7b93932b1ba1760811b608482015260a401610695565b600087516001600160401b03811115612213576122136146f8565b60405190808252806020026020018201604052801561223c578160200160208202803683370190505b50905060005b885181101561232f577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e8bb9ae685838151811061228c5761228c61544e565b60200260200101516040518263ffffffff1660e01b81526004016122b291815260200190565b602060405180830381865afa1580156122cf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906122f39190615382565b8282815181106123055761230561544e565b6001600160a01b03909216602092830291909101909101528061232781615555565b915050612242565b5063ffffffff8716600081815260cc6020526040808220805460ff19166001179055513392917fc20d1bb0f1623680306b83d4ff4bb99a2beb9d86d97832f3ca40fd13a29df1ec91a3505050505050505b50505050565b60ce546001600160a01b031633146123ea5760405162461bcd60e51b815260206004820152602160248201527f5461736b2067656e657261746f72206d757374206265207468652063616c6c656044820152603960f91b6064820152608401610695565b612421604051806080016040528060008152602001600063ffffffff16815260200160608152602001600063ffffffff1681525090565b84815263ffffffff438116602080840191909152908516606083015260408051601f850183900483028101830190915283815290849084908190840183828082843760009201919091525050505060408083019190915251612487908290602001615994565b60408051601f19818403018152828252805160209182012060c9805463ffffffff908116600090815260ca90945293909220555416907f1695b8d06ec800b4615e745cfb5bd00c1f2875615d42925c3b5afa543bb24c48906124ea908490615994565b60405180910390a260c9546125069063ffffffff16600161580c565b60c9805463ffffffff191663ffffffff929092169190911790555050505050565b604080518082019091526060808252602082015260008481036125a05760405162461bcd60e51b81526020600482015260376024820152600080516020615aff83398151915260448201527f7265733a20656d7074792071756f72756d20696e7075740000000000000000006064820152608401610695565b604083015151851480156125b8575060a08301515185145b80156125c8575060c08301515185145b80156125d8575060e08301515185145b6126425760405162461bcd60e51b81526020600482015260416024820152600080516020615aff83398151915260448201527f7265733a20696e7075742071756f72756d206c656e677468206d69736d6174636064820152600d60fb1b608482015260a401610695565b825151602084015151146126ba5760405162461bcd60e51b815260206004820152604460248201819052600080516020615aff833981519152908201527f7265733a20696e707574206e6f6e7369676e6572206c656e677468206d69736d6064820152630c2e8c6d60e31b608482015260a401610695565b4363ffffffff168463ffffffff16106127295760405162461bcd60e51b815260206004820152603c6024820152600080516020615aff83398151915260448201527f7265733a20696e76616c6964207265666572656e636520626c6f636b000000006064820152608401610695565b6040805180820182526000808252602080830191909152825180840190935260608084529083015290866001600160401b0381111561276a5761276a6146f8565b604051908082528060200260200182016040528015612793578160200160208202803683370190505b506020820152866001600160401b038111156127b1576127b16146f8565b6040519080825280602002602001820160405280156127da578160200160208202803683370190505b50815260408051808201909152606080825260208201528560200151516001600160401b0381111561280e5761280e6146f8565b604051908082528060200260200182016040528015612837578160200160208202803683370190505b5081526020860151516001600160401b03811115612857576128576146f8565b604051908082528060200260200182016040528015612880578160200160208202803683370190505b50816020018190525060006129528a8a8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505060408051639aa1653d60e01b815290516001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169350639aa1653d925060048083019260209291908290030181865afa158015612929573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061294d9190615a16565b613e7a565b905060005b876020015151811015612bce5761297d886020015182815181106120db576120db61544e565b836020015182815181106129935761299361544e565b60209081029190910101528015612a535760208301516129b4600183615a33565b815181106129c4576129c461544e565b602002602001015160001c836020015182815181106129e5576129e561544e565b602002602001015160001c11612a53576040805162461bcd60e51b8152602060048201526024810191909152600080516020615aff83398151915260448201527f7265733a206e6f6e5369676e65725075626b657973206e6f7420736f727465646064820152608401610695565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166304ec635184602001518381518110612a9857612a9861544e565b60200260200101518b8b600001518581518110612ab757612ab761544e565b60200260200101516040518463ffffffff1660e01b8152600401612af49392919092835263ffffffff918216602084015216604082015260600190565b602060405180830381865afa158015612b11573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b359190615695565b6001600160c01b031683600001518281518110612b5457612b5461544e565b602002602001018181525050612bba610904612b8e8486600001518581518110612b8057612b8061544e565b602002602001015116613f0d565b8a602001518481518110612ba457612ba461544e565b6020026020010151613f3890919063ffffffff16565b945080612bc681615555565b915050612957565b5050612bd98361401b565b60975490935060ff16600081612bf0576000612c72565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c448feb86040518163ffffffff1660e01b8152600401602060405180830381865afa158015612c4e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612c729190615a46565b905060005b8a8110156132f0578215612dd2578963ffffffff16827f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663249a0c428f8f86818110612cce57612cce61544e565b60405160e085901b6001600160e01b031916815292013560f81c600483015250602401602060405180830381865afa158015612d0e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d329190615a46565b612d3c9190615a5f565b11612dd25760405162461bcd60e51b81526020600482015260666024820152600080516020615aff83398151915260448201527f7265733a205374616b6552656769737472792075706461746573206d7573742060648201527f62652077697468696e207769746864726177616c44656c6179426c6f636b732060848201526577696e646f7760d01b60a482015260c401610695565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166368bccaac8d8d84818110612e1357612e1361544e565b9050013560f81c60f81b60f81c8c8c60a001518581518110612e3757612e3761544e565b60209081029190910101516040516001600160e01b031960e086901b16815260ff909316600484015263ffffffff9182166024840152166044820152606401602060405180830381865afa158015612e93573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612eb79190615a72565b6001600160401b031916612eda8a6040015183815181106120db576120db61544e565b67ffffffffffffffff191614612f765760405162461bcd60e51b81526020600482015260616024820152600080516020615aff83398151915260448201527f7265733a2071756f72756d41706b206861736820696e2073746f72616765206460648201527f6f6573206e6f74206d617463682070726f76696465642071756f72756d2061706084820152606b60f81b60a482015260c401610695565b612fa689604001518281518110612f8f57612f8f61544e565b602002602001015187613a7290919063ffffffff16565b95507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663c8294c568d8d84818110612fe957612fe961544e565b9050013560f81c60f81b60f81c8c8c60c00151858151811061300d5761300d61544e565b60209081029190910101516040516001600160e01b031960e086901b16815260ff909316600484015263ffffffff9182166024840152166044820152606401602060405180830381865afa158015613069573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061308d9190615516565b856020015182815181106130a3576130a361544e565b6001600160601b039092166020928302919091018201528501518051829081106130cf576130cf61544e565b6020026020010151856000015182815181106130ed576130ed61544e565b60200260200101906001600160601b031690816001600160601b0316815250506000805b8a60200151518110156132db57613165866000015182815181106131375761313761544e565b60200260200101518f8f868181106131515761315161544e565b600192013560f81c9290921c811614919050565b156132c9577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f2be94ae8f8f868181106131ab576131ab61544e565b9050013560f81c60f81b60f81c8e896020015185815181106131cf576131cf61544e565b60200260200101518f60e0015188815181106131ed576131ed61544e565b602002602001015187815181106132065761320661544e565b60209081029190910101516040516001600160e01b031960e087901b16815260ff909416600485015263ffffffff92831660248501526044840191909152166064820152608401602060405180830381865afa15801561326a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061328e9190615516565b87518051859081106132a2576132a261544e565b602002602001018181516132b69190615a9d565b6001600160601b03169052506001909101905b806132d381615555565b915050613111565b505080806132e890615555565b915050612c77565b50505060008061330a8c868a606001518b608001516107e9565b915091508161337b5760405162461bcd60e51b81526020600482015260436024820152600080516020615aff83398151915260448201527f7265733a2070616972696e6720707265636f6d70696c652063616c6c206661696064820152621b195960ea1b608482015260a401610695565b806133dc5760405162461bcd60e51b81526020600482015260396024820152600080516020615aff83398151915260448201527f7265733a207369676e617475726520697320696e76616c6964000000000000006064820152608401610695565b505060008782602001516040516020016133f792919061594c565b60408051808303601f190181529190528051602090910120929b929a509198505050505050505050565b6134296140b6565b6134336000614110565b565b60408051600180825281830190925260009160609183916020808301908036833701905050905084816000815181106134705761347061544e565b60209081029190910101526040516361c8a12f60e11b81526000906001600160a01b0388169063c391425e906134ac90889086906004016158c2565b600060405180830381865afa1580156134c9573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526134f191908101906155b5565b6000815181106135035761350361544e565b60209081029190910101516040516304ec635160e01b81526004810188905263ffffffff87811660248301529091166044820181905291506000906001600160a01b038916906304ec635190606401602060405180830381865afa15801561356f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906135939190615695565b6001600160c01b0316905060006135a982614162565b9050816135b78a838a610973565b9550955050505050935093915050565b6135cf6140b6565b6001600160a01b0381166136345760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610695565b6106a781614110565b600054610100900460ff161580801561365d5750600054600160ff909116105b806136775750303b158015613677575060005460ff166001145b6136da5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610695565b6000805460ff1916600117905580156136fd576000805461ff0019166101001790555b61370885600061422e565b61371184614110565b60cd80546001600160a01b038086166001600160a01b03199283161790925560ce8054928516929091169190911790558015613787576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b606560009054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156137e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138059190615382565b6001600160a01b0316336001600160a01b0316146138355760405162461bcd60e51b81526004016106959061539f565b6066541981196066541916146138b35760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e756e70617573653a20696e76616c696420617474656d7060448201527f7420746f2070617573652066756e6374696f6e616c69747900000000000000006064820152608401610695565b606681905560405181815233907f3582d1828e26bf56bd801502bc021ac0bc8afb57c826e4986b45593c8fad389c906020016107de565b6001600160a01b0381166139785760405162461bcd60e51b815260206004820152604960248201527f5061757361626c652e5f73657450617573657252656769737472793a206e657760448201527f50617573657252656769737472792063616e6e6f7420626520746865207a65726064820152686f206164647265737360b81b608482015260a401610695565b606554604080516001600160a01b03928316815291831660208301527f6e9fcd539896fca60e8b0f01dd580233e48a6b0f7df013b89ba7f565869acdb6910160405180910390a1606580546001600160a01b0319166001600160a01b0392909216919091179055565b60408051808201909152600080825260208201526139fd6145d3565b835181526020808501519082015260408082018490526000908360608460076107d05a03fa90508080613a2c57fe5b5080613a6a5760405162461bcd60e51b815260206004820152600d60248201526c1958cb5b5d5b0b59985a5b1959609a1b6044820152606401610695565b505092915050565b6040805180820190915260008082526020820152613a8e6145f1565b835181526020808501518183015283516040808401919091529084015160608301526000908360808460066107d05a03fa90508080613ac957fe5b5080613a6a5760405162461bcd60e51b815260206004820152600d60248201526c1958cb5859190b59985a5b1959609a1b6044820152606401610695565b613b0f61460f565b50604080516080810182527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c28183019081527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6060830152815281518083019092527f275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec82527f1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d60208381019190915281019190915290565b604080518082019091526000808252602082015260008080613bf7600080516020615adf83398151915286615464565b90505b613c0381614318565b9093509150600080516020615adf8339815191528283098303613c3c576040805180820190915290815260208101919091529392505050565b600080516020615adf833981519152600182089050613bfa565b604080518082018252868152602080820186905282518084019093528683528201849052600091829190613c88614634565b60005b6002811015613e4d576000613ca182600661587f565b9050848260028110613cb557613cb561544e565b60200201515183613cc7836000615a5f565b600c8110613cd757613cd761544e565b6020020152848260028110613cee57613cee61544e565b60200201516020015183826001613d059190615a5f565b600c8110613d1557613d1561544e565b6020020152838260028110613d2c57613d2c61544e565b6020020151515183613d3f836002615a5f565b600c8110613d4f57613d4f61544e565b6020020152838260028110613d6657613d6661544e565b6020020151516001602002015183613d7f836003615a5f565b600c8110613d8f57613d8f61544e565b6020020152838260028110613da657613da661544e565b602002015160200151600060028110613dc157613dc161544e565b602002015183613dd2836004615a5f565b600c8110613de257613de261544e565b6020020152838260028110613df957613df961544e565b602002015160200151600160028110613e1457613e1461544e565b602002015183613e25836005615a5f565b600c8110613e3557613e3561544e565b60200201525080613e4581615555565b915050613c8b565b50613e56614653565b60006020826101808560088cfa9151919c9115159b50909950505050505050505050565b600080613e868461439a565b9050808360ff166001901b11613f045760405162461bcd60e51b815260206004820152603f60248201527f4269746d61705574696c732e6f72646572656442797465734172726179546f4260448201527f69746d61703a206269746d61702065786365656473206d61782076616c7565006064820152608401610695565b90505b92915050565b6000805b8215613f0757613f22600184615a33565b9092169180613f3081615abd565b915050613f11565b60408051808201909152600080825260208201526102008261ffff1610613f945760405162461bcd60e51b815260206004820152601060248201526f7363616c61722d746f6f2d6c6172676560801b6044820152606401610695565b8161ffff16600103613fa7575081613f07565b6040805180820190915260008082526020820181905284906001905b8161ffff168661ffff161061401057600161ffff871660ff83161c81169003613ff357613ff08484613a72565b93505b613ffd8384613a72565b92506201fffe600192831b169101613fc3565b509195945050505050565b6040805180820190915260008082526020820152815115801561404057506020820151155b1561405e575050604080518082019091526000808252602082015290565b604051806040016040528083600001518152602001600080516020615adf83398151915284602001516140919190615464565b6140a990600080516020615adf833981519152615a33565b905292915050565b919050565b6033546001600160a01b031633146134335760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610695565b603380546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b606060008061417084613f0d565b61ffff166001600160401b0381111561418b5761418b6146f8565b6040519080825280601f01601f1916602001820160405280156141b5576020820181803683370190505b5090506000805b8251821080156141cd575061010081105b15614224576001811b935085841615614214578060f81b8383815181106141f6576141f661544e565b60200101906001600160f81b031916908160001a9053508160010191505b61421d81615555565b90506141bc565b5090949350505050565b6065546001600160a01b031615801561424f57506001600160a01b03821615155b6142d15760405162461bcd60e51b815260206004820152604760248201527f5061757361626c652e5f696e697469616c697a655061757365723a205f696e6960448201527f7469616c697a6550617573657228292063616e206f6e6c792062652063616c6c6064820152666564206f6e636560c81b608482015260a401610695565b606681905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2614314826138ea565b5050565b60008080600080516020615adf8339815191526003600080516020615adf83398151915286600080516020615adf83398151915288890909089050600061438e827f0c19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52600080516020615adf83398151915261452a565b91959194509092505050565b6000610100825111156144235760405162461bcd60e51b8152602060048201526044602482018190527f4269746d61705574696c732e6f72646572656442797465734172726179546f42908201527f69746d61703a206f7264657265644279746573417272617920697320746f6f206064820152636c6f6e6760e01b608482015260a401610695565b815160000361443457506000919050565b6000808360008151811061444a5761444a61544e565b0160200151600160f89190911c81901b92505b8451811015614521578481815181106144785761447861544e565b0160200151600160f89190911c1b915082821161450d5760405162461bcd60e51b815260206004820152604760248201527f4269746d61705574696c732e6f72646572656442797465734172726179546f4260448201527f69746d61703a206f72646572656442797465734172726179206973206e6f74206064820152661bdc99195c995960ca1b608482015260a401610695565b9181179161451a81615555565b905061445d565b50909392505050565b600080614535614653565b61453d614671565b602080825281810181905260408201819052606082018890526080820187905260a082018690528260c08360056107d05a03fa9250828061457a57fe5b50826145c85760405162461bcd60e51b815260206004820152601a60248201527f424e3235342e6578704d6f643a2063616c6c206661696c7572650000000000006044820152606401610695565b505195945050505050565b60405180606001604052806003906020820280368337509192915050565b60405180608001604052806004906020820280368337509192915050565b604051806040016040528061462261468f565b815260200161462f61468f565b905290565b604051806101800160405280600c906020820280368337509192915050565b60405180602001604052806001906020820280368337509192915050565b6040518060c001604052806006906020820280368337509192915050565b60405180604001604052806002906020820280368337509192915050565b6001600160a01b03811681146106a757600080fd5b6000602082840312156146d457600080fd5b8135613f04816146ad565b6000602082840312156146f157600080fd5b5035919050565b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b0381118282101715614730576147306146f8565b60405290565b60405161010081016001600160401b0381118282101715614730576147306146f8565b604051601f8201601f191681016001600160401b0381118282101715614781576147816146f8565b604052919050565b60006040828403121561479b57600080fd5b6147a361470e565b9050813581526020820135602082015292915050565b600082601f8301126147ca57600080fd5b6147d261470e565b8060408401858111156147e457600080fd5b845b818110156147fe5780358452602093840193016147e6565b509095945050505050565b60006080828403121561481b57600080fd5b61482361470e565b905061482f83836147b9565b815261483e83604084016147b9565b602082015292915050565b600080600080610120858703121561486057600080fd5b843593506148718660208701614789565b92506148808660608701614809565b915061488f8660e08701614789565b905092959194509250565b63ffffffff811681146106a757600080fd5b80356140b18161489a565b6000602082840312156148c957600080fd5b8135613f048161489a565b6000806000606084860312156148e957600080fd5b83356148f4816146ad565b92506020848101356001600160401b038082111561491157600080fd5b818701915087601f83011261492557600080fd5b813581811115614937576149376146f8565b614949601f8201601f19168501614759565b9150808252888482850101111561495f57600080fd5b8084840185840137600084828401015250809450505050614982604085016148ac565b90509250925092565b600081518084526020808501808196508360051b810191508286016000805b86811015614a21578385038a52825180518087529087019087870190845b81811015614a0c57835180516001600160a01b031684528a8101518b8501526040908101516001600160601b031690840152928901926060909201916001016149c8565b50509a87019a955050918501916001016149aa565b509298975050505050505050565b602081526000614a42602083018461498b565b9392505050565b80151581146106a757600080fd5b600060208284031215614a6957600080fd5b8135613f0481614a49565b60008083601f840112614a8657600080fd5b5081356001600160401b03811115614a9d57600080fd5b602083019150836020828501011115614ab557600080fd5b9250929050565b60008060008060008060808789031215614ad557600080fd5b8635614ae0816146ad565b95506020870135614af08161489a565b945060408701356001600160401b0380821115614b0c57600080fd5b614b188a838b01614a74565b90965094506060890135915080821115614b3157600080fd5b818901915089601f830112614b4557600080fd5b813581811115614b5457600080fd5b8a60208260051b8501011115614b6957600080fd5b6020830194508093505050509295509295509295565b600081518084526020808501945080840160005b83811015614bb557815163ffffffff1687529582019590820190600101614b93565b509495945050505050565b600060208083528351608082850152614bdc60a0850182614b7f565b905081850151601f1980868403016040870152614bf98383614b7f565b92506040870151915080868403016060870152614c168383614b7f565b60608801518782038301608089015280518083529194508501925084840190600581901b8501860160005b82811015614c6d5784878303018452614c5b828751614b7f565b95880195938801939150600101614c41565b509998505050505050505050565b60ff811681146106a757600080fd5b600060208284031215614c9c57600080fd5b8135613f0481614c7b565b600060808284031215614cb957600080fd5b50919050565b600060408284031215614cb957600080fd5b60006001600160401b03821115614cea57614cea6146f8565b5060051b60200190565b600082601f830112614d0557600080fd5b81356020614d1a614d1583614cd1565b614759565b82815260059290921b84018101918181019086841115614d3957600080fd5b8286015b84811015614d5d578035614d508161489a565b8352918301918301614d3d565b509695505050505050565b600082601f830112614d7957600080fd5b81356020614d89614d1583614cd1565b82815260069290921b84018101918181019086841115614da857600080fd5b8286015b84811015614d5d57614dbe8882614789565b835291830191604001614dac565b600082601f830112614ddd57600080fd5b81356020614ded614d1583614cd1565b82815260059290921b84018101918181019086841115614e0c57600080fd5b8286015b84811015614d5d5780356001600160401b03811115614e2f5760008081fd5b614e3d8986838b0101614cf4565b845250918301918301614e10565b60006101808284031215614e5e57600080fd5b614e66614736565b905081356001600160401b0380821115614e7f57600080fd5b614e8b85838601614cf4565b83526020840135915080821115614ea157600080fd5b614ead85838601614d68565b60208401526040840135915080821115614ec657600080fd5b614ed285838601614d68565b6040840152614ee48560608601614809565b6060840152614ef68560e08601614789565b6080840152610120840135915080821115614f1057600080fd5b614f1c85838601614cf4565b60a0840152610140840135915080821115614f3657600080fd5b614f4285838601614cf4565b60c0840152610160840135915080821115614f5c57600080fd5b50614f6984828501614dcc565b60e08301525092915050565b600080600060808486031215614f8a57600080fd5b83356001600160401b0380821115614fa157600080fd5b614fad87838801614ca7565b9450614fbc8760208801614cbf565b93506060860135915080821115614fd257600080fd5b50614fdf86828701614e4b565b9150509250925092565b600080600060608486031215614ffe57600080fd5b8335615009816146ad565b92506020848101356001600160401b0381111561502557600080fd5b8501601f8101871361503657600080fd5b8035615044614d1582614cd1565b81815260059190911b8201830190838101908983111561506357600080fd5b928401925b8284101561508157833582529284019290840190615068565b8096505050505050614982604085016148ac565b6020808252825182820181905260009190848201906040850190845b818110156150cd578351835292840192918401916001016150b1565b50909695505050505050565b60008060008060c085870312156150ef57600080fd5b84356001600160401b038082111561510657600080fd5b61511288838901614ca7565b95506151218860208901614cbf565b94506151308860608901614cbf565b935060a087013591508082111561514657600080fd5b5061515387828801614d68565b91505092959194509250565b6000806000806060858703121561517557600080fd5b8435935060208501356151878161489a565b925060408501356001600160401b038111156151a257600080fd5b6151ae87828801614a74565b95989497509550505050565b6000806000806000608086880312156151d257600080fd5b8535945060208601356001600160401b03808211156151f057600080fd5b6151fc89838a01614a74565b9096509450604088013591506152118261489a565b9092506060870135908082111561522757600080fd5b5061523488828901614e4b565b9150509295509295909350565b600081518084526020808501945080840160005b83811015614bb55781516001600160601b031687529582019590820190600101615255565b60408152600083516040808401526152956080840182615241565b90506020850151603f198483030160608501526152b28282615241565b925050508260208301529392505050565b6000806000606084860312156152d857600080fd5b83356152e3816146ad565b92506020840135915060408401356152fa8161489a565b809150509250925092565b82815260406020820152600061531e604083018461498b565b949350505050565b6000806000806080858703121561533c57600080fd5b8435615347816146ad565b93506020850135615357816146ad565b92506040850135615367816146ad565b91506060850135615377816146ad565b939692955090935050565b60006020828403121561539457600080fd5b8151613f04816146ad565b6020808252602a908201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160408201526939903ab73830bab9b2b960b11b606082015260800190565b6000602082840312156153fb57600080fd5b8151613f0481614a49565b60208082526028908201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160408201526739903830bab9b2b960c11b606082015260800190565b634e487b7160e01b600052603260045260246000fd5b60008261548157634e487b7160e01b600052601260045260246000fd5b500690565b6000602080838503121561549957600080fd5b82516001600160401b038111156154af57600080fd5b8301601f810185136154c057600080fd5b80516154ce614d1582614cd1565b81815260059190911b820183019083810190878311156154ed57600080fd5b928401925b8284101561550b578351825292840192908401906154f2565b979650505050505050565b60006020828403121561552857600080fd5b81516001600160601b0381168114613f0457600080fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016155675761556761553f565b5060010190565b63ffffffff84168152604060208201819052810182905260006001600160fb1b0383111561559b57600080fd5b8260051b8085606085013791909101606001949350505050565b600060208083850312156155c857600080fd5b82516001600160401b038111156155de57600080fd5b8301601f810185136155ef57600080fd5b80516155fd614d1582614cd1565b81815260059190911b8201830190838101908783111561561c57600080fd5b928401925b8284101561550b5783516156348161489a565b82529284019290840190615621565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b63ffffffff8416815260406020820152600061568c604083018486615643565b95945050505050565b6000602082840312156156a757600080fd5b81516001600160c01b0381168114613f0457600080fd5b6000602082840312156156d057600080fd5b8151613f048161489a565b600060ff821660ff81036156f1576156f161553f565b60010192915050565b60408152600061570e604083018587615643565b905063ffffffff83166020830152949350505050565b6000808335601e1984360301811261573b57600080fd5b8301803591506001600160401b0382111561575557600080fd5b602001915036819003821315614ab557600080fd5b6020815281356020820152600060208301356157858161489a565b63ffffffff81166040840152506040830135601e198436030181126157a957600080fd5b83016020810190356001600160401b038111156157c557600080fd5b8036038213156157d457600080fd5b608060608501526157e960a085018284615643565b9150506157f8606085016148ac565b63ffffffff81166080850152509392505050565b63ffffffff8181168382160190808211156158295761582961553f565b5092915050565b803561583b8161489a565b63ffffffff168252602090810135910152565b60408101613f078284615830565b6001600160601b03818116838216028082169190828114613a6a57613a6a61553f565b8082028115828204841417613f0757613f0761553f565b608081016158a48285615830565b63ffffffff8351166040830152602083015160608301529392505050565b60006040820163ffffffff851683526020604081850152818551808452606086019150828701935060005b81811015615909578451835293830193918301916001016158ed565b5090979650505050505050565b608081016159248285615830565b823561592f8161489a565b63ffffffff16604083015260209290920135606090910152919050565b63ffffffff60e01b8360e01b1681526000600482018351602080860160005b838110156159875781518552938201939082019060010161596b565b5092979650505050505050565b6000602080835283518184015263ffffffff8185015116604084015260408401516080606085015280518060a086015260005b818110156159e35782810184015186820160c0015283016159c7565b50600085820160c00152606086015163ffffffff811660808701529250601f01601f19169390930160c001949350505050565b600060208284031215615a2857600080fd5b8151613f0481614c7b565b81810381811115613f0757613f0761553f565b600060208284031215615a5857600080fd5b5051919050565b80820180821115613f0757613f0761553f565b600060208284031215615a8457600080fd5b815167ffffffffffffffff1981168114613f0457600080fd5b6001600160601b038281168282160390808211156158295761582961553f565b600061ffff808316818103615ad457615ad461553f565b600101939250505056fe30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47424c535369676e6174757265436865636b65722e636865636b5369676e617475a2646970667358221220f9169804370da5b04ee262342505bca83f8241d9d4b0816633b1be3512165f1d64736f6c63430008140033"]
    #[doc = r" ```"]
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xfd[P`\x046\x10a\x02\x1cW`\05`\xe0\x1c\x80ckS.\x9e\x11a\x01%W\x80c\x8d\xa5\xcb[\x11a\0\xadW\x80c\xf2\xfd\xe3\x8b\x11a\0|W\x80c\xf2\xfd\xe3\x8b\x14a\x05\x87W\x80c\xf5\xc9\x89\x9d\x14a\x05\x9aW\x80c\xf6<[\xab\x14a\x05\xc0W\x80c\xf8\xc8v^\x14a\x05\xc8W\x80c\xfa\xbc\x1c\xbc\x14a\x05\xdbW`\0\x80\xfd[\x80c\x8d\xa5\xcb[\x14a\x05!W\x80c\xb9\x8d\t\x08\x14a\x052W\x80c\xce\xfd\xc1\xd4\x14a\x05?W\x80c\xdf\\\xf7#\x14a\x05`W`\0\x80\xfd[\x80cqP\x18\xa6\x11a\0\xf4W\x80cqP\x18\xa6\x14a\x04\xd5W\x80cr\xd1\x8e\x8d\x14a\x04\xddW\x80cz\xfa\x1e\xed\x14a\x04\xebW\x80c\x88o\x11\x95\x14a\x04\xfeW\x80c\x8b\0\xce|\x14a\x05\x11W`\0\x80\xfd[\x80ckS.\x9e\x14a\x04gW\x80ck\x92x~\x14a\x04zW\x80cm\x14\xa9\x87\x14a\x04\x8dW\x80cn\xfbF6\x14a\x04\xb4W`\0\x80\xfd[\x80cOs\x9ft\x11a\x01\xa8W\x80c\\\x15Vb\x11a\x01wW\x80c\\\x15Vb\x14a\x03\xceW\x80c\\\x97Z\xbb\x14a\x03\xeeW\x80c]\xec\xc3\xf5\x14a\x03\xf6W\x80c]\xf4YF\x14a\x04\x19W\x80ch0H5\x14a\x04@W`\0\x80\xfd[\x80cOs\x9ft\x14a\x03`W\x80cY\\jg\x14a\x03\x80W\x80cZ\xc8j\xb7\x14a\x03\x88W\x80c[\xae\xc9\xa0\x14a\x03\xbbW`\0\x80\xfd[\x80c$Z{\xfc\x11a\x01\xefW\x80c$Z{\xfc\x14a\x02\xb4W\x80c,\xb2#\xd5\x14a\x02\xdfW\x80c-\x89\xf6\xfc\x14a\x03\rW\x80c5c\xb0\xd1\x14a\x03-W\x80cAl~^\x14a\x03MW`\0\x80\xfd[\x80c\x10\xd6z/\x14a\x02!W\x80c\x13d9\xdd\x14a\x026W\x80c\x17\x1f\x1d[\x14a\x02IW\x80c\x1a\xd41\x89\x14a\x02xW[`\0\x80\xfd[a\x024a\x02/6`\x04aF\xc2V[a\x05\xeeV[\0[a\x024a\x02D6`\x04aF\xdfV[a\x06\xaaV[a\x02\\a\x02W6`\x04aHIV[a\x07\xe9V[`@\x80Q\x92\x15\x15\x83R\x90\x15\x15` \x83\x01R\x01[`@Q\x80\x91\x03\x90\xf3[a\x02\x9f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[`@Qc\xff\xff\xff\xff\x90\x91\x16\x81R` \x01a\x02oV[`\xcdTa\x02\xc7\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[`@Q`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x81R` \x01a\x02oV[a\x02\xffa\x02\xed6`\x04aH\xb7V[`\xcb` R`\0\x90\x81R`@\x90 T\x81V[`@Q\x90\x81R` \x01a\x02oV[a\x02\xffa\x03\x1b6`\x04aH\xb7V[`\xca` R`\0\x90\x81R`@\x90 T\x81V[a\x03@a\x03;6`\x04aH\xd4V[a\tsV[`@Qa\x02o\x91\x90aJ/V[a\x024a\x03[6`\x04aJWV[a\x0e\tV[a\x03sa\x03n6`\x04aJ\xbcV[a\x0f~V[`@Qa\x02o\x91\x90aK\xc0V[a\x024a\x16\xa6V[a\x03\xaba\x03\x966`\x04aL\x8aV[`fT`\x01`\xff\x90\x92\x16\x91\x90\x91\x1b\x90\x81\x16\x14\x90V[`@Q\x90\x15\x15\x81R` \x01a\x02oV[a\x024a\x03\xc96`\x04aOuV[a\x17mV[a\x03\xe1a\x03\xdc6`\x04aO\xe9V[a\x1b\xecV[`@Qa\x02o\x91\x90aP\x95V[`fTa\x02\xffV[a\x03\xaba\x04\x046`\x04aH\xb7V[`\xcc` R`\0\x90\x81R`@\x90 T`\xff\x16\x81V[a\x02\xc7\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\xc7\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x024a\x04u6`\x04aP\xd9V[a\x1d\xb4V[a\x024a\x04\x886`\x04aQ_V[a#\x86V[a\x02\xc7\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x04\xc7a\x04\xc26`\x04aQ\xbaV[a%'V[`@Qa\x02o\x92\x91\x90aRzV[a\x024a4!V[`\xc9Tc\xff\xff\xff\xff\x16a\x02\x9fV[`\xceTa\x02\xc7\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[`eTa\x02\xc7\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[`\xc9Ta\x02\x9f\x90c\xff\xff\xff\xff\x16\x81V[`3T`\x01`\x01`\xa0\x1b\x03\x16a\x02\xc7V[`\x97Ta\x03\xab\x90`\xff\x16\x81V[a\x05Ra\x05M6`\x04aR\xc3V[a45V[`@Qa\x02o\x92\x91\x90aS\x05V[a\x02\xc7\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x024a\x05\x956`\x04aF\xc2V[a5\xc7V[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\x02\x9fV[a\x02\x9f`d\x81V[a\x024a\x05\xd66`\x04aS&V[a6=V[a\x024a\x05\xe96`\x04aF\xdfV[a7\x8eV[`e`\0\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xa0\x1b\x03\x16`\x01`\x01`\xa0\x1b\x03\x16c\xea\xb6mz`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x06AW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x06e\x91\x90aS\x82V[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a\x06\x9eW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x06\x95\x90aS\x9fV[`@Q\x80\x91\x03\x90\xfd[a\x06\xa7\x81a8\xeaV[PV[`eT`@Qc#}\xfbG`\xe1\x1b\x81R3`\x04\x82\x01R`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x90cF\xfb\xf6\x8e\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x06\xf2W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x07\x16\x91\x90aS\xe9V[a\x072W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x06\x95\x90aT\x06V[`fT\x81\x81\x16\x14a\x07\xabW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7fPausable.pause: invalid attempt `D\x82\x01R\x7fto unpause functionality\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`f\x81\x90U`@Q\x81\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01[`@Q\x80\x91\x03\x90\xa2PV[`\0\x80`\0\x7f0dNr\xe11\xa0)\xb8PE\xb6\x81\x81X](3\xe8Hy\xb9p\x91C\xe1\xf5\x93\xf0\0\0\x01\x87\x87`\0\x01Q\x88` \x01Q\x88`\0\x01Q`\0`\x02\x81\x10a\x081Wa\x081aTNV[` \x02\x01Q\x89Q`\x01` \x02\x01Q\x8a` \x01Q`\0`\x02\x81\x10a\x08VWa\x08VaTNV[` \x02\x01Q\x8b` \x01Q`\x01`\x02\x81\x10a\x08rWa\x08raTNV[` \x90\x81\x02\x91\x90\x91\x01Q\x8cQ\x8d\x83\x01Q`@Qa\x08\xcf\x9a\x99\x98\x97\x96\x95\x94\x01\x98\x89R` \x89\x01\x97\x90\x97R`@\x88\x01\x95\x90\x95R``\x87\x01\x93\x90\x93R`\x80\x86\x01\x91\x90\x91R`\xa0\x85\x01R`\xc0\x84\x01R`\xe0\x83\x01Ra\x01\0\x82\x01Ra\x01 \x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `\0\x1ca\x08\xf2\x91\x90aTdV[\x90Pa\tea\t\x0ba\t\x04\x88\x84a9\xe1V[\x86\x90a:rV[a\t\x13a;\x07V[a\t[a\tL\x85a\tF`@\x80Q\x80\x82\x01\x82R`\0\x80\x82R` \x91\x82\x01R\x81Q\x80\x83\x01\x90\x92R`\x01\x82R`\x02\x90\x82\x01R\x90V[\x90a9\xe1V[a\tU\x8ca;\xc7V[\x90a:rV[\x88b\x01\xd4\xc0a<VV[\x90\x98\x90\x97P\x95PPPPPPV[```\0\x84`\x01`\x01`\xa0\x1b\x03\x16ch0H5`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\t\xb5W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\t\xd9\x91\x90aS\x82V[\x90P`\0\x85`\x01`\x01`\xa0\x1b\x03\x16c\x9e\x99#\xc2`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\n\x1bW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n?\x91\x90aS\x82V[\x90P`\0\x86`\x01`\x01`\xa0\x1b\x03\x16c]\xf4YF`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\n\x81W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\n\xa5\x91\x90aS\x82V[\x90P`\0\x86Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\n\xc2Wa\n\xc2aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\n\xf5W\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\n\xe0W\x90P[P\x90P`\0[\x87Q\x81\x10\x15a\r\xfdW`\0\x88\x82\x81Q\x81\x10a\x0b\x18Wa\x0b\x18aTNV[\x01` \x01Q`@Qc\x89\x02bE`\xe0\x1b\x81R`\xf8\x91\x90\x91\x1c`\x04\x82\x01\x81\x90Rc\xff\xff\xff\xff\x8a\x16`$\x83\x01R\x91P`\0\x90`\x01`\x01`\xa0\x1b\x03\x87\x16\x90c\x89\x02bE\x90`D\x01`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0byW=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x0b\xa1\x91\x90\x81\x01\x90aT\x86V[\x90P\x80Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\x0b\xbcWa\x0b\xbcaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x0c\x07W\x81` \x01[`@\x80Q``\x81\x01\x82R`\0\x80\x82R` \x80\x83\x01\x82\x90R\x92\x82\x01R\x82R`\0\x19\x90\x92\x01\x91\x01\x81a\x0b\xdaW\x90P[P\x84\x84\x81Q\x81\x10a\x0c\x1aWa\x0c\x1aaTNV[` \x02` \x01\x01\x81\x90RP`\0[\x81Q\x81\x10\x15a\r\xe7W`@Q\x80``\x01`@R\x80\x87`\x01`\x01`\xa0\x1b\x03\x16cG\xb3\x14\xe8\x85\x85\x81Q\x81\x10a\x0c]Wa\x0c]aTNV[` \x02` \x01\x01Q`@Q\x82c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x0c\x83\x91\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0c\xa0W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0c\xc4\x91\x90aS\x82V[`\x01`\x01`\xa0\x1b\x03\x16\x81R` \x01\x83\x83\x81Q\x81\x10a\x0c\xe4Wa\x0c\xe4aTNV[` \x02` \x01\x01Q\x81R` \x01\x89`\x01`\x01`\xa0\x1b\x03\x16c\xfa(\xc6'\x85\x85\x81Q\x81\x10a\r\x12Wa\r\x12aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x84\x90\x1b\x16\x81R`\x04\x81\x01\x91\x90\x91R`\xff\x88\x16`$\x82\x01Rc\xff\xff\xff\xff\x8f\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\rnW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r\x92\x91\x90aU\x16V[`\x01`\x01``\x1b\x03\x16\x81RP\x85\x85\x81Q\x81\x10a\r\xb0Wa\r\xb0aTNV[` \x02` \x01\x01Q\x82\x81Q\x81\x10a\r\xc9Wa\r\xc9aTNV[` \x02` \x01\x01\x81\x90RP\x80\x80a\r\xdf\x90aUUV[\x91PPa\x0c(V[PPP\x80\x80a\r\xf5\x90aUUV[\x91PPa\n\xfbV[P\x97\x96PPPPPPPV[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\x8d\xa5\xcb[`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0egW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0e\x8b\x91\x90aS\x82V[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a\x0f7W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\\`$\x82\x01R\x7fBLSSignatureChecker.onlyCoordina`D\x82\x01R\x7ftorOwner: caller is not the owne`d\x82\x01R\x7fr of the registryCoordinator\0\0\0\0`\x84\x82\x01R`\xa4\x01a\x06\x95V[`\x97\x80T`\xff\x19\x16\x82\x15\x15\x90\x81\x17\x90\x91U`@Q\x90\x81R\x7f@\xe4\xed\x88\n)\xe0\xf6\xdd\xce0tW\xfbu\xcd\xdfO\xee\xf7\xd3\xec\xb00\x1b\xfd\xf4\x97j\x0e-\xfc\x90` \x01`@Q\x80\x91\x03\x90\xa1PV[a\x0f\xa9`@Q\x80`\x80\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`\0\x87`\x01`\x01`\xa0\x1b\x03\x16ch0H5`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0f\xe9W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x10\r\x91\x90aS\x82V[\x90Pa\x10:`@Q\x80`\x80\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`@Qca\xc8\xa1/`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x8a\x16\x90c\xc3\x91B^\x90a\x10j\x90\x8b\x90\x89\x90\x89\x90`\x04\x01aUnV[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x10\x87W=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x10\xaf\x91\x90\x81\x01\x90aU\xb5V[\x81R`@Qc@\xe0:\x81`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x83\x16\x90c\x81\xc0u\x02\x90a\x10\xe1\x90\x8b\x90\x8b\x90\x8b\x90`\x04\x01aVlV[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x10\xfeW=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x11&\x91\x90\x81\x01\x90aU\xb5V[`@\x82\x01R\x85`\x01`\x01`@\x1b\x03\x81\x11\x15a\x11CWa\x11CaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x11vW\x81` \x01[``\x81R` \x01\x90`\x01\x90\x03\x90\x81a\x11aW\x90P[P``\x82\x01R`\0[`\xff\x81\x16\x87\x11\x15a\x15\xb7W`\0\x85`\x01`\x01`@\x1b\x03\x81\x11\x15a\x11\xa4Wa\x11\xa4aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x11\xcdW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x83``\x01Q\x83`\xff\x16\x81Q\x81\x10a\x11\xe7Wa\x11\xe7aTNV[` \x02` \x01\x01\x81\x90RP`\0[\x86\x81\x10\x15a\x14\xb7W`\0\x8c`\x01`\x01`\xa0\x1b\x03\x16c\x04\xeccQ\x8a\x8a\x85\x81\x81\x10a\x12 Wa\x12 aTNV[\x90P` \x02\x015\x8e\x88`\0\x01Q\x86\x81Q\x81\x10a\x12>Wa\x12>aTNV[` \x02` \x01\x01Q`@Q\x84c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x12{\x93\x92\x91\x90\x92\x83Rc\xff\xff\xff\xff\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x12\x98W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x12\xbc\x91\x90aV\x95V[\x90P\x80`\x01`\x01`\xc0\x1b\x03\x16`\0\x03a\x13cW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\\`$\x82\x01R\x7fOperatorStateRetriever.getCheckS`D\x82\x01R\x7fignaturesIndices: operator must `d\x82\x01R\x7fbe registered at blocknumber\0\0\0\0`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x8a\x8a\x85`\xff\x16\x81\x81\x10a\x13xWa\x13xaTNV[`\x01`\x01`\x01`\xc0\x1b\x03\x85\x16\x91\x90\x93\x015`\xf8\x1c\x1c\x82\x16\x90\x91\x03\x90Pa\x14\xa4W\x85`\x01`\x01`\xa0\x1b\x03\x16c\xdd\x98F\xb9\x8a\x8a\x85\x81\x81\x10a\x13\xb9Wa\x13\xb9aTNV[\x90P` \x02\x015\x8d\x8d\x88`\xff\x16\x81\x81\x10a\x13\xd5Wa\x13\xd5aTNV[`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x87\x90\x1b\x16\x81R`\x04\x81\x01\x94\x90\x94R\x91\x90\x91\x015`\xf8\x1c`$\x83\x01RPc\xff\xff\xff\xff\x8f\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x14+W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x14O\x91\x90aV\xbeV[\x85``\x01Q\x85`\xff\x16\x81Q\x81\x10a\x14hWa\x14haTNV[` \x02` \x01\x01Q\x84\x81Q\x81\x10a\x14\x81Wa\x14\x81aTNV[c\xff\xff\xff\xff\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x82a\x14\xa0\x81aUUV[\x93PP[P\x80a\x14\xaf\x81aUUV[\x91PPa\x11\xf5V[P`\0\x81`\x01`\x01`@\x1b\x03\x81\x11\x15a\x14\xd2Wa\x14\xd2aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x14\xfbW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x82\x81\x10\x15a\x15|W\x84``\x01Q\x84`\xff\x16\x81Q\x81\x10a\x15\"Wa\x15\"aTNV[` \x02` \x01\x01Q\x81\x81Q\x81\x10a\x15;Wa\x15;aTNV[` \x02` \x01\x01Q\x82\x82\x81Q\x81\x10a\x15UWa\x15UaTNV[c\xff\xff\xff\xff\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x80a\x15t\x81aUUV[\x91PPa\x15\x01V[P\x80\x84``\x01Q\x84`\xff\x16\x81Q\x81\x10a\x15\x97Wa\x15\x97aTNV[` \x02` \x01\x01\x81\x90RPPP\x80\x80a\x15\xaf\x90aV\xdbV[\x91PPa\x11\x7fV[P`\0\x89`\x01`\x01`\xa0\x1b\x03\x16c]\xf4YF`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x15\xf8W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x16\x1c\x91\x90aS\x82V[`@Qc5IR\xa3`\xe2\x1b\x81R\x90\x91P`\x01`\x01`\xa0\x1b\x03\x82\x16\x90c\xd5%J\x8c\x90a\x16O\x90\x8b\x90\x8b\x90\x8e\x90`\x04\x01aV\xfaV[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x16lW=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x16\x94\x91\x90\x81\x01\x90aU\xb5V[` \x83\x01RP\x98\x97PPPPPPPPV[`eT`@Qc#}\xfbG`\xe1\x1b\x81R3`\x04\x82\x01R`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x90cF\xfb\xf6\x8e\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x16\xeeW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x17\x12\x91\x90aS\xe9V[a\x17.W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x06\x95\x90aT\x06V[`\0\x19`f\x81\x90U`@Q\x90\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01`@Q\x80\x91\x03\x90\xa2V[`\xcdT`\x01`\x01`\xa0\x1b\x03\x163\x14a\x17\xc7W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x1d`$\x82\x01R\x7fAggregator must be the caller\0\0\0`D\x82\x01R`d\x01a\x06\x95V[`\0a\x17\xd9`@\x85\x01` \x86\x01aH\xb7V[\x90P6`\0a\x17\xeb`@\x87\x01\x87aW$V[\x90\x92P\x90P`\0a\x18\x02`\x80\x88\x01``\x89\x01aH\xb7V[\x90P`\xca`\0a\x18\x15` \x89\x01\x89aH\xb7V[c\xff\xff\xff\xff\x16c\xff\xff\xff\xff\x16\x81R` \x01\x90\x81R` \x01`\0 T\x87`@Q` \x01a\x18A\x91\x90aWjV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x14a\x18\xcaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`=`$\x82\x01R\x7fsupplied task does not match the`D\x82\x01R\x7f one recorded in the contract\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`\0`\xcb\x81a\x18\xdc` \x8a\x01\x8aaH\xb7V[c\xff\xff\xff\xff\x16c\xff\xff\xff\xff\x16\x81R` \x01\x90\x81R` \x01`\0 T\x14a\x19YW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`,`$\x82\x01R\x7fAggregator has already responded`D\x82\x01Rk to the task`\xa0\x1b`d\x82\x01R`\x84\x01a\x06\x95V[a\x19\x83\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x85aX\x0cV[c\xff\xff\xff\xff\x16Cc\xff\xff\xff\xff\x16\x11\x15a\x19\xf4W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`-`$\x82\x01R\x7fAggregator has responded to the `D\x82\x01Rltask too late`\x98\x1b`d\x82\x01R`\x84\x01a\x06\x95V[`\0\x86`@Q` \x01a\x1a\x07\x91\x90aXNV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P`\0\x80a\x1a/\x83\x87\x87\x8a\x8ca%'V[\x91P\x91P`\0[\x85\x81\x10\x15a\x1b.W\x84`\xff\x16\x83` \x01Q\x82\x81Q\x81\x10a\x1aXWa\x1aXaTNV[` \x02` \x01\x01Qa\x1aj\x91\x90aX\\V[`\x01`\x01``\x1b\x03\x16`d\x84`\0\x01Q\x83\x81Q\x81\x10a\x1a\x8bWa\x1a\x8baTNV[` \x02` \x01\x01Q`\x01`\x01``\x1b\x03\x16a\x1a\xa6\x91\x90aX\x7fV[\x10\x15a\x1b\x1cW`@\x80QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`$\x81\x01\x91\x90\x91R\x7fSignatories do not own at least `D\x82\x01R\x7fthreshold percentage of a quorum`d\x82\x01R`\x84\x01a\x06\x95V[\x80a\x1b&\x81aUUV[\x91PPa\x1a6V[P`@\x80Q\x80\x82\x01\x82Rc\xff\xff\xff\xffC\x16\x81R` \x80\x82\x01\x84\x90R\x91Q\x90\x91a\x1b[\x91\x8c\x91\x84\x91\x01aX\x96V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 `\xcb`\0\x8c`\0\x01` \x81\x01\x90a\x1b\x88\x91\x90aH\xb7V[c\xff\xff\xff\xff\x16c\xff\xff\xff\xff\x16\x81R` \x01\x90\x81R` \x01`\0 \x81\x90UP\x7f4\x9c\x1e\xe6\x0eN\x89r\xee\x9d\xbad,\x17tT=\\A6\x87\x9b\x7fL\xaa\xf0K\xf8\x1aHz*\x8a\x82`@Qa\x1b\xd7\x92\x91\x90aX\x96V[`@Q\x80\x91\x03\x90\xa1PPPPPPPPPPPV[```\0\x84`\x01`\x01`\xa0\x1b\x03\x16c\xc3\x91B^\x84\x86`@Q\x83c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x1c\x1e\x92\x91\x90aX\xc2V[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x1c;W=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra\x1cc\x91\x90\x81\x01\x90aU\xb5V[\x90P`\0\x84Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\x1c\x80Wa\x1c\x80aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1c\xa9W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x85Q\x81\x10\x15a\x1d\xaaW\x86`\x01`\x01`\xa0\x1b\x03\x16c\x04\xeccQ\x87\x83\x81Q\x81\x10a\x1c\xd9Wa\x1c\xd9aTNV[` \x02` \x01\x01Q\x87\x86\x85\x81Q\x81\x10a\x1c\xf4Wa\x1c\xf4aTNV[` \x02` \x01\x01Q`@Q\x84c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\x1d1\x93\x92\x91\x90\x92\x83Rc\xff\xff\xff\xff\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x1dNW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x1dr\x91\x90aV\x95V[`\x01`\x01`\xc0\x1b\x03\x16\x82\x82\x81Q\x81\x10a\x1d\x8dWa\x1d\x8daTNV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x80a\x1d\xa2\x81aUUV[\x91PPa\x1c\xafV[P\x95\x94PPPPPV[`\0a\x1d\xc3` \x85\x01\x85aH\xb7V[c\xff\xff\xff\xff\x81\x16`\0\x90\x81R`\xcb` R`@\x90 T\x90\x91P\x855\x90a\x1e5W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7fTask hasn't been responded to ye`D\x82\x01R`\x1d`\xfa\x1b`d\x82\x01R`\x84\x01a\x06\x95V[\x84\x84`@Q` \x01a\x1eH\x92\x91\x90aY\x16V[`@\x80Q`\x1f\x19\x81\x84\x03\x01\x81R\x91\x81R\x81Q` \x92\x83\x01 c\xff\xff\xff\xff\x85\x16`\0\x90\x81R`\xcb\x90\x93R\x91 T\x14a\x1e\xe7W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`=`$\x82\x01R\x7fTask response does not match the`D\x82\x01R\x7f one recorded in the contract\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[c\xff\xff\xff\xff\x82\x16`\0\x90\x81R`\xcc` R`@\x90 T`\xff\x16\x15a\x1f\x7fW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`C`$\x82\x01R\x7fThe response to this task has al`D\x82\x01R\x7fready been challenged successful`d\x82\x01Rb6<\x97`\xe9\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[`da\x1f\x8e` \x86\x01\x86aH\xb7V[a\x1f\x98\x91\x90aX\x0cV[c\xff\xff\xff\xff\x16Cc\xff\xff\xff\xff\x16\x11\x15a \x19W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`7`$\x82\x01R\x7fThe challenge period for this ta`D\x82\x01R\x7fsk has already expired.\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`\0a %\x82\x80aX\x7fV[\x90P` \x86\x015\x81\x14`\x01\x81\x90\x03a sW`@Q3\x90c\xff\xff\xff\xff\x86\x16\x90\x7f\xfd>&\xbe\xebYg\xfcZW\xa0Di\x14\xea\xbcE\xb4\xaaGLg\xa5\x1bKQ`\xca\xc6\r\xdb\x05\x90`\0\x90\xa3PPPPa#\x80V[`\0\x85Q`\x01`\x01`@\x1b\x03\x81\x11\x15a \x8eWa \x8eaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a \xb7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x86Q\x81\x10\x15a!)Wa \xfa\x87\x82\x81Q\x81\x10a \xdbWa \xdbaTNV[` \x02` \x01\x01Q\x80Q`\0\x90\x81R` \x91\x82\x01Q\x90\x91R`@\x90 \x90V[\x82\x82\x81Q\x81\x10a!\x0cWa!\x0caTNV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x80a!!\x81aUUV[\x91PPa \xbdV[P`\0a!<`@\x8b\x01` \x8c\x01aH\xb7V[\x82`@Q` \x01a!N\x92\x91\x90aYLV[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x87` \x015\x81\x14a!\xf8W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`P`$\x82\x01R\x7fThe pubkeys of non-signing opera`D\x82\x01R\x7ftors supplied by the challenger `d\x82\x01Ro0\xb92\x9077\xba\x101\xb7\xb992\xb1\xba\x17`\x81\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[`\0\x87Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\"\x13Wa\"\x13aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\"<W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x88Q\x81\x10\x15a#/W\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xe8\xbb\x9a\xe6\x85\x83\x81Q\x81\x10a\"\x8cWa\"\x8caTNV[` \x02` \x01\x01Q`@Q\x82c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a\"\xb2\x91\x81R` \x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\"\xcfW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\"\xf3\x91\x90aS\x82V[\x82\x82\x81Q\x81\x10a#\x05Wa#\x05aTNV[`\x01`\x01`\xa0\x1b\x03\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x80a#'\x81aUUV[\x91PPa\"BV[Pc\xff\xff\xff\xff\x87\x16`\0\x81\x81R`\xcc` R`@\x80\x82 \x80T`\xff\x19\x16`\x01\x17\x90UQ3\x92\x91\x7f\xc2\r\x1b\xb0\xf1b6\x800k\x83\xd4\xffK\xb9\x9a+\xeb\x9d\x86\xd9x2\xf3\xca@\xfd\x13\xa2\x9d\xf1\xec\x91\xa3PPPPPPP[PPPPV[`\xceT`\x01`\x01`\xa0\x1b\x03\x163\x14a#\xeaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`!`$\x82\x01R\x7fTask generator must be the calle`D\x82\x01R`9`\xf9\x1b`d\x82\x01R`\x84\x01a\x06\x95V[a$!`@Q\x80`\x80\x01`@R\x80`\0\x81R` \x01`\0c\xff\xff\xff\xff\x16\x81R` \x01``\x81R` \x01`\0c\xff\xff\xff\xff\x16\x81RP\x90V[\x84\x81Rc\xff\xff\xff\xffC\x81\x16` \x80\x84\x01\x91\x90\x91R\x90\x85\x16``\x83\x01R`@\x80Q`\x1f\x85\x01\x83\x90\x04\x83\x02\x81\x01\x83\x01\x90\x91R\x83\x81R\x90\x84\x90\x84\x90\x81\x90\x84\x01\x83\x82\x80\x82\x847`\0\x92\x01\x91\x90\x91RPPPP`@\x80\x83\x01\x91\x90\x91RQa$\x87\x90\x82\x90` \x01aY\x94V[`@\x80Q`\x1f\x19\x81\x84\x03\x01\x81R\x82\x82R\x80Q` \x91\x82\x01 `\xc9\x80Tc\xff\xff\xff\xff\x90\x81\x16`\0\x90\x81R`\xca\x90\x94R\x93\x90\x92 UT\x16\x90\x7f\x16\x95\xb8\xd0n\xc8\0\xb4a^t\\\xfb[\xd0\x0c\x1f(ua]B\x92\\;Z\xfaT;\xb2LH\x90a$\xea\x90\x84\x90aY\x94V[`@Q\x80\x91\x03\x90\xa2`\xc9Ta%\x06\x90c\xff\xff\xff\xff\x16`\x01aX\x0cV[`\xc9\x80Tc\xff\xff\xff\xff\x19\x16c\xff\xff\xff\xff\x92\x90\x92\x16\x91\x90\x91\x17\x90UPPPPPV[`@\x80Q\x80\x82\x01\x90\x91R``\x80\x82R` \x82\x01R`\0\x84\x81\x03a%\xa0W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`7`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: empty quorum input\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`@\x83\x01QQ\x85\x14\x80\x15a%\xb8WP`\xa0\x83\x01QQ\x85\x14[\x80\x15a%\xc8WP`\xc0\x83\x01QQ\x85\x14[\x80\x15a%\xd8WP`\xe0\x83\x01QQ\x85\x14[a&BW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`A`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: input quorum length mismatc`d\x82\x01R`\r`\xfb\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x82QQ` \x84\x01QQ\x14a&\xbaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R`\0\x80Q` aZ\xff\x839\x81Q\x91R\x90\x82\x01R\x7fres: input nonsigner length mism`d\x82\x01Rc\x0c.\x8cm`\xe3\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[Cc\xff\xff\xff\xff\x16\x84c\xff\xff\xff\xff\x16\x10a')W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`<`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: invalid reference block\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`@\x80Q\x80\x82\x01\x82R`\0\x80\x82R` \x80\x83\x01\x91\x90\x91R\x82Q\x80\x84\x01\x90\x93R``\x80\x84R\x90\x83\x01R\x90\x86`\x01`\x01`@\x1b\x03\x81\x11\x15a'jWa'jaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a'\x93W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P` \x82\x01R\x86`\x01`\x01`@\x1b\x03\x81\x11\x15a'\xb1Wa'\xb1aF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a'\xdaW\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x81R`@\x80Q\x80\x82\x01\x90\x91R``\x80\x82R` \x82\x01R\x85` \x01QQ`\x01`\x01`@\x1b\x03\x81\x11\x15a(\x0eWa(\x0eaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a(7W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x81R` \x86\x01QQ`\x01`\x01`@\x1b\x03\x81\x11\x15a(WWa(WaF\xf8V[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a(\x80W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x81` \x01\x81\x90RP`\0a)R\x8a\x8a\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPP`@\x80Qc\x9a\xa1e=`\xe0\x1b\x81R\x90Q`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x93Pc\x9a\xa1e=\x92P`\x04\x80\x83\x01\x92` \x92\x91\x90\x82\x90\x03\x01\x81\x86Z\xfa\x15\x80\x15a))W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a)M\x91\x90aZ\x16V[a>zV[\x90P`\0[\x87` \x01QQ\x81\x10\x15a+\xceWa)}\x88` \x01Q\x82\x81Q\x81\x10a \xdbWa \xdbaTNV[\x83` \x01Q\x82\x81Q\x81\x10a)\x93Wa)\x93aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01R\x80\x15a*SW` \x83\x01Qa)\xb4`\x01\x83aZ3V[\x81Q\x81\x10a)\xc4Wa)\xc4aTNV[` \x02` \x01\x01Q`\0\x1c\x83` \x01Q\x82\x81Q\x81\x10a)\xe5Wa)\xe5aTNV[` \x02` \x01\x01Q`\0\x1c\x11a*SW`@\x80QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`$\x81\x01\x91\x90\x91R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: nonSignerPubkeys not sorted`d\x82\x01R`\x84\x01a\x06\x95V[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\x04\xeccQ\x84` \x01Q\x83\x81Q\x81\x10a*\x98Wa*\x98aTNV[` \x02` \x01\x01Q\x8b\x8b`\0\x01Q\x85\x81Q\x81\x10a*\xb7Wa*\xb7aTNV[` \x02` \x01\x01Q`@Q\x84c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a*\xf4\x93\x92\x91\x90\x92\x83Rc\xff\xff\xff\xff\x91\x82\x16` \x84\x01R\x16`@\x82\x01R``\x01\x90V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a+\x11W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a+5\x91\x90aV\x95V[`\x01`\x01`\xc0\x1b\x03\x16\x83`\0\x01Q\x82\x81Q\x81\x10a+TWa+TaTNV[` \x02` \x01\x01\x81\x81RPPa+\xbaa\t\x04a+\x8e\x84\x86`\0\x01Q\x85\x81Q\x81\x10a+\x80Wa+\x80aTNV[` \x02` \x01\x01Q\x16a?\rV[\x8a` \x01Q\x84\x81Q\x81\x10a+\xa4Wa+\xa4aTNV[` \x02` \x01\x01Qa?8\x90\x91\x90c\xff\xff\xff\xff\x16V[\x94P\x80a+\xc6\x81aUUV[\x91PPa)WV[PPa+\xd9\x83a@\x1bV[`\x97T\x90\x93P`\xff\x16`\0\x81a+\xf0W`\0a,rV[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xc4H\xfe\xb8`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a,NW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a,r\x91\x90aZFV[\x90P`\0[\x8a\x81\x10\x15a2\xf0W\x82\x15a-\xd2W\x89c\xff\xff\xff\xff\x16\x82\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c$\x9a\x0cB\x8f\x8f\x86\x81\x81\x10a,\xceWa,\xceaTNV[`@Q`\xe0\x85\x90\x1b`\x01`\x01`\xe0\x1b\x03\x19\x16\x81R\x92\x015`\xf8\x1c`\x04\x83\x01RP`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a-\x0eW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a-2\x91\x90aZFV[a-<\x91\x90aZ_V[\x11a-\xd2W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`f`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: StakeRegistry updates must `d\x82\x01R\x7fbe within withdrawalDelayBlocks `\x84\x82\x01Rewindow`\xd0\x1b`\xa4\x82\x01R`\xc4\x01a\x06\x95V[\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16ch\xbc\xca\xac\x8d\x8d\x84\x81\x81\x10a.\x13Wa.\x13aTNV[\x90P\x015`\xf8\x1c`\xf8\x1b`\xf8\x1c\x8c\x8c`\xa0\x01Q\x85\x81Q\x81\x10a.7Wa.7aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x86\x90\x1b\x16\x81R`\xff\x90\x93\x16`\x04\x84\x01Rc\xff\xff\xff\xff\x91\x82\x16`$\x84\x01R\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a.\x93W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a.\xb7\x91\x90aZrV[`\x01`\x01`@\x1b\x03\x19\x16a.\xda\x8a`@\x01Q\x83\x81Q\x81\x10a \xdbWa \xdbaTNV[g\xff\xff\xff\xff\xff\xff\xff\xff\x19\x16\x14a/vW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`a`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: quorumApk hash in storage d`d\x82\x01R\x7foes not match provided quorum ap`\x84\x82\x01R`k`\xf8\x1b`\xa4\x82\x01R`\xc4\x01a\x06\x95V[a/\xa6\x89`@\x01Q\x82\x81Q\x81\x10a/\x8fWa/\x8faTNV[` \x02` \x01\x01Q\x87a:r\x90\x91\x90c\xff\xff\xff\xff\x16V[\x95P\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xc8)LV\x8d\x8d\x84\x81\x81\x10a/\xe9Wa/\xe9aTNV[\x90P\x015`\xf8\x1c`\xf8\x1b`\xf8\x1c\x8c\x8c`\xc0\x01Q\x85\x81Q\x81\x10a0\rWa0\raTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x86\x90\x1b\x16\x81R`\xff\x90\x93\x16`\x04\x84\x01Rc\xff\xff\xff\xff\x91\x82\x16`$\x84\x01R\x16`D\x82\x01R`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a0iW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a0\x8d\x91\x90aU\x16V[\x85` \x01Q\x82\x81Q\x81\x10a0\xa3Wa0\xa3aTNV[`\x01`\x01``\x1b\x03\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x82\x01R\x85\x01Q\x80Q\x82\x90\x81\x10a0\xcfWa0\xcfaTNV[` \x02` \x01\x01Q\x85`\0\x01Q\x82\x81Q\x81\x10a0\xedWa0\xedaTNV[` \x02` \x01\x01\x90`\x01`\x01``\x1b\x03\x16\x90\x81`\x01`\x01``\x1b\x03\x16\x81RPP`\0\x80[\x8a` \x01QQ\x81\x10\x15a2\xdbWa1e\x86`\0\x01Q\x82\x81Q\x81\x10a17Wa17aTNV[` \x02` \x01\x01Q\x8f\x8f\x86\x81\x81\x10a1QWa1QaTNV[`\x01\x92\x015`\xf8\x1c\x92\x90\x92\x1c\x81\x16\x14\x91\x90PV[\x15a2\xc9W\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xf2\xbe\x94\xae\x8f\x8f\x86\x81\x81\x10a1\xabWa1\xabaTNV[\x90P\x015`\xf8\x1c`\xf8\x1b`\xf8\x1c\x8e\x89` \x01Q\x85\x81Q\x81\x10a1\xcfWa1\xcfaTNV[` \x02` \x01\x01Q\x8f`\xe0\x01Q\x88\x81Q\x81\x10a1\xedWa1\xedaTNV[` \x02` \x01\x01Q\x87\x81Q\x81\x10a2\x06Wa2\x06aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Q`\x01`\x01`\xe0\x1b\x03\x19`\xe0\x87\x90\x1b\x16\x81R`\xff\x90\x94\x16`\x04\x85\x01Rc\xff\xff\xff\xff\x92\x83\x16`$\x85\x01R`D\x84\x01\x91\x90\x91R\x16`d\x82\x01R`\x84\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a2jW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a2\x8e\x91\x90aU\x16V[\x87Q\x80Q\x85\x90\x81\x10a2\xa2Wa2\xa2aTNV[` \x02` \x01\x01\x81\x81Qa2\xb6\x91\x90aZ\x9dV[`\x01`\x01``\x1b\x03\x16\x90RP`\x01\x90\x91\x01\x90[\x80a2\xd3\x81aUUV[\x91PPa1\x11V[PP\x80\x80a2\xe8\x90aUUV[\x91PPa,wV[PPP`\0\x80a3\n\x8c\x86\x8a``\x01Q\x8b`\x80\x01Qa\x07\xe9V[\x91P\x91P\x81a3{W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`C`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: pairing precompile call fai`d\x82\x01Rb\x1b\x19Y`\xea\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x80a3\xdcW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`9`$\x82\x01R`\0\x80Q` aZ\xff\x839\x81Q\x91R`D\x82\x01R\x7fres: signature is invalid\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[PP`\0\x87\x82` \x01Q`@Q` \x01a3\xf7\x92\x91\x90aYLV[`@\x80Q\x80\x83\x03`\x1f\x19\x01\x81R\x91\x90R\x80Q` \x90\x91\x01 \x92\x9b\x92\x9aP\x91\x98PPPPPPPPPV[a4)a@\xb6V[a43`\0aA\x10V[V[`@\x80Q`\x01\x80\x82R\x81\x83\x01\x90\x92R`\0\x91``\x91\x83\x91` \x80\x83\x01\x90\x806\x837\x01\x90PP\x90P\x84\x81`\0\x81Q\x81\x10a4pWa4paTNV[` \x90\x81\x02\x91\x90\x91\x01\x01R`@Qca\xc8\xa1/`\xe1\x1b\x81R`\0\x90`\x01`\x01`\xa0\x1b\x03\x88\x16\x90c\xc3\x91B^\x90a4\xac\x90\x88\x90\x86\x90`\x04\x01aX\xc2V[`\0`@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a4\xc9W=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra4\xf1\x91\x90\x81\x01\x90aU\xb5V[`\0\x81Q\x81\x10a5\x03Wa5\x03aTNV[` \x90\x81\x02\x91\x90\x91\x01\x01Q`@Qc\x04\xeccQ`\xe0\x1b\x81R`\x04\x81\x01\x88\x90Rc\xff\xff\xff\xff\x87\x81\x16`$\x83\x01R\x90\x91\x16`D\x82\x01\x81\x90R\x91P`\0\x90`\x01`\x01`\xa0\x1b\x03\x89\x16\x90c\x04\xeccQ\x90`d\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a5oW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a5\x93\x91\x90aV\x95V[`\x01`\x01`\xc0\x1b\x03\x16\x90P`\0a5\xa9\x82aAbV[\x90P\x81a5\xb7\x8a\x83\x8aa\tsV[\x95P\x95PPPPP\x93P\x93\x91PPV[a5\xcfa@\xb6V[`\x01`\x01`\xa0\x1b\x03\x81\x16a64W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7fOwnable: new owner is the zero a`D\x82\x01Reddress`\xd0\x1b`d\x82\x01R`\x84\x01a\x06\x95V[a\x06\xa7\x81aA\x10V[`\0Ta\x01\0\x90\x04`\xff\x16\x15\x80\x80\x15a6]WP`\0T`\x01`\xff\x90\x91\x16\x10[\x80a6wWP0;\x15\x80\x15a6wWP`\0T`\xff\x16`\x01\x14[a6\xdaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7fInitializable: contract is alrea`D\x82\x01Rm\x19\x1eH\x1a[\x9a]\x1aX[\x1a^\x99Y`\x92\x1b`d\x82\x01R`\x84\x01a\x06\x95V[`\0\x80T`\xff\x19\x16`\x01\x17\x90U\x80\x15a6\xfdW`\0\x80Ta\xff\0\x19\x16a\x01\0\x17\x90U[a7\x08\x85`\0aB.V[a7\x11\x84aA\x10V[`\xcd\x80T`\x01`\x01`\xa0\x1b\x03\x80\x86\x16`\x01`\x01`\xa0\x1b\x03\x19\x92\x83\x16\x17\x90\x92U`\xce\x80T\x92\x85\x16\x92\x90\x91\x16\x91\x90\x91\x17\x90U\x80\x15a7\x87W`\0\x80Ta\xff\0\x19\x16\x90U`@Q`\x01\x81R\x7f\x7f&\xb8?\xf9n\x1f+jh/\x138R\xf6y\x8a\t\xc4e\xda\x95\x92\x14`\xce\xfb8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xa1[PPPPPV[`e`\0\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xa0\x1b\x03\x16`\x01`\x01`\xa0\x1b\x03\x16c\xea\xb6mz`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a7\xe1W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a8\x05\x91\x90aS\x82V[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a85W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x06\x95\x90aS\x9fV[`fT\x19\x81\x19`fT\x19\x16\x14a8\xb3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7fPausable.unpause: invalid attemp`D\x82\x01R\x7ft to pause functionality\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x06\x95V[`f\x81\x90U`@Q\x81\x81R3\x90\x7f5\x82\xd1\x82\x8e&\xbfV\xbd\x80\x15\x02\xbc\x02\x1a\xc0\xbc\x8a\xfbW\xc8&\xe4\x98kEY<\x8f\xad8\x9c\x90` \x01a\x07\xdeV[`\x01`\x01`\xa0\x1b\x03\x81\x16a9xW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`I`$\x82\x01R\x7fPausable._setPauserRegistry: new`D\x82\x01R\x7fPauserRegistry cannot be the zer`d\x82\x01Rho address`\xb8\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[`eT`@\x80Q`\x01`\x01`\xa0\x1b\x03\x92\x83\x16\x81R\x91\x83\x16` \x83\x01R\x7fn\x9f\xcdS\x98\x96\xfc\xa6\x0e\x8b\x0f\x01\xddX\x023\xe4\x8ak\x0f}\xf0\x13\xb8\x9b\xa7\xf5e\x86\x9a\xcd\xb6\x91\x01`@Q\x80\x91\x03\x90\xa1`e\x80T`\x01`\x01`\xa0\x1b\x03\x19\x16`\x01`\x01`\xa0\x1b\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01Ra9\xfdaE\xd3V[\x83Q\x81R` \x80\x85\x01Q\x90\x82\x01R`@\x80\x82\x01\x84\x90R`\0\x90\x83``\x84`\x07a\x07\xd0Z\x03\xfa\x90P\x80\x80a:,W\xfe[P\x80a:jW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\r`$\x82\x01Rl\x19X\xcb[][\x0bY\x98Z[\x19Y`\x9a\x1b`D\x82\x01R`d\x01a\x06\x95V[PP\x92\x91PPV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01Ra:\x8eaE\xf1V[\x83Q\x81R` \x80\x85\x01Q\x81\x83\x01R\x83Q`@\x80\x84\x01\x91\x90\x91R\x90\x84\x01Q``\x83\x01R`\0\x90\x83`\x80\x84`\x06a\x07\xd0Z\x03\xfa\x90P\x80\x80a:\xc9W\xfe[P\x80a:jW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\r`$\x82\x01Rl\x19X\xcbXY\x19\x0bY\x98Z[\x19Y`\x9a\x1b`D\x82\x01R`d\x01a\x06\x95V[a;\x0faF\x0fV[P`@\x80Q`\x80\x81\x01\x82R\x7f\x19\x8e\x93\x93\x92\rH:r`\xbf\xb71\xfb]%\xf1\xaaI35\xa9\xe7\x12\x97\xe4\x85\xb7\xae\xf3\x12\xc2\x81\x83\x01\x90\x81R\x7f\x18\0\xde\xef\x12\x1f\x1evBj\0f^\\DygC\"\xd4\xf7^\xda\xddF\xde\xbd\\\xd9\x92\xf6\xed``\x83\x01R\x81R\x81Q\x80\x83\x01\x90\x92R\x7f']\xc4\xa2\x88\xd1\xaf\xb3\xcb\xb1\xac\t\x18u$\xc7\xdb69]\xf7\xbe;\x99\xe6s\xb1:\x07Ze\xec\x82R\x7f\x1d\x9b\xef\xcd\x05\xa52>m\xa4\xd45\xf3\xb6\x17\xcd\xb3\xaf\x83(\\-\xf7\x11\xef9\xc0\x15q\x82\x7f\x9d` \x83\x81\x01\x91\x90\x91R\x81\x01\x91\x90\x91R\x90V[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R`\0\x80\x80a;\xf7`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x86aTdV[\x90P[a<\x03\x81aC\x18V[\x90\x93P\x91P`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x82\x83\t\x83\x03a<<W`@\x80Q\x80\x82\x01\x90\x91R\x90\x81R` \x81\x01\x91\x90\x91R\x93\x92PPPV[`\0\x80Q` aZ\xdf\x839\x81Q\x91R`\x01\x82\x08\x90Pa;\xfaV[`@\x80Q\x80\x82\x01\x82R\x86\x81R` \x80\x82\x01\x86\x90R\x82Q\x80\x84\x01\x90\x93R\x86\x83R\x82\x01\x84\x90R`\0\x91\x82\x91\x90a<\x88aF4V[`\0[`\x02\x81\x10\x15a>MW`\0a<\xa1\x82`\x06aX\x7fV[\x90P\x84\x82`\x02\x81\x10a<\xb5Wa<\xb5aTNV[` \x02\x01QQ\x83a<\xc7\x83`\0aZ_V[`\x0c\x81\x10a<\xd7Wa<\xd7aTNV[` \x02\x01R\x84\x82`\x02\x81\x10a<\xeeWa<\xeeaTNV[` \x02\x01Q` \x01Q\x83\x82`\x01a=\x05\x91\x90aZ_V[`\x0c\x81\x10a=\x15Wa=\x15aTNV[` \x02\x01R\x83\x82`\x02\x81\x10a=,Wa=,aTNV[` \x02\x01QQQ\x83a=?\x83`\x02aZ_V[`\x0c\x81\x10a=OWa=OaTNV[` \x02\x01R\x83\x82`\x02\x81\x10a=fWa=faTNV[` \x02\x01QQ`\x01` \x02\x01Q\x83a=\x7f\x83`\x03aZ_V[`\x0c\x81\x10a=\x8fWa=\x8faTNV[` \x02\x01R\x83\x82`\x02\x81\x10a=\xa6Wa=\xa6aTNV[` \x02\x01Q` \x01Q`\0`\x02\x81\x10a=\xc1Wa=\xc1aTNV[` \x02\x01Q\x83a=\xd2\x83`\x04aZ_V[`\x0c\x81\x10a=\xe2Wa=\xe2aTNV[` \x02\x01R\x83\x82`\x02\x81\x10a=\xf9Wa=\xf9aTNV[` \x02\x01Q` \x01Q`\x01`\x02\x81\x10a>\x14Wa>\x14aTNV[` \x02\x01Q\x83a>%\x83`\x05aZ_V[`\x0c\x81\x10a>5Wa>5aTNV[` \x02\x01RP\x80a>E\x81aUUV[\x91PPa<\x8bV[Pa>VaFSV[`\0` \x82a\x01\x80\x85`\x08\x8c\xfa\x91Q\x91\x9c\x91\x15\x15\x9bP\x90\x99PPPPPPPPPPV[`\0\x80a>\x86\x84aC\x9aV[\x90P\x80\x83`\xff\x16`\x01\x90\x1b\x11a?\x04W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`?`$\x82\x01R\x7fBitmapUtils.orderedBytesArrayToB`D\x82\x01R\x7fitmap: bitmap exceeds max value\0`d\x82\x01R`\x84\x01a\x06\x95V[\x90P[\x92\x91PPV[`\0\x80[\x82\x15a?\x07Wa?\"`\x01\x84aZ3V[\x90\x92\x16\x91\x80a?0\x81aZ\xbdV[\x91PPa?\x11V[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01Ra\x02\0\x82a\xff\xff\x16\x10a?\x94W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x10`$\x82\x01Roscalar-too-large`\x80\x1b`D\x82\x01R`d\x01a\x06\x95V[\x81a\xff\xff\x16`\x01\x03a?\xa7WP\x81a?\x07V[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01\x81\x90R\x84\x90`\x01\x90[\x81a\xff\xff\x16\x86a\xff\xff\x16\x10a@\x10W`\x01a\xff\xff\x87\x16`\xff\x83\x16\x1c\x81\x16\x90\x03a?\xf3Wa?\xf0\x84\x84a:rV[\x93P[a?\xfd\x83\x84a:rV[\x92Pb\x01\xff\xfe`\x01\x92\x83\x1b\x16\x91\x01a?\xc3V[P\x91\x95\x94PPPPPV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R\x81Q\x15\x80\x15a@@WP` \x82\x01Q\x15[\x15a@^WPP`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R\x90V[`@Q\x80`@\x01`@R\x80\x83`\0\x01Q\x81R` \x01`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x84` \x01Qa@\x91\x91\x90aTdV[a@\xa9\x90`\0\x80Q` aZ\xdf\x839\x81Q\x91RaZ3V[\x90R\x92\x91PPV[\x91\x90PV[`3T`\x01`\x01`\xa0\x1b\x03\x163\x14a43W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7fOwnable: caller is not the owner`D\x82\x01R`d\x01a\x06\x95V[`3\x80T`\x01`\x01`\xa0\x1b\x03\x83\x81\x16`\x01`\x01`\xa0\x1b\x03\x19\x83\x16\x81\x17\x90\x93U`@Q\x91\x16\x91\x90\x82\x90\x7f\x8b\xe0\x07\x9cS\x16Y\x14\x13D\xcd\x1f\xd0\xa4\xf2\x84\x19I\x7f\x97\"\xa3\xda\xaf\xe3\xb4\x18okdW\xe0\x90`\0\x90\xa3PPV[```\0\x80aAp\x84a?\rV[a\xff\xff\x16`\x01`\x01`@\x1b\x03\x81\x11\x15aA\x8bWaA\x8baF\xf8V[`@Q\x90\x80\x82R\x80`\x1f\x01`\x1f\x19\x16` \x01\x82\x01`@R\x80\x15aA\xb5W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\0\x80[\x82Q\x82\x10\x80\x15aA\xcdWPa\x01\0\x81\x10[\x15aB$W`\x01\x81\x1b\x93P\x85\x84\x16\x15aB\x14W\x80`\xf8\x1b\x83\x83\x81Q\x81\x10aA\xf6WaA\xf6aTNV[` \x01\x01\x90`\x01`\x01`\xf8\x1b\x03\x19\x16\x90\x81`\0\x1a\x90SP\x81`\x01\x01\x91P[aB\x1d\x81aUUV[\x90PaA\xbcV[P\x90\x94\x93PPPPV[`eT`\x01`\x01`\xa0\x1b\x03\x16\x15\x80\x15aBOWP`\x01`\x01`\xa0\x1b\x03\x82\x16\x15\x15[aB\xd1W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fPausable._initializePauser: _ini`D\x82\x01R\x7ftializePauser() can only be call`d\x82\x01Rfed once`\xc8\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[`f\x81\x90U`@Q\x81\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01`@Q\x80\x91\x03\x90\xa2aC\x14\x82a8\xeaV[PPV[`\0\x80\x80`\0\x80Q` aZ\xdf\x839\x81Q\x91R`\x03`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x86`\0\x80Q` aZ\xdf\x839\x81Q\x91R\x88\x89\t\t\x08\x90P`\0aC\x8e\x82\x7f\x0c\x19\x13\x9c\xb8Lh\nn\x14\x11m\xa0`V\x17e\xe0Z\xa4Z\x1cr\xa3O\x08#\x05\xb6\x1f?R`\0\x80Q` aZ\xdf\x839\x81Q\x91RaE*V[\x91\x95\x91\x94P\x90\x92PPPV[`\0a\x01\0\x82Q\x11\x15aD#W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R\x7fBitmapUtils.orderedBytesArrayToB\x90\x82\x01R\x7fitmap: orderedBytesArray is too `d\x82\x01Rclong`\xe0\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x81Q`\0\x03aD4WP`\0\x91\x90PV[`\0\x80\x83`\0\x81Q\x81\x10aDJWaDJaTNV[\x01` \x01Q`\x01`\xf8\x91\x90\x91\x1c\x81\x90\x1b\x92P[\x84Q\x81\x10\x15aE!W\x84\x81\x81Q\x81\x10aDxWaDxaTNV[\x01` \x01Q`\x01`\xf8\x91\x90\x91\x1c\x1b\x91P\x82\x82\x11aE\rW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fBitmapUtils.orderedBytesArrayToB`D\x82\x01R\x7fitmap: orderedBytesArray is not `d\x82\x01Rf\x1b\xdc\x99\x19\\\x99Y`\xca\x1b`\x84\x82\x01R`\xa4\x01a\x06\x95V[\x91\x81\x17\x91aE\x1a\x81aUUV[\x90PaD]V[P\x90\x93\x92PPPV[`\0\x80aE5aFSV[aE=aFqV[` \x80\x82R\x81\x81\x01\x81\x90R`@\x82\x01\x81\x90R``\x82\x01\x88\x90R`\x80\x82\x01\x87\x90R`\xa0\x82\x01\x86\x90R\x82`\xc0\x83`\x05a\x07\xd0Z\x03\xfa\x92P\x82\x80aEzW\xfe[P\x82aE\xc8W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x1a`$\x82\x01R\x7fBN254.expMod: call failure\0\0\0\0\0\0`D\x82\x01R`d\x01a\x06\x95V[PQ\x95\x94PPPPPV[`@Q\x80``\x01`@R\x80`\x03\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`\x80\x01`@R\x80`\x04\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`@\x01`@R\x80aF\"aF\x8fV[\x81R` \x01aF/aF\x8fV[\x90R\x90V[`@Q\x80a\x01\x80\x01`@R\x80`\x0c\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80` \x01`@R\x80`\x01\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`\xc0\x01`@R\x80`\x06\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`@\x01`@R\x80`\x02\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x14a\x06\xa7W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aF\xd4W`\0\x80\xfd[\x815a?\x04\x81aF\xadV[`\0` \x82\x84\x03\x12\x15aF\xf1W`\0\x80\xfd[P5\x91\x90PV[cNH{q`\xe0\x1b`\0R`A`\x04R`$`\0\xfd[`@\x80Q\x90\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aG0WaG0aF\xf8V[`@R\x90V[`@Qa\x01\0\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aG0WaG0aF\xf8V[`@Q`\x1f\x82\x01`\x1f\x19\x16\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aG\x81WaG\x81aF\xf8V[`@R\x91\x90PV[`\0`@\x82\x84\x03\x12\x15aG\x9bW`\0\x80\xfd[aG\xa3aG\x0eV[\x90P\x815\x81R` \x82\x015` \x82\x01R\x92\x91PPV[`\0\x82`\x1f\x83\x01\x12aG\xcaW`\0\x80\xfd[aG\xd2aG\x0eV[\x80`@\x84\x01\x85\x81\x11\x15aG\xe4W`\0\x80\xfd[\x84[\x81\x81\x10\x15aG\xfeW\x805\x84R` \x93\x84\x01\x93\x01aG\xe6V[P\x90\x95\x94PPPPPV[`\0`\x80\x82\x84\x03\x12\x15aH\x1bW`\0\x80\xfd[aH#aG\x0eV[\x90PaH/\x83\x83aG\xb9V[\x81RaH>\x83`@\x84\x01aG\xb9V[` \x82\x01R\x92\x91PPV[`\0\x80`\0\x80a\x01 \x85\x87\x03\x12\x15aH`W`\0\x80\xfd[\x845\x93PaHq\x86` \x87\x01aG\x89V[\x92PaH\x80\x86``\x87\x01aH\tV[\x91PaH\x8f\x86`\xe0\x87\x01aG\x89V[\x90P\x92\x95\x91\x94P\x92PV[c\xff\xff\xff\xff\x81\x16\x81\x14a\x06\xa7W`\0\x80\xfd[\x805a@\xb1\x81aH\x9aV[`\0` \x82\x84\x03\x12\x15aH\xc9W`\0\x80\xfd[\x815a?\x04\x81aH\x9aV[`\0\x80`\0``\x84\x86\x03\x12\x15aH\xe9W`\0\x80\xfd[\x835aH\xf4\x81aF\xadV[\x92P` \x84\x81\x015`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aI\x11W`\0\x80\xfd[\x81\x87\x01\x91P\x87`\x1f\x83\x01\x12aI%W`\0\x80\xfd[\x815\x81\x81\x11\x15aI7WaI7aF\xf8V[aII`\x1f\x82\x01`\x1f\x19\x16\x85\x01aGYV[\x91P\x80\x82R\x88\x84\x82\x85\x01\x01\x11\x15aI_W`\0\x80\xfd[\x80\x84\x84\x01\x85\x84\x017`\0\x84\x82\x84\x01\x01RP\x80\x94PPPPaI\x82`@\x85\x01aH\xacV[\x90P\x92P\x92P\x92V[`\0\x81Q\x80\x84R` \x80\x85\x01\x80\x81\x96P\x83`\x05\x1b\x81\x01\x91P\x82\x86\x01`\0\x80[\x86\x81\x10\x15aJ!W\x83\x85\x03\x8aR\x82Q\x80Q\x80\x87R\x90\x87\x01\x90\x87\x87\x01\x90\x84[\x81\x81\x10\x15aJ\x0cW\x83Q\x80Q`\x01`\x01`\xa0\x1b\x03\x16\x84R\x8a\x81\x01Q\x8b\x85\x01R`@\x90\x81\x01Q`\x01`\x01``\x1b\x03\x16\x90\x84\x01R\x92\x89\x01\x92``\x90\x92\x01\x91`\x01\x01aI\xc8V[PP\x9a\x87\x01\x9a\x95PP\x91\x85\x01\x91`\x01\x01aI\xaaV[P\x92\x98\x97PPPPPPPPV[` \x81R`\0aJB` \x83\x01\x84aI\x8bV[\x93\x92PPPV[\x80\x15\x15\x81\x14a\x06\xa7W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aJiW`\0\x80\xfd[\x815a?\x04\x81aJIV[`\0\x80\x83`\x1f\x84\x01\x12aJ\x86W`\0\x80\xfd[P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aJ\x9dW`\0\x80\xfd[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15aJ\xb5W`\0\x80\xfd[\x92P\x92\x90PV[`\0\x80`\0\x80`\0\x80`\x80\x87\x89\x03\x12\x15aJ\xd5W`\0\x80\xfd[\x865aJ\xe0\x81aF\xadV[\x95P` \x87\x015aJ\xf0\x81aH\x9aV[\x94P`@\x87\x015`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aK\x0cW`\0\x80\xfd[aK\x18\x8a\x83\x8b\x01aJtV[\x90\x96P\x94P``\x89\x015\x91P\x80\x82\x11\x15aK1W`\0\x80\xfd[\x81\x89\x01\x91P\x89`\x1f\x83\x01\x12aKEW`\0\x80\xfd[\x815\x81\x81\x11\x15aKTW`\0\x80\xfd[\x8a` \x82`\x05\x1b\x85\x01\x01\x11\x15aKiW`\0\x80\xfd[` \x83\x01\x94P\x80\x93PPPP\x92\x95P\x92\x95P\x92\x95V[`\0\x81Q\x80\x84R` \x80\x85\x01\x94P\x80\x84\x01`\0[\x83\x81\x10\x15aK\xb5W\x81Qc\xff\xff\xff\xff\x16\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01aK\x93V[P\x94\x95\x94PPPPPV[`\0` \x80\x83R\x83Q`\x80\x82\x85\x01RaK\xdc`\xa0\x85\x01\x82aK\x7fV[\x90P\x81\x85\x01Q`\x1f\x19\x80\x86\x84\x03\x01`@\x87\x01RaK\xf9\x83\x83aK\x7fV[\x92P`@\x87\x01Q\x91P\x80\x86\x84\x03\x01``\x87\x01RaL\x16\x83\x83aK\x7fV[``\x88\x01Q\x87\x82\x03\x83\x01`\x80\x89\x01R\x80Q\x80\x83R\x91\x94P\x85\x01\x92P\x84\x84\x01\x90`\x05\x81\x90\x1b\x85\x01\x86\x01`\0[\x82\x81\x10\x15aLmW\x84\x87\x83\x03\x01\x84RaL[\x82\x87QaK\x7fV[\x95\x88\x01\x95\x93\x88\x01\x93\x91P`\x01\x01aLAV[P\x99\x98PPPPPPPPPV[`\xff\x81\x16\x81\x14a\x06\xa7W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aL\x9cW`\0\x80\xfd[\x815a?\x04\x81aL{V[`\0`\x80\x82\x84\x03\x12\x15aL\xb9W`\0\x80\xfd[P\x91\x90PV[`\0`@\x82\x84\x03\x12\x15aL\xb9W`\0\x80\xfd[`\0`\x01`\x01`@\x1b\x03\x82\x11\x15aL\xeaWaL\xeaaF\xf8V[P`\x05\x1b` \x01\x90V[`\0\x82`\x1f\x83\x01\x12aM\x05W`\0\x80\xfd[\x815` aM\x1aaM\x15\x83aL\xd1V[aGYV[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aM9W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aM]W\x805aMP\x81aH\x9aV[\x83R\x91\x83\x01\x91\x83\x01aM=V[P\x96\x95PPPPPPV[`\0\x82`\x1f\x83\x01\x12aMyW`\0\x80\xfd[\x815` aM\x89aM\x15\x83aL\xd1V[\x82\x81R`\x06\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aM\xa8W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aM]WaM\xbe\x88\x82aG\x89V[\x83R\x91\x83\x01\x91`@\x01aM\xacV[`\0\x82`\x1f\x83\x01\x12aM\xddW`\0\x80\xfd[\x815` aM\xedaM\x15\x83aL\xd1V[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aN\x0cW`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aM]W\x805`\x01`\x01`@\x1b\x03\x81\x11\x15aN/W`\0\x80\x81\xfd[aN=\x89\x86\x83\x8b\x01\x01aL\xf4V[\x84RP\x91\x83\x01\x91\x83\x01aN\x10V[`\0a\x01\x80\x82\x84\x03\x12\x15aN^W`\0\x80\xfd[aNfaG6V[\x90P\x815`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aN\x7fW`\0\x80\xfd[aN\x8b\x85\x83\x86\x01aL\xf4V[\x83R` \x84\x015\x91P\x80\x82\x11\x15aN\xa1W`\0\x80\xfd[aN\xad\x85\x83\x86\x01aMhV[` \x84\x01R`@\x84\x015\x91P\x80\x82\x11\x15aN\xc6W`\0\x80\xfd[aN\xd2\x85\x83\x86\x01aMhV[`@\x84\x01RaN\xe4\x85``\x86\x01aH\tV[``\x84\x01RaN\xf6\x85`\xe0\x86\x01aG\x89V[`\x80\x84\x01Ra\x01 \x84\x015\x91P\x80\x82\x11\x15aO\x10W`\0\x80\xfd[aO\x1c\x85\x83\x86\x01aL\xf4V[`\xa0\x84\x01Ra\x01@\x84\x015\x91P\x80\x82\x11\x15aO6W`\0\x80\xfd[aOB\x85\x83\x86\x01aL\xf4V[`\xc0\x84\x01Ra\x01`\x84\x015\x91P\x80\x82\x11\x15aO\\W`\0\x80\xfd[PaOi\x84\x82\x85\x01aM\xccV[`\xe0\x83\x01RP\x92\x91PPV[`\0\x80`\0`\x80\x84\x86\x03\x12\x15aO\x8aW`\0\x80\xfd[\x835`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aO\xa1W`\0\x80\xfd[aO\xad\x87\x83\x88\x01aL\xa7V[\x94PaO\xbc\x87` \x88\x01aL\xbfV[\x93P``\x86\x015\x91P\x80\x82\x11\x15aO\xd2W`\0\x80\xfd[PaO\xdf\x86\x82\x87\x01aNKV[\x91PP\x92P\x92P\x92V[`\0\x80`\0``\x84\x86\x03\x12\x15aO\xfeW`\0\x80\xfd[\x835aP\t\x81aF\xadV[\x92P` \x84\x81\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aP%W`\0\x80\xfd[\x85\x01`\x1f\x81\x01\x87\x13aP6W`\0\x80\xfd[\x805aPDaM\x15\x82aL\xd1V[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x89\x83\x11\x15aPcW`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15aP\x81W\x835\x82R\x92\x84\x01\x92\x90\x84\x01\x90aPhV[\x80\x96PPPPPPaI\x82`@\x85\x01aH\xacV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R`\0\x91\x90\x84\x82\x01\x90`@\x85\x01\x90\x84[\x81\x81\x10\x15aP\xcdW\x83Q\x83R\x92\x84\x01\x92\x91\x84\x01\x91`\x01\x01aP\xb1V[P\x90\x96\x95PPPPPPV[`\0\x80`\0\x80`\xc0\x85\x87\x03\x12\x15aP\xefW`\0\x80\xfd[\x845`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aQ\x06W`\0\x80\xfd[aQ\x12\x88\x83\x89\x01aL\xa7V[\x95PaQ!\x88` \x89\x01aL\xbfV[\x94PaQ0\x88``\x89\x01aL\xbfV[\x93P`\xa0\x87\x015\x91P\x80\x82\x11\x15aQFW`\0\x80\xfd[PaQS\x87\x82\x88\x01aMhV[\x91PP\x92\x95\x91\x94P\x92PV[`\0\x80`\0\x80``\x85\x87\x03\x12\x15aQuW`\0\x80\xfd[\x845\x93P` \x85\x015aQ\x87\x81aH\x9aV[\x92P`@\x85\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aQ\xa2W`\0\x80\xfd[aQ\xae\x87\x82\x88\x01aJtV[\x95\x98\x94\x97P\x95PPPPV[`\0\x80`\0\x80`\0`\x80\x86\x88\x03\x12\x15aQ\xd2W`\0\x80\xfd[\x855\x94P` \x86\x015`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aQ\xf0W`\0\x80\xfd[aQ\xfc\x89\x83\x8a\x01aJtV[\x90\x96P\x94P`@\x88\x015\x91PaR\x11\x82aH\x9aV[\x90\x92P``\x87\x015\x90\x80\x82\x11\x15aR'W`\0\x80\xfd[PaR4\x88\x82\x89\x01aNKV[\x91PP\x92\x95P\x92\x95\x90\x93PV[`\0\x81Q\x80\x84R` \x80\x85\x01\x94P\x80\x84\x01`\0[\x83\x81\x10\x15aK\xb5W\x81Q`\x01`\x01``\x1b\x03\x16\x87R\x95\x82\x01\x95\x90\x82\x01\x90`\x01\x01aRUV[`@\x81R`\0\x83Q`@\x80\x84\x01RaR\x95`\x80\x84\x01\x82aRAV[\x90P` \x85\x01Q`?\x19\x84\x83\x03\x01``\x85\x01RaR\xb2\x82\x82aRAV[\x92PPP\x82` \x83\x01R\x93\x92PPPV[`\0\x80`\0``\x84\x86\x03\x12\x15aR\xd8W`\0\x80\xfd[\x835aR\xe3\x81aF\xadV[\x92P` \x84\x015\x91P`@\x84\x015aR\xfa\x81aH\x9aV[\x80\x91PP\x92P\x92P\x92V[\x82\x81R`@` \x82\x01R`\0aS\x1e`@\x83\x01\x84aI\x8bV[\x94\x93PPPPV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15aS<W`\0\x80\xfd[\x845aSG\x81aF\xadV[\x93P` \x85\x015aSW\x81aF\xadV[\x92P`@\x85\x015aSg\x81aF\xadV[\x91P``\x85\x015aSw\x81aF\xadV[\x93\x96\x92\x95P\x90\x93PPV[`\0` \x82\x84\x03\x12\x15aS\x94W`\0\x80\xfd[\x81Qa?\x04\x81aF\xadV[` \x80\x82R`*\x90\x82\x01R\x7fmsg.sender is not permissioned a`@\x82\x01Ri9\x90:\xb780\xba\xb9\xb2\xb9`\xb1\x1b``\x82\x01R`\x80\x01\x90V[`\0` \x82\x84\x03\x12\x15aS\xfbW`\0\x80\xfd[\x81Qa?\x04\x81aJIV[` \x80\x82R`(\x90\x82\x01R\x7fmsg.sender is not permissioned a`@\x82\x01Rg9\x9080\xba\xb9\xb2\xb9`\xc1\x1b``\x82\x01R`\x80\x01\x90V[cNH{q`\xe0\x1b`\0R`2`\x04R`$`\0\xfd[`\0\x82aT\x81WcNH{q`\xe0\x1b`\0R`\x12`\x04R`$`\0\xfd[P\x06\x90V[`\0` \x80\x83\x85\x03\x12\x15aT\x99W`\0\x80\xfd[\x82Q`\x01`\x01`@\x1b\x03\x81\x11\x15aT\xafW`\0\x80\xfd[\x83\x01`\x1f\x81\x01\x85\x13aT\xc0W`\0\x80\xfd[\x80QaT\xceaM\x15\x82aL\xd1V[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15aT\xedW`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15aU\x0bW\x83Q\x82R\x92\x84\x01\x92\x90\x84\x01\x90aT\xf2V[\x97\x96PPPPPPPV[`\0` \x82\x84\x03\x12\x15aU(W`\0\x80\xfd[\x81Q`\x01`\x01``\x1b\x03\x81\x16\x81\x14a?\x04W`\0\x80\xfd[cNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[`\0`\x01\x82\x01aUgWaUgaU?V[P`\x01\x01\x90V[c\xff\xff\xff\xff\x84\x16\x81R`@` \x82\x01\x81\x90R\x81\x01\x82\x90R`\0`\x01`\x01`\xfb\x1b\x03\x83\x11\x15aU\x9bW`\0\x80\xfd[\x82`\x05\x1b\x80\x85``\x85\x017\x91\x90\x91\x01``\x01\x94\x93PPPPV[`\0` \x80\x83\x85\x03\x12\x15aU\xc8W`\0\x80\xfd[\x82Q`\x01`\x01`@\x1b\x03\x81\x11\x15aU\xdeW`\0\x80\xfd[\x83\x01`\x1f\x81\x01\x85\x13aU\xefW`\0\x80\xfd[\x80QaU\xfdaM\x15\x82aL\xd1V[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15aV\x1cW`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15aU\x0bW\x83QaV4\x81aH\x9aV[\x82R\x92\x84\x01\x92\x90\x84\x01\x90aV!V[\x81\x83R\x81\x81` \x85\x017P`\0\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1f\x90\x91\x01`\x1f\x19\x16\x90\x91\x01\x01\x90V[c\xff\xff\xff\xff\x84\x16\x81R`@` \x82\x01R`\0aV\x8c`@\x83\x01\x84\x86aVCV[\x95\x94PPPPPV[`\0` \x82\x84\x03\x12\x15aV\xa7W`\0\x80\xfd[\x81Q`\x01`\x01`\xc0\x1b\x03\x81\x16\x81\x14a?\x04W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aV\xd0W`\0\x80\xfd[\x81Qa?\x04\x81aH\x9aV[`\0`\xff\x82\x16`\xff\x81\x03aV\xf1WaV\xf1aU?V[`\x01\x01\x92\x91PPV[`@\x81R`\0aW\x0e`@\x83\x01\x85\x87aVCV[\x90Pc\xff\xff\xff\xff\x83\x16` \x83\x01R\x94\x93PPPPV[`\0\x80\x835`\x1e\x19\x846\x03\x01\x81\x12aW;W`\0\x80\xfd[\x83\x01\x805\x91P`\x01`\x01`@\x1b\x03\x82\x11\x15aWUW`\0\x80\xfd[` \x01\x91P6\x81\x90\x03\x82\x13\x15aJ\xb5W`\0\x80\xfd[` \x81R\x815` \x82\x01R`\0` \x83\x015aW\x85\x81aH\x9aV[c\xff\xff\xff\xff\x81\x16`@\x84\x01RP`@\x83\x015`\x1e\x19\x846\x03\x01\x81\x12aW\xa9W`\0\x80\xfd[\x83\x01` \x81\x01\x905`\x01`\x01`@\x1b\x03\x81\x11\x15aW\xc5W`\0\x80\xfd[\x806\x03\x82\x13\x15aW\xd4W`\0\x80\xfd[`\x80``\x85\x01RaW\xe9`\xa0\x85\x01\x82\x84aVCV[\x91PPaW\xf8``\x85\x01aH\xacV[c\xff\xff\xff\xff\x81\x16`\x80\x85\x01RP\x93\x92PPPV[c\xff\xff\xff\xff\x81\x81\x16\x83\x82\x16\x01\x90\x80\x82\x11\x15aX)WaX)aU?V[P\x92\x91PPV[\x805aX;\x81aH\x9aV[c\xff\xff\xff\xff\x16\x82R` \x90\x81\x015\x91\x01RV[`@\x81\x01a?\x07\x82\x84aX0V[`\x01`\x01``\x1b\x03\x81\x81\x16\x83\x82\x16\x02\x80\x82\x16\x91\x90\x82\x81\x14a:jWa:jaU?V[\x80\x82\x02\x81\x15\x82\x82\x04\x84\x14\x17a?\x07Wa?\x07aU?V[`\x80\x81\x01aX\xa4\x82\x85aX0V[c\xff\xff\xff\xff\x83Q\x16`@\x83\x01R` \x83\x01Q``\x83\x01R\x93\x92PPPV[`\0`@\x82\x01c\xff\xff\xff\xff\x85\x16\x83R` `@\x81\x85\x01R\x81\x85Q\x80\x84R``\x86\x01\x91P\x82\x87\x01\x93P`\0[\x81\x81\x10\x15aY\tW\x84Q\x83R\x93\x83\x01\x93\x91\x83\x01\x91`\x01\x01aX\xedV[P\x90\x97\x96PPPPPPPV[`\x80\x81\x01aY$\x82\x85aX0V[\x825aY/\x81aH\x9aV[c\xff\xff\xff\xff\x16`@\x83\x01R` \x92\x90\x92\x015``\x90\x91\x01R\x91\x90PV[c\xff\xff\xff\xff`\xe0\x1b\x83`\xe0\x1b\x16\x81R`\0`\x04\x82\x01\x83Q` \x80\x86\x01`\0[\x83\x81\x10\x15aY\x87W\x81Q\x85R\x93\x82\x01\x93\x90\x82\x01\x90`\x01\x01aYkV[P\x92\x97\x96PPPPPPPV[`\0` \x80\x83R\x83Q\x81\x84\x01Rc\xff\xff\xff\xff\x81\x85\x01Q\x16`@\x84\x01R`@\x84\x01Q`\x80``\x85\x01R\x80Q\x80`\xa0\x86\x01R`\0[\x81\x81\x10\x15aY\xe3W\x82\x81\x01\x84\x01Q\x86\x82\x01`\xc0\x01R\x83\x01aY\xc7V[P`\0\x85\x82\x01`\xc0\x01R``\x86\x01Qc\xff\xff\xff\xff\x81\x16`\x80\x87\x01R\x92P`\x1f\x01`\x1f\x19\x16\x93\x90\x93\x01`\xc0\x01\x94\x93PPPPV[`\0` \x82\x84\x03\x12\x15aZ(W`\0\x80\xfd[\x81Qa?\x04\x81aL{V[\x81\x81\x03\x81\x81\x11\x15a?\x07Wa?\x07aU?V[`\0` \x82\x84\x03\x12\x15aZXW`\0\x80\xfd[PQ\x91\x90PV[\x80\x82\x01\x80\x82\x11\x15a?\x07Wa?\x07aU?V[`\0` \x82\x84\x03\x12\x15aZ\x84W`\0\x80\xfd[\x81Qg\xff\xff\xff\xff\xff\xff\xff\xff\x19\x81\x16\x81\x14a?\x04W`\0\x80\xfd[`\x01`\x01``\x1b\x03\x82\x81\x16\x82\x82\x16\x03\x90\x80\x82\x11\x15aX)WaX)aU?V[`\0a\xff\xff\x80\x83\x16\x81\x81\x03aZ\xd4WaZ\xd4aU?V[`\x01\x01\x93\x92PPPV\xfe0dNr\xe11\xa0)\xb8PE\xb6\x81\x81X]\x97\x81j\x91hq\xca\x8d< \x8c\x16\xd8|\xfdGBLSSignatureChecker.checkSignatu\xa2dipfsX\"\x12 \xf9\x16\x98\x047\r\xa5\xb0N\xe2b4%\x05\xbc\xa8?\x82A\xd9\xd4\xb0\x81f3\xb1\xbe5\x12\x16_\x1ddsolcC\0\x08\x14\03");
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct CheckSignaturesIndices { uint32[] nonSignerQuorumBitmapIndices; uint32[] quorumApkIndices; uint32[] totalStakeIndices; uint32[][] nonSignerStakeIndices; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct CheckSignaturesIndices {
        pub nonSignerQuorumBitmapIndices: ::alloy_sol_types::private::Vec<u32>,
        pub quorumApkIndices: ::alloy_sol_types::private::Vec<u32>,
        pub totalStakeIndices: ::alloy_sol_types::private::Vec<u32>,
        pub nonSignerStakeIndices:
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Vec<u32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
            ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
            ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
            ::alloy_sol_types::sol_data::Array<
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Vec<u32>,
            ::alloy_sol_types::private::Vec<u32>,
            ::alloy_sol_types::private::Vec<u32>,
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Vec<u32>>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CheckSignaturesIndices> for UnderlyingRustTuple<'_> {
            fn from(value: CheckSignaturesIndices) -> Self {
                (
                    value.nonSignerQuorumBitmapIndices,
                    value.quorumApkIndices,
                    value.totalStakeIndices,
                    value.nonSignerStakeIndices,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CheckSignaturesIndices {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    nonSignerQuorumBitmapIndices: tuple.0,
                    quorumApkIndices: tuple.1,
                    totalStakeIndices: tuple.2,
                    nonSignerStakeIndices: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for CheckSignaturesIndices {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for CheckSignaturesIndices {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::tokenize(&self.nonSignerQuorumBitmapIndices), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::tokenize(&self.quorumApkIndices), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::tokenize(&self.totalStakeIndices), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>> as alloy_sol_types::SolType>::tokenize(&self.nonSignerStakeIndices),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for CheckSignaturesIndices {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for CheckSignaturesIndices {
            const NAME: &'static str = "CheckSignaturesIndices";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("CheckSignaturesIndices(uint32[] nonSignerQuorumBitmapIndices,uint32[] quorumApkIndices,uint32[] totalStakeIndices,uint32[][] nonSignerStakeIndices)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::eip712_data_word(&self.nonSignerQuorumBitmapIndices).0, <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::eip712_data_word(&self.quorumApkIndices).0, <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::eip712_data_word(&self.totalStakeIndices).0, <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>> as alloy_sol_types::SolType>::eip712_data_word(&self.nonSignerStakeIndices).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for CheckSignaturesIndices {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonSignerQuorumBitmapIndices) + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.quorumApkIndices) + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.totalStakeIndices) + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonSignerStakeIndices)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.nonSignerQuorumBitmapIndices, out);
                <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.quorumApkIndices, out);
                <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.totalStakeIndices, out);
                <::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonSignerStakeIndices,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct G1Point { uint256 X; uint256 Y; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct G1Point {
        pub X: ::alloy_sol_types::private::U256,
        pub Y: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::U256,
            ::alloy_sol_types::private::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<G1Point> for UnderlyingRustTuple<'_> {
            fn from(value: G1Point) -> Self {
                (value.X, value.Y)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for G1Point {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    X: tuple.0,
                    Y: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for G1Point {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for G1Point {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.X,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.Y,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for G1Point {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for G1Point {
            const NAME: &'static str = "G1Point";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("G1Point(uint256 X,uint256 Y)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::eip712_data_word(&self.X).0, <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::eip712_data_word(&self.Y).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for G1Point {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.X) + <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.Y)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.X, out);
                <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.Y, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct G2Point { uint256[2] X; uint256[2] Y; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct G2Point {
        pub X: [::alloy_sol_types::private::U256; 2usize],
        pub Y: [::alloy_sol_types::private::U256; 2usize],
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::FixedArray<::alloy_sol_types::sol_data::Uint<256>, 2usize>,
            ::alloy_sol_types::sol_data::FixedArray<::alloy_sol_types::sol_data::Uint<256>, 2usize>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [::alloy_sol_types::private::U256; 2usize],
            [::alloy_sol_types::private::U256; 2usize],
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<G2Point> for UnderlyingRustTuple<'_> {
            fn from(value: G2Point) -> Self {
                (value.X, value.Y)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for G2Point {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    X: tuple.0,
                    Y: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for G2Point {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for G2Point {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.X),
                    <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.Y),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for G2Point {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for G2Point {
            const NAME: &'static str = "G2Point";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("G2Point(uint256[2] X,uint256[2] Y)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.X)
                    .0,
                    <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.Y)
                    .0,
                ]
                .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for G2Point {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.X
                    )
                    + <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.Y
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::FixedArray<
                    ::alloy_sol_types::sol_data::Uint<256>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.X, out
                );
                <::alloy_sol_types::sol_data::FixedArray<
                    ::alloy_sol_types::sol_data::Uint<256>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.Y, out
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct NonSignerStakesAndSignature { uint32[] nonSignerQuorumBitmapIndices; G1Point[] nonSignerPubkeys; G1Point[] quorumApks; G2Point apkG2; G1Point sigma; uint32[] quorumApkIndices; uint32[] totalStakeIndices; uint32[][] nonSignerStakeIndices; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct NonSignerStakesAndSignature {
        pub nonSignerQuorumBitmapIndices: ::alloy_sol_types::private::Vec<u32>,
        pub nonSignerPubkeys:
            ::alloy_sol_types::private::Vec<<G1Point as ::alloy_sol_types::SolType>::RustType>,
        pub quorumApks:
            ::alloy_sol_types::private::Vec<<G1Point as ::alloy_sol_types::SolType>::RustType>,
        pub apkG2: <G2Point as ::alloy_sol_types::SolType>::RustType,
        pub sigma: <G1Point as ::alloy_sol_types::SolType>::RustType,
        pub quorumApkIndices: ::alloy_sol_types::private::Vec<u32>,
        pub totalStakeIndices: ::alloy_sol_types::private::Vec<u32>,
        pub nonSignerStakeIndices:
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Vec<u32>>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
            ::alloy_sol_types::sol_data::Array<G1Point>,
            ::alloy_sol_types::sol_data::Array<G1Point>,
            G2Point,
            G1Point,
            ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
            ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
            ::alloy_sol_types::sol_data::Array<
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
            >,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Vec<u32>,
            ::alloy_sol_types::private::Vec<<G1Point as ::alloy_sol_types::SolType>::RustType>,
            ::alloy_sol_types::private::Vec<<G1Point as ::alloy_sol_types::SolType>::RustType>,
            <G2Point as ::alloy_sol_types::SolType>::RustType,
            <G1Point as ::alloy_sol_types::SolType>::RustType,
            ::alloy_sol_types::private::Vec<u32>,
            ::alloy_sol_types::private::Vec<u32>,
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Vec<u32>>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NonSignerStakesAndSignature> for UnderlyingRustTuple<'_> {
            fn from(value: NonSignerStakesAndSignature) -> Self {
                (
                    value.nonSignerQuorumBitmapIndices,
                    value.nonSignerPubkeys,
                    value.quorumApks,
                    value.apkG2,
                    value.sigma,
                    value.quorumApkIndices,
                    value.totalStakeIndices,
                    value.nonSignerStakeIndices,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NonSignerStakesAndSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    nonSignerQuorumBitmapIndices: tuple.0,
                    nonSignerPubkeys: tuple.1,
                    quorumApks: tuple.2,
                    apkG2: tuple.3,
                    sigma: tuple.4,
                    quorumApkIndices: tuple.5,
                    totalStakeIndices: tuple.6,
                    nonSignerStakeIndices: tuple.7,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for NonSignerStakesAndSignature {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for NonSignerStakesAndSignature {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::tokenize(&self.nonSignerQuorumBitmapIndices), <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::SolType>::tokenize(&self.nonSignerPubkeys), <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::SolType>::tokenize(&self.quorumApks), <G2Point as alloy_sol_types::SolType>::tokenize(&self.apkG2), <G1Point as alloy_sol_types::SolType>::tokenize(&self.sigma), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::tokenize(&self.quorumApkIndices), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::tokenize(&self.totalStakeIndices), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>> as alloy_sol_types::SolType>::tokenize(&self.nonSignerStakeIndices),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for NonSignerStakesAndSignature {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for NonSignerStakesAndSignature {
            const NAME: &'static str = "NonSignerStakesAndSignature";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("NonSignerStakesAndSignature(uint32[] nonSignerQuorumBitmapIndices,G1Point[] nonSignerPubkeys,G1Point[] quorumApks,G2Point apkG2,G1Point sigma,uint32[] quorumApkIndices,uint32[] totalStakeIndices,uint32[][] nonSignerStakeIndices)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                let mut components = alloy_sol_types::private::Vec::with_capacity(4);
                components.push(<G1Point as alloy_sol_types::SolStruct>::eip712_root_type());
                components.extend(<G1Point as alloy_sol_types::SolStruct>::eip712_components());
                components.push(<G1Point as alloy_sol_types::SolStruct>::eip712_root_type());
                components.extend(<G1Point as alloy_sol_types::SolStruct>::eip712_components());
                components.push(<G2Point as alloy_sol_types::SolStruct>::eip712_root_type());
                components.extend(<G2Point as alloy_sol_types::SolStruct>::eip712_components());
                components.push(<G1Point as alloy_sol_types::SolStruct>::eip712_root_type());
                components.extend(<G1Point as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::eip712_data_word(&self.nonSignerQuorumBitmapIndices).0, <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::SolType>::eip712_data_word(&self.nonSignerPubkeys).0, <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::SolType>::eip712_data_word(&self.quorumApks).0, <G2Point as alloy_sol_types::SolType>::eip712_data_word(&self.apkG2).0, <G1Point as alloy_sol_types::SolType>::eip712_data_word(&self.sigma).0, <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::eip712_data_word(&self.quorumApkIndices).0, <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::SolType>::eip712_data_word(&self.totalStakeIndices).0, <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>> as alloy_sol_types::SolType>::eip712_data_word(&self.nonSignerStakeIndices).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for NonSignerStakesAndSignature {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonSignerQuorumBitmapIndices) + <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonSignerPubkeys) + <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.quorumApks) + <G2Point as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.apkG2) + <G1Point as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.sigma) + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.quorumApkIndices) + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.totalStakeIndices) + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nonSignerStakeIndices)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.nonSignerQuorumBitmapIndices, out);
                <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.nonSignerPubkeys, out);
                <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.quorumApks, out);
                <G2Point as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.apkG2, out);
                <G1Point as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.sigma, out);
                <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.quorumApkIndices, out);
                <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.totalStakeIndices, out);
                <::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.nonSignerStakeIndices,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct Operator { address operator; bytes32 operatorId; uint96 stake; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Operator {
        pub operator: ::alloy_sol_types::private::Address,
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        pub stake: <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Address,
            ::alloy_sol_types::sol_data::FixedBytes<32>,
            ::alloy_sol_types::sol_data::Uint<96>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Address,
            ::alloy_sol_types::private::FixedBytes<32>,
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Operator> for UnderlyingRustTuple<'_> {
            fn from(value: Operator) -> Self {
                (value.operator, value.operatorId, value.stake)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Operator {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    operatorId: tuple.1,
                    stake: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Operator {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Operator {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.operator), <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.operatorId), <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::SolType>::tokenize(&self.stake),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Operator {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Operator {
            const NAME: &'static str = "Operator";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Operator(address operator,bytes32 operatorId,uint96 stake)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(&self.operator).0, <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::eip712_data_word(&self.operatorId).0, <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::SolType>::eip712_data_word(&self.stake).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Operator {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.operator) + <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.operatorId) + <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.stake)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.operator, out);
                <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.operatorId, out);
                <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.stake, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct QuorumStakeTotals { uint96[] signedStakeForQuorum; uint96[] totalStakeForQuorum; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct QuorumStakeTotals {
        pub signedStakeForQuorum: ::alloy_sol_types::private::Vec<
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
        >,
        pub totalStakeForQuorum: ::alloy_sol_types::private::Vec<
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>>,
            ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Vec<
                <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
            >,
            ::alloy_sol_types::private::Vec<
                <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QuorumStakeTotals> for UnderlyingRustTuple<'_> {
            fn from(value: QuorumStakeTotals) -> Self {
                (value.signedStakeForQuorum, value.totalStakeForQuorum)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QuorumStakeTotals {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signedStakeForQuorum: tuple.0,
                    totalStakeForQuorum: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QuorumStakeTotals {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QuorumStakeTotals {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::SolType>::tokenize(&self.signedStakeForQuorum), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::SolType>::tokenize(&self.totalStakeForQuorum),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QuorumStakeTotals {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QuorumStakeTotals {
            const NAME: &'static str = "QuorumStakeTotals";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QuorumStakeTotals(uint96[] signedStakeForQuorum,uint96[] totalStakeForQuorum)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::SolType>::eip712_data_word(&self.signedStakeForQuorum).0, <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::SolType>::eip712_data_word(&self.totalStakeForQuorum).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QuorumStakeTotals {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.signedStakeForQuorum) + <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.totalStakeForQuorum)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.signedStakeForQuorum, out);
                <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.totalStakeForQuorum, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct Task { uint256 numberToBeSquared; uint32 taskCreatedBlock; bytes quorumNumbers; uint32 quorumThresholdPercentage; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Task {
        pub numberToBeSquared: ::alloy_sol_types::private::U256,
        pub taskCreatedBlock: u32,
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
        pub quorumThresholdPercentage: u32,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<32>,
            ::alloy_sol_types::sol_data::Bytes,
            ::alloy_sol_types::sol_data::Uint<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::U256,
            u32,
            ::alloy_sol_types::private::Bytes,
            u32,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Task> for UnderlyingRustTuple<'_> {
            fn from(value: Task) -> Self {
                (
                    value.numberToBeSquared,
                    value.taskCreatedBlock,
                    value.quorumNumbers,
                    value.quorumThresholdPercentage,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Task {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    numberToBeSquared: tuple.0,
                    taskCreatedBlock: tuple.1,
                    quorumNumbers: tuple.2,
                    quorumThresholdPercentage: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Task {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Task {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numberToBeSquared,
                    ),
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.taskCreatedBlock,
                    ),
                    <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.quorumThresholdPercentage,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Task {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Task {
            const NAME: &'static str = "Task";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("Task(uint256 numberToBeSquared,uint32 taskCreatedBlock,bytes quorumNumbers,uint32 quorumThresholdPercentage)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::eip712_data_word(&self.numberToBeSquared).0, <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::eip712_data_word(&self.taskCreatedBlock).0, <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(&self.quorumNumbers).0, <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::eip712_data_word(&self.quorumThresholdPercentage).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Task {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.numberToBeSquared) + <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.taskCreatedBlock) + <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.quorumNumbers) + <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.quorumThresholdPercentage)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.numberToBeSquared, out);
                <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.taskCreatedBlock, out);
                <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.quorumNumbers, out);
                <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.quorumThresholdPercentage, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct TaskResponse { uint32 referenceTaskIndex; uint256 numberSquared; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TaskResponse {
        pub referenceTaskIndex: u32,
        pub numberSquared: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<32>,
            ::alloy_sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u32, ::alloy_sol_types::private::U256);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TaskResponse> for UnderlyingRustTuple<'_> {
            fn from(value: TaskResponse) -> Self {
                (value.referenceTaskIndex, value.numberSquared)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TaskResponse {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    referenceTaskIndex: tuple.0,
                    numberSquared: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for TaskResponse {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for TaskResponse {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.referenceTaskIndex,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numberSquared,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for TaskResponse {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for TaskResponse {
            const NAME: &'static str = "TaskResponse";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "TaskResponse(uint32 referenceTaskIndex,uint256 numberSquared)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::eip712_data_word(&self.referenceTaskIndex).0, <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::eip712_data_word(&self.numberSquared).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for TaskResponse {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.referenceTaskIndex) + <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.numberSquared)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.referenceTaskIndex, out);
                <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.numberSquared, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "```solidity\nstruct TaskResponseMetadata { uint32 taskResponsedBlock; bytes32 hashOfNonSigners; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TaskResponseMetadata {
        pub taskResponsedBlock: u32,
        pub hashOfNonSigners: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<32>,
            ::alloy_sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u32, ::alloy_sol_types::private::FixedBytes<32>);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TaskResponseMetadata> for UnderlyingRustTuple<'_> {
            fn from(value: TaskResponseMetadata) -> Self {
                (value.taskResponsedBlock, value.hashOfNonSigners)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TaskResponseMetadata {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    taskResponsedBlock: tuple.0,
                    hashOfNonSigners: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for TaskResponseMetadata {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for TaskResponseMetadata {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(&self.taskResponsedBlock), <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.hashOfNonSigners),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for TaskResponseMetadata {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for TaskResponseMetadata {
            const NAME: &'static str = "TaskResponseMetadata";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "TaskResponseMetadata(uint32 taskResponsedBlock,bytes32 hashOfNonSigners)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::eip712_data_word(&self.taskResponsedBlock).0, <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::eip712_data_word(&self.hashOfNonSigners).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for TaskResponseMetadata {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.taskResponsedBlock) + <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.hashOfNonSigners)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.taskResponsedBlock, out);
                <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.hashOfNonSigners, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.\n```solidity\nevent Initialized(uint8 version);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    127u8, 38u8, 184u8, 63u8, 249u8, 110u8, 31u8, 43u8, 106u8, 104u8, 47u8, 19u8,
                    56u8, 82u8, 246u8, 121u8, 138u8, 9u8, 196u8, 101u8, 218u8, 149u8, 146u8, 20u8,
                    96u8, 206u8, 251u8, 56u8, 71u8, 64u8, 36u8, 152u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self.version,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `NewTaskCreated(uint32,(uint256,uint32,bytes,uint32))` and selector `0x1695b8d06ec800b4615e745cfb5bd00c1f2875615d42925c3b5afa543bb24c48`.\n```solidity\nevent NewTaskCreated(uint32 indexed taskIndex, Task task);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct NewTaskCreated {
        #[allow(missing_docs)]
        pub taskIndex: u32,
        #[allow(missing_docs)]
        pub task: <Task as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for NewTaskCreated {
            type DataTuple<'a> = (Task,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            const SIGNATURE: &'static str = "NewTaskCreated(uint32,(uint256,uint32,bytes,uint32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    22u8, 149u8, 184u8, 208u8, 110u8, 200u8, 0u8, 180u8, 97u8, 94u8, 116u8, 92u8,
                    251u8, 91u8, 208u8, 12u8, 31u8, 40u8, 117u8, 97u8, 93u8, 66u8, 146u8, 92u8,
                    59u8, 90u8, 250u8, 84u8, 59u8, 178u8, 76u8, 72u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    taskIndex: topics.1,
                    task: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<Task as alloy_sol_types::SolType>::tokenize(&self.task),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.taskIndex.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic(&self.taskIndex);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for NewTaskCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&NewTaskCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &NewTaskCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.\n```solidity\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8, 31u8,
                    208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8, 218u8,
                    175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.previousOwner);
                out[2usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.newOwner);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `Paused(address,uint256)` and selector `0xab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d`.\n```solidity\nevent Paused(address indexed account, uint256 newPausedStatus);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newPausedStatus: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Paused(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    171u8, 64u8, 163u8, 116u8, 188u8, 81u8, 222u8, 55u8, 34u8, 0u8, 168u8, 188u8,
                    152u8, 26u8, 248u8, 201u8, 236u8, 220u8, 8u8, 223u8, 218u8, 239u8, 11u8, 182u8,
                    224u8, 159u8, 136u8, 243u8, 198u8, 22u8, 239u8, 61u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    newPausedStatus: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newPausedStatus,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.account);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `PauserRegistrySet(address,address)` and selector `0x6e9fcd539896fca60e8b0f01dd580233e48a6b0f7df013b89ba7f565869acdb6`.\n```solidity\nevent PauserRegistrySet(address pauserRegistry, address newPauserRegistry);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct PauserRegistrySet {
        #[allow(missing_docs)]
        pub pauserRegistry: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newPauserRegistry: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PauserRegistrySet {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "PauserRegistrySet(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    110u8, 159u8, 205u8, 83u8, 152u8, 150u8, 252u8, 166u8, 14u8, 139u8, 15u8, 1u8,
                    221u8, 88u8, 2u8, 51u8, 228u8, 138u8, 107u8, 15u8, 125u8, 240u8, 19u8, 184u8,
                    155u8, 167u8, 245u8, 101u8, 134u8, 154u8, 205u8, 182u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    pauserRegistry: data.0,
                    newPauserRegistry: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauserRegistry,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newPauserRegistry,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PauserRegistrySet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PauserRegistrySet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PauserRegistrySet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `StaleStakesForbiddenUpdate(bool)` and selector `0x40e4ed880a29e0f6ddce307457fb75cddf4feef7d3ecb0301bfdf4976a0e2dfc`.\n```solidity\nevent StaleStakesForbiddenUpdate(bool value);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct StaleStakesForbiddenUpdate {
        #[allow(missing_docs)]
        pub value: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for StaleStakesForbiddenUpdate {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "StaleStakesForbiddenUpdate(bool)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    64u8, 228u8, 237u8, 136u8, 10u8, 41u8, 224u8, 246u8, 221u8, 206u8, 48u8, 116u8,
                    87u8, 251u8, 117u8, 205u8, 223u8, 79u8, 238u8, 247u8, 211u8, 236u8, 176u8,
                    48u8, 27u8, 253u8, 244u8, 151u8, 106u8, 14u8, 45u8, 252u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { value: data.0 }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for StaleStakesForbiddenUpdate {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&StaleStakesForbiddenUpdate> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &StaleStakesForbiddenUpdate) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `TaskChallengedSuccessfully(uint32,address)` and selector `0xc20d1bb0f1623680306b83d4ff4bb99a2beb9d86d97832f3ca40fd13a29df1ec`.\n```solidity\nevent TaskChallengedSuccessfully(uint32 indexed taskIndex, address indexed challenger);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct TaskChallengedSuccessfully {
        #[allow(missing_docs)]
        pub taskIndex: u32,
        #[allow(missing_docs)]
        pub challenger: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TaskChallengedSuccessfully {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TaskChallengedSuccessfully(uint32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    194u8, 13u8, 27u8, 176u8, 241u8, 98u8, 54u8, 128u8, 48u8, 107u8, 131u8, 212u8,
                    255u8, 75u8, 185u8, 154u8, 43u8, 235u8, 157u8, 134u8, 217u8, 120u8, 50u8,
                    243u8, 202u8, 64u8, 253u8, 19u8, 162u8, 157u8, 241u8, 236u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    taskIndex: topics.1,
                    challenger: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.taskIndex.clone(),
                    self.challenger.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic(&self.taskIndex);
                out[2usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.challenger);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TaskChallengedSuccessfully {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TaskChallengedSuccessfully> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TaskChallengedSuccessfully) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `TaskChallengedUnsuccessfully(uint32,address)` and selector `0xfd3e26beeb5967fc5a57a0446914eabc45b4aa474c67a51b4b5160cac60ddb05`.\n```solidity\nevent TaskChallengedUnsuccessfully(uint32 indexed taskIndex, address indexed challenger);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct TaskChallengedUnsuccessfully {
        #[allow(missing_docs)]
        pub taskIndex: u32,
        #[allow(missing_docs)]
        pub challenger: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TaskChallengedUnsuccessfully {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "TaskChallengedUnsuccessfully(uint32,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    253u8, 62u8, 38u8, 190u8, 235u8, 89u8, 103u8, 252u8, 90u8, 87u8, 160u8, 68u8,
                    105u8, 20u8, 234u8, 188u8, 69u8, 180u8, 170u8, 71u8, 76u8, 103u8, 165u8, 27u8,
                    75u8, 81u8, 96u8, 202u8, 198u8, 13u8, 219u8, 5u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    taskIndex: topics.1,
                    challenger: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.taskIndex.clone(),
                    self.challenger.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic(&self.taskIndex);
                out[2usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.challenger);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TaskChallengedUnsuccessfully {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TaskChallengedUnsuccessfully> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TaskChallengedUnsuccessfully) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `TaskCompleted(uint32)` and selector `0x9a144f228a931b9d0d1696fbcdaf310b24b5d2d21e799db623fc986a0f547430`.\n```solidity\nevent TaskCompleted(uint32 indexed taskIndex);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct TaskCompleted {
        #[allow(missing_docs)]
        pub taskIndex: u32,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TaskCompleted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            const SIGNATURE: &'static str = "TaskCompleted(uint32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    154u8, 20u8, 79u8, 34u8, 138u8, 147u8, 27u8, 157u8, 13u8, 22u8, 150u8, 251u8,
                    205u8, 175u8, 49u8, 11u8, 36u8, 181u8, 210u8, 210u8, 30u8, 121u8, 157u8, 182u8,
                    35u8, 252u8, 152u8, 106u8, 15u8, 84u8, 116u8, 48u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    taskIndex: topics.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.taskIndex.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic(&self.taskIndex);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TaskCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TaskCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TaskCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `TaskResponded((uint32,uint256),(uint32,bytes32))` and selector `0x349c1ee60e4e8972ee9dba642c1774543d5c4136879b7f4caaf04bf81a487a2a`.\n```solidity\nevent TaskResponded(TaskResponse taskResponse, TaskResponseMetadata taskResponseMetadata);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct TaskResponded {
        #[allow(missing_docs)]
        pub taskResponse: <TaskResponse as ::alloy_sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub taskResponseMetadata: <TaskResponseMetadata as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TaskResponded {
            type DataTuple<'a> = (TaskResponse, TaskResponseMetadata);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TaskResponded((uint32,uint256),(uint32,bytes32))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    52u8, 156u8, 30u8, 230u8, 14u8, 78u8, 137u8, 114u8, 238u8, 157u8, 186u8, 100u8,
                    44u8, 23u8, 116u8, 84u8, 61u8, 92u8, 65u8, 54u8, 135u8, 155u8, 127u8, 76u8,
                    170u8, 240u8, 75u8, 248u8, 26u8, 72u8, 122u8, 42u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    taskResponse: data.0,
                    taskResponseMetadata: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <TaskResponse as alloy_sol_types::SolType>::tokenize(&self.taskResponse),
                    <TaskResponseMetadata as alloy_sol_types::SolType>::tokenize(
                        &self.taskResponseMetadata,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TaskResponded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TaskResponded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TaskResponded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Event with signature `Unpaused(address,uint256)` and selector `0x3582d1828e26bf56bd801502bc021ac0bc8afb57c826e4986b45593c8fad389c`.\n```solidity\nevent Unpaused(address indexed account, uint256 newPausedStatus);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newPausedStatus: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Unpaused(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    53u8, 130u8, 209u8, 130u8, 142u8, 38u8, 191u8, 86u8, 189u8, 128u8, 21u8, 2u8,
                    188u8, 2u8, 26u8, 192u8, 188u8, 138u8, 251u8, 87u8, 200u8, 38u8, 228u8, 152u8,
                    107u8, 69u8, 89u8, 60u8, 143u8, 173u8, 56u8, 156u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    newPausedStatus: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newPausedStatus,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.account);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Constructor`.\n```solidity\nconstructor(address _registryCoordinator, uint32 _taskResponseWindowBlock);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub _registryCoordinator: ::alloy_sol_types::private::Address,
        pub _taskResponseWindowBlock: u32,
    }
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._registryCoordinator, value._taskResponseWindowBlock)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _registryCoordinator: tuple.0,
                        _taskResponseWindowBlock: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._registryCoordinator,
                    ),
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self._taskResponseWindowBlock,
                    ),
                )
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `TASK_CHALLENGE_WINDOW_BLOCK()` and selector `0xf63c5bab`.\n```solidity\nfunction TASK_CHALLENGE_WINDOW_BLOCK() external view returns (uint32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TASK_CHALLENGE_WINDOW_BLOCKCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`TASK_CHALLENGE_WINDOW_BLOCK()`](TASK_CHALLENGE_WINDOW_BLOCKCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TASK_CHALLENGE_WINDOW_BLOCKReturn {
        pub _0: u32,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TASK_CHALLENGE_WINDOW_BLOCKCall> for UnderlyingRustTuple<'_> {
                fn from(value: TASK_CHALLENGE_WINDOW_BLOCKCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TASK_CHALLENGE_WINDOW_BLOCKCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TASK_CHALLENGE_WINDOW_BLOCKReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TASK_CHALLENGE_WINDOW_BLOCKReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TASK_CHALLENGE_WINDOW_BLOCKReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TASK_CHALLENGE_WINDOW_BLOCKCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = TASK_CHALLENGE_WINDOW_BLOCKReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TASK_CHALLENGE_WINDOW_BLOCK()";
            const SELECTOR: [u8; 4] = [246u8, 60u8, 91u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `TASK_RESPONSE_WINDOW_BLOCK()` and selector `0x1ad43189`.\n```solidity\nfunction TASK_RESPONSE_WINDOW_BLOCK() external view returns (uint32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TASK_RESPONSE_WINDOW_BLOCKCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`TASK_RESPONSE_WINDOW_BLOCK()`](TASK_RESPONSE_WINDOW_BLOCKCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct TASK_RESPONSE_WINDOW_BLOCKReturn {
        pub _0: u32,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TASK_RESPONSE_WINDOW_BLOCKCall> for UnderlyingRustTuple<'_> {
                fn from(value: TASK_RESPONSE_WINDOW_BLOCKCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TASK_RESPONSE_WINDOW_BLOCKCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<TASK_RESPONSE_WINDOW_BLOCKReturn> for UnderlyingRustTuple<'_> {
                fn from(value: TASK_RESPONSE_WINDOW_BLOCKReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for TASK_RESPONSE_WINDOW_BLOCKReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for TASK_RESPONSE_WINDOW_BLOCKCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = TASK_RESPONSE_WINDOW_BLOCKReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TASK_RESPONSE_WINDOW_BLOCK()";
            const SELECTOR: [u8; 4] = [26u8, 212u8, 49u8, 137u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `aggregator()` and selector `0x245a7bfc`.\n```solidity\nfunction aggregator() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct aggregatorCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`aggregator()`](aggregatorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct aggregatorReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<aggregatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: aggregatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for aggregatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<aggregatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: aggregatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for aggregatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for aggregatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = aggregatorReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "aggregator()";
            const SELECTOR: [u8; 4] = [36u8, 90u8, 123u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `allTaskHashes(uint32)` and selector `0x2d89f6fc`.\n```solidity\nfunction allTaskHashes(uint32) external view returns (bytes32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct allTaskHashesCall {
        pub _0: u32,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`allTaskHashes(uint32)`](allTaskHashesCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct allTaskHashesReturn {
        pub _0: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allTaskHashesCall> for UnderlyingRustTuple<'_> {
                fn from(value: allTaskHashesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allTaskHashesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allTaskHashesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allTaskHashesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allTaskHashesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allTaskHashesCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = allTaskHashesReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allTaskHashes(uint32)";
            const SELECTOR: [u8; 4] = [45u8, 137u8, 246u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `allTaskResponses(uint32)` and selector `0x2cb223d5`.\n```solidity\nfunction allTaskResponses(uint32) external view returns (bytes32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct allTaskResponsesCall {
        pub _0: u32,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`allTaskResponses(uint32)`](allTaskResponsesCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct allTaskResponsesReturn {
        pub _0: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allTaskResponsesCall> for UnderlyingRustTuple<'_> {
                fn from(value: allTaskResponsesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allTaskResponsesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<allTaskResponsesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: allTaskResponsesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for allTaskResponsesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for allTaskResponsesCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = allTaskResponsesReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "allTaskResponses(uint32)";
            const SELECTOR: [u8; 4] = [44u8, 178u8, 35u8, 213u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `blsApkRegistry()` and selector `0x5df45946`.\n```solidity\nfunction blsApkRegistry() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct blsApkRegistryCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`blsApkRegistry()`](blsApkRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct blsApkRegistryReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blsApkRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: blsApkRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for blsApkRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blsApkRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: blsApkRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for blsApkRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blsApkRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = blsApkRegistryReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blsApkRegistry()";
            const SELECTOR: [u8; 4] = [93u8, 244u8, 89u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `checkSignatures(bytes32,bytes,uint32,(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]))` and selector `0x6efb4636`.\n```solidity\nfunction checkSignatures(bytes32 msgHash, bytes memory quorumNumbers, uint32 referenceBlockNumber, NonSignerStakesAndSignature memory params) external view returns (QuorumStakeTotals memory, bytes32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct checkSignaturesCall {
        pub msgHash: ::alloy_sol_types::private::FixedBytes<32>,
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
        pub referenceBlockNumber: u32,
        pub params: <NonSignerStakesAndSignature as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`checkSignatures(bytes32,bytes,uint32,(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]))`](checkSignaturesCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct checkSignaturesReturn {
        pub _0: <QuorumStakeTotals as ::alloy_sol_types::SolType>::RustType,
        pub _1: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::Uint<32>,
                NonSignerStakesAndSignature,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::FixedBytes<32>,
                ::alloy_sol_types::private::Bytes,
                u32,
                <NonSignerStakesAndSignature as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkSignaturesCall> for UnderlyingRustTuple<'_> {
                fn from(value: checkSignaturesCall) -> Self {
                    (
                        value.msgHash,
                        value.quorumNumbers,
                        value.referenceBlockNumber,
                        value.params,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkSignaturesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        msgHash: tuple.0,
                        quorumNumbers: tuple.1,
                        referenceBlockNumber: tuple.2,
                        params: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                QuorumStakeTotals,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <QuorumStakeTotals as ::alloy_sol_types::SolType>::RustType,
                ::alloy_sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<checkSignaturesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: checkSignaturesReturn) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for checkSignaturesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for checkSignaturesCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::Uint<32>,
                NonSignerStakesAndSignature,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = checkSignaturesReturn;
            type ReturnTuple<'a> = (
                QuorumStakeTotals,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "checkSignatures(bytes32,bytes,uint32,(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]))";
            const SELECTOR: [u8; 4] = [110u8, 251u8, 70u8, 54u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.msgHash), <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(&self.quorumNumbers), <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(&self.referenceBlockNumber), <NonSignerStakesAndSignature as alloy_sol_types::SolType>::tokenize(&self.params),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `createNewTask(uint256,uint32,bytes)` and selector `0x6b92787e`.\n```solidity\nfunction createNewTask(uint256 numberToBeSquared, uint32 quorumThresholdPercentage, bytes memory quorumNumbers) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct createNewTaskCall {
        pub numberToBeSquared: ::alloy_sol_types::private::U256,
        pub quorumThresholdPercentage: u32,
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`createNewTask(uint256,uint32,bytes)`](createNewTaskCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct createNewTaskReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::U256,
                u32,
                ::alloy_sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createNewTaskCall> for UnderlyingRustTuple<'_> {
                fn from(value: createNewTaskCall) -> Self {
                    (
                        value.numberToBeSquared,
                        value.quorumThresholdPercentage,
                        value.quorumNumbers,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createNewTaskCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        numberToBeSquared: tuple.0,
                        quorumThresholdPercentage: tuple.1,
                        quorumNumbers: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createNewTaskReturn> for UnderlyingRustTuple<'_> {
                fn from(value: createNewTaskReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createNewTaskReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createNewTaskCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = createNewTaskReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createNewTask(uint256,uint32,bytes)";
            const SELECTOR: [u8; 4] = [107u8, 146u8, 120u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.numberToBeSquared,
                    ),
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.quorumThresholdPercentage,
                    ),
                    <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `delegation()` and selector `0xdf5cf723`.\n```solidity\nfunction delegation() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct delegationCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`delegation()`](delegationCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct delegationReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegationCall> for UnderlyingRustTuple<'_> {
                fn from(value: delegationCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<delegationReturn> for UnderlyingRustTuple<'_> {
                fn from(value: delegationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for delegationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for delegationCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = delegationReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "delegation()";
            const SELECTOR: [u8; 4] = [223u8, 92u8, 247u8, 35u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `generator()` and selector `0x7afa1eed`.\n```solidity\nfunction generator() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct generatorCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`generator()`](generatorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct generatorReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<generatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: generatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for generatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<generatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: generatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for generatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for generatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = generatorReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "generator()";
            const SELECTOR: [u8; 4] = [122u8, 250u8, 30u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `getCheckSignaturesIndices(address,uint32,bytes,bytes32[])` and selector `0x4f739f74`.\n```solidity\nfunction getCheckSignaturesIndices(address registryCoordinator, uint32 referenceBlockNumber, bytes memory quorumNumbers, bytes32[] memory nonSignerOperatorIds) external view returns (CheckSignaturesIndices memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getCheckSignaturesIndicesCall {
        pub registryCoordinator: ::alloy_sol_types::private::Address,
        pub referenceBlockNumber: u32,
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
        pub nonSignerOperatorIds:
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::FixedBytes<32>>,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`getCheckSignaturesIndices(address,uint32,bytes,bytes32[])`](getCheckSignaturesIndicesCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getCheckSignaturesIndicesReturn {
        pub _0: <CheckSignaturesIndices as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                u32,
                ::alloy_sol_types::private::Bytes,
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCheckSignaturesIndicesCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCheckSignaturesIndicesCall) -> Self {
                    (
                        value.registryCoordinator,
                        value.referenceBlockNumber,
                        value.quorumNumbers,
                        value.nonSignerOperatorIds,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCheckSignaturesIndicesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registryCoordinator: tuple.0,
                        referenceBlockNumber: tuple.1,
                        quorumNumbers: tuple.2,
                        nonSignerOperatorIds: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (CheckSignaturesIndices,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<CheckSignaturesIndices as ::alloy_sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCheckSignaturesIndicesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getCheckSignaturesIndicesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCheckSignaturesIndicesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCheckSignaturesIndicesCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCheckSignaturesIndicesReturn;
            type ReturnTuple<'a> = (CheckSignaturesIndices,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "getCheckSignaturesIndices(address,uint32,bytes,bytes32[])";
            const SELECTOR: [u8; 4] = [79u8, 115u8, 159u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.registryCoordinator), <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(&self.referenceBlockNumber), <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(&self.quorumNumbers), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>> as alloy_sol_types::SolType>::tokenize(&self.nonSignerOperatorIds),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `getOperatorState(address,bytes,uint32)` and selector `0x3563b0d1`.\n```solidity\nfunction getOperatorState(address registryCoordinator, bytes memory quorumNumbers, uint32 blockNumber) external view returns (Operator[][] memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorState_0Call {
        pub registryCoordinator: ::alloy_sol_types::private::Address,
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
        pub blockNumber: u32,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`getOperatorState(address,bytes,uint32)`](getOperatorState_0Call) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorState_0Return {
        pub _0: ::alloy_sol_types::private::Vec<
            ::alloy_sol_types::private::Vec<<Operator as ::alloy_sol_types::SolType>::RustType>,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Bytes,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorState_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorState_0Call) -> Self {
                    (
                        value.registryCoordinator,
                        value.quorumNumbers,
                        value.blockNumber,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorState_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registryCoordinator: tuple.0,
                        quorumNumbers: tuple.1,
                        blockNumber: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<Operator>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Vec<
                    ::alloy_sol_types::private::Vec<
                        <Operator as ::alloy_sol_types::SolType>::RustType,
                    >,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorState_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorState_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorState_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorState_0Call {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorState_0Return;
            type ReturnTuple<'a> = (
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<Operator>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorState(address,bytes,uint32)";
            const SELECTOR: [u8; 4] = [53u8, 99u8, 176u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.registryCoordinator,
                    ),
                    <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.blockNumber,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `getOperatorState(address,bytes32,uint32)` and selector `0xcefdc1d4`.\n```solidity\nfunction getOperatorState(address registryCoordinator, bytes32 operatorId, uint32 blockNumber) external view returns (uint256, Operator[][] memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorState_1Call {
        pub registryCoordinator: ::alloy_sol_types::private::Address,
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        pub blockNumber: u32,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`getOperatorState(address,bytes32,uint32)`](getOperatorState_1Call) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorState_1Return {
        pub _0: ::alloy_sol_types::private::U256,
        pub _1: ::alloy_sol_types::private::Vec<
            ::alloy_sol_types::private::Vec<<Operator as ::alloy_sol_types::SolType>::RustType>,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::FixedBytes<32>,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorState_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorState_1Call) -> Self {
                    (
                        value.registryCoordinator,
                        value.operatorId,
                        value.blockNumber,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorState_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registryCoordinator: tuple.0,
                        operatorId: tuple.1,
                        blockNumber: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<Operator>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::U256,
                ::alloy_sol_types::private::Vec<
                    ::alloy_sol_types::private::Vec<
                        <Operator as ::alloy_sol_types::SolType>::RustType,
                    >,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorState_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorState_1Return) -> Self {
                    (value._0, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorState_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorState_1Call {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorState_1Return;
            type ReturnTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<Operator>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorState(address,bytes32,uint32)";
            const SELECTOR: [u8; 4] = [206u8, 253u8, 193u8, 212u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.registryCoordinator), <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.operatorId), <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(&self.blockNumber),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `getQuorumBitmapsAtBlockNumber(address,bytes32[],uint32)` and selector `0x5c155662`.\n```solidity\nfunction getQuorumBitmapsAtBlockNumber(address registryCoordinator, bytes32[] memory operatorIds, uint32 blockNumber) external view returns (uint256[] memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapsAtBlockNumberCall {
        pub registryCoordinator: ::alloy_sol_types::private::Address,
        pub operatorIds:
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::FixedBytes<32>>,
        pub blockNumber: u32,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`getQuorumBitmapsAtBlockNumber(address,bytes32[],uint32)`](getQuorumBitmapsAtBlockNumberCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapsAtBlockNumberReturn {
        pub _0: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::U256>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>>,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::FixedBytes<32>>,
                u32,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapsAtBlockNumberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapsAtBlockNumberCall) -> Self {
                    (
                        value.registryCoordinator,
                        value.operatorIds,
                        value.blockNumber,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapsAtBlockNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registryCoordinator: tuple.0,
                        operatorIds: tuple.1,
                        blockNumber: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<256>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (::alloy_sol_types::private::Vec<::alloy_sol_types::private::U256>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapsAtBlockNumberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapsAtBlockNumberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapsAtBlockNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getQuorumBitmapsAtBlockNumberCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>>,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getQuorumBitmapsAtBlockNumberReturn;
            type ReturnTuple<'a> =
                (::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<256>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "getQuorumBitmapsAtBlockNumber(address,bytes32[],uint32)";
            const SELECTOR: [u8; 4] = [92u8, 21u8, 86u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.registryCoordinator), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>> as alloy_sol_types::SolType>::tokenize(&self.operatorIds), <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(&self.blockNumber),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `getTaskResponseWindowBlock()` and selector `0xf5c9899d`.\n```solidity\nfunction getTaskResponseWindowBlock() external view returns (uint32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getTaskResponseWindowBlockCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`getTaskResponseWindowBlock()`](getTaskResponseWindowBlockCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getTaskResponseWindowBlockReturn {
        pub _0: u32,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTaskResponseWindowBlockCall> for UnderlyingRustTuple<'_> {
                fn from(value: getTaskResponseWindowBlockCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTaskResponseWindowBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getTaskResponseWindowBlockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getTaskResponseWindowBlockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getTaskResponseWindowBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getTaskResponseWindowBlockCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getTaskResponseWindowBlockReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getTaskResponseWindowBlock()";
            const SELECTOR: [u8; 4] = [245u8, 201u8, 137u8, 157u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `initialize(address,address,address,address)` and selector `0xf8c8765e`.\n```solidity\nfunction initialize(address _pauserRegistry, address initialOwner, address _aggregator, address _generator) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeCall {
        pub _pauserRegistry: ::alloy_sol_types::private::Address,
        pub initialOwner: ::alloy_sol_types::private::Address,
        pub _aggregator: ::alloy_sol_types::private::Address,
        pub _generator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`initialize(address,address,address,address)`](initializeCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value._pauserRegistry,
                        value.initialOwner,
                        value._aggregator,
                        value._generator,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _pauserRegistry: tuple.0,
                        initialOwner: tuple.1,
                        _aggregator: tuple.2,
                        _generator: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,address,address,address)";
            const SELECTOR: [u8; 4] = [248u8, 200u8, 118u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._pauserRegistry,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.initialOwner,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._aggregator,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._generator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `latestTaskNum()` and selector `0x8b00ce7c`.\n```solidity\nfunction latestTaskNum() external view returns (uint32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct latestTaskNumCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`latestTaskNum()`](latestTaskNumCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct latestTaskNumReturn {
        pub _0: u32,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestTaskNumCall> for UnderlyingRustTuple<'_> {
                fn from(value: latestTaskNumCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for latestTaskNumCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<latestTaskNumReturn> for UnderlyingRustTuple<'_> {
                fn from(value: latestTaskNumReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for latestTaskNumReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for latestTaskNumCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = latestTaskNumReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "latestTaskNum()";
            const SELECTOR: [u8; 4] = [139u8, 0u8, 206u8, 124u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `owner()` and selector `0x8da5cb5b`.\n```solidity\nfunction owner() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`owner()`](ownerCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `pause(uint256)` and selector `0x136439dd`.\n```solidity\nfunction pause(uint256 newPausedStatus) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauseCall {
        pub newPausedStatus: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`pause(uint256)`](pauseCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    (value.newPausedStatus,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPausedStatus: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause(uint256)";
            const SELECTOR: [u8; 4] = [19u8, 100u8, 57u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newPausedStatus,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `pauseAll()` and selector `0x595c6a67`.\n```solidity\nfunction pauseAll() external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauseAllCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`pauseAll()`](pauseAllCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauseAllReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseAllCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseAllCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseAllCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseAllReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseAllReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseAllReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseAllCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseAllReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauseAll()";
            const SELECTOR: [u8; 4] = [89u8, 92u8, 106u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `paused(uint8)` and selector `0x5ac86ab7`.\n```solidity\nfunction paused(uint8 index) external view returns (bool);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct paused_0Call {
        pub index: u8,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`paused(uint8)`](paused_0Call) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct paused_0Return {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paused_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: paused_0Call) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paused_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paused_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: paused_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paused_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for paused_0Call {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = paused_0Return;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused(uint8)";
            const SELECTOR: [u8; 4] = [90u8, 200u8, 106u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self.index,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `paused()` and selector `0x5c975abb`.\n```solidity\nfunction paused() external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct paused_1Call {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`paused()`](paused_1Call) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct paused_1Return {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paused_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: paused_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paused_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paused_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: paused_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paused_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for paused_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = paused_1Return;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `pauserRegistry()` and selector `0x886f1195`.\n```solidity\nfunction pauserRegistry() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauserRegistryCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`pauserRegistry()`](pauserRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauserRegistryReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauserRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauserRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauserRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauserRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauserRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauserRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauserRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauserRegistryReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauserRegistry()";
            const SELECTOR: [u8; 4] = [136u8, 111u8, 17u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `raiseAndResolveChallenge((uint256,uint32,bytes,uint32),(uint32,uint256),(uint32,bytes32),(uint256,uint256)[])` and selector `0x6b532e9e`.\n```solidity\nfunction raiseAndResolveChallenge(Task memory task, TaskResponse memory taskResponse, TaskResponseMetadata memory taskResponseMetadata, G1Point[] memory pubkeysOfNonSigningOperators) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct raiseAndResolveChallengeCall {
        pub task: <Task as ::alloy_sol_types::SolType>::RustType,
        pub taskResponse: <TaskResponse as ::alloy_sol_types::SolType>::RustType,
        pub taskResponseMetadata: <TaskResponseMetadata as ::alloy_sol_types::SolType>::RustType,
        pub pubkeysOfNonSigningOperators:
            ::alloy_sol_types::private::Vec<<G1Point as ::alloy_sol_types::SolType>::RustType>,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`raiseAndResolveChallenge((uint256,uint32,bytes,uint32),(uint32,uint256),(uint32,bytes32),(uint256,uint256)[])`](raiseAndResolveChallengeCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct raiseAndResolveChallengeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                Task,
                TaskResponse,
                TaskResponseMetadata,
                ::alloy_sol_types::sol_data::Array<G1Point>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Task as ::alloy_sol_types::SolType>::RustType,
                <TaskResponse as ::alloy_sol_types::SolType>::RustType,
                <TaskResponseMetadata as ::alloy_sol_types::SolType>::RustType,
                ::alloy_sol_types::private::Vec<<G1Point as ::alloy_sol_types::SolType>::RustType>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<raiseAndResolveChallengeCall> for UnderlyingRustTuple<'_> {
                fn from(value: raiseAndResolveChallengeCall) -> Self {
                    (
                        value.task,
                        value.taskResponse,
                        value.taskResponseMetadata,
                        value.pubkeysOfNonSigningOperators,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for raiseAndResolveChallengeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        task: tuple.0,
                        taskResponse: tuple.1,
                        taskResponseMetadata: tuple.2,
                        pubkeysOfNonSigningOperators: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<raiseAndResolveChallengeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: raiseAndResolveChallengeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for raiseAndResolveChallengeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for raiseAndResolveChallengeCall {
            type Parameters<'a> = (
                Task,
                TaskResponse,
                TaskResponseMetadata,
                ::alloy_sol_types::sol_data::Array<G1Point>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = raiseAndResolveChallengeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "raiseAndResolveChallenge((uint256,uint32,bytes,uint32),(uint32,uint256),(uint32,bytes32),(uint256,uint256)[])";
            const SELECTOR: [u8; 4] = [107u8, 83u8, 46u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Task as alloy_sol_types::SolType>::tokenize(&self.task), <TaskResponse as alloy_sol_types::SolType>::tokenize(&self.taskResponse), <TaskResponseMetadata as alloy_sol_types::SolType>::tokenize(&self.taskResponseMetadata), <::alloy_sol_types::sol_data::Array<G1Point> as alloy_sol_types::SolType>::tokenize(&self.pubkeysOfNonSigningOperators),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `registryCoordinator()` and selector `0x6d14a987`.\n```solidity\nfunction registryCoordinator() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registryCoordinatorCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`registryCoordinator()`](registryCoordinatorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registryCoordinatorReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registryCoordinatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: registryCoordinatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registryCoordinatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registryCoordinatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: registryCoordinatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registryCoordinatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registryCoordinatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = registryCoordinatorReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registryCoordinator()";
            const SELECTOR: [u8; 4] = [109u8, 20u8, 169u8, 135u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `renounceOwnership()` and selector `0x715018a6`.\n```solidity\nfunction renounceOwnership() external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `respondToTask((uint256,uint32,bytes,uint32),(uint32,uint256),(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]))` and selector `0x5baec9a0`.\n```solidity\nfunction respondToTask(Task memory task, TaskResponse memory taskResponse, NonSignerStakesAndSignature memory nonSignerStakesAndSignature) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct respondToTaskCall {
        pub task: <Task as ::alloy_sol_types::SolType>::RustType,
        pub taskResponse: <TaskResponse as ::alloy_sol_types::SolType>::RustType,
        pub nonSignerStakesAndSignature:
            <NonSignerStakesAndSignature as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`respondToTask((uint256,uint32,bytes,uint32),(uint32,uint256),(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]))`](respondToTaskCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct respondToTaskReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Task, TaskResponse, NonSignerStakesAndSignature);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Task as ::alloy_sol_types::SolType>::RustType,
                <TaskResponse as ::alloy_sol_types::SolType>::RustType,
                <NonSignerStakesAndSignature as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<respondToTaskCall> for UnderlyingRustTuple<'_> {
                fn from(value: respondToTaskCall) -> Self {
                    (
                        value.task,
                        value.taskResponse,
                        value.nonSignerStakesAndSignature,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for respondToTaskCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        task: tuple.0,
                        taskResponse: tuple.1,
                        nonSignerStakesAndSignature: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<respondToTaskReturn> for UnderlyingRustTuple<'_> {
                fn from(value: respondToTaskReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for respondToTaskReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for respondToTaskCall {
            type Parameters<'a> = (Task, TaskResponse, NonSignerStakesAndSignature);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = respondToTaskReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "respondToTask((uint256,uint32,bytes,uint32),(uint32,uint256),(uint32[],(uint256,uint256)[],(uint256,uint256)[],(uint256[2],uint256[2]),(uint256,uint256),uint32[],uint32[],uint32[][]))";
            const SELECTOR: [u8; 4] = [91u8, 174u8, 201u8, 160u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Task as alloy_sol_types::SolType>::tokenize(&self.task),
                    <TaskResponse as alloy_sol_types::SolType>::tokenize(&self.taskResponse),
                    <NonSignerStakesAndSignature as alloy_sol_types::SolType>::tokenize(
                        &self.nonSignerStakesAndSignature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `setPauserRegistry(address)` and selector `0x10d67a2f`.\n```solidity\nfunction setPauserRegistry(address newPauserRegistry) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setPauserRegistryCall {
        pub newPauserRegistry: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`setPauserRegistry(address)`](setPauserRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setPauserRegistryReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPauserRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: setPauserRegistryCall) -> Self {
                    (value.newPauserRegistry,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setPauserRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPauserRegistry: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPauserRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setPauserRegistryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setPauserRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setPauserRegistryCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setPauserRegistryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setPauserRegistry(address)";
            const SELECTOR: [u8; 4] = [16u8, 214u8, 122u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newPauserRegistry,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `setStaleStakesForbidden(bool)` and selector `0x416c7e5e`.\n```solidity\nfunction setStaleStakesForbidden(bool value) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setStaleStakesForbiddenCall {
        pub value: bool,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`setStaleStakesForbidden(bool)`](setStaleStakesForbiddenCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setStaleStakesForbiddenReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setStaleStakesForbiddenCall> for UnderlyingRustTuple<'_> {
                fn from(value: setStaleStakesForbiddenCall) -> Self {
                    (value.value,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setStaleStakesForbiddenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { value: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setStaleStakesForbiddenReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setStaleStakesForbiddenReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setStaleStakesForbiddenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setStaleStakesForbiddenCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Bool,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setStaleStakesForbiddenReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setStaleStakesForbidden(bool)";
            const SELECTOR: [u8; 4] = [65u8, 108u8, 126u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.value,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `stakeRegistry()` and selector `0x68304835`.\n```solidity\nfunction stakeRegistry() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct stakeRegistryCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`stakeRegistry()`](stakeRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct stakeRegistryReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeRegistryReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeRegistry()";
            const SELECTOR: [u8; 4] = [104u8, 48u8, 72u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `staleStakesForbidden()` and selector `0xb98d0908`.\n```solidity\nfunction staleStakesForbidden() external view returns (bool);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct staleStakesForbiddenCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`staleStakesForbidden()`](staleStakesForbiddenCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct staleStakesForbiddenReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<staleStakesForbiddenCall> for UnderlyingRustTuple<'_> {
                fn from(value: staleStakesForbiddenCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for staleStakesForbiddenCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<staleStakesForbiddenReturn> for UnderlyingRustTuple<'_> {
                fn from(value: staleStakesForbiddenReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for staleStakesForbiddenReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for staleStakesForbiddenCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = staleStakesForbiddenReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "staleStakesForbidden()";
            const SELECTOR: [u8; 4] = [185u8, 141u8, 9u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `taskNumber()` and selector `0x72d18e8d`.\n```solidity\nfunction taskNumber() external view returns (uint32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct taskNumberCall {}
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`taskNumber()`](taskNumberCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct taskNumberReturn {
        pub _0: u32,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<taskNumberCall> for UnderlyingRustTuple<'_> {
                fn from(value: taskNumberCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for taskNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<taskNumberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: taskNumberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for taskNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for taskNumberCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = taskNumberReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "taskNumber()";
            const SELECTOR: [u8; 4] = [114u8, 209u8, 142u8, 141u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `taskSuccesfullyChallenged(uint32)` and selector `0x5decc3f5`.\n```solidity\nfunction taskSuccesfullyChallenged(uint32) external view returns (bool);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct taskSuccesfullyChallengedCall {
        pub _0: u32,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`taskSuccesfullyChallenged(uint32)`](taskSuccesfullyChallengedCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct taskSuccesfullyChallengedReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<taskSuccesfullyChallengedCall> for UnderlyingRustTuple<'_> {
                fn from(value: taskSuccesfullyChallengedCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for taskSuccesfullyChallengedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<taskSuccesfullyChallengedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: taskSuccesfullyChallengedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for taskSuccesfullyChallengedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for taskSuccesfullyChallengedCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = taskSuccesfullyChallengedReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "taskSuccesfullyChallenged(uint32)";
            const SELECTOR: [u8; 4] = [93u8, 236u8, 195u8, 245u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.\n```solidity\nfunction transferOwnership(address newOwner) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        pub newOwner: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `trySignatureAndApkVerification(bytes32,(uint256,uint256),(uint256[2],uint256[2]),(uint256,uint256))` and selector `0x171f1d5b`.\n```solidity\nfunction trySignatureAndApkVerification(bytes32 msgHash, G1Point memory apk, G2Point memory apkG2, G1Point memory sigma) external view returns (bool pairingSuccessful, bool siganatureIsValid);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct trySignatureAndApkVerificationCall {
        pub msgHash: ::alloy_sol_types::private::FixedBytes<32>,
        pub apk: <G1Point as ::alloy_sol_types::SolType>::RustType,
        pub apkG2: <G2Point as ::alloy_sol_types::SolType>::RustType,
        pub sigma: <G1Point as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`trySignatureAndApkVerification(bytes32,(uint256,uint256),(uint256[2],uint256[2]),(uint256,uint256))`](trySignatureAndApkVerificationCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct trySignatureAndApkVerificationReturn {
        pub pairingSuccessful: bool,
        pub siganatureIsValid: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                G1Point,
                G2Point,
                G1Point,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::FixedBytes<32>,
                <G1Point as ::alloy_sol_types::SolType>::RustType,
                <G2Point as ::alloy_sol_types::SolType>::RustType,
                <G1Point as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trySignatureAndApkVerificationCall> for UnderlyingRustTuple<'_> {
                fn from(value: trySignatureAndApkVerificationCall) -> Self {
                    (value.msgHash, value.apk, value.apkG2, value.sigma)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for trySignatureAndApkVerificationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        msgHash: tuple.0,
                        apk: tuple.1,
                        apkG2: tuple.2,
                        sigma: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Bool,
                ::alloy_sol_types::sol_data::Bool,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool, bool);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<trySignatureAndApkVerificationReturn> for UnderlyingRustTuple<'_> {
                fn from(value: trySignatureAndApkVerificationReturn) -> Self {
                    (value.pairingSuccessful, value.siganatureIsValid)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for trySignatureAndApkVerificationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        pairingSuccessful: tuple.0,
                        siganatureIsValid: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for trySignatureAndApkVerificationCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                G1Point,
                G2Point,
                G1Point,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = trySignatureAndApkVerificationReturn;
            type ReturnTuple<'a> = (
                ::alloy_sol_types::sol_data::Bool,
                ::alloy_sol_types::sol_data::Bool,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "trySignatureAndApkVerification(bytes32,(uint256,uint256),(uint256[2],uint256[2]),(uint256,uint256))";
            const SELECTOR: [u8; 4] = [23u8, 31u8, 29u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.msgHash), <G1Point as alloy_sol_types::SolType>::tokenize(&self.apk), <G2Point as alloy_sol_types::SolType>::tokenize(&self.apkG2), <G1Point as alloy_sol_types::SolType>::tokenize(&self.sigma),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Function with signature `unpause(uint256)` and selector `0xfabc1cbc`.\n```solidity\nfunction unpause(uint256 newPausedStatus) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct unpauseCall {
        pub newPausedStatus: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container type for the return parameters of the [`unpause(uint256)`](unpauseCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    (value.newPausedStatus,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPausedStatus: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause(uint256)";
            const SELECTOR: [u8; 4] = [250u8, 188u8, 28u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newPausedStatus,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container for all the [`IncredibleSquaringTaskManager`](self) function calls."]
    pub enum IncredibleSquaringTaskManagerCalls {
        TASK_CHALLENGE_WINDOW_BLOCK(TASK_CHALLENGE_WINDOW_BLOCKCall),
        TASK_RESPONSE_WINDOW_BLOCK(TASK_RESPONSE_WINDOW_BLOCKCall),
        aggregator(aggregatorCall),
        allTaskHashes(allTaskHashesCall),
        allTaskResponses(allTaskResponsesCall),
        blsApkRegistry(blsApkRegistryCall),
        checkSignatures(checkSignaturesCall),
        createNewTask(createNewTaskCall),
        delegation(delegationCall),
        generator(generatorCall),
        getCheckSignaturesIndices(getCheckSignaturesIndicesCall),
        getOperatorState_0(getOperatorState_0Call),
        getOperatorState_1(getOperatorState_1Call),
        getQuorumBitmapsAtBlockNumber(getQuorumBitmapsAtBlockNumberCall),
        getTaskResponseWindowBlock(getTaskResponseWindowBlockCall),
        initialize(initializeCall),
        latestTaskNum(latestTaskNumCall),
        owner(ownerCall),
        pause(pauseCall),
        pauseAll(pauseAllCall),
        paused_0(paused_0Call),
        paused_1(paused_1Call),
        pauserRegistry(pauserRegistryCall),
        raiseAndResolveChallenge(raiseAndResolveChallengeCall),
        registryCoordinator(registryCoordinatorCall),
        renounceOwnership(renounceOwnershipCall),
        respondToTask(respondToTaskCall),
        setPauserRegistry(setPauserRegistryCall),
        setStaleStakesForbidden(setStaleStakesForbiddenCall),
        stakeRegistry(stakeRegistryCall),
        staleStakesForbidden(staleStakesForbiddenCall),
        taskNumber(taskNumberCall),
        taskSuccesfullyChallenged(taskSuccesfullyChallengedCall),
        transferOwnership(transferOwnershipCall),
        trySignatureAndApkVerification(trySignatureAndApkVerificationCall),
        unpause(unpauseCall),
    }
    #[automatically_derived]
    impl IncredibleSquaringTaskManagerCalls {
        #[doc = r" All the selectors of this enum."]
        #[doc = r""]
        #[doc = r" Note that the selectors might not be in the same order as the variants."]
        #[doc = r" No guarantees are made about the order of the selectors."]
        #[doc = r""]
        #[doc = r" Prefer using `SolInterface` methods instead."]
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [16u8, 214u8, 122u8, 47u8],
            [19u8, 100u8, 57u8, 221u8],
            [23u8, 31u8, 29u8, 91u8],
            [26u8, 212u8, 49u8, 137u8],
            [36u8, 90u8, 123u8, 252u8],
            [44u8, 178u8, 35u8, 213u8],
            [45u8, 137u8, 246u8, 252u8],
            [53u8, 99u8, 176u8, 209u8],
            [65u8, 108u8, 126u8, 94u8],
            [79u8, 115u8, 159u8, 116u8],
            [89u8, 92u8, 106u8, 103u8],
            [90u8, 200u8, 106u8, 183u8],
            [91u8, 174u8, 201u8, 160u8],
            [92u8, 21u8, 86u8, 98u8],
            [92u8, 151u8, 90u8, 187u8],
            [93u8, 236u8, 195u8, 245u8],
            [93u8, 244u8, 89u8, 70u8],
            [104u8, 48u8, 72u8, 53u8],
            [107u8, 83u8, 46u8, 158u8],
            [107u8, 146u8, 120u8, 126u8],
            [109u8, 20u8, 169u8, 135u8],
            [110u8, 251u8, 70u8, 54u8],
            [113u8, 80u8, 24u8, 166u8],
            [114u8, 209u8, 142u8, 141u8],
            [122u8, 250u8, 30u8, 237u8],
            [136u8, 111u8, 17u8, 149u8],
            [139u8, 0u8, 206u8, 124u8],
            [141u8, 165u8, 203u8, 91u8],
            [185u8, 141u8, 9u8, 8u8],
            [206u8, 253u8, 193u8, 212u8],
            [223u8, 92u8, 247u8, 35u8],
            [242u8, 253u8, 227u8, 139u8],
            [245u8, 201u8, 137u8, 157u8],
            [246u8, 60u8, 91u8, 171u8],
            [248u8, 200u8, 118u8, 94u8],
            [250u8, 188u8, 28u8, 188u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for IncredibleSquaringTaskManagerCalls {
        const NAME: &'static str = "IncredibleSquaringTaskManagerCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 36usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::TASK_CHALLENGE_WINDOW_BLOCK(_) => {
                    <TASK_CHALLENGE_WINDOW_BLOCKCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::TASK_RESPONSE_WINDOW_BLOCK(_) => {
                    <TASK_RESPONSE_WINDOW_BLOCKCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::aggregator(_) => <aggregatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::allTaskHashes(_) => <allTaskHashesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::allTaskResponses(_) => {
                    <allTaskResponsesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::blsApkRegistry(_) => {
                    <blsApkRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::checkSignatures(_) => {
                    <checkSignaturesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createNewTask(_) => <createNewTaskCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::delegation(_) => <delegationCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::generator(_) => <generatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getCheckSignaturesIndices(_) => {
                    <getCheckSignaturesIndicesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorState_0(_) => {
                    <getOperatorState_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorState_1(_) => {
                    <getOperatorState_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getQuorumBitmapsAtBlockNumber(_) => {
                    <getQuorumBitmapsAtBlockNumberCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getTaskResponseWindowBlock(_) => {
                    <getTaskResponseWindowBlockCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::initialize(_) => <initializeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::latestTaskNum(_) => <latestTaskNumCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauseAll(_) => <pauseAllCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused_0(_) => <paused_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused_1(_) => <paused_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauserRegistry(_) => {
                    <pauserRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::raiseAndResolveChallenge(_) => {
                    <raiseAndResolveChallengeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::registryCoordinator(_) => {
                    <registryCoordinatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceOwnership(_) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::respondToTask(_) => <respondToTaskCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setPauserRegistry(_) => {
                    <setPauserRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setStaleStakesForbidden(_) => {
                    <setStaleStakesForbiddenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::stakeRegistry(_) => <stakeRegistryCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::staleStakesForbidden(_) => {
                    <staleStakesForbiddenCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::taskNumber(_) => <taskNumberCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::taskSuccesfullyChallenged(_) => {
                    <taskSuccesfullyChallengedCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferOwnership(_) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::trySignatureAndApkVerification(_) => {
                    <trySignatureAndApkVerificationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<
                IncredibleSquaringTaskManagerCalls,
            >] = &[
                {
                    fn setPauserRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <setPauserRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::setPauserRegistry)
                    }
                    setPauserRegistry
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::pause)
                    }
                    pause
                },
                {
                    fn trySignatureAndApkVerification(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <trySignatureAndApkVerificationCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(IncredibleSquaringTaskManagerCalls::trySignatureAndApkVerification)
                    }
                    trySignatureAndApkVerification
                },
                {
                    fn TASK_RESPONSE_WINDOW_BLOCK(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <TASK_RESPONSE_WINDOW_BLOCKCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(IncredibleSquaringTaskManagerCalls::TASK_RESPONSE_WINDOW_BLOCK)
                    }
                    TASK_RESPONSE_WINDOW_BLOCK
                },
                {
                    fn aggregator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <aggregatorCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::aggregator)
                    }
                    aggregator
                },
                {
                    fn allTaskResponses(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <allTaskResponsesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::allTaskResponses)
                    }
                    allTaskResponses
                },
                {
                    fn allTaskHashes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <allTaskHashesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::allTaskHashes)
                    }
                    allTaskHashes
                },
                {
                    fn getOperatorState_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <getOperatorState_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::getOperatorState_0)
                    }
                    getOperatorState_0
                },
                {
                    fn setStaleStakesForbidden(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <setStaleStakesForbiddenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::setStaleStakesForbidden)
                    }
                    setStaleStakesForbidden
                },
                {
                    fn getCheckSignaturesIndices(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <getCheckSignaturesIndicesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::getCheckSignaturesIndices)
                    }
                    getCheckSignaturesIndices
                },
                {
                    fn pauseAll(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <pauseAllCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::pauseAll)
                    }
                    pauseAll
                },
                {
                    fn paused_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <paused_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::paused_0)
                    }
                    paused_0
                },
                {
                    fn respondToTask(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <respondToTaskCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::respondToTask)
                    }
                    respondToTask
                },
                {
                    fn getQuorumBitmapsAtBlockNumber(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <getQuorumBitmapsAtBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(IncredibleSquaringTaskManagerCalls::getQuorumBitmapsAtBlockNumber)
                    }
                    getQuorumBitmapsAtBlockNumber
                },
                {
                    fn paused_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <paused_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::paused_1)
                    }
                    paused_1
                },
                {
                    fn taskSuccesfullyChallenged(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <taskSuccesfullyChallengedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::taskSuccesfullyChallenged)
                    }
                    taskSuccesfullyChallenged
                },
                {
                    fn blsApkRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <blsApkRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::blsApkRegistry)
                    }
                    blsApkRegistry
                },
                {
                    fn stakeRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <stakeRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::stakeRegistry)
                    }
                    stakeRegistry
                },
                {
                    fn raiseAndResolveChallenge(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <raiseAndResolveChallengeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::raiseAndResolveChallenge)
                    }
                    raiseAndResolveChallenge
                },
                {
                    fn createNewTask(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <createNewTaskCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::createNewTask)
                    }
                    createNewTask
                },
                {
                    fn registryCoordinator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <registryCoordinatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::registryCoordinator)
                    }
                    registryCoordinator
                },
                {
                    fn checkSignatures(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <checkSignaturesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::checkSignatures)
                    }
                    checkSignatures
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn taskNumber(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <taskNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::taskNumber)
                    }
                    taskNumber
                },
                {
                    fn generator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <generatorCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::generator)
                    }
                    generator
                },
                {
                    fn pauserRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <pauserRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::pauserRegistry)
                    }
                    pauserRegistry
                },
                {
                    fn latestTaskNum(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <latestTaskNumCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::latestTaskNum)
                    }
                    latestTaskNum
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::owner)
                    }
                    owner
                },
                {
                    fn staleStakesForbidden(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <staleStakesForbiddenCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::staleStakesForbidden)
                    }
                    staleStakesForbidden
                },
                {
                    fn getOperatorState_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <getOperatorState_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::getOperatorState_1)
                    }
                    getOperatorState_1
                },
                {
                    fn delegation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <delegationCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::delegation)
                    }
                    delegation
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(IncredibleSquaringTaskManagerCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn getTaskResponseWindowBlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <getTaskResponseWindowBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(IncredibleSquaringTaskManagerCalls::getTaskResponseWindowBlock)
                    }
                    getTaskResponseWindowBlock
                },
                {
                    fn TASK_CHALLENGE_WINDOW_BLOCK(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <TASK_CHALLENGE_WINDOW_BLOCKCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(IncredibleSquaringTaskManagerCalls::TASK_CHALLENGE_WINDOW_BLOCK)
                    }
                    TASK_CHALLENGE_WINDOW_BLOCK
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::initialize)
                    }
                    initialize
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<IncredibleSquaringTaskManagerCalls>
                    {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(IncredibleSquaringTaskManagerCalls::unpause)
                    }
                    unpause
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::TASK_CHALLENGE_WINDOW_BLOCK(inner) => <TASK_CHALLENGE_WINDOW_BLOCKCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::TASK_RESPONSE_WINDOW_BLOCK(inner) => <TASK_RESPONSE_WINDOW_BLOCKCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::aggregator(inner) => <aggregatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::allTaskHashes(inner) => <allTaskHashesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::allTaskResponses(inner) => <allTaskResponsesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::blsApkRegistry(inner) => <blsApkRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::checkSignatures(inner) => <checkSignaturesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::createNewTask(inner) => <createNewTaskCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::delegation(inner) => <delegationCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::generator(inner) => <generatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getCheckSignaturesIndices(inner) => <getCheckSignaturesIndicesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorState_0(inner) => <getOperatorState_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorState_1(inner) => <getOperatorState_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getQuorumBitmapsAtBlockNumber(inner) => <getQuorumBitmapsAtBlockNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getTaskResponseWindowBlock(inner) => <getTaskResponseWindowBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::latestTaskNum(inner) => <latestTaskNumCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::owner(inner) => <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::pause(inner) => <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::pauseAll(inner) => <pauseAllCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::paused_0(inner) => <paused_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::paused_1(inner) => <paused_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::pauserRegistry(inner) => <pauserRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::raiseAndResolveChallenge(inner) => <raiseAndResolveChallengeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::registryCoordinator(inner) => <registryCoordinatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::renounceOwnership(inner) => <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::respondToTask(inner) => <respondToTaskCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::setPauserRegistry(inner) => <setPauserRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::setStaleStakesForbidden(inner) => <setStaleStakesForbiddenCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::stakeRegistry(inner) => <stakeRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::staleStakesForbidden(inner) => <staleStakesForbiddenCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::taskNumber(inner) => <taskNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::taskSuccesfullyChallenged(inner) => <taskSuccesfullyChallengedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::transferOwnership(inner) => <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::trySignatureAndApkVerification(inner) => <trySignatureAndApkVerificationCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::unpause(inner) => <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::TASK_CHALLENGE_WINDOW_BLOCK(inner) => {
                    <TASK_CHALLENGE_WINDOW_BLOCKCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::TASK_RESPONSE_WINDOW_BLOCK(inner) => {
                    <TASK_RESPONSE_WINDOW_BLOCKCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::aggregator(inner) => {
                    <aggregatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::allTaskHashes(inner) => {
                    <allTaskHashesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::allTaskResponses(inner) => {
                    <allTaskResponsesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::blsApkRegistry(inner) => {
                    <blsApkRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::checkSignatures(inner) => {
                    <checkSignaturesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::createNewTask(inner) => {
                    <createNewTaskCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::delegation(inner) => {
                    <delegationCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::generator(inner) => {
                    <generatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getCheckSignaturesIndices(inner) => {
                    <getCheckSignaturesIndicesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::getOperatorState_0(inner) => {
                    <getOperatorState_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getOperatorState_1(inner) => {
                    <getOperatorState_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::getQuorumBitmapsAtBlockNumber(inner) => {
                    <getQuorumBitmapsAtBlockNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::getTaskResponseWindowBlock(inner) => {
                    <getTaskResponseWindowBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::latestTaskNum(inner) => {
                    <latestTaskNumCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::owner(inner) => {
                    <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pauseAll(inner) => {
                    <pauseAllCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused_0(inner) => {
                    <paused_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused_1(inner) => {
                    <paused_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::pauserRegistry(inner) => {
                    <pauserRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::raiseAndResolveChallenge(inner) => {
                    <raiseAndResolveChallengeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::registryCoordinator(inner) => {
                    <registryCoordinatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::renounceOwnership(inner) => {
                    <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::respondToTask(inner) => {
                    <respondToTaskCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setPauserRegistry(inner) => {
                    <setPauserRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::setStaleStakesForbidden(inner) => {
                    <setStaleStakesForbiddenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::stakeRegistry(inner) => {
                    <stakeRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::staleStakesForbidden(inner) => {
                    <staleStakesForbiddenCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::taskNumber(inner) => {
                    <taskNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::taskSuccesfullyChallenged(inner) => {
                    <taskSuccesfullyChallengedCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::transferOwnership(inner) => {
                    <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::trySignatureAndApkVerification(inner) => {
                    <trySignatureAndApkVerificationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    #[allow(missing_docs)]
    #[derive(Debug, Serialize, Deserialize)]
    #[doc = "Container for all the [`IncredibleSquaringTaskManager`](self) events."]
    pub enum IncredibleSquaringTaskManagerEvents {
        Initialized(Initialized),
        NewTaskCreated(NewTaskCreated),
        OwnershipTransferred(OwnershipTransferred),
        Paused(Paused),
        PauserRegistrySet(PauserRegistrySet),
        StaleStakesForbiddenUpdate(StaleStakesForbiddenUpdate),
        TaskChallengedSuccessfully(TaskChallengedSuccessfully),
        TaskChallengedUnsuccessfully(TaskChallengedUnsuccessfully),
        TaskCompleted(TaskCompleted),
        TaskResponded(TaskResponded),
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl IncredibleSquaringTaskManagerEvents {
        #[doc = r" All the selectors of this enum."]
        #[doc = r""]
        #[doc = r" Note that the selectors might not be in the same order as the variants."]
        #[doc = r" No guarantees are made about the order of the selectors."]
        #[doc = r""]
        #[doc = r" Prefer using `SolInterface` methods instead."]
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                22u8, 149u8, 184u8, 208u8, 110u8, 200u8, 0u8, 180u8, 97u8, 94u8, 116u8, 92u8,
                251u8, 91u8, 208u8, 12u8, 31u8, 40u8, 117u8, 97u8, 93u8, 66u8, 146u8, 92u8, 59u8,
                90u8, 250u8, 84u8, 59u8, 178u8, 76u8, 72u8,
            ],
            [
                52u8, 156u8, 30u8, 230u8, 14u8, 78u8, 137u8, 114u8, 238u8, 157u8, 186u8, 100u8,
                44u8, 23u8, 116u8, 84u8, 61u8, 92u8, 65u8, 54u8, 135u8, 155u8, 127u8, 76u8, 170u8,
                240u8, 75u8, 248u8, 26u8, 72u8, 122u8, 42u8,
            ],
            [
                53u8, 130u8, 209u8, 130u8, 142u8, 38u8, 191u8, 86u8, 189u8, 128u8, 21u8, 2u8,
                188u8, 2u8, 26u8, 192u8, 188u8, 138u8, 251u8, 87u8, 200u8, 38u8, 228u8, 152u8,
                107u8, 69u8, 89u8, 60u8, 143u8, 173u8, 56u8, 156u8,
            ],
            [
                64u8, 228u8, 237u8, 136u8, 10u8, 41u8, 224u8, 246u8, 221u8, 206u8, 48u8, 116u8,
                87u8, 251u8, 117u8, 205u8, 223u8, 79u8, 238u8, 247u8, 211u8, 236u8, 176u8, 48u8,
                27u8, 253u8, 244u8, 151u8, 106u8, 14u8, 45u8, 252u8,
            ],
            [
                110u8, 159u8, 205u8, 83u8, 152u8, 150u8, 252u8, 166u8, 14u8, 139u8, 15u8, 1u8,
                221u8, 88u8, 2u8, 51u8, 228u8, 138u8, 107u8, 15u8, 125u8, 240u8, 19u8, 184u8,
                155u8, 167u8, 245u8, 101u8, 134u8, 154u8, 205u8, 182u8,
            ],
            [
                127u8, 38u8, 184u8, 63u8, 249u8, 110u8, 31u8, 43u8, 106u8, 104u8, 47u8, 19u8, 56u8,
                82u8, 246u8, 121u8, 138u8, 9u8, 196u8, 101u8, 218u8, 149u8, 146u8, 20u8, 96u8,
                206u8, 251u8, 56u8, 71u8, 64u8, 36u8, 152u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8, 31u8, 208u8,
                164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8, 218u8, 175u8, 227u8,
                180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                154u8, 20u8, 79u8, 34u8, 138u8, 147u8, 27u8, 157u8, 13u8, 22u8, 150u8, 251u8,
                205u8, 175u8, 49u8, 11u8, 36u8, 181u8, 210u8, 210u8, 30u8, 121u8, 157u8, 182u8,
                35u8, 252u8, 152u8, 106u8, 15u8, 84u8, 116u8, 48u8,
            ],
            [
                171u8, 64u8, 163u8, 116u8, 188u8, 81u8, 222u8, 55u8, 34u8, 0u8, 168u8, 188u8,
                152u8, 26u8, 248u8, 201u8, 236u8, 220u8, 8u8, 223u8, 218u8, 239u8, 11u8, 182u8,
                224u8, 159u8, 136u8, 243u8, 198u8, 22u8, 239u8, 61u8,
            ],
            [
                194u8, 13u8, 27u8, 176u8, 241u8, 98u8, 54u8, 128u8, 48u8, 107u8, 131u8, 212u8,
                255u8, 75u8, 185u8, 154u8, 43u8, 235u8, 157u8, 134u8, 217u8, 120u8, 50u8, 243u8,
                202u8, 64u8, 253u8, 19u8, 162u8, 157u8, 241u8, 236u8,
            ],
            [
                253u8, 62u8, 38u8, 190u8, 235u8, 89u8, 103u8, 252u8, 90u8, 87u8, 160u8, 68u8,
                105u8, 20u8, 234u8, 188u8, 69u8, 180u8, 170u8, 71u8, 76u8, 103u8, 165u8, 27u8,
                75u8, 81u8, 96u8, 202u8, 198u8, 13u8, 219u8, 5u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for IncredibleSquaringTaskManagerEvents {
        const NAME: &'static str = "IncredibleSquaringTaskManagerEvents";
        const COUNT: usize = 11usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::Initialized)
                }
                Some(<NewTaskCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <NewTaskCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::NewTaskCreated)
                }
                Some(<OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OwnershipTransferred)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::Paused)
                }
                Some(<PauserRegistrySet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <PauserRegistrySet as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::PauserRegistrySet)
                }
                Some(<StaleStakesForbiddenUpdate as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <StaleStakesForbiddenUpdate as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::StaleStakesForbiddenUpdate)
                }
                Some(<TaskChallengedSuccessfully as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TaskChallengedSuccessfully as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::TaskChallengedSuccessfully)
                }
                Some(
                    <TaskChallengedUnsuccessfully as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => <TaskChallengedUnsuccessfully as alloy_sol_types::SolEvent>::decode_raw_log(
                    topics, data, validate,
                )
                .map(Self::TaskChallengedUnsuccessfully),
                Some(<TaskCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TaskCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::TaskCompleted)
                }
                Some(<TaskResponded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TaskResponded as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::TaskResponded)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::Unpaused)
                }
                _ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                    name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                    log: alloy_sol_types::private::Box::new(
                        alloy_sol_types::private::LogData::new_unchecked(
                            topics.to_vec(),
                            data.to_vec().into(),
                        ),
                    ),
                }),
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for IncredibleSquaringTaskManagerEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::NewTaskCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::PauserRegistrySet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::StaleStakesForbiddenUpdate(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TaskChallengedSuccessfully(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TaskChallengedUnsuccessfully(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TaskCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TaskResponded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::NewTaskCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
                Self::PauserRegistrySet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::StaleStakesForbiddenUpdate(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TaskChallengedSuccessfully(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TaskChallengedUnsuccessfully(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TaskCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TaskResponded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use ::alloy_contract;
    #[doc = "Creates a new wrapper around an on-chain [`IncredibleSquaringTaskManager`](self) contract instance.\n\nSee the [wrapper's documentation](`IncredibleSquaringTaskManagerInstance`) for more details."]
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> IncredibleSquaringTaskManagerInstance<T, P, N> {
        IncredibleSquaringTaskManagerInstance::<T, P, N>::new(address, provider)
    }
    #[doc = "Deploys this contract using the given `provider` and constructor arguments, if any.\n\nReturns a new instance of the contract, if the deployment was successful.\n\nFor more fine-grained control over the deployment process, use [`deploy_builder`] instead."]
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _registryCoordinator: ::alloy_sol_types::private::Address,
        _taskResponseWindowBlock: u32,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<IncredibleSquaringTaskManagerInstance<T, P, N>>,
    > {
        IncredibleSquaringTaskManagerInstance::<T, P, N>::deploy(
            provider,
            _registryCoordinator,
            _taskResponseWindowBlock,
        )
    }
    #[doc = "Creates a `RawCallBuilder` for deploying this contract using the given `provider`\nand constructor arguments, if any.\n\nThis is a simple wrapper around creating a `RawCallBuilder` with the data set to\nthe bytecode concatenated with the constructor's ABI-encoded arguments."]
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _registryCoordinator: ::alloy_sol_types::private::Address,
        _taskResponseWindowBlock: u32,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        IncredibleSquaringTaskManagerInstance::<T, P, N>::deploy_builder(
            provider,
            _registryCoordinator,
            _taskResponseWindowBlock,
        )
    }
    #[doc = "A [`IncredibleSquaringTaskManager`](self) instance.\n\nContains type-safe methods for interacting with an on-chain instance of the\n[`IncredibleSquaringTaskManager`](self) contract located at a given `address`, using a given\nprovider `P`.\n\nIf the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)\ndocumentation on how to provide it), the `deploy` and `deploy_builder` methods can\nbe used to deploy a new instance of the contract.\n\nSee the [module-level documentation](self) for all the available methods."]
    #[derive(Clone)]
    pub struct IncredibleSquaringTaskManagerInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for IncredibleSquaringTaskManagerInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("IncredibleSquaringTaskManagerInstance")
                .field(&self.address)
                .finish()
        }
    }
    #[doc = r" Instantiation and getters/setters."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > IncredibleSquaringTaskManagerInstance<T, P, N>
    {
        #[doc = "Creates a new wrapper around an on-chain [`IncredibleSquaringTaskManager`](self) contract instance.\n\nSee the [wrapper's documentation](`IncredibleSquaringTaskManagerInstance`) for more details."]
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, provider: P) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        #[doc = "Deploys this contract using the given `provider` and constructor arguments, if any.\n\nReturns a new instance of the contract, if the deployment was successful.\n\nFor more fine-grained control over the deployment process, use [`deploy_builder`] instead."]
        #[inline]
        pub async fn deploy(
            provider: P,
            _registryCoordinator: ::alloy_sol_types::private::Address,
            _taskResponseWindowBlock: u32,
        ) -> alloy_contract::Result<IncredibleSquaringTaskManagerInstance<T, P, N>> {
            let call_builder =
                Self::deploy_builder(provider, _registryCoordinator, _taskResponseWindowBlock);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        #[doc = "Creates a `RawCallBuilder` for deploying this contract using the given `provider`\nand constructor arguments, if any.\n\nThis is a simple wrapper around creating a `RawCallBuilder` with the data set to\nthe bytecode concatenated with the constructor's ABI-encoded arguments."]
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _registryCoordinator: ::alloy_sol_types::private::Address,
            _taskResponseWindowBlock: u32,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(&constructorCall {
                        _registryCoordinator,
                        _taskResponseWindowBlock,
                    })[..],
                ]
                .concat()
                .into(),
            )
        }
        #[doc = r" Returns a reference to the address."]
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        #[doc = r" Sets the address."]
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        #[doc = r" Sets the address and returns `self`."]
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        #[doc = r" Returns a reference to the provider."]
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> IncredibleSquaringTaskManagerInstance<T, &P, N> {
        #[doc = r" Clones the provider and returns a new instance with the cloned provider."]
        #[inline]
        pub fn with_cloned_provider(self) -> IncredibleSquaringTaskManagerInstance<T, P, N> {
            IncredibleSquaringTaskManagerInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    #[doc = r" Function calls."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > IncredibleSquaringTaskManagerInstance<T, P, N>
    {
        #[doc = r" Creates a new call builder using this contract instance's provider and address."]
        #[doc = r""]
        #[doc = r" Note that the call can be any function call, not just those defined in this"]
        #[doc = r" contract. Prefer using the other methods for building type-safe contract calls."]
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        #[doc = "Creates a new call builder for the [`TASK_CHALLENGE_WINDOW_BLOCK`] function."]
        pub fn TASK_CHALLENGE_WINDOW_BLOCK(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TASK_CHALLENGE_WINDOW_BLOCKCall, N> {
            self.call_builder(&TASK_CHALLENGE_WINDOW_BLOCKCall {})
        }
        #[doc = "Creates a new call builder for the [`TASK_RESPONSE_WINDOW_BLOCK`] function."]
        pub fn TASK_RESPONSE_WINDOW_BLOCK(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, TASK_RESPONSE_WINDOW_BLOCKCall, N> {
            self.call_builder(&TASK_RESPONSE_WINDOW_BLOCKCall {})
        }
        #[doc = "Creates a new call builder for the [`aggregator`] function."]
        pub fn aggregator(&self) -> alloy_contract::SolCallBuilder<T, &P, aggregatorCall, N> {
            self.call_builder(&aggregatorCall {})
        }
        #[doc = "Creates a new call builder for the [`allTaskHashes`] function."]
        pub fn allTaskHashes(
            &self,
            _0: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, allTaskHashesCall, N> {
            self.call_builder(&allTaskHashesCall { _0 })
        }
        #[doc = "Creates a new call builder for the [`allTaskResponses`] function."]
        pub fn allTaskResponses(
            &self,
            _0: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, allTaskResponsesCall, N> {
            self.call_builder(&allTaskResponsesCall { _0 })
        }
        #[doc = "Creates a new call builder for the [`blsApkRegistry`] function."]
        pub fn blsApkRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, blsApkRegistryCall, N> {
            self.call_builder(&blsApkRegistryCall {})
        }
        #[doc = "Creates a new call builder for the [`checkSignatures`] function."]
        pub fn checkSignatures(
            &self,
            msgHash: ::alloy_sol_types::private::FixedBytes<32>,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
            referenceBlockNumber: u32,
            params: <NonSignerStakesAndSignature as ::alloy_sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, checkSignaturesCall, N> {
            self.call_builder(&checkSignaturesCall {
                msgHash,
                quorumNumbers,
                referenceBlockNumber,
                params,
            })
        }
        #[doc = "Creates a new call builder for the [`createNewTask`] function."]
        pub fn createNewTask(
            &self,
            numberToBeSquared: ::alloy_sol_types::private::U256,
            quorumThresholdPercentage: u32,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, createNewTaskCall, N> {
            self.call_builder(&createNewTaskCall {
                numberToBeSquared,
                quorumThresholdPercentage,
                quorumNumbers,
            })
        }
        #[doc = "Creates a new call builder for the [`delegation`] function."]
        pub fn delegation(&self) -> alloy_contract::SolCallBuilder<T, &P, delegationCall, N> {
            self.call_builder(&delegationCall {})
        }
        #[doc = "Creates a new call builder for the [`generator`] function."]
        pub fn generator(&self) -> alloy_contract::SolCallBuilder<T, &P, generatorCall, N> {
            self.call_builder(&generatorCall {})
        }
        #[doc = "Creates a new call builder for the [`getCheckSignaturesIndices`] function."]
        pub fn getCheckSignaturesIndices(
            &self,
            registryCoordinator: ::alloy_sol_types::private::Address,
            referenceBlockNumber: u32,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
            nonSignerOperatorIds: ::alloy_sol_types::private::Vec<
                ::alloy_sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCheckSignaturesIndicesCall, N> {
            self.call_builder(&getCheckSignaturesIndicesCall {
                registryCoordinator,
                referenceBlockNumber,
                quorumNumbers,
                nonSignerOperatorIds,
            })
        }
        #[doc = "Creates a new call builder for the [`getOperatorState_0`] function."]
        pub fn getOperatorState_0(
            &self,
            registryCoordinator: ::alloy_sol_types::private::Address,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
            blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorState_0Call, N> {
            self.call_builder(&getOperatorState_0Call {
                registryCoordinator,
                quorumNumbers,
                blockNumber,
            })
        }
        #[doc = "Creates a new call builder for the [`getOperatorState_1`] function."]
        pub fn getOperatorState_1(
            &self,
            registryCoordinator: ::alloy_sol_types::private::Address,
            operatorId: ::alloy_sol_types::private::FixedBytes<32>,
            blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorState_1Call, N> {
            self.call_builder(&getOperatorState_1Call {
                registryCoordinator,
                operatorId,
                blockNumber,
            })
        }
        #[doc = "Creates a new call builder for the [`getQuorumBitmapsAtBlockNumber`] function."]
        pub fn getQuorumBitmapsAtBlockNumber(
            &self,
            registryCoordinator: ::alloy_sol_types::private::Address,
            operatorIds: ::alloy_sol_types::private::Vec<
                ::alloy_sol_types::private::FixedBytes<32>,
            >,
            blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, getQuorumBitmapsAtBlockNumberCall, N> {
            self.call_builder(&getQuorumBitmapsAtBlockNumberCall {
                registryCoordinator,
                operatorIds,
                blockNumber,
            })
        }
        #[doc = "Creates a new call builder for the [`getTaskResponseWindowBlock`] function."]
        pub fn getTaskResponseWindowBlock(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getTaskResponseWindowBlockCall, N> {
            self.call_builder(&getTaskResponseWindowBlockCall {})
        }
        #[doc = "Creates a new call builder for the [`initialize`] function."]
        pub fn initialize(
            &self,
            _pauserRegistry: ::alloy_sol_types::private::Address,
            initialOwner: ::alloy_sol_types::private::Address,
            _aggregator: ::alloy_sol_types::private::Address,
            _generator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(&initializeCall {
                _pauserRegistry,
                initialOwner,
                _aggregator,
                _generator,
            })
        }
        #[doc = "Creates a new call builder for the [`latestTaskNum`] function."]
        pub fn latestTaskNum(&self) -> alloy_contract::SolCallBuilder<T, &P, latestTaskNumCall, N> {
            self.call_builder(&latestTaskNumCall {})
        }
        #[doc = "Creates a new call builder for the [`owner`] function."]
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        #[doc = "Creates a new call builder for the [`pause`] function."]
        pub fn pause(
            &self,
            newPausedStatus: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall { newPausedStatus })
        }
        #[doc = "Creates a new call builder for the [`pauseAll`] function."]
        pub fn pauseAll(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseAllCall, N> {
            self.call_builder(&pauseAllCall {})
        }
        #[doc = "Creates a new call builder for the [`paused_0`] function."]
        pub fn paused_0(
            &self,
            index: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, paused_0Call, N> {
            self.call_builder(&paused_0Call { index })
        }
        #[doc = "Creates a new call builder for the [`paused_1`] function."]
        pub fn paused_1(&self) -> alloy_contract::SolCallBuilder<T, &P, paused_1Call, N> {
            self.call_builder(&paused_1Call {})
        }
        #[doc = "Creates a new call builder for the [`pauserRegistry`] function."]
        pub fn pauserRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauserRegistryCall, N> {
            self.call_builder(&pauserRegistryCall {})
        }
        #[doc = "Creates a new call builder for the [`raiseAndResolveChallenge`] function."]
        pub fn raiseAndResolveChallenge(
            &self,
            task: <Task as ::alloy_sol_types::SolType>::RustType,
            taskResponse: <TaskResponse as ::alloy_sol_types::SolType>::RustType,
            taskResponseMetadata: <TaskResponseMetadata as ::alloy_sol_types::SolType>::RustType,
            pubkeysOfNonSigningOperators: ::alloy_sol_types::private::Vec<
                <G1Point as ::alloy_sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, raiseAndResolveChallengeCall, N> {
            self.call_builder(&raiseAndResolveChallengeCall {
                task,
                taskResponse,
                taskResponseMetadata,
                pubkeysOfNonSigningOperators,
            })
        }
        #[doc = "Creates a new call builder for the [`registryCoordinator`] function."]
        pub fn registryCoordinator(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, registryCoordinatorCall, N> {
            self.call_builder(&registryCoordinatorCall {})
        }
        #[doc = "Creates a new call builder for the [`renounceOwnership`] function."]
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        #[doc = "Creates a new call builder for the [`respondToTask`] function."]
        pub fn respondToTask(
            &self,
            task: <Task as ::alloy_sol_types::SolType>::RustType,
            taskResponse: <TaskResponse as ::alloy_sol_types::SolType>::RustType,
            nonSignerStakesAndSignature: <NonSignerStakesAndSignature as ::alloy_sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, respondToTaskCall, N> {
            self.call_builder(&respondToTaskCall {
                task,
                taskResponse,
                nonSignerStakesAndSignature,
            })
        }
        #[doc = "Creates a new call builder for the [`setPauserRegistry`] function."]
        pub fn setPauserRegistry(
            &self,
            newPauserRegistry: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setPauserRegistryCall, N> {
            self.call_builder(&setPauserRegistryCall { newPauserRegistry })
        }
        #[doc = "Creates a new call builder for the [`setStaleStakesForbidden`] function."]
        pub fn setStaleStakesForbidden(
            &self,
            value: bool,
        ) -> alloy_contract::SolCallBuilder<T, &P, setStaleStakesForbiddenCall, N> {
            self.call_builder(&setStaleStakesForbiddenCall { value })
        }
        #[doc = "Creates a new call builder for the [`stakeRegistry`] function."]
        pub fn stakeRegistry(&self) -> alloy_contract::SolCallBuilder<T, &P, stakeRegistryCall, N> {
            self.call_builder(&stakeRegistryCall {})
        }
        #[doc = "Creates a new call builder for the [`staleStakesForbidden`] function."]
        pub fn staleStakesForbidden(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, staleStakesForbiddenCall, N> {
            self.call_builder(&staleStakesForbiddenCall {})
        }
        #[doc = "Creates a new call builder for the [`taskNumber`] function."]
        pub fn taskNumber(&self) -> alloy_contract::SolCallBuilder<T, &P, taskNumberCall, N> {
            self.call_builder(&taskNumberCall {})
        }
        #[doc = "Creates a new call builder for the [`taskSuccesfullyChallenged`] function."]
        pub fn taskSuccesfullyChallenged(
            &self,
            _0: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, taskSuccesfullyChallengedCall, N> {
            self.call_builder(&taskSuccesfullyChallengedCall { _0 })
        }
        #[doc = "Creates a new call builder for the [`transferOwnership`] function."]
        pub fn transferOwnership(
            &self,
            newOwner: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        #[doc = "Creates a new call builder for the [`trySignatureAndApkVerification`] function."]
        pub fn trySignatureAndApkVerification(
            &self,
            msgHash: ::alloy_sol_types::private::FixedBytes<32>,
            apk: <G1Point as ::alloy_sol_types::SolType>::RustType,
            apkG2: <G2Point as ::alloy_sol_types::SolType>::RustType,
            sigma: <G1Point as ::alloy_sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, trySignatureAndApkVerificationCall, N> {
            self.call_builder(&trySignatureAndApkVerificationCall {
                msgHash,
                apk,
                apkG2,
                sigma,
            })
        }
        #[doc = "Creates a new call builder for the [`unpause`] function."]
        pub fn unpause(
            &self,
            newPausedStatus: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall { newPausedStatus })
        }
    }
    #[doc = r" Event filters."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > IncredibleSquaringTaskManagerInstance<T, P, N>
    {
        #[doc = r" Creates a new event filter using this contract instance's provider and address."]
        #[doc = r""]
        #[doc = r" Note that the type can be any event, not just those defined in this contract."]
        #[doc = r" Prefer using the other methods for building type-safe event filters."]
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        #[doc = "Creates a new event filter for the [`Initialized`] event."]
        pub fn Initialized_filter(&self) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        #[doc = "Creates a new event filter for the [`NewTaskCreated`] event."]
        pub fn NewTaskCreated_filter(&self) -> alloy_contract::Event<T, &P, NewTaskCreated, N> {
            self.event_filter::<NewTaskCreated>()
        }
        #[doc = "Creates a new event filter for the [`OwnershipTransferred`] event."]
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        #[doc = "Creates a new event filter for the [`Paused`] event."]
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        #[doc = "Creates a new event filter for the [`PauserRegistrySet`] event."]
        pub fn PauserRegistrySet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, PauserRegistrySet, N> {
            self.event_filter::<PauserRegistrySet>()
        }
        #[doc = "Creates a new event filter for the [`StaleStakesForbiddenUpdate`] event."]
        pub fn StaleStakesForbiddenUpdate_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, StaleStakesForbiddenUpdate, N> {
            self.event_filter::<StaleStakesForbiddenUpdate>()
        }
        #[doc = "Creates a new event filter for the [`TaskChallengedSuccessfully`] event."]
        pub fn TaskChallengedSuccessfully_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TaskChallengedSuccessfully, N> {
            self.event_filter::<TaskChallengedSuccessfully>()
        }
        #[doc = "Creates a new event filter for the [`TaskChallengedUnsuccessfully`] event."]
        pub fn TaskChallengedUnsuccessfully_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TaskChallengedUnsuccessfully, N> {
            self.event_filter::<TaskChallengedUnsuccessfully>()
        }
        #[doc = "Creates a new event filter for the [`TaskCompleted`] event."]
        pub fn TaskCompleted_filter(&self) -> alloy_contract::Event<T, &P, TaskCompleted, N> {
            self.event_filter::<TaskCompleted>()
        }
        #[doc = "Creates a new event filter for the [`TaskResponded`] event."]
        pub fn TaskResponded_filter(&self) -> alloy_contract::Event<T, &P, TaskResponded, N> {
            self.event_filter::<TaskResponded>()
        }
        #[doc = "Creates a new event filter for the [`Unpaused`] event."]
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
