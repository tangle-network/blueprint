#![allow(clippy::all, warnings)]

#[doc = "\n\nGenerated by the following Solidity interface...\n```solidity\ninterface RegistryCoordinator {\n    type OperatorStatus is uint8;\n    struct G1Point {\n        uint256 X;\n        uint256 Y;\n    }\n    struct G2Point {\n        uint256[2] X;\n        uint256[2] Y;\n    }\n    struct OperatorInfo {\n        bytes32 operatorId;\n        OperatorStatus status;\n    }\n    struct OperatorKickParam {\n        uint8 quorumNumber;\n        address operator;\n    }\n    struct OperatorSetParam {\n        uint32 maxOperatorCount;\n        uint16 kickBIPsOfOperatorStake;\n        uint16 kickBIPsOfTotalStake;\n    }\n    struct PubkeyRegistrationParams {\n        G1Point pubkeyRegistrationSignature;\n        G1Point pubkeyG1;\n        G2Point pubkeyG2;\n    }\n    struct QuorumBitmapUpdate {\n        uint32 updateBlockNumber;\n        uint32 nextUpdateBlockNumber;\n        uint192 quorumBitmap;\n    }\n    struct SignatureWithSaltAndExpiry {\n        bytes signature;\n        bytes32 salt;\n        uint256 expiry;\n    }\n    struct StrategyParams {\n        address strategy;\n        uint96 multiplier;\n    }\n\n    event ChurnApproverUpdated(address prevChurnApprover, address newChurnApprover);\n    event EjectorUpdated(address prevEjector, address newEjector);\n    event Initialized(uint8 version);\n    event OperatorDeregistered(address indexed operator, bytes32 indexed operatorId);\n    event OperatorRegistered(address indexed operator, bytes32 indexed operatorId);\n    event OperatorSetParamsUpdated(uint8 indexed quorumNumber, OperatorSetParam operatorSetParams);\n    event OperatorSocketUpdate(bytes32 indexed operatorId, string socket);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event Paused(address indexed account, uint256 newPausedStatus);\n    event PauserRegistrySet(address pauserRegistry, address newPauserRegistry);\n    event QuorumBlockNumberUpdated(uint8 indexed quorumNumber, uint256 blocknumber);\n    event Unpaused(address indexed account, uint256 newPausedStatus);\n\n    constructor(address _serviceManager, address _stakeRegistry, address _blsApkRegistry, address _indexRegistry);\n\n    function OPERATOR_CHURN_APPROVAL_TYPEHASH() external view returns (bytes32);\n    function PUBKEY_REGISTRATION_TYPEHASH() external view returns (bytes32);\n    function blsApkRegistry() external view returns (address);\n    function calculateOperatorChurnApprovalDigestHash(address registeringOperator, bytes32 registeringOperatorId, OperatorKickParam[] memory operatorKickParams, bytes32 salt, uint256 expiry) external view returns (bytes32);\n    function churnApprover() external view returns (address);\n    function createQuorum(OperatorSetParam memory operatorSetParams, uint96 minimumStake, StrategyParams[] memory strategyParams) external;\n    function deregisterOperator(bytes memory quorumNumbers) external;\n    function ejectOperator(address operator, bytes memory quorumNumbers) external;\n    function ejector() external view returns (address);\n    function getCurrentQuorumBitmap(bytes32 operatorId) external view returns (uint192);\n    function getOperator(address operator) external view returns (OperatorInfo memory);\n    function getOperatorFromId(bytes32 operatorId) external view returns (address);\n    function getOperatorId(address operator) external view returns (bytes32);\n    function getOperatorSetParams(uint8 quorumNumber) external view returns (OperatorSetParam memory);\n    function getOperatorStatus(address operator) external view returns (OperatorStatus);\n    function getQuorumBitmapAtBlockNumberByIndex(bytes32 operatorId, uint32 blockNumber, uint256 index) external view returns (uint192);\n    function getQuorumBitmapHistoryLength(bytes32 operatorId) external view returns (uint256);\n    function getQuorumBitmapIndicesAtBlockNumber(uint32 blockNumber, bytes32[] memory operatorIds) external view returns (uint32[] memory);\n    function getQuorumBitmapUpdateByIndex(bytes32 operatorId, uint256 index) external view returns (QuorumBitmapUpdate memory);\n    function indexRegistry() external view returns (address);\n    function initialize(address _initialOwner, address _churnApprover, address _ejector, address _pauserRegistry, uint256 _initialPausedStatus, OperatorSetParam[] memory _operatorSetParams, uint96[] memory _minimumStakes, StrategyParams[][] memory _strategyParams) external;\n    function isChurnApproverSaltUsed(bytes32) external view returns (bool);\n    function numRegistries() external view returns (uint256);\n    function owner() external view returns (address);\n    function pause(uint256 newPausedStatus) external;\n    function pauseAll() external;\n    function paused(uint8 index) external view returns (bool);\n    function paused() external view returns (uint256);\n    function pauserRegistry() external view returns (address);\n    function pubkeyRegistrationMessageHash(address operator) external view returns (G1Point memory);\n    function quorumCount() external view returns (uint8);\n    function quorumUpdateBlockNumber(uint8) external view returns (uint256);\n    function registerOperator(bytes memory quorumNumbers, string memory socket, PubkeyRegistrationParams memory params, SignatureWithSaltAndExpiry memory operatorSignature) external;\n    function registerOperatorWithChurn(bytes memory quorumNumbers, string memory socket, PubkeyRegistrationParams memory params, OperatorKickParam[] memory operatorKickParams, SignatureWithSaltAndExpiry memory churnApproverSignature, SignatureWithSaltAndExpiry memory operatorSignature) external;\n    function registries(uint256) external view returns (address);\n    function renounceOwnership() external;\n    function serviceManager() external view returns (address);\n    function setChurnApprover(address _churnApprover) external;\n    function setEjector(address _ejector) external;\n    function setOperatorSetParams(uint8 quorumNumber, OperatorSetParam memory operatorSetParams) external;\n    function setPauserRegistry(address newPauserRegistry) external;\n    function stakeRegistry() external view returns (address);\n    function transferOwnership(address newOwner) external;\n    function unpause(uint256 newPausedStatus) external;\n    function updateOperators(address[] memory operators) external;\n    function updateOperatorsForQuorum(address[][] memory operatorsPerQuorum, bytes memory quorumNumbers) external;\n    function updateSocket(string memory socket) external;\n}\n```\n\n...which was generated by the following JSON ABI:\n```json\n[\n  {\n    \"type\": \"constructor\",\n    \"inputs\": [\n      {\n        \"name\": \"_serviceManager\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IServiceManager\"\n      },\n      {\n        \"name\": \"_stakeRegistry\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IStakeRegistry\"\n      },\n      {\n        \"name\": \"_blsApkRegistry\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IBLSApkRegistry\"\n      },\n      {\n        \"name\": \"_indexRegistry\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IIndexRegistry\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"OPERATOR_CHURN_APPROVAL_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"PUBKEY_REGISTRATION_TYPEHASH\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"blsApkRegistry\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IBLSApkRegistry\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"calculateOperatorChurnApprovalDigestHash\",\n    \"inputs\": [\n      {\n        \"name\": \"registeringOperator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"registeringOperatorId\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"operatorKickParams\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IRegistryCoordinator.OperatorKickParam[]\",\n        \"components\": [\n          {\n            \"name\": \"quorumNumber\",\n            \"type\": \"uint8\",\n            \"internalType\": \"uint8\"\n          },\n          {\n            \"name\": \"operator\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          }\n        ]\n      },\n      {\n        \"name\": \"salt\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"expiry\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"churnApprover\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"createQuorum\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorSetParams\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IRegistryCoordinator.OperatorSetParam\",\n        \"components\": [\n          {\n            \"name\": \"maxOperatorCount\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"kickBIPsOfOperatorStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          },\n          {\n            \"name\": \"kickBIPsOfTotalStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          }\n        ]\n      },\n      {\n        \"name\": \"minimumStake\",\n        \"type\": \"uint96\",\n        \"internalType\": \"uint96\"\n      },\n      {\n        \"name\": \"strategyParams\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IStakeRegistry.StrategyParams[]\",\n        \"components\": [\n          {\n            \"name\": \"strategy\",\n            \"type\": \"address\",\n            \"internalType\": \"contract IStrategy\"\n          },\n          {\n            \"name\": \"multiplier\",\n            \"type\": \"uint96\",\n            \"internalType\": \"uint96\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"deregisterOperator\",\n    \"inputs\": [\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"ejectOperator\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"ejector\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getCurrentQuorumBitmap\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint192\",\n        \"internalType\": \"uint192\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperator\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IRegistryCoordinator.OperatorInfo\",\n        \"components\": [\n          {\n            \"name\": \"operatorId\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"status\",\n            \"type\": \"uint8\",\n            \"internalType\": \"enum IRegistryCoordinator.OperatorStatus\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorFromId\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorId\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorSetParams\",\n    \"inputs\": [\n      {\n        \"name\": \"quorumNumber\",\n        \"type\": \"uint8\",\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IRegistryCoordinator.OperatorSetParam\",\n        \"components\": [\n          {\n            \"name\": \"maxOperatorCount\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"kickBIPsOfOperatorStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          },\n          {\n            \"name\": \"kickBIPsOfTotalStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorStatus\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint8\",\n        \"internalType\": \"enum IRegistryCoordinator.OperatorStatus\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getQuorumBitmapAtBlockNumberByIndex\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"index\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint192\",\n        \"internalType\": \"uint192\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getQuorumBitmapHistoryLength\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getQuorumBitmapIndicesAtBlockNumber\",\n    \"inputs\": [\n      {\n        \"name\": \"blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      },\n      {\n        \"name\": \"operatorIds\",\n        \"type\": \"bytes32[]\",\n        \"internalType\": \"bytes32[]\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint32[]\",\n        \"internalType\": \"uint32[]\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getQuorumBitmapUpdateByIndex\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"index\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IRegistryCoordinator.QuorumBitmapUpdate\",\n        \"components\": [\n          {\n            \"name\": \"updateBlockNumber\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"nextUpdateBlockNumber\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"quorumBitmap\",\n            \"type\": \"uint192\",\n            \"internalType\": \"uint192\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"indexRegistry\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IIndexRegistry\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"initialize\",\n    \"inputs\": [\n      {\n        \"name\": \"_initialOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_churnApprover\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_ejector\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_pauserRegistry\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IPauserRegistry\"\n      },\n      {\n        \"name\": \"_initialPausedStatus\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"_operatorSetParams\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IRegistryCoordinator.OperatorSetParam[]\",\n        \"components\": [\n          {\n            \"name\": \"maxOperatorCount\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"kickBIPsOfOperatorStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          },\n          {\n            \"name\": \"kickBIPsOfTotalStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          }\n        ]\n      },\n      {\n        \"name\": \"_minimumStakes\",\n        \"type\": \"uint96[]\",\n        \"internalType\": \"uint96[]\"\n      },\n      {\n        \"name\": \"_strategyParams\",\n        \"type\": \"tuple[][]\",\n        \"internalType\": \"struct IStakeRegistry.StrategyParams[][]\",\n        \"components\": [\n          {\n            \"name\": \"strategy\",\n            \"type\": \"address\",\n            \"internalType\": \"contract IStrategy\"\n          },\n          {\n            \"name\": \"multiplier\",\n            \"type\": \"uint96\",\n            \"internalType\": \"uint96\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"isChurnApproverSaltUsed\",\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"numRegistries\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"owner\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"pause\",\n    \"inputs\": [\n      {\n        \"name\": \"newPausedStatus\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"pauseAll\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"paused\",\n    \"inputs\": [\n      {\n        \"name\": \"index\",\n        \"type\": \"uint8\",\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"paused\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"pauserRegistry\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IPauserRegistry\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"pubkeyRegistrationMessageHash\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct BN254.G1Point\",\n        \"components\": [\n          {\n            \"name\": \"X\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          },\n          {\n            \"name\": \"Y\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"quorumCount\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint8\",\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"quorumUpdateBlockNumber\",\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint8\",\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registerOperator\",\n    \"inputs\": [\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      },\n      {\n        \"name\": \"socket\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      },\n      {\n        \"name\": \"params\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IBLSApkRegistry.PubkeyRegistrationParams\",\n        \"components\": [\n          {\n            \"name\": \"pubkeyRegistrationSignature\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G1Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"pubkeyG1\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G1Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"pubkeyG2\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G2Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256[2]\",\n                \"internalType\": \"uint256[2]\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256[2]\",\n                \"internalType\": \"uint256[2]\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"name\": \"operatorSignature\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"salt\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registerOperatorWithChurn\",\n    \"inputs\": [\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      },\n      {\n        \"name\": \"socket\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      },\n      {\n        \"name\": \"params\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IBLSApkRegistry.PubkeyRegistrationParams\",\n        \"components\": [\n          {\n            \"name\": \"pubkeyRegistrationSignature\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G1Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"pubkeyG1\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G1Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256\",\n                \"internalType\": \"uint256\"\n              }\n            ]\n          },\n          {\n            \"name\": \"pubkeyG2\",\n            \"type\": \"tuple\",\n            \"internalType\": \"struct BN254.G2Point\",\n            \"components\": [\n              {\n                \"name\": \"X\",\n                \"type\": \"uint256[2]\",\n                \"internalType\": \"uint256[2]\"\n              },\n              {\n                \"name\": \"Y\",\n                \"type\": \"uint256[2]\",\n                \"internalType\": \"uint256[2]\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"name\": \"operatorKickParams\",\n        \"type\": \"tuple[]\",\n        \"internalType\": \"struct IRegistryCoordinator.OperatorKickParam[]\",\n        \"components\": [\n          {\n            \"name\": \"quorumNumber\",\n            \"type\": \"uint8\",\n            \"internalType\": \"uint8\"\n          },\n          {\n            \"name\": \"operator\",\n            \"type\": \"address\",\n            \"internalType\": \"address\"\n          }\n        ]\n      },\n      {\n        \"name\": \"churnApproverSignature\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"salt\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"operatorSignature\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"salt\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registries\",\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"renounceOwnership\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"serviceManager\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IServiceManager\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setChurnApprover\",\n    \"inputs\": [\n      {\n        \"name\": \"_churnApprover\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setEjector\",\n    \"inputs\": [\n      {\n        \"name\": \"_ejector\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setOperatorSetParams\",\n    \"inputs\": [\n      {\n        \"name\": \"quorumNumber\",\n        \"type\": \"uint8\",\n        \"internalType\": \"uint8\"\n      },\n      {\n        \"name\": \"operatorSetParams\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct IRegistryCoordinator.OperatorSetParam\",\n        \"components\": [\n          {\n            \"name\": \"maxOperatorCount\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"kickBIPsOfOperatorStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          },\n          {\n            \"name\": \"kickBIPsOfTotalStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"setPauserRegistry\",\n    \"inputs\": [\n      {\n        \"name\": \"newPauserRegistry\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IPauserRegistry\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"stakeRegistry\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IStakeRegistry\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"transferOwnership\",\n    \"inputs\": [\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"unpause\",\n    \"inputs\": [\n      {\n        \"name\": \"newPausedStatus\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperators\",\n    \"inputs\": [\n      {\n        \"name\": \"operators\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperatorsForQuorum\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorsPerQuorum\",\n        \"type\": \"address[][]\",\n        \"internalType\": \"address[][]\"\n      },\n      {\n        \"name\": \"quorumNumbers\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateSocket\",\n    \"inputs\": [\n      {\n        \"name\": \"socket\",\n        \"type\": \"string\",\n        \"internalType\": \"string\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"ChurnApproverUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"prevChurnApprover\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newChurnApprover\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"EjectorUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"prevEjector\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newEjector\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Initialized\",\n    \"inputs\": [\n      {\n        \"name\": \"version\",\n        \"type\": \"uint8\",\n        \"indexed\": false,\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorDeregistered\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"indexed\": true,\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorRegistered\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"indexed\": true,\n        \"internalType\": \"bytes32\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorSetParamsUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"quorumNumber\",\n        \"type\": \"uint8\",\n        \"indexed\": true,\n        \"internalType\": \"uint8\"\n      },\n      {\n        \"name\": \"operatorSetParams\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct IRegistryCoordinator.OperatorSetParam\",\n        \"components\": [\n          {\n            \"name\": \"maxOperatorCount\",\n            \"type\": \"uint32\",\n            \"internalType\": \"uint32\"\n          },\n          {\n            \"name\": \"kickBIPsOfOperatorStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          },\n          {\n            \"name\": \"kickBIPsOfTotalStake\",\n            \"type\": \"uint16\",\n            \"internalType\": \"uint16\"\n          }\n        ]\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorSocketUpdate\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorId\",\n        \"type\": \"bytes32\",\n        \"indexed\": true,\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"socket\",\n        \"type\": \"string\",\n        \"indexed\": false,\n        \"internalType\": \"string\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OwnershipTransferred\",\n    \"inputs\": [\n      {\n        \"name\": \"previousOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Paused\",\n    \"inputs\": [\n      {\n        \"name\": \"account\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newPausedStatus\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"PauserRegistrySet\",\n    \"inputs\": [\n      {\n        \"name\": \"pauserRegistry\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"contract IPauserRegistry\"\n      },\n      {\n        \"name\": \"newPauserRegistry\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"contract IPauserRegistry\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"QuorumBlockNumberUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"quorumNumber\",\n        \"type\": \"uint8\",\n        \"indexed\": true,\n        \"internalType\": \"uint8\"\n      },\n      {\n        \"name\": \"blocknumber\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Unpaused\",\n    \"inputs\": [\n      {\n        \"name\": \"account\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newPausedStatus\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  }\n]\n```"]
#[allow(missing_docs, clippy::too_many_arguments)]
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod RegistryCoordinator {
    use super::*;
    use ::alloy_sol_types;
    #[doc = r" The creation / init bytecode of the contract."]
    #[doc = r""]
    #[doc = r" ```text"]
    #[doc = "0x6101c06040523480156200001257600080fd5b506040516200614b3803806200614b833981016040819052620000359162000254565b604080518082018252601681527f4156535265676973747279436f6f7264696e61746f720000000000000000000060208083019182528351808501909452600684526576302e302e3160d01b908401528151902060e08190527f6bda7e3f385e48841048390444cced5cc795af87758af67622e5f4f0882c4a996101008190524660a05287938793879387939192917f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f620001358184846040805160208101859052908101839052606081018290524660808201523060a082015260009060c0016040516020818303038152906040528051906020012090509392505050565b6080523060c05261012052505050506001600160a01b039384166101405291831661018052821661016052166101a0526200016f62000179565b50505050620002bc565b600054610100900460ff1615620001e65760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff908116101562000239576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b6001600160a01b03811681146200025157600080fd5b50565b600080600080608085870312156200026b57600080fd5b845162000278816200023b565b60208601519094506200028b816200023b565b60408601519093506200029e816200023b565b6060860151909250620002b1816200023b565b939692955090935050565b60805160a05160c05160e05161010051610120516101405161016051610180516101a051615d87620003c460003960008181610637015281816111110152818161201601528181612d490152818161355a0152613b3101526000818161057c01528181611fa10152818161244b01528181612cc9015281816134b1015281816137060152613ab001526000818161054201528181610ead01528181611fdf01528181612c4b01528181612e3101528181612eab015281816134310152613bad01526000818161048601528181612ba1015261337901526000613db401526000613e0301526000613dde01526000613d3701526000613d6101526000613d8b0152615d876000f3fe608060405234801561001057600080fd5b50600436106102945760003560e01c80635df45946116101675780639feab859116100ce578063d75b4c8811610087578063d75b4c88146106f5578063dd8283f314610708578063e65797ad1461071b578063f2fde38b146107be578063fabc1cbc146107d1578063fd39105a146107e457600080fd5b80639feab85914610659578063a50857bf14610680578063c391425e14610693578063ca0de882146106b3578063ca4f2d97146106da578063d72d8dd6146106ed57600080fd5b8063871ef04911610120578063871ef049146105cc578063886f1195146105df5780638da5cb5b146105f85780639aa1653d146106005780639b5d177b1461061f5780639e9923c21461063257600080fd5b80635df459461461053d5780636347c9001461056457806368304835146105775780636e3b17db1461059e578063715018a6146105b157806384ca5213146105b957600080fd5b806328f61b311161020b5780635140a548116101c45780635140a548146104c85780635865c60c146104db578063595c6a67146104fb5780635ac86ab7146105035780635b0b829f146105225780635c975abb1461053557600080fd5b806328f61b3114610435578063296bb0641461044857806329d1e0c31461045b5780632cdd1e861461046e5780633998fdd3146104815780633c2a7f4c146104a857600080fd5b806310d67a2f1161025d57806310d67a2f1461034a57806313542a4e1461035d578063136439dd146103865780631478851f146103995780631eb812da146103cc578063249a0c421461041557600080fd5b8062cf2ab51461029957806303fd3492146102ae57806304ec6351146102e1578063054310e61461030c5780630cf4b76714610337575b600080fd5b6102ac6102a73660046148ab565b610820565b005b6102ce6102bc3660046148ec565b60009081526098602052604090205490565b6040519081526020015b60405180910390f35b6102f46102ef366004614917565b610935565b6040516001600160c01b0390911681526020016102d8565b609d5461031f906001600160a01b031681565b6040516001600160a01b0390911681526020016102d8565b6102ac610345366004614a36565b610b2b565b6102ac610358366004614aab565b610c13565b6102ce61036b366004614aab565b6001600160a01b031660009081526099602052604090205490565b6102ac6103943660046148ec565b610cc6565b6103bc6103a73660046148ec565b609a6020526000908152604090205460ff1681565b60405190151581526020016102d8565b6103df6103da366004614ac8565b610e03565b60408051825163ffffffff908116825260208085015190911690820152918101516001600160c01b0316908201526060016102d8565b6102ce610423366004614afb565b609b6020526000908152604090205481565b609e5461031f906001600160a01b031681565b61031f6104563660046148ec565b610e94565b6102ac610469366004614aab565b610f20565b6102ac61047c366004614aab565b610f31565b61031f7f000000000000000000000000000000000000000000000000000000000000000081565b6104bb6104b6366004614aab565b610f42565b6040516102d89190614b16565b6102ac6104d6366004614b6e565b610fc1565b6104ee6104e9366004614aab565b6114d1565b6040516102d89190614c11565b6102ac611545565b6103bc610511366004614afb565b6001805460ff9092161b9081161490565b6102ac610530366004614c96565b611611565b6001546102ce565b61031f7f000000000000000000000000000000000000000000000000000000000000000081565b61031f6105723660046148ec565b6116a8565b61031f7f000000000000000000000000000000000000000000000000000000000000000081565b6102ac6105ac366004614cca565b6116d2565b6102ac611792565b6102ce6105c7366004614d81565b6117a6565b6102f46105da3660046148ec565b6117f0565b60005461031f906201000090046001600160a01b031681565b61031f6117fb565b60965461060d9060ff1681565b60405160ff90911681526020016102d8565b6102ac61062d366004614f1a565b611814565b61031f7f000000000000000000000000000000000000000000000000000000000000000081565b6102ce7f2bd82124057f0913bc3b772ce7b83e8057c1ad1f3510fc83778be20f10ec5de681565b6102ac61068e366004615013565b611b4b565b6106a66106a13660046150bb565b611cce565b6040516102d89190615160565b6102ce7f4d404e3276e7ac2163d8ee476afa6a41d1f68fb71f2d8b6546b24e55ce01b72a81565b6102ac6106e83660046151aa565b611d87565b609c546102ce565b6102ac610703366004615290565b611ded565b6102ac610716366004615443565b611e00565b61078a610729366004614afb565b60408051606080820183526000808352602080840182905292840181905260ff9490941684526097825292829020825193840183525463ffffffff8116845261ffff600160201b8204811692850192909252600160301b9004169082015290565b60408051825163ffffffff16815260208084015161ffff9081169183019190915292820151909216908201526060016102d8565b6102ac6107cc366004614aab565b612104565b6102ac6107df3660046148ec565b61217a565b6108136107f2366004614aab565b6001600160a01b031660009081526099602052604090206001015460ff1690565b6040516102d89190615517565b6001546002906004908116036108515760405162461bcd60e51b815260040161084890615525565b60405180910390fd5b60005b8281101561092f5760008484838181106108705761087061555c565b90506020020160208101906108859190614aab565b6001600160a01b03811660009081526099602090815260408083208151808301909252805482526001810154949550929390929183019060ff1660028111156108d0576108d0614bd9565b60028111156108e1576108e1614bd9565b905250805190915060006108f4826122d6565b9050600061090a826001600160c01b0316612341565b905061091785858361240d565b5050505050808061092790615588565b915050610854565b50505050565b60008381526098602052604081208054829190849081106109585761095861555c565b600091825260209182902060408051606081018252929091015463ffffffff808216808552600160201b8304821695850195909552600160401b9091046001600160c01b03169183019190915290925085161015610a525760405162461bcd60e51b815260206004820152606560248201527f5265676973747279436f6f7264696e61746f722e67657451756f72756d42697460448201527f6d61704174426c6f636b4e756d6265724279496e6465783a2071756f72756d4260648201527f69746d61705570646174652069732066726f6d20616674657220626c6f636b4e6084820152643ab6b132b960d91b60a482015260c401610848565b602081015163ffffffff161580610a785750806020015163ffffffff168463ffffffff16105b610b1f5760405162461bcd60e51b815260206004820152606660248201527f5265676973747279436f6f7264696e61746f722e67657451756f72756d42697460448201527f6d61704174426c6f636b4e756d6265724279496e6465783a2071756f72756d4260648201527f69746d61705570646174652069732066726f6d206265666f726520626c6f636b608482015265273ab6b132b960d11b60a482015260c401610848565b60400151949350505050565b60013360009081526099602052604090206001015460ff166002811115610b5457610b54614bd9565b14610bc75760405162461bcd60e51b815260206004820152603c60248201527f5265676973747279436f6f7264696e61746f722e757064617465536f636b657460448201527f3a206f70657261746f72206973206e6f742072656769737465726564000000006064820152608401610848565b33600090815260996020526040908190205490517fec2963ab21c1e50e1e582aa542af2e4bf7bf38e6e1403c27b42e1c5d6e621eaa90610c089084906155e7565b60405180910390a250565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8a91906155fa565b6001600160a01b0316336001600160a01b031614610cba5760405162461bcd60e51b815260040161084890615617565b610cc3816124fa565b50565b60005460405163237dfb4760e11b8152336004820152620100009091046001600160a01b0316906346fbf68e90602401602060405180830381865afa158015610d13573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d379190615661565b610d535760405162461bcd60e51b815260040161084890615683565b60015481811614610dcc5760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e70617573653a20696e76616c696420617474656d70742060448201527f746f20756e70617573652066756e6374696f6e616c69747900000000000000006064820152608401610848565b600181905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d90602001610c08565b60408051606081018252600080825260208201819052918101919091526000838152609860205260409020805483908110610e4057610e4061555c565b600091825260209182902060408051606081018252919092015463ffffffff8082168352600160201b820416938201939093526001600160c01b03600160401b909304929092169082015290505b92915050565b6040516308f6629d60e31b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906347b314e890602401602060405180830381865afa158015610efc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8e91906155fa565b610f286125ff565b610cc38161265e565b610f396125ff565b610cc3816126c7565b6040805180820190915260008082526020820152610e8e610fbc7f2bd82124057f0913bc3b772ce7b83e8057c1ad1f3510fc83778be20f10ec5de684604051602001610fa19291909182526001600160a01b0316602082015260400190565b60405160208183030381529060405280519060200120612730565b61277e565b600154600290600490811603610fe95760405162461bcd60e51b815260040161084890615525565b600061103184848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505060965460ff16915061280d9050565b90508483146110a25760405162461bcd60e51b81526020600482015260436024820152600080516020615cf283398151915260448201527f6f7273466f7251756f72756d3a20696e707574206c656e677468206d69736d616064820152620e8c6d60eb1b608482015260a401610848565b60005b838110156114c85760008585838181106110c1576110c161555c565b919091013560f81c915036905060008989858181106110e2576110e261555c565b90506020028101906110f491906156cb565b6040516379a0849160e11b815260ff8616600482015291935091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f341092290602401602060405180830381865afa158015611160573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111849190615714565b63ffffffff1681146112205760405162461bcd60e51b81526020600482015260656024820152600080516020615cf283398151915260448201527f6f7273466f7251756f72756d3a206e756d626572206f6620757064617465642060648201527f6f70657261746f727320646f6573206e6f74206d617463682071756f72756d206084820152641d1bdd185b60da1b60a482015260c401610848565b6000805b828110156114675760008484838181106112405761124061555c565b90506020020160208101906112559190614aab565b6001600160a01b03811660009081526099602090815260408083208151808301909252805482526001810154949550929390929183019060ff1660028111156112a0576112a0614bd9565b60028111156112b1576112b1614bd9565b905250805190915060006112c4826122d6565b905060016001600160c01b03821660ff8b161c8116146113485760405162461bcd60e51b815260206004820152604460248201819052600080516020615cf2833981519152908201527f6f7273466f7251756f72756d3a206f70657261746f72206e6f7420696e2071756064820152636f72756d60e01b608482015260a401610848565b856001600160a01b0316846001600160a01b0316116113f35760405162461bcd60e51b81526020600482015260676024820152600080516020615cf283398151915260448201527f6f7273466f7251756f72756d3a206f70657261746f7273206172726179206d7560648201527f737420626520736f7274656420696e20617363656e64696e6720616464726573608482015266399037b93232b960c91b60a482015260c401610848565b5061145183838f8f8d908e600161140a9190615731565b9261141793929190615744565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061240d92505050565b50909250611460905081615588565b9050611224565b5060ff84166000818152609b6020908152604091829020439081905591519182527f46077d55330763f16269fd75e5761663f4192d2791747c0189b16ad31db07db4910160405180910390a250505050806114c190615588565b90506110a5565b50505050505050565b60408051808201909152600080825260208201526001600160a01b0382166000908152609960209081526040918290208251808401909352805483526001810154909183019060ff16600281111561152b5761152b614bd9565b600281111561153c5761153c614bd9565b90525092915050565b60005460405163237dfb4760e11b8152336004820152620100009091046001600160a01b0316906346fbf68e90602401602060405180830381865afa158015611592573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115b69190615661565b6115d25760405162461bcd60e51b815260040161084890615683565b600019600181905560405190815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2565b6116196125ff565b609654829060ff908116908216106116995760405162461bcd60e51b815260206004820152603760248201527f5265676973747279436f6f7264696e61746f722e71756f72756d45786973747360448201527f3a2071756f72756d20646f6573206e6f742065786973740000000000000000006064820152608401610848565b6116a3838361289e565b505050565b609c81815481106116b857600080fd5b6000918252602090912001546001600160a01b0316905081565b609e546001600160a01b031633146117525760405162461bcd60e51b815260206004820152603a60248201527f5265676973747279436f6f7264696e61746f722e6f6e6c79456a6563746f723a60448201527f2063616c6c6572206973206e6f742074686520656a6563746f720000000000006064820152608401610848565b6116a38383838080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061294b92505050565b61179a6125ff565b6117a46000612dbd565b565b60006117e67f4d404e3276e7ac2163d8ee476afa6a41d1f68fb71f2d8b6546b24e55ce01b72a8787878787604051602001610fa19695949392919061576e565b9695505050505050565b6000610e8e826122d6565b600061180f6064546001600160a01b031690565b905090565b600180546000919081160361183b5760405162461bcd60e51b815260040161084890615525565b8389146118be5760405162461bcd60e51b8152602060048201526044602482018190527f5265676973747279436f6f7264696e61746f722e72656769737465724f706572908201527f61746f7257697468436875726e3a20696e707574206c656e677468206d69736d6064820152630c2e8c6d60e31b608482015260a401610848565b60006118ca3388612e0f565b905061192a33828888808060200260200160405190810160405280939291908181526020016000905b8282101561191f57611910604083028601368190038101906157f3565b815260200190600101906118f3565b505050505087612f44565b600061197133838e8e8e8e8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92506130d1915050565b905060005b8b811015611b3c576000609760008f8f858181106119965761199661555c565b919091013560f81c82525060208082019290925260409081016000208151606081018352905463ffffffff811680835261ffff600160201b8304811695840195909552600160301b90910490931691810191909152845180519193509084908110611a0357611a0361555c565b602002602001015163ffffffff161115611b2957611aa48e8e84818110611a2c57611a2c61555c565b9050013560f81c60f81b60f81c84604001518481518110611a4f57611a4f61555c565b60200260200101513386602001518681518110611a6e57611a6e61555c565b60200260200101518d8d88818110611a8857611a8861555c565b905060400201803603810190611a9e91906157f3565b866135e8565b611b29898984818110611ab957611ab961555c565b9050604002016020016020810190611ad19190614aab565b8f8f8590866001611ae29190615731565b92611aef93929190615744565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061294b92505050565b5080611b3481615588565b915050611976565b50505050505050505050505050565b6001805460009190811603611b725760405162461bcd60e51b815260040161084890615525565b6000611b7e3385612e0f565b90506000611bc733838b8b8b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92506130d1915050565b51905060005b88811015611cc25760008a8a83818110611be957611be961555c565b919091013560f81c600081815260976020526040902054855191935063ffffffff169150849084908110611c1f57611c1f61555c565b602002602001015163ffffffff161115611caf5760405162461bcd60e51b8152602060048201526044602482018190527f5265676973747279436f6f7264696e61746f722e72656769737465724f706572908201527f61746f723a206f70657261746f7220636f756e742065786365656473206d6178606482015263696d756d60e01b608482015260a401610848565b5080611cba81615588565b915050611bcd565b50505050505050505050565b6060600082516001600160401b03811115611ceb57611ceb61494f565b604051908082528060200260200182016040528015611d14578160200160208202803683370190505b50905060005b8351811015611d7f57611d4685858381518110611d3957611d3961555c565b60200260200101516138bc565b828281518110611d5857611d5861555c565b63ffffffff9092166020928302919091019091015280611d7781615588565b915050611d1a565b509392505050565b60018054600290811603611dad5760405162461bcd60e51b815260040161084890615525565b6116a33384848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061294b92505050565b611df56125ff565b6116a38383836139f8565b600054610100900460ff1615808015611e205750600054600160ff909116105b80611e3a5750303b158015611e3a575060005460ff166001145b611e9d5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610848565b6000805460ff191660011790558015611ec0576000805461ff0019166101001790555b82518451148015611ed2575081518351145b611f3c5760405162461bcd60e51b815260206004820152603560248201527f5265676973747279436f6f7264696e61746f722e696e697469616c697a653a206044820152740d2dce0eae840d8cadccee8d040dad2e6dac2e8c6d605b1b6064820152608401610848565b611f4589612dbd565b611f4f8686613c0f565b611f588861265e565b611f61876126c7565b609c80546001818101835560008381527faf85b9071dfafeac1409d3f1d19bafc9bc7c37974cde8df0ee6168f0086e539c92830180546001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166001600160a01b03199283161790925585548085018755850180547f0000000000000000000000000000000000000000000000000000000000000000841690831617905585549384019095559190920180547f000000000000000000000000000000000000000000000000000000000000000090921691909316179091555b84518110156120b2576120a085828151811061205f5761205f61555c565b60200260200101518583815181106120795761207961555c565b60200260200101518584815181106120935761209361555c565b60200260200101516139f8565b806120aa81615588565b915050612041565b5080156120f9576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050505050505050565b61210c6125ff565b6001600160a01b0381166121715760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610848565b610cc381612dbd565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156121cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121f191906155fa565b6001600160a01b0316336001600160a01b0316146122215760405162461bcd60e51b815260040161084890615617565b60015419811960015419161461229f5760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e756e70617573653a20696e76616c696420617474656d7060448201527f7420746f2070617573652066756e6374696f6e616c69747900000000000000006064820152608401610848565b600181905560405181815233907f3582d1828e26bf56bd801502bc021ac0bc8afb57c826e4986b45593c8fad389c90602001610c08565b6000818152609860205260408120548082036122f55750600092915050565b600083815260986020526040902061230e60018361580f565b8154811061231e5761231e61555c565b600091825260209091200154600160401b90046001600160c01b03169392505050565b606060008061234f84613cff565b61ffff166001600160401b0381111561236a5761236a61494f565b6040519080825280601f01601f191660200182016040528015612394576020820181803683370190505b5090506000805b8251821080156123ac575061010081105b15612403576001811b9350858416156123f3578060f81b8383815181106123d5576123d561555c565b60200101906001600160f81b031916908160001a9053508160010191505b6123fc81615588565b905061239b565b5090949350505050565b60018260200151600281111561242557612425614bd9565b1461242f57505050565b81516040516333567f7f60e11b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906366acfefe9061248490889086908890600401615822565b6020604051808303816000875af11580156124a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124c79190615852565b90506001600160c01b038116156124f3576124f3856124ee836001600160c01b0316612341565b61294b565b5050505050565b6001600160a01b0381166125885760405162461bcd60e51b815260206004820152604960248201527f5061757361626c652e5f73657450617573657252656769737472793a206e657760448201527f50617573657252656769737472792063616e6e6f7420626520746865207a65726064820152686f206164647265737360b81b608482015260a401610848565b600054604080516001600160a01b03620100009093048316815291831660208301527f6e9fcd539896fca60e8b0f01dd580233e48a6b0f7df013b89ba7f565869acdb6910160405180910390a1600080546001600160a01b03909216620100000262010000600160b01b0319909216919091179055565b336126086117fb565b6001600160a01b0316146117a45760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610848565b609d54604080516001600160a01b03928316815291831660208301527f315457d8a8fe60f04af17c16e2f5a5e1db612b31648e58030360759ef8f3528c910160405180910390a1609d80546001600160a01b0319166001600160a01b0392909216919091179055565b609e54604080516001600160a01b03928316815291831660208301527f8f30ab09f43a6c157d7fce7e0a13c003042c1c95e8a72e7a146a21c0caa24dc9910160405180910390a1609e80546001600160a01b0319166001600160a01b0392909216919091179055565b6000610e8e61273d613d2a565b8360405161190160f01b6020820152602281018390526042810182905260009060620160405160208183030381529060405280519060200120905092915050565b6040805180820190915260008082526020820152600080806127ae600080516020615d3283398151915286615891565b90505b6127ba81613e51565b9093509150600080516020615d3283398151915282830983036127f3576040805180820190915290815260208101919091529392505050565b600080516020615d328339815191526001820890506127b1565b60008061281984613ed3565b9050808360ff166001901b116128975760405162461bcd60e51b815260206004820152603f60248201527f4269746d61705574696c732e6f72646572656442797465734172726179546f4260448201527f69746d61703a206269746d61702065786365656473206d61782076616c7565006064820152608401610848565b9392505050565b60ff8216600081815260976020908152604091829020845181548684018051888701805163ffffffff90951665ffffffffffff199094168417600160201b61ffff938416021767ffff0000000000001916600160301b95831695909502949094179094558551918252518316938101939093525116918101919091527f3ee6fe8d54610244c3e9d3c066ae4aee997884aa28f10616ae821925401318ac9060600160405180910390a25050565b6001600160a01b0382166000908152609960205260409020805460018083015460ff16600281111561297f5761297f614bd9565b146129fe5760405162461bcd60e51b815260206004820152604360248201527f5265676973747279436f6f7264696e61746f722e5f646572656769737465724f60448201527f70657261746f723a206f70657261746f72206973206e6f7420726567697374656064820152621c995960ea1b608482015260a401610848565b609654600090612a1290859060ff1661280d565b90506000612a1f836122d6565b90506001600160c01b038216612a9d5760405162461bcd60e51b815260206004820152603b60248201527f5265676973747279436f6f7264696e61746f722e5f646572656769737465724f60448201527f70657261746f723a206269746d61702063616e6e6f74206265203000000000006064820152608401610848565b612ab46001600160c01b0383811690831681161490565b612b4c5760405162461bcd60e51b815260206004820152605960248201527f5265676973747279436f6f7264696e61746f722e5f646572656769737465724f60448201527f70657261746f723a206f70657261746f72206973206e6f74207265676973746560648201527f72656420666f72207370656369666965642071756f72756d7300000000000000608482015260a401610848565b6001600160c01b0382811619821616612b658482614063565b6001600160c01b038116612c345760018501805460ff191660021790556040516351b27a6d60e11b81526001600160a01b0388811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063a364f4da90602401600060405180830381600087803b158015612be557600080fd5b505af1158015612bf9573d6000803e3d6000fd5b50506040518692506001600160a01b038a1691507f396fdcb180cb0fea26928113fb0fd1c3549863f9cd563e6a184f1d578116c8e490600090a35b60405163f4e24fe560e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063f4e24fe590612c82908a908a906004016158a5565b600060405180830381600087803b158015612c9c57600080fd5b505af1158015612cb0573d6000803e3d6000fd5b505060405163bd29b8cd60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016925063bd29b8cd9150612d029087908a906004016158c9565b600060405180830381600087803b158015612d1c57600080fd5b505af1158015612d30573d6000803e3d6000fd5b505060405163bd29b8cd60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016925063bd29b8cd9150612d829087908a906004016158c9565b600060405180830381600087803b158015612d9c57600080fd5b505af1158015612db0573d6000803e3d6000fd5b5050505050505050505050565b606480546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6040516309aa152760e11b81526001600160a01b0383811660048301526000917f0000000000000000000000000000000000000000000000000000000000000000909116906313542a4e90602401602060405180830381865afa158015612e7a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e9e91906158e2565b90506000819003610e8e577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bf79ce588484612ee387610f42565b6040518463ffffffff1660e01b8152600401612f01939291906158fb565b6020604051808303816000875af1158015612f20573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061289791906158e2565b6020808201516000908152609a909152604090205460ff1615612fea5760405162461bcd60e51b815260206004820152605260248201527f5265676973747279436f6f7264696e61746f722e5f766572696679436875726e60448201527f417070726f7665725369676e61747572653a20636875726e417070726f766572606482015271081cd85b1d08185b1c9958591e481d5cd95960721b608482015260a401610848565b428160400151101561307f5760405162461bcd60e51b815260206004820152605260248201527f5265676973747279436f6f7264696e61746f722e5f766572696679436875726e60448201527f417070726f7665725369676e61747572653a20636875726e417070726f766572606482015271081cda59db985d1d5c9948195e1c1a5c995960721b608482015260a401610848565b602080820180516000908152609a909252604091829020805460ff19166001179055609d5490519183015161092f926001600160a01b03909216916130ca91889188918891906117a6565b8351614224565b6130f560405180606001604052806060815260200160608152602001606081525090565b600061313d86868080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505060965460ff16915061280d9050565b9050600061314a886122d6565b90506001600160c01b0382166131c85760405162461bcd60e51b815260206004820152603960248201527f5265676973747279436f6f7264696e61746f722e5f72656769737465724f706560448201527f7261746f723a206269746d61702063616e6e6f742062652030000000000000006064820152608401610848565b8082166001600160c01b03161561327e5760405162461bcd60e51b815260206004820152606860248201527f5265676973747279436f6f7264696e61746f722e5f72656769737465724f706560448201527f7261746f723a206f70657261746f7220616c726561647920726567697374657260648201527f656420666f7220736f6d652071756f72756d73206265696e672072656769737460848201526732b932b2103337b960c11b60a482015260c401610848565b6001600160c01b03818116908316176132978982614063565b887fec2963ab21c1e50e1e582aa542af2e4bf7bf38e6e1403c27b42e1c5d6e621eaa876040516132c791906155e7565b60405180910390a260016001600160a01b038b1660009081526099602052604090206001015460ff16600281111561330157613301614bd9565b1461341a576040805180820182528a8152600160208083018281526001600160a01b038f166000908152609990925293902082518155925183820180549394939192909160ff19169083600281111561335c5761335c614bd9565b021790555050604051639926ee7d60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169150639926ee7d906133b1908d90899060040161596b565b600060405180830381600087803b1580156133cb57600080fd5b505af11580156133df573d6000803e3d6000fd5b50506040518b92506001600160a01b038d1691507fe8e68cef1c3a761ed7be7e8463a375f27f7bc335e51824223cacce636ec5c3fe90600090a35b604051631fd93ca960e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690633fb279529061346a908d908c908c906004016159df565b600060405180830381600087803b15801561348457600080fd5b505af1158015613498573d6000803e3d6000fd5b5050604051632550477760e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169250632550477791506134ee908d908d908d908d90600401615a04565b6000604051808303816000875af115801561350d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526135359190810190615a90565b60408087019190915260208601919091525162bff04d60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169062bff04d90613592908c908c908c90600401615af3565b6000604051808303816000875af11580156135b1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526135d99190810190615b0d565b84525050509695505050505050565b6020808301516001600160a01b03808216600081815260999094526040909320549192908716036136675760405162461bcd60e51b81526020600482015260356024820152600080516020615d1283398151915260448201527439371d1031b0b73737ba1031b43ab9371039b2b63360591b6064820152608401610848565b8760ff16846000015160ff16146136e45760405162461bcd60e51b81526020600482015260476024820152600080516020615d1283398151915260448201527f726e3a2071756f72756d4e756d626572206e6f74207468652073616d65206173606482015266081cda59db995960ca1b608482015260a401610848565b604051635401ed2760e01b81526004810182905260ff891660248201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635401ed2790604401602060405180830381865afa158015613755573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137799190615ba6565b905061378581856143de565b6001600160601b0316866001600160601b0316116138185760405162461bcd60e51b81526020600482015260566024820152600080516020615d1283398151915260448201527f726e3a20696e636f6d696e67206f70657261746f722068617320696e7375666660648201527534b1b4b2b73a1039ba30b5b2903337b91031b43ab93760511b608482015260a401610848565b6138228885614402565b6001600160601b0316816001600160601b0316106120f95760405162461bcd60e51b815260206004820152605c6024820152600080516020615d1283398151915260448201527f726e3a2063616e6e6f74206b69636b206f70657261746f722077697468206d6f60648201527f7265207468616e206b69636b424950734f66546f74616c5374616b6500000000608482015260a401610848565b600081815260986020526040812054815b8181101561394e5760016138e1828461580f565b6138eb919061580f565b92508463ffffffff16609860008681526020019081526020016000208463ffffffff168154811061391e5761391e61555c565b60009182526020909120015463ffffffff161161393c575050610e8e565b8061394681615588565b9150506138cd565b5060405162461bcd60e51b815260206004820152606c60248201527f5265676973747279436f6f7264696e61746f722e67657451756f72756d42697460448201527f6d6170496e6465784174426c6f636b4e756d6265723a206e6f206269746d617060648201527f2075706461746520666f756e6420666f72206f70657261746f7249642061742060848201526b313637b1b590373ab6b132b960a11b60a482015260c401610848565b60965460ff1660c08110613a6c5760405162461bcd60e51b815260206004820152603560248201527f5265676973747279436f6f7264696e61746f722e63726561746551756f72756d6044820152740e881b585e081c5d5bdc9d5b5cc81c995858da1959605a1b6064820152608401610848565b613a77816001615bc3565b6096805460ff191660ff9290921691909117905580613a96818661289e565b60405160016296b58960e01b031981526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063ff694a7790613ae990849088908890600401615bdc565b600060405180830381600087803b158015613b0357600080fd5b505af1158015613b17573d6000803e3d6000fd5b505060405163136ca0f960e11b815260ff841660048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031692506326d941f29150602401600060405180830381600087803b158015613b7f57600080fd5b505af1158015613b93573d6000803e3d6000fd5b505060405163136ca0f960e11b815260ff841660048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031692506326d941f29150602401600060405180830381600087803b158015613bfb57600080fd5b505af11580156120f9573d6000803e3d6000fd5b6000546201000090046001600160a01b0316158015613c3657506001600160a01b03821615155b613cb85760405162461bcd60e51b815260206004820152604760248201527f5061757361626c652e5f696e697469616c697a655061757365723a205f696e6960448201527f7469616c697a6550617573657228292063616e206f6e6c792062652063616c6c6064820152666564206f6e636560c81b608482015260a401610848565b600181905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2613cfb826124fa565b5050565b6000805b8215610e8e57613d1460018461580f565b9092169180613d2281615c55565b915050613d03565b6000306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016148015613d8357507f000000000000000000000000000000000000000000000000000000000000000046145b15613dad57507f000000000000000000000000000000000000000000000000000000000000000090565b50604080517f00000000000000000000000000000000000000000000000000000000000000006020808301919091527f0000000000000000000000000000000000000000000000000000000000000000828401527f000000000000000000000000000000000000000000000000000000000000000060608301524660808301523060a0808401919091528351808403909101815260c0909201909252805191012090565b60008080600080516020615d328339815191526003600080516020615d3283398151915286600080516020615d32833981519152888909090890506000613ec7827f0c19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52600080516020615d3283398151915261441c565b91959194509092505050565b600061010082511115613f5c5760405162461bcd60e51b8152602060048201526044602482018190527f4269746d61705574696c732e6f72646572656442797465734172726179546f42908201527f69746d61703a206f7264657265644279746573417272617920697320746f6f206064820152636c6f6e6760e01b608482015260a401610848565b8151600003613f6d57506000919050565b60008083600081518110613f8357613f8361555c565b0160200151600160f89190911c81901b92505b845181101561405a57848181518110613fb157613fb161555c565b0160200151600160f89190911c1b91508282116140465760405162461bcd60e51b815260206004820152604760248201527f4269746d61705574696c732e6f72646572656442797465734172726179546f4260448201527f69746d61703a206f72646572656442797465734172726179206973206e6f74206064820152661bdc99195c995960ca1b608482015260a401610848565b9181179161405381615588565b9050613f96565b50909392505050565b6000828152609860205260408120549081900361410b576000838152609860209081526040808320815160608101835263ffffffff43811682528185018681526001600160c01b03808a16958401958652845460018101865594885295909620915191909201805495519351909416600160401b026001600160401b03938316600160201b0267ffffffffffffffff1990961691909216179390931716919091179055505050565b600083815260986020526040812061412460018461580f565b815481106141345761413461555c565b6000918252602090912001805490915063ffffffff4381169116036141765780546001600160401b0316600160401b6001600160c01b0385160217815561092f565b805463ffffffff438116600160201b81810267ffffffff0000000019909416939093178455600087815260986020908152604080832081516060810183529485528483018481526001600160c01b03808c1693870193845282546001810184559286529390942094519401805493519151909216600160401b026001600160401b0391861690960267ffffffffffffffff199093169390941692909217179190911691909117905550505050565b6001600160a01b0383163b1561433e57604051630b135d3f60e11b808252906001600160a01b03851690631626ba7e9061426490869086906004016158c9565b602060405180830381865afa158015614281573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906142a59190615c76565b6001600160e01b031916146116a35760405162461bcd60e51b815260206004820152605360248201527f454950313237315369676e61747572655574696c732e636865636b5369676e6160448201527f747572655f454950313237313a2045524331323731207369676e6174757265206064820152721d995c9a599a58d85d1a5bdb8819985a5b1959606a1b608482015260a401610848565b826001600160a01b031661435283836144c5565b6001600160a01b0316146116a35760405162461bcd60e51b815260206004820152604760248201527f454950313237315369676e61747572655574696c732e636865636b5369676e6160448201527f747572655f454950313237313a207369676e6174757265206e6f742066726f6d6064820152661039b4b3b732b960c91b608482015260a401610848565b6020810151600090612710906143f89061ffff1685615ca0565b6128979190615ccb565b6040810151600090612710906143f89061ffff1685615ca0565b60008061442761482b565b61442f614849565b602080825281810181905260408201819052606082018890526080820187905260a082018690528260c08360056107d05a03fa9250828061446c57fe5b50826144ba5760405162461bcd60e51b815260206004820152601a60248201527f424e3235342e6578704d6f643a2063616c6c206661696c7572650000000000006044820152606401610848565b505195945050505050565b60008060006144d485856144e1565b91509150611d7f8161454f565b60008082516041036145175760208301516040840151606085015160001a61450b87828585614705565b94509450505050614548565b825160400361454057602083015160408401516145358683836147f2565b935093505050614548565b506000905060025b9250929050565b600081600481111561456357614563614bd9565b0361456b5750565b600181600481111561457f5761457f614bd9565b036145cc5760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610848565b60028160048111156145e0576145e0614bd9565b0361462d5760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610848565b600381600481111561464157614641614bd9565b036146995760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608401610848565b60048160048111156146ad576146ad614bd9565b03610cc35760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b6064820152608401610848565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561473c57506000905060036147e9565b8460ff16601b1415801561475457508460ff16601c14155b1561476557506000905060046147e9565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa1580156147b9573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166147e2576000600192509250506147e9565b9150600090505b94509492505050565b6000806001600160ff1b0383168161480f60ff86901c601b615731565b905061481d87828885614705565b935093505050935093915050565b60405180602001604052806001906020820280368337509192915050565b6040518060c001604052806006906020820280368337509192915050565b60008083601f84011261487957600080fd5b5081356001600160401b0381111561489057600080fd5b6020830191508360208260051b850101111561454857600080fd5b600080602083850312156148be57600080fd5b82356001600160401b038111156148d457600080fd5b6148e085828601614867565b90969095509350505050565b6000602082840312156148fe57600080fd5b5035919050565b63ffffffff81168114610cc357600080fd5b60008060006060848603121561492c57600080fd5b83359250602084013561493e81614905565b929592945050506040919091013590565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156149875761498761494f565b60405290565b604080519081016001600160401b03811182821017156149875761498761494f565b604051601f8201601f191681016001600160401b03811182821017156149d7576149d761494f565b604052919050565b60006001600160401b038311156149f8576149f861494f565b614a0b601f8401601f19166020016149af565b9050828152838383011115614a1f57600080fd5b828260208301376000602084830101529392505050565b600060208284031215614a4857600080fd5b81356001600160401b03811115614a5e57600080fd5b8201601f81018413614a6f57600080fd5b614a7e848235602084016149df565b949350505050565b6001600160a01b0381168114610cc357600080fd5b8035614aa681614a86565b919050565b600060208284031215614abd57600080fd5b813561289781614a86565b60008060408385031215614adb57600080fd5b50508035926020909101359150565b803560ff81168114614aa657600080fd5b600060208284031215614b0d57600080fd5b61289782614aea565b815181526020808301519082015260408101610e8e565b60008083601f840112614b3f57600080fd5b5081356001600160401b03811115614b5657600080fd5b60208301915083602082850101111561454857600080fd5b60008060008060408587031215614b8457600080fd5b84356001600160401b0380821115614b9b57600080fd5b614ba788838901614867565b90965094506020870135915080821115614bc057600080fd5b50614bcd87828801614b2d565b95989497509550505050565b634e487b7160e01b600052602160045260246000fd5b60038110614c0d57634e487b7160e01b600052602160045260246000fd5b9052565b815181526020808301516040830191614c2c90840182614bef565b5092915050565b803561ffff81168114614aa657600080fd5b600060608284031215614c5757600080fd5b614c5f614965565b90508135614c6c81614905565b8152614c7a60208301614c33565b6020820152614c8b60408301614c33565b604082015292915050565b60008060808385031215614ca957600080fd5b614cb283614aea565b9150614cc18460208501614c45565b90509250929050565b600080600060408486031215614cdf57600080fd5b8335614cea81614a86565b925060208401356001600160401b03811115614d0557600080fd5b614d1186828701614b2d565b9497909650939450505050565b60006001600160401b03821115614d3757614d3761494f565b5060051b60200190565b600060408284031215614d5357600080fd5b614d5b61498d565b9050614d6682614aea565b81526020820135614d7681614a86565b602082015292915050565b600080600080600060a08688031215614d9957600080fd5b8535614da481614a86565b945060208681013594506040808801356001600160401b03811115614dc857600080fd5b8801601f81018a13614dd957600080fd5b8035614dec614de782614d1e565b6149af565b81815260069190911b8201840190848101908c831115614e0b57600080fd5b928501925b82841015614e3157614e228d85614d41565b82529284019290850190614e10565b999c989b5098996060810135995060800135979650505050505050565b60006101008284031215614e6157600080fd5b50919050565b60008083601f840112614e7957600080fd5b5081356001600160401b03811115614e9057600080fd5b6020830191508360208260061b850101111561454857600080fd5b600060608284031215614ebd57600080fd5b614ec5614965565b905081356001600160401b03811115614edd57600080fd5b8201601f81018413614eee57600080fd5b614efd848235602084016149df565b825250602082013560208201526040820135604082015292915050565b60008060008060008060008060006101a08a8c031215614f3957600080fd5b89356001600160401b0380821115614f5057600080fd5b614f5c8d838e01614b2d565b909b50995060208c0135915080821115614f7557600080fd5b614f818d838e01614b2d565b9099509750879150614f968d60408e01614e4e565b96506101408c0135915080821115614fad57600080fd5b614fb98d838e01614e67565b90965094506101608c0135915080821115614fd357600080fd5b614fdf8d838e01614eab565b93506101808c0135915080821115614ff657600080fd5b506150038c828d01614eab565b9150509295985092959850929598565b600080600080600080610160878903121561502d57600080fd5b86356001600160401b038082111561504457600080fd5b6150508a838b01614b2d565b9098509650602089013591508082111561506957600080fd5b6150758a838b01614b2d565b909650945084915061508a8a60408b01614e4e565b93506101408901359150808211156150a157600080fd5b506150ae89828a01614eab565b9150509295509295509295565b600080604083850312156150ce57600080fd5b82356150d981614905565b91506020838101356001600160401b038111156150f557600080fd5b8401601f8101861361510657600080fd5b8035615114614de782614d1e565b81815260059190911b8201830190838101908883111561513357600080fd5b928401925b8284101561515157833582529284019290840190615138565b80955050505050509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561519e57835163ffffffff168352928401929184019160010161517c565b50909695505050505050565b600080602083850312156151bd57600080fd5b82356001600160401b038111156151d357600080fd5b6148e085828601614b2d565b6001600160601b0381168114610cc357600080fd5b600082601f83011261520557600080fd5b81356020615215614de783614d1e565b82815260069290921b8401810191818101908684111561523457600080fd5b8286015b8481101561528557604081890312156152515760008081fd5b61525961498d565b813561526481614a86565b815281850135615273816151df565b81860152835291830191604001615238565b509695505050505050565b600080600060a084860312156152a557600080fd5b6152af8585614c45565b925060608401356152bf816151df565b915060808401356001600160401b038111156152da57600080fd5b6152e6868287016151f4565b9150509250925092565b600082601f83011261530157600080fd5b81356020615311614de783614d1e565b8281526060928302850182019282820191908785111561533057600080fd5b8387015b85811015615353576153468982614c45565b8452928401928101615334565b5090979650505050505050565b600082601f83011261537157600080fd5b81356020615381614de783614d1e565b82815260059290921b840181019181810190868411156153a057600080fd5b8286015b848110156152855780356153b7816151df565b83529183019183016153a4565b600082601f8301126153d557600080fd5b813560206153e5614de783614d1e565b82815260059290921b8401810191818101908684111561540457600080fd5b8286015b848110156152855780356001600160401b038111156154275760008081fd5b6154358986838b01016151f4565b845250918301918301615408565b600080600080600080600080610100898b03121561546057600080fd5b61546989614a9b565b975061547760208a01614a9b565b965061548560408a01614a9b565b955061549360608a01614a9b565b94506080890135935060a08901356001600160401b03808211156154b657600080fd5b6154c28c838d016152f0565b945060c08b01359150808211156154d857600080fd5b6154e48c838d01615360565b935060e08b01359150808211156154fa57600080fd5b506155078b828c016153c4565b9150509295985092959890939650565b60208101610e8e8284614bef565b60208082526019908201527f5061757361626c653a20696e6465782069732070617573656400000000000000604082015260600190565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006001820161559a5761559a615572565b5060010190565b6000815180845260005b818110156155c7576020818501810151868301820152016155ab565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061289760208301846155a1565b60006020828403121561560c57600080fd5b815161289781614a86565b6020808252602a908201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160408201526939903ab73830bab9b2b960b11b606082015260800190565b60006020828403121561567357600080fd5b8151801515811461289757600080fd5b60208082526028908201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160408201526739903830bab9b2b960c11b606082015260800190565b6000808335601e198436030181126156e257600080fd5b8301803591506001600160401b038211156156fc57600080fd5b6020019150600581901b360382131561454857600080fd5b60006020828403121561572657600080fd5b815161289781614905565b80820180821115610e8e57610e8e615572565b6000808585111561575457600080fd5b8386111561576157600080fd5b5050820193919092039150565b600060c08201888352602060018060a01b03808a16828601526040898187015260c0606087015283895180865260e088019150848b01955060005b818110156157d3578651805160ff16845286015185168684015295850195918301916001016157a9565b505060808701989098525050505060a09091019190915250949350505050565b60006040828403121561580557600080fd5b6128978383614d41565b81810381811115610e8e57610e8e615572565b60018060a01b038416815282602082015260606040820152600061584960608301846155a1565b95945050505050565b60006020828403121561586457600080fd5b81516001600160c01b038116811461289757600080fd5b634e487b7160e01b600052601260045260246000fd5b6000826158a0576158a061587b565b500690565b6001600160a01b0383168152604060208201819052600090614a7e908301846155a1565b828152604060208201526000614a7e60408301846155a1565b6000602082840312156158f457600080fd5b5051919050565b6001600160a01b03841681526101608101615923602083018580358252602090810135910152565b61593d606083016040860180358252602090810135910152565b60406080850160a0840137604060c0850160e084013782516101208301526020830151610140830152614a7e565b60018060a01b038316815260406020820152600082516060604084015261599560a08401826155a1565b90506020840151606084015260408401516080840152809150509392505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b038416815260406020820181905260009061584990830184866159b6565b60018060a01b03851681528360208201526060604082015260006117e66060830184866159b6565b600082601f830112615a3d57600080fd5b81516020615a4d614de783614d1e565b82815260059290921b84018101918181019086841115615a6c57600080fd5b8286015b84811015615285578051615a83816151df565b8352918301918301615a70565b60008060408385031215615aa357600080fd5b82516001600160401b0380821115615aba57600080fd5b615ac686838701615a2c565b93506020850151915080821115615adc57600080fd5b50615ae985828601615a2c565b9150509250929050565b8381526040602082015260006158496040830184866159b6565b60006020808385031215615b2057600080fd5b82516001600160401b03811115615b3657600080fd5b8301601f81018513615b4757600080fd5b8051615b55614de782614d1e565b81815260059190911b82018301908381019087831115615b7457600080fd5b928401925b82841015615b9b578351615b8c81614905565b82529284019290840190615b79565b979650505050505050565b600060208284031215615bb857600080fd5b8151612897816151df565b60ff8181168382160190811115610e8e57610e8e615572565b60006060820160ff8616835260206001600160601b03808716828601526040606081870152838751808652608088019150848901955060005b81811015615c4557865180516001600160a01b031684528601518516868401529585019591830191600101615c15565b50909a9950505050505050505050565b600061ffff808316818103615c6c57615c6c615572565b6001019392505050565b600060208284031215615c8857600080fd5b81516001600160e01b03198116811461289757600080fd5b6001600160601b03818116838216028082169190828114615cc357615cc3615572565b505092915050565b60006001600160601b0380841680615ce557615ce561587b565b9216919091049291505056fe5265676973747279436f6f7264696e61746f722e7570646174654f70657261745265676973747279436f6f7264696e61746f722e5f76616c696461746543687530644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47a26469706673582212208d8b4dfde053d85837f1454ad329a51343c75d718d88d9362a8d22cce02463b664736f6c63430008140033"]
    #[doc = r" ```"]
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(b"a\x01\xc0`@R4\x80\x15b\0\0\x12W`\0\x80\xfd[P`@Qb\0aK8\x03\x80b\0aK\x839\x81\x01`@\x81\x90Rb\0\05\x91b\0\x02TV[`@\x80Q\x80\x82\x01\x82R`\x16\x81R\x7fAVSRegistryCoordinator\0\0\0\0\0\0\0\0\0\0` \x80\x83\x01\x91\x82R\x83Q\x80\x85\x01\x90\x94R`\x06\x84Rev0.0.1`\xd0\x1b\x90\x84\x01R\x81Q\x90 `\xe0\x81\x90R\x7fk\xda~?8^H\x84\x10H9\x04D\xcc\xed\\\xc7\x95\xaf\x87u\x8a\xf6v\"\xe5\xf4\xf0\x88,J\x99a\x01\0\x81\x90RF`\xa0R\x87\x93\x87\x93\x87\x93\x87\x93\x91\x92\x91\x7f\x8bs\xc3\xc6\x9b\xb8\xfe=Q.\xccL\xf7Y\xccy#\x9f{\x17\x9b\x0f\xfa\xca\xa9\xa7]R+9@\x0fb\0\x015\x81\x84\x84`@\x80Q` \x81\x01\x85\x90R\x90\x81\x01\x83\x90R``\x81\x01\x82\x90RF`\x80\x82\x01R0`\xa0\x82\x01R`\0\x90`\xc0\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x93\x92PPPV[`\x80R0`\xc0Ra\x01 RPPPP`\x01`\x01`\xa0\x1b\x03\x93\x84\x16a\x01@R\x91\x83\x16a\x01\x80R\x82\x16a\x01`R\x16a\x01\xa0Rb\0\x01ob\0\x01yV[PPPPb\0\x02\xbcV[`\0Ta\x01\0\x90\x04`\xff\x16\x15b\0\x01\xe6W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`'`$\x82\x01R\x7fInitializable: contract is initi`D\x82\x01Rfalizing`\xc8\x1b`d\x82\x01R`\x84\x01`@Q\x80\x91\x03\x90\xfd[`\0T`\xff\x90\x81\x16\x10\x15b\0\x029W`\0\x80T`\xff\x19\x16`\xff\x90\x81\x17\x90\x91U`@Q\x90\x81R\x7f\x7f&\xb8?\xf9n\x1f+jh/\x138R\xf6y\x8a\t\xc4e\xda\x95\x92\x14`\xce\xfb8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xa1[V[`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x14b\0\x02QW`\0\x80\xfd[PV[`\0\x80`\0\x80`\x80\x85\x87\x03\x12\x15b\0\x02kW`\0\x80\xfd[\x84Qb\0\x02x\x81b\0\x02;V[` \x86\x01Q\x90\x94Pb\0\x02\x8b\x81b\0\x02;V[`@\x86\x01Q\x90\x93Pb\0\x02\x9e\x81b\0\x02;V[``\x86\x01Q\x90\x92Pb\0\x02\xb1\x81b\0\x02;V[\x93\x96\x92\x95P\x90\x93PPV[`\x80Q`\xa0Q`\xc0Q`\xe0Qa\x01\0Qa\x01 Qa\x01@Qa\x01`Qa\x01\x80Qa\x01\xa0Qa]\x87b\0\x03\xc4`\09`\0\x81\x81a\x067\x01R\x81\x81a\x11\x11\x01R\x81\x81a \x16\x01R\x81\x81a-I\x01R\x81\x81a5Z\x01Ra;1\x01R`\0\x81\x81a\x05|\x01R\x81\x81a\x1f\xa1\x01R\x81\x81a$K\x01R\x81\x81a,\xc9\x01R\x81\x81a4\xb1\x01R\x81\x81a7\x06\x01Ra:\xb0\x01R`\0\x81\x81a\x05B\x01R\x81\x81a\x0e\xad\x01R\x81\x81a\x1f\xdf\x01R\x81\x81a,K\x01R\x81\x81a.1\x01R\x81\x81a.\xab\x01R\x81\x81a41\x01Ra;\xad\x01R`\0\x81\x81a\x04\x86\x01R\x81\x81a+\xa1\x01Ra3y\x01R`\0a=\xb4\x01R`\0a>\x03\x01R`\0a=\xde\x01R`\0a=7\x01R`\0a=a\x01R`\0a=\x8b\x01Ra]\x87`\0\xf3\xfe`\x80`@R4\x80\x15a\0\x10W`\0\x80\xfd[P`\x046\x10a\x02\x94W`\05`\xe0\x1c\x80c]\xf4YF\x11a\x01gW\x80c\x9f\xea\xb8Y\x11a\0\xceW\x80c\xd7[L\x88\x11a\0\x87W\x80c\xd7[L\x88\x14a\x06\xf5W\x80c\xdd\x82\x83\xf3\x14a\x07\x08W\x80c\xe6W\x97\xad\x14a\x07\x1bW\x80c\xf2\xfd\xe3\x8b\x14a\x07\xbeW\x80c\xfa\xbc\x1c\xbc\x14a\x07\xd1W\x80c\xfd9\x10Z\x14a\x07\xe4W`\0\x80\xfd[\x80c\x9f\xea\xb8Y\x14a\x06YW\x80c\xa5\x08W\xbf\x14a\x06\x80W\x80c\xc3\x91B^\x14a\x06\x93W\x80c\xca\r\xe8\x82\x14a\x06\xb3W\x80c\xcaO-\x97\x14a\x06\xdaW\x80c\xd7-\x8d\xd6\x14a\x06\xedW`\0\x80\xfd[\x80c\x87\x1e\xf0I\x11a\x01 W\x80c\x87\x1e\xf0I\x14a\x05\xccW\x80c\x88o\x11\x95\x14a\x05\xdfW\x80c\x8d\xa5\xcb[\x14a\x05\xf8W\x80c\x9a\xa1e=\x14a\x06\0W\x80c\x9b]\x17{\x14a\x06\x1fW\x80c\x9e\x99#\xc2\x14a\x062W`\0\x80\xfd[\x80c]\xf4YF\x14a\x05=W\x80ccG\xc9\0\x14a\x05dW\x80ch0H5\x14a\x05wW\x80cn;\x17\xdb\x14a\x05\x9eW\x80cqP\x18\xa6\x14a\x05\xb1W\x80c\x84\xcaR\x13\x14a\x05\xb9W`\0\x80\xfd[\x80c(\xf6\x1b1\x11a\x02\x0bW\x80cQ@\xa5H\x11a\x01\xc4W\x80cQ@\xa5H\x14a\x04\xc8W\x80cXe\xc6\x0c\x14a\x04\xdbW\x80cY\\jg\x14a\x04\xfbW\x80cZ\xc8j\xb7\x14a\x05\x03W\x80c[\x0b\x82\x9f\x14a\x05\"W\x80c\\\x97Z\xbb\x14a\x055W`\0\x80\xfd[\x80c(\xf6\x1b1\x14a\x045W\x80c)k\xb0d\x14a\x04HW\x80c)\xd1\xe0\xc3\x14a\x04[W\x80c,\xdd\x1e\x86\x14a\x04nW\x80c9\x98\xfd\xd3\x14a\x04\x81W\x80c<*\x7fL\x14a\x04\xa8W`\0\x80\xfd[\x80c\x10\xd6z/\x11a\x02]W\x80c\x10\xd6z/\x14a\x03JW\x80c\x13T*N\x14a\x03]W\x80c\x13d9\xdd\x14a\x03\x86W\x80c\x14x\x85\x1f\x14a\x03\x99W\x80c\x1e\xb8\x12\xda\x14a\x03\xccW\x80c$\x9a\x0cB\x14a\x04\x15W`\0\x80\xfd[\x80b\xcf*\xb5\x14a\x02\x99W\x80c\x03\xfd4\x92\x14a\x02\xaeW\x80c\x04\xeccQ\x14a\x02\xe1W\x80c\x05C\x10\xe6\x14a\x03\x0cW\x80c\x0c\xf4\xb7g\x14a\x037W[`\0\x80\xfd[a\x02\xaca\x02\xa76`\x04aH\xabV[a\x08 V[\0[a\x02\xcea\x02\xbc6`\x04aH\xecV[`\0\x90\x81R`\x98` R`@\x90 T\x90V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xf3[a\x02\xf4a\x02\xef6`\x04aI\x17V[a\t5V[`@Q`\x01`\x01`\xc0\x1b\x03\x90\x91\x16\x81R` \x01a\x02\xd8V[`\x9dTa\x03\x1f\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[`@Q`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x81R` \x01a\x02\xd8V[a\x02\xaca\x03E6`\x04aJ6V[a\x0b+V[a\x02\xaca\x03X6`\x04aJ\xabV[a\x0c\x13V[a\x02\xcea\x03k6`\x04aJ\xabV[`\x01`\x01`\xa0\x1b\x03\x16`\0\x90\x81R`\x99` R`@\x90 T\x90V[a\x02\xaca\x03\x946`\x04aH\xecV[a\x0c\xc6V[a\x03\xbca\x03\xa76`\x04aH\xecV[`\x9a` R`\0\x90\x81R`@\x90 T`\xff\x16\x81V[`@Q\x90\x15\x15\x81R` \x01a\x02\xd8V[a\x03\xdfa\x03\xda6`\x04aJ\xc8V[a\x0e\x03V[`@\x80Q\x82Qc\xff\xff\xff\xff\x90\x81\x16\x82R` \x80\x85\x01Q\x90\x91\x16\x90\x82\x01R\x91\x81\x01Q`\x01`\x01`\xc0\x1b\x03\x16\x90\x82\x01R``\x01a\x02\xd8V[a\x02\xcea\x04#6`\x04aJ\xfbV[`\x9b` R`\0\x90\x81R`@\x90 T\x81V[`\x9eTa\x03\x1f\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[a\x03\x1fa\x04V6`\x04aH\xecV[a\x0e\x94V[a\x02\xaca\x04i6`\x04aJ\xabV[a\x0f V[a\x02\xaca\x04|6`\x04aJ\xabV[a\x0f1V[a\x03\x1f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x04\xbba\x04\xb66`\x04aJ\xabV[a\x0fBV[`@Qa\x02\xd8\x91\x90aK\x16V[a\x02\xaca\x04\xd66`\x04aKnV[a\x0f\xc1V[a\x04\xeea\x04\xe96`\x04aJ\xabV[a\x14\xd1V[`@Qa\x02\xd8\x91\x90aL\x11V[a\x02\xaca\x15EV[a\x03\xbca\x05\x116`\x04aJ\xfbV[`\x01\x80T`\xff\x90\x92\x16\x1b\x90\x81\x16\x14\x90V[a\x02\xaca\x0506`\x04aL\x96V[a\x16\x11V[`\x01Ta\x02\xceV[a\x03\x1f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x1fa\x05r6`\x04aH\xecV[a\x16\xa8V[a\x03\x1f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\xaca\x05\xac6`\x04aL\xcaV[a\x16\xd2V[a\x02\xaca\x17\x92V[a\x02\xcea\x05\xc76`\x04aM\x81V[a\x17\xa6V[a\x02\xf4a\x05\xda6`\x04aH\xecV[a\x17\xf0V[`\0Ta\x03\x1f\x90b\x01\0\0\x90\x04`\x01`\x01`\xa0\x1b\x03\x16\x81V[a\x03\x1fa\x17\xfbV[`\x96Ta\x06\r\x90`\xff\x16\x81V[`@Q`\xff\x90\x91\x16\x81R` \x01a\x02\xd8V[a\x02\xaca\x06-6`\x04aO\x1aV[a\x18\x14V[a\x03\x1f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\xce\x7f+\xd8!$\x05\x7f\t\x13\xbc;w,\xe7\xb8>\x80W\xc1\xad\x1f5\x10\xfc\x83w\x8b\xe2\x0f\x10\xec]\xe6\x81V[a\x02\xaca\x06\x8e6`\x04aP\x13V[a\x1bKV[a\x06\xa6a\x06\xa16`\x04aP\xbbV[a\x1c\xceV[`@Qa\x02\xd8\x91\x90aQ`V[a\x02\xce\x7fM@N2v\xe7\xac!c\xd8\xeeGj\xfajA\xd1\xf6\x8f\xb7\x1f-\x8beF\xb2NU\xce\x01\xb7*\x81V[a\x02\xaca\x06\xe86`\x04aQ\xaaV[a\x1d\x87V[`\x9cTa\x02\xceV[a\x02\xaca\x07\x036`\x04aR\x90V[a\x1d\xedV[a\x02\xaca\x07\x166`\x04aTCV[a\x1e\0V[a\x07\x8aa\x07)6`\x04aJ\xfbV[`@\x80Q``\x80\x82\x01\x83R`\0\x80\x83R` \x80\x84\x01\x82\x90R\x92\x84\x01\x81\x90R`\xff\x94\x90\x94\x16\x84R`\x97\x82R\x92\x82\x90 \x82Q\x93\x84\x01\x83RTc\xff\xff\xff\xff\x81\x16\x84Ra\xff\xff`\x01` \x1b\x82\x04\x81\x16\x92\x85\x01\x92\x90\x92R`\x01`0\x1b\x90\x04\x16\x90\x82\x01R\x90V[`@\x80Q\x82Qc\xff\xff\xff\xff\x16\x81R` \x80\x84\x01Qa\xff\xff\x90\x81\x16\x91\x83\x01\x91\x90\x91R\x92\x82\x01Q\x90\x92\x16\x90\x82\x01R``\x01a\x02\xd8V[a\x02\xaca\x07\xcc6`\x04aJ\xabV[a!\x04V[a\x02\xaca\x07\xdf6`\x04aH\xecV[a!zV[a\x08\x13a\x07\xf26`\x04aJ\xabV[`\x01`\x01`\xa0\x1b\x03\x16`\0\x90\x81R`\x99` R`@\x90 `\x01\x01T`\xff\x16\x90V[`@Qa\x02\xd8\x91\x90aU\x17V[`\x01T`\x02\x90`\x04\x90\x81\x16\x03a\x08QW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[`@Q\x80\x91\x03\x90\xfd[`\0[\x82\x81\x10\x15a\t/W`\0\x84\x84\x83\x81\x81\x10a\x08pWa\x08paU\\V[\x90P` \x02\x01` \x81\x01\x90a\x08\x85\x91\x90aJ\xabV[`\x01`\x01`\xa0\x1b\x03\x81\x16`\0\x90\x81R`\x99` \x90\x81R`@\x80\x83 \x81Q\x80\x83\x01\x90\x92R\x80T\x82R`\x01\x81\x01T\x94\x95P\x92\x93\x90\x92\x91\x83\x01\x90`\xff\x16`\x02\x81\x11\x15a\x08\xd0Wa\x08\xd0aK\xd9V[`\x02\x81\x11\x15a\x08\xe1Wa\x08\xe1aK\xd9V[\x90RP\x80Q\x90\x91P`\0a\x08\xf4\x82a\"\xd6V[\x90P`\0a\t\n\x82`\x01`\x01`\xc0\x1b\x03\x16a#AV[\x90Pa\t\x17\x85\x85\x83a$\rV[PPPPP\x80\x80a\t'\x90aU\x88V[\x91PPa\x08TV[PPPPV[`\0\x83\x81R`\x98` R`@\x81 \x80T\x82\x91\x90\x84\x90\x81\x10a\tXWa\tXaU\\V[`\0\x91\x82R` \x91\x82\x90 `@\x80Q``\x81\x01\x82R\x92\x90\x91\x01Tc\xff\xff\xff\xff\x80\x82\x16\x80\x85R`\x01` \x1b\x83\x04\x82\x16\x95\x85\x01\x95\x90\x95R`\x01`@\x1b\x90\x91\x04`\x01`\x01`\xc0\x1b\x03\x16\x91\x83\x01\x91\x90\x91R\x90\x92P\x85\x16\x10\x15a\nRW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`e`$\x82\x01R\x7fRegistryCoordinator.getQuorumBit`D\x82\x01R\x7fmapAtBlockNumberByIndex: quorumB`d\x82\x01R\x7fitmapUpdate is from after blockN`\x84\x82\x01Rd:\xb6\xb12\xb9`\xd9\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[` \x81\x01Qc\xff\xff\xff\xff\x16\x15\x80a\nxWP\x80` \x01Qc\xff\xff\xff\xff\x16\x84c\xff\xff\xff\xff\x16\x10[a\x0b\x1fW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`f`$\x82\x01R\x7fRegistryCoordinator.getQuorumBit`D\x82\x01R\x7fmapAtBlockNumberByIndex: quorumB`d\x82\x01R\x7fitmapUpdate is from before block`\x84\x82\x01Re':\xb6\xb12\xb9`\xd1\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[`@\x01Q\x94\x93PPPPV[`\x013`\0\x90\x81R`\x99` R`@\x90 `\x01\x01T`\xff\x16`\x02\x81\x11\x15a\x0bTWa\x0bTaK\xd9V[\x14a\x0b\xc7W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`<`$\x82\x01R\x7fRegistryCoordinator.updateSocket`D\x82\x01R\x7f: operator is not registered\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[3`\0\x90\x81R`\x99` R`@\x90\x81\x90 T\x90Q\x7f\xec)c\xab!\xc1\xe5\x0e\x1eX*\xa5B\xaf.K\xf7\xbf8\xe6\xe1@<'\xb4.\x1c]nb\x1e\xaa\x90a\x0c\x08\x90\x84\x90aU\xe7V[`@Q\x80\x91\x03\x90\xa2PV[`\0`\x02\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xa0\x1b\x03\x16`\x01`\x01`\xa0\x1b\x03\x16c\xea\xb6mz`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0cfW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0c\x8a\x91\x90aU\xfaV[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a\x0c\xbaW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aV\x17V[a\x0c\xc3\x81a$\xfaV[PV[`\0T`@Qc#}\xfbG`\xe1\x1b\x81R3`\x04\x82\x01Rb\x01\0\0\x90\x91\x04`\x01`\x01`\xa0\x1b\x03\x16\x90cF\xfb\xf6\x8e\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\r\x13W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r7\x91\x90aVaV[a\rSW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aV\x83V[`\x01T\x81\x81\x16\x14a\r\xccW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7fPausable.pause: invalid attempt `D\x82\x01R\x7fto unpause functionality\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[`\x01\x81\x90U`@Q\x81\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01a\x0c\x08V[`@\x80Q``\x81\x01\x82R`\0\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x91\x90\x91R`\0\x83\x81R`\x98` R`@\x90 \x80T\x83\x90\x81\x10a\x0e@Wa\x0e@aU\\V[`\0\x91\x82R` \x91\x82\x90 `@\x80Q``\x81\x01\x82R\x91\x90\x92\x01Tc\xff\xff\xff\xff\x80\x82\x16\x83R`\x01` \x1b\x82\x04\x16\x93\x82\x01\x93\x90\x93R`\x01`\x01`\xc0\x1b\x03`\x01`@\x1b\x90\x93\x04\x92\x90\x92\x16\x90\x82\x01R\x90P[\x92\x91PPV[`@Qc\x08\xf6b\x9d`\xe3\x1b\x81R`\x04\x81\x01\x82\x90R`\0\x90\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x90cG\xb3\x14\xe8\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0e\xfcW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0e\x8e\x91\x90aU\xfaV[a\x0f(a%\xffV[a\x0c\xc3\x81a&^V[a\x0f9a%\xffV[a\x0c\xc3\x81a&\xc7V[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01Ra\x0e\x8ea\x0f\xbc\x7f+\xd8!$\x05\x7f\t\x13\xbc;w,\xe7\xb8>\x80W\xc1\xad\x1f5\x10\xfc\x83w\x8b\xe2\x0f\x10\xec]\xe6\x84`@Q` \x01a\x0f\xa1\x92\x91\x90\x91\x82R`\x01`\x01`\xa0\x1b\x03\x16` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a'0V[a'~V[`\x01T`\x02\x90`\x04\x90\x81\x16\x03a\x0f\xe9W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[`\0a\x101\x84\x84\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPP`\x96T`\xff\x16\x91Pa(\r\x90PV[\x90P\x84\x83\x14a\x10\xa2W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`C`$\x82\x01R`\0\x80Q` a\\\xf2\x839\x81Q\x91R`D\x82\x01R\x7forsForQuorum: input length misma`d\x82\x01Rb\x0e\x8cm`\xeb\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\0[\x83\x81\x10\x15a\x14\xc8W`\0\x85\x85\x83\x81\x81\x10a\x10\xc1Wa\x10\xc1aU\\V[\x91\x90\x91\x015`\xf8\x1c\x91P6\x90P`\0\x89\x89\x85\x81\x81\x10a\x10\xe2Wa\x10\xe2aU\\V[\x90P` \x02\x81\x01\x90a\x10\xf4\x91\x90aV\xcbV[`@Qcy\xa0\x84\x91`\xe1\x1b\x81R`\xff\x86\x16`\x04\x82\x01R\x91\x93P\x91P\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x90c\xf3A\t\"\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x11`W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\x84\x91\x90aW\x14V[c\xff\xff\xff\xff\x16\x81\x14a\x12 W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`e`$\x82\x01R`\0\x80Q` a\\\xf2\x839\x81Q\x91R`D\x82\x01R\x7forsForQuorum: number of updated `d\x82\x01R\x7foperators does not match quorum `\x84\x82\x01Rd\x1d\x1b\xdd\x18[`\xda\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[`\0\x80[\x82\x81\x10\x15a\x14gW`\0\x84\x84\x83\x81\x81\x10a\x12@Wa\x12@aU\\V[\x90P` \x02\x01` \x81\x01\x90a\x12U\x91\x90aJ\xabV[`\x01`\x01`\xa0\x1b\x03\x81\x16`\0\x90\x81R`\x99` \x90\x81R`@\x80\x83 \x81Q\x80\x83\x01\x90\x92R\x80T\x82R`\x01\x81\x01T\x94\x95P\x92\x93\x90\x92\x91\x83\x01\x90`\xff\x16`\x02\x81\x11\x15a\x12\xa0Wa\x12\xa0aK\xd9V[`\x02\x81\x11\x15a\x12\xb1Wa\x12\xb1aK\xd9V[\x90RP\x80Q\x90\x91P`\0a\x12\xc4\x82a\"\xd6V[\x90P`\x01`\x01`\x01`\xc0\x1b\x03\x82\x16`\xff\x8b\x16\x1c\x81\x16\x14a\x13HW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R`\0\x80Q` a\\\xf2\x839\x81Q\x91R\x90\x82\x01R\x7forsForQuorum: operator not in qu`d\x82\x01Rcorum`\xe0\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[\x85`\x01`\x01`\xa0\x1b\x03\x16\x84`\x01`\x01`\xa0\x1b\x03\x16\x11a\x13\xf3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`g`$\x82\x01R`\0\x80Q` a\\\xf2\x839\x81Q\x91R`D\x82\x01R\x7forsForQuorum: operators array mu`d\x82\x01R\x7fst be sorted in ascending addres`\x84\x82\x01Rf9\x907\xb922\xb9`\xc9\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[Pa\x14Q\x83\x83\x8f\x8f\x8d\x90\x8e`\x01a\x14\n\x91\x90aW1V[\x92a\x14\x17\x93\x92\x91\x90aWDV[\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa$\r\x92PPPV[P\x90\x92Pa\x14`\x90P\x81aU\x88V[\x90Pa\x12$V[P`\xff\x84\x16`\0\x81\x81R`\x9b` \x90\x81R`@\x91\x82\x90 C\x90\x81\x90U\x91Q\x91\x82R\x7fF\x07}U3\x07c\xf1bi\xfdu\xe5v\x16c\xf4\x19-'\x91t|\x01\x89\xb1j\xd3\x1d\xb0}\xb4\x91\x01`@Q\x80\x91\x03\x90\xa2PPPP\x80a\x14\xc1\x90aU\x88V[\x90Pa\x10\xa5V[PPPPPPPV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R`\x01`\x01`\xa0\x1b\x03\x82\x16`\0\x90\x81R`\x99` \x90\x81R`@\x91\x82\x90 \x82Q\x80\x84\x01\x90\x93R\x80T\x83R`\x01\x81\x01T\x90\x91\x83\x01\x90`\xff\x16`\x02\x81\x11\x15a\x15+Wa\x15+aK\xd9V[`\x02\x81\x11\x15a\x15<Wa\x15<aK\xd9V[\x90RP\x92\x91PPV[`\0T`@Qc#}\xfbG`\xe1\x1b\x81R3`\x04\x82\x01Rb\x01\0\0\x90\x91\x04`\x01`\x01`\xa0\x1b\x03\x16\x90cF\xfb\xf6\x8e\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x15\x92W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15\xb6\x91\x90aVaV[a\x15\xd2W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aV\x83V[`\0\x19`\x01\x81\x90U`@Q\x90\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01`@Q\x80\x91\x03\x90\xa2V[a\x16\x19a%\xffV[`\x96T\x82\x90`\xff\x90\x81\x16\x90\x82\x16\x10a\x16\x99W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`7`$\x82\x01R\x7fRegistryCoordinator.quorumExists`D\x82\x01R\x7f: quorum does not exist\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[a\x16\xa3\x83\x83a(\x9eV[PPPV[`\x9c\x81\x81T\x81\x10a\x16\xb8W`\0\x80\xfd[`\0\x91\x82R` \x90\x91 \x01T`\x01`\x01`\xa0\x1b\x03\x16\x90P\x81V[`\x9eT`\x01`\x01`\xa0\x1b\x03\x163\x14a\x17RW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`:`$\x82\x01R\x7fRegistryCoordinator.onlyEjector:`D\x82\x01R\x7f caller is not the ejector\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[a\x16\xa3\x83\x83\x83\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa)K\x92PPPV[a\x17\x9aa%\xffV[a\x17\xa4`\0a-\xbdV[V[`\0a\x17\xe6\x7fM@N2v\xe7\xac!c\xd8\xeeGj\xfajA\xd1\xf6\x8f\xb7\x1f-\x8beF\xb2NU\xce\x01\xb7*\x87\x87\x87\x87\x87`@Q` \x01a\x0f\xa1\x96\x95\x94\x93\x92\x91\x90aWnV[\x96\x95PPPPPPV[`\0a\x0e\x8e\x82a\"\xd6V[`\0a\x18\x0f`dT`\x01`\x01`\xa0\x1b\x03\x16\x90V[\x90P\x90V[`\x01\x80T`\0\x91\x90\x81\x16\x03a\x18;W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[\x83\x89\x14a\x18\xbeW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R\x7fRegistryCoordinator.registerOper\x90\x82\x01R\x7fatorWithChurn: input length mism`d\x82\x01Rc\x0c.\x8cm`\xe3\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\0a\x18\xca3\x88a.\x0fV[\x90Pa\x19*3\x82\x88\x88\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01`\0\x90[\x82\x82\x10\x15a\x19\x1fWa\x19\x10`@\x83\x02\x86\x016\x81\x90\x03\x81\x01\x90aW\xf3V[\x81R` \x01\x90`\x01\x01\x90a\x18\xf3V[PPPPP\x87a/DV[`\0a\x19q3\x83\x8e\x8e\x8e\x8e\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP\x8c\x92Pa0\xd1\x91PPV[\x90P`\0[\x8b\x81\x10\x15a\x1b<W`\0`\x97`\0\x8f\x8f\x85\x81\x81\x10a\x19\x96Wa\x19\x96aU\\V[\x91\x90\x91\x015`\xf8\x1c\x82RP` \x80\x82\x01\x92\x90\x92R`@\x90\x81\x01`\0 \x81Q``\x81\x01\x83R\x90Tc\xff\xff\xff\xff\x81\x16\x80\x83Ra\xff\xff`\x01` \x1b\x83\x04\x81\x16\x95\x84\x01\x95\x90\x95R`\x01`0\x1b\x90\x91\x04\x90\x93\x16\x91\x81\x01\x91\x90\x91R\x84Q\x80Q\x91\x93P\x90\x84\x90\x81\x10a\x1a\x03Wa\x1a\x03aU\\V[` \x02` \x01\x01Qc\xff\xff\xff\xff\x16\x11\x15a\x1b)Wa\x1a\xa4\x8e\x8e\x84\x81\x81\x10a\x1a,Wa\x1a,aU\\V[\x90P\x015`\xf8\x1c`\xf8\x1b`\xf8\x1c\x84`@\x01Q\x84\x81Q\x81\x10a\x1aOWa\x1aOaU\\V[` \x02` \x01\x01Q3\x86` \x01Q\x86\x81Q\x81\x10a\x1anWa\x1anaU\\V[` \x02` \x01\x01Q\x8d\x8d\x88\x81\x81\x10a\x1a\x88Wa\x1a\x88aU\\V[\x90P`@\x02\x01\x806\x03\x81\x01\x90a\x1a\x9e\x91\x90aW\xf3V[\x86a5\xe8V[a\x1b)\x89\x89\x84\x81\x81\x10a\x1a\xb9Wa\x1a\xb9aU\\V[\x90P`@\x02\x01` \x01` \x81\x01\x90a\x1a\xd1\x91\x90aJ\xabV[\x8f\x8f\x85\x90\x86`\x01a\x1a\xe2\x91\x90aW1V[\x92a\x1a\xef\x93\x92\x91\x90aWDV[\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa)K\x92PPPV[P\x80a\x1b4\x81aU\x88V[\x91PPa\x19vV[PPPPPPPPPPPPPV[`\x01\x80T`\0\x91\x90\x81\x16\x03a\x1brW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[`\0a\x1b~3\x85a.\x0fV[\x90P`\0a\x1b\xc73\x83\x8b\x8b\x8b\x8b\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP\x8c\x92Pa0\xd1\x91PPV[Q\x90P`\0[\x88\x81\x10\x15a\x1c\xc2W`\0\x8a\x8a\x83\x81\x81\x10a\x1b\xe9Wa\x1b\xe9aU\\V[\x91\x90\x91\x015`\xf8\x1c`\0\x81\x81R`\x97` R`@\x90 T\x85Q\x91\x93Pc\xff\xff\xff\xff\x16\x91P\x84\x90\x84\x90\x81\x10a\x1c\x1fWa\x1c\x1faU\\V[` \x02` \x01\x01Qc\xff\xff\xff\xff\x16\x11\x15a\x1c\xafW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R\x7fRegistryCoordinator.registerOper\x90\x82\x01R\x7fator: operator count exceeds max`d\x82\x01Rcimum`\xe0\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[P\x80a\x1c\xba\x81aU\x88V[\x91PPa\x1b\xcdV[PPPPPPPPPPV[```\0\x82Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\x1c\xebWa\x1c\xebaIOV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1d\x14W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x83Q\x81\x10\x15a\x1d\x7fWa\x1dF\x85\x85\x83\x81Q\x81\x10a\x1d9Wa\x1d9aU\\V[` \x02` \x01\x01Qa8\xbcV[\x82\x82\x81Q\x81\x10a\x1dXWa\x1dXaU\\V[c\xff\xff\xff\xff\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x80a\x1dw\x81aU\x88V[\x91PPa\x1d\x1aV[P\x93\x92PPPV[`\x01\x80T`\x02\x90\x81\x16\x03a\x1d\xadW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[a\x16\xa33\x84\x84\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa)K\x92PPPV[a\x1d\xf5a%\xffV[a\x16\xa3\x83\x83\x83a9\xf8V[`\0Ta\x01\0\x90\x04`\xff\x16\x15\x80\x80\x15a\x1e WP`\0T`\x01`\xff\x90\x91\x16\x10[\x80a\x1e:WP0;\x15\x80\x15a\x1e:WP`\0T`\xff\x16`\x01\x14[a\x1e\x9dW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7fInitializable: contract is alrea`D\x82\x01Rm\x19\x1eH\x1a[\x9a]\x1aX[\x1a^\x99Y`\x92\x1b`d\x82\x01R`\x84\x01a\x08HV[`\0\x80T`\xff\x19\x16`\x01\x17\x90U\x80\x15a\x1e\xc0W`\0\x80Ta\xff\0\x19\x16a\x01\0\x17\x90U[\x82Q\x84Q\x14\x80\x15a\x1e\xd2WP\x81Q\x83Q\x14[a\x1f<W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7fRegistryCoordinator.initialize: `D\x82\x01Rt\r-\xce\x0e\xae\x84\r\x8c\xad\xcc\xee\x8d\x04\r\xad.m\xac.\x8cm`[\x1b`d\x82\x01R`\x84\x01a\x08HV[a\x1fE\x89a-\xbdV[a\x1fO\x86\x86a<\x0fV[a\x1fX\x88a&^V[a\x1fa\x87a&\xc7V[`\x9c\x80T`\x01\x81\x81\x01\x83U`\0\x83\x81R\x7f\xaf\x85\xb9\x07\x1d\xfa\xfe\xac\x14\t\xd3\xf1\xd1\x9b\xaf\xc9\xbc|7\x97L\xde\x8d\xf0\xeeah\xf0\x08nS\x9c\x92\x83\x01\x80T`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x01`\x01`\xa0\x1b\x03\x19\x92\x83\x16\x17\x90\x92U\x85T\x80\x85\x01\x87U\x85\x01\x80T\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\x16\x90\x83\x16\x17\x90U\x85T\x93\x84\x01\x90\x95U\x91\x90\x92\x01\x80T\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16\x91\x90\x93\x16\x17\x90\x91U[\x84Q\x81\x10\x15a \xb2Wa \xa0\x85\x82\x81Q\x81\x10a _Wa _aU\\V[` \x02` \x01\x01Q\x85\x83\x81Q\x81\x10a yWa yaU\\V[` \x02` \x01\x01Q\x85\x84\x81Q\x81\x10a \x93Wa \x93aU\\V[` \x02` \x01\x01Qa9\xf8V[\x80a \xaa\x81aU\x88V[\x91PPa AV[P\x80\x15a \xf9W`\0\x80Ta\xff\0\x19\x16\x90U`@Q`\x01\x81R\x7f\x7f&\xb8?\xf9n\x1f+jh/\x138R\xf6y\x8a\t\xc4e\xda\x95\x92\x14`\xce\xfb8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xa1[PPPPPPPPPV[a!\x0ca%\xffV[`\x01`\x01`\xa0\x1b\x03\x81\x16a!qW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7fOwnable: new owner is the zero a`D\x82\x01Reddress`\xd0\x1b`d\x82\x01R`\x84\x01a\x08HV[a\x0c\xc3\x81a-\xbdV[`\0`\x02\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xa0\x1b\x03\x16`\x01`\x01`\xa0\x1b\x03\x16c\xea\xb6mz`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a!\xcdW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a!\xf1\x91\x90aU\xfaV[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a\"!W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aV\x17V[`\x01T\x19\x81\x19`\x01T\x19\x16\x14a\"\x9fW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7fPausable.unpause: invalid attemp`D\x82\x01R\x7ft to pause functionality\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[`\x01\x81\x90U`@Q\x81\x81R3\x90\x7f5\x82\xd1\x82\x8e&\xbfV\xbd\x80\x15\x02\xbc\x02\x1a\xc0\xbc\x8a\xfbW\xc8&\xe4\x98kEY<\x8f\xad8\x9c\x90` \x01a\x0c\x08V[`\0\x81\x81R`\x98` R`@\x81 T\x80\x82\x03a\"\xf5WP`\0\x92\x91PPV[`\0\x83\x81R`\x98` R`@\x90 a#\x0e`\x01\x83aX\x0fV[\x81T\x81\x10a#\x1eWa#\x1eaU\\V[`\0\x91\x82R` \x90\x91 \x01T`\x01`@\x1b\x90\x04`\x01`\x01`\xc0\x1b\x03\x16\x93\x92PPPV[```\0\x80a#O\x84a<\xffV[a\xff\xff\x16`\x01`\x01`@\x1b\x03\x81\x11\x15a#jWa#jaIOV[`@Q\x90\x80\x82R\x80`\x1f\x01`\x1f\x19\x16` \x01\x82\x01`@R\x80\x15a#\x94W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\0\x80[\x82Q\x82\x10\x80\x15a#\xacWPa\x01\0\x81\x10[\x15a$\x03W`\x01\x81\x1b\x93P\x85\x84\x16\x15a#\xf3W\x80`\xf8\x1b\x83\x83\x81Q\x81\x10a#\xd5Wa#\xd5aU\\V[` \x01\x01\x90`\x01`\x01`\xf8\x1b\x03\x19\x16\x90\x81`\0\x1a\x90SP\x81`\x01\x01\x91P[a#\xfc\x81aU\x88V[\x90Pa#\x9bV[P\x90\x94\x93PPPPV[`\x01\x82` \x01Q`\x02\x81\x11\x15a$%Wa$%aK\xd9V[\x14a$/WPPPV[\x81Q`@Qc3V\x7f\x7f`\xe1\x1b\x81R`\0\x90`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cf\xac\xfe\xfe\x90a$\x84\x90\x88\x90\x86\x90\x88\x90`\x04\x01aX\"V[` `@Q\x80\x83\x03\x81`\0\x87Z\xf1\x15\x80\x15a$\xa3W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a$\xc7\x91\x90aXRV[\x90P`\x01`\x01`\xc0\x1b\x03\x81\x16\x15a$\xf3Wa$\xf3\x85a$\xee\x83`\x01`\x01`\xc0\x1b\x03\x16a#AV[a)KV[PPPPPV[`\x01`\x01`\xa0\x1b\x03\x81\x16a%\x88W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`I`$\x82\x01R\x7fPausable._setPauserRegistry: new`D\x82\x01R\x7fPauserRegistry cannot be the zer`d\x82\x01Rho address`\xb8\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\0T`@\x80Q`\x01`\x01`\xa0\x1b\x03b\x01\0\0\x90\x93\x04\x83\x16\x81R\x91\x83\x16` \x83\x01R\x7fn\x9f\xcdS\x98\x96\xfc\xa6\x0e\x8b\x0f\x01\xddX\x023\xe4\x8ak\x0f}\xf0\x13\xb8\x9b\xa7\xf5e\x86\x9a\xcd\xb6\x91\x01`@Q\x80\x91\x03\x90\xa1`\0\x80T`\x01`\x01`\xa0\x1b\x03\x90\x92\x16b\x01\0\0\x02b\x01\0\0`\x01`\xb0\x1b\x03\x19\x90\x92\x16\x91\x90\x91\x17\x90UV[3a&\x08a\x17\xfbV[`\x01`\x01`\xa0\x1b\x03\x16\x14a\x17\xa4W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7fOwnable: caller is not the owner`D\x82\x01R`d\x01a\x08HV[`\x9dT`@\x80Q`\x01`\x01`\xa0\x1b\x03\x92\x83\x16\x81R\x91\x83\x16` \x83\x01R\x7f1TW\xd8\xa8\xfe`\xf0J\xf1|\x16\xe2\xf5\xa5\xe1\xdba+1d\x8eX\x03\x03`u\x9e\xf8\xf3R\x8c\x91\x01`@Q\x80\x91\x03\x90\xa1`\x9d\x80T`\x01`\x01`\xa0\x1b\x03\x19\x16`\x01`\x01`\xa0\x1b\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`\x9eT`@\x80Q`\x01`\x01`\xa0\x1b\x03\x92\x83\x16\x81R\x91\x83\x16` \x83\x01R\x7f\x8f0\xab\t\xf4:l\x15}\x7f\xce~\n\x13\xc0\x03\x04,\x1c\x95\xe8\xa7.z\x14j!\xc0\xca\xa2M\xc9\x91\x01`@Q\x80\x91\x03\x90\xa1`\x9e\x80T`\x01`\x01`\xa0\x1b\x03\x19\x16`\x01`\x01`\xa0\x1b\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`\0a\x0e\x8ea'=a=*V[\x83`@Qa\x19\x01`\xf0\x1b` \x82\x01R`\"\x81\x01\x83\x90R`B\x81\x01\x82\x90R`\0\x90`b\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x92\x91PPV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R`\0\x80\x80a'\xae`\0\x80Q` a]2\x839\x81Q\x91R\x86aX\x91V[\x90P[a'\xba\x81a>QV[\x90\x93P\x91P`\0\x80Q` a]2\x839\x81Q\x91R\x82\x83\t\x83\x03a'\xf3W`@\x80Q\x80\x82\x01\x90\x91R\x90\x81R` \x81\x01\x91\x90\x91R\x93\x92PPPV[`\0\x80Q` a]2\x839\x81Q\x91R`\x01\x82\x08\x90Pa'\xb1V[`\0\x80a(\x19\x84a>\xd3V[\x90P\x80\x83`\xff\x16`\x01\x90\x1b\x11a(\x97W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`?`$\x82\x01R\x7fBitmapUtils.orderedBytesArrayToB`D\x82\x01R\x7fitmap: bitmap exceeds max value\0`d\x82\x01R`\x84\x01a\x08HV[\x93\x92PPPV[`\xff\x82\x16`\0\x81\x81R`\x97` \x90\x81R`@\x91\x82\x90 \x84Q\x81T\x86\x84\x01\x80Q\x88\x87\x01\x80Qc\xff\xff\xff\xff\x90\x95\x16e\xff\xff\xff\xff\xff\xff\x19\x90\x94\x16\x84\x17`\x01` \x1ba\xff\xff\x93\x84\x16\x02\x17g\xff\xff\0\0\0\0\0\0\x19\x16`\x01`0\x1b\x95\x83\x16\x95\x90\x95\x02\x94\x90\x94\x17\x90\x94U\x85Q\x91\x82RQ\x83\x16\x93\x81\x01\x93\x90\x93RQ\x16\x91\x81\x01\x91\x90\x91R\x7f>\xe6\xfe\x8dTa\x02D\xc3\xe9\xd3\xc0f\xaeJ\xee\x99x\x84\xaa(\xf1\x06\x16\xae\x82\x19%@\x13\x18\xac\x90``\x01`@Q\x80\x91\x03\x90\xa2PPV[`\x01`\x01`\xa0\x1b\x03\x82\x16`\0\x90\x81R`\x99` R`@\x90 \x80T`\x01\x80\x83\x01T`\xff\x16`\x02\x81\x11\x15a)\x7fWa)\x7faK\xd9V[\x14a)\xfeW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`C`$\x82\x01R\x7fRegistryCoordinator._deregisterO`D\x82\x01R\x7fperator: operator is not registe`d\x82\x01Rb\x1c\x99Y`\xea\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\x96T`\0\x90a*\x12\x90\x85\x90`\xff\x16a(\rV[\x90P`\0a*\x1f\x83a\"\xd6V[\x90P`\x01`\x01`\xc0\x1b\x03\x82\x16a*\x9dW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`;`$\x82\x01R\x7fRegistryCoordinator._deregisterO`D\x82\x01R\x7fperator: bitmap cannot be 0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[a*\xb4`\x01`\x01`\xc0\x1b\x03\x83\x81\x16\x90\x83\x16\x81\x16\x14\x90V[a+LW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`Y`$\x82\x01R\x7fRegistryCoordinator._deregisterO`D\x82\x01R\x7fperator: operator is not registe`d\x82\x01R\x7fred for specified quorums\0\0\0\0\0\0\0`\x84\x82\x01R`\xa4\x01a\x08HV[`\x01`\x01`\xc0\x1b\x03\x82\x81\x16\x19\x82\x16\x16a+e\x84\x82a@cV[`\x01`\x01`\xc0\x1b\x03\x81\x16a,4W`\x01\x85\x01\x80T`\xff\x19\x16`\x02\x17\x90U`@QcQ\xb2zm`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x88\x81\x16`\x04\x83\x01R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xa3d\xf4\xda\x90`$\x01`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a+\xe5W`\0\x80\xfd[PZ\xf1\x15\x80\x15a+\xf9W=`\0\x80>=`\0\xfd[PP`@Q\x86\x92P`\x01`\x01`\xa0\x1b\x03\x8a\x16\x91P\x7f9o\xdc\xb1\x80\xcb\x0f\xea&\x92\x81\x13\xfb\x0f\xd1\xc3T\x98c\xf9\xcdV>j\x18O\x1dW\x81\x16\xc8\xe4\x90`\0\x90\xa3[`@Qc\xf4\xe2O\xe5`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xf4\xe2O\xe5\x90a,\x82\x90\x8a\x90\x8a\x90`\x04\x01aX\xa5V[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a,\x9cW`\0\x80\xfd[PZ\xf1\x15\x80\x15a,\xb0W=`\0\x80>=`\0\xfd[PP`@Qc\xbd)\xb8\xcd`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc\xbd)\xb8\xcd\x91Pa-\x02\x90\x87\x90\x8a\x90`\x04\x01aX\xc9V[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a-\x1cW`\0\x80\xfd[PZ\xf1\x15\x80\x15a-0W=`\0\x80>=`\0\xfd[PP`@Qc\xbd)\xb8\xcd`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc\xbd)\xb8\xcd\x91Pa-\x82\x90\x87\x90\x8a\x90`\x04\x01aX\xc9V[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a-\x9cW`\0\x80\xfd[PZ\xf1\x15\x80\x15a-\xb0W=`\0\x80>=`\0\xfd[PPPPPPPPPPPV[`d\x80T`\x01`\x01`\xa0\x1b\x03\x83\x81\x16`\x01`\x01`\xa0\x1b\x03\x19\x83\x16\x81\x17\x90\x93U`@Q\x91\x16\x91\x90\x82\x90\x7f\x8b\xe0\x07\x9cS\x16Y\x14\x13D\xcd\x1f\xd0\xa4\xf2\x84\x19I\x7f\x97\"\xa3\xda\xaf\xe3\xb4\x18okdW\xe0\x90`\0\x90\xa3PPV[`@Qc\t\xaa\x15'`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x83\x81\x16`\x04\x83\x01R`\0\x91\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x13T*N\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a.zW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a.\x9e\x91\x90aX\xe2V[\x90P`\0\x81\x90\x03a\x0e\x8eW\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xbfy\xceX\x84\x84a.\xe3\x87a\x0fBV[`@Q\x84c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a/\x01\x93\x92\x91\x90aX\xfbV[` `@Q\x80\x83\x03\x81`\0\x87Z\xf1\x15\x80\x15a/ W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a(\x97\x91\x90aX\xe2V[` \x80\x82\x01Q`\0\x90\x81R`\x9a\x90\x91R`@\x90 T`\xff\x16\x15a/\xeaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`R`$\x82\x01R\x7fRegistryCoordinator._verifyChurn`D\x82\x01R\x7fApproverSignature: churnApprover`d\x82\x01Rq\x08\x1c\xd8[\x1d\x08\x18[\x1c\x99XY\x1eH\x1d\\\xd9Y`r\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[B\x81`@\x01Q\x10\x15a0\x7fW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`R`$\x82\x01R\x7fRegistryCoordinator._verifyChurn`D\x82\x01R\x7fApproverSignature: churnApprover`d\x82\x01Rq\x08\x1c\xdaY\xdb\x98]\x1d\\\x99H\x19^\x1c\x1a\\\x99Y`r\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[` \x80\x82\x01\x80Q`\0\x90\x81R`\x9a\x90\x92R`@\x91\x82\x90 \x80T`\xff\x19\x16`\x01\x17\x90U`\x9dT\x90Q\x91\x83\x01Qa\t/\x92`\x01`\x01`\xa0\x1b\x03\x90\x92\x16\x91a0\xca\x91\x88\x91\x88\x91\x88\x91\x90a\x17\xa6V[\x83QaB$V[a0\xf5`@Q\x80``\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`\0a1=\x86\x86\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPP`\x96T`\xff\x16\x91Pa(\r\x90PV[\x90P`\0a1J\x88a\"\xd6V[\x90P`\x01`\x01`\xc0\x1b\x03\x82\x16a1\xc8W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`9`$\x82\x01R\x7fRegistryCoordinator._registerOpe`D\x82\x01R\x7frator: bitmap cannot be 0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[\x80\x82\x16`\x01`\x01`\xc0\x1b\x03\x16\x15a2~W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`h`$\x82\x01R\x7fRegistryCoordinator._registerOpe`D\x82\x01R\x7frator: operator already register`d\x82\x01R\x7fed for some quorums being regist`\x84\x82\x01Rg2\xb92\xb2\x1037\xb9`\xc1\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[`\x01`\x01`\xc0\x1b\x03\x81\x81\x16\x90\x83\x16\x17a2\x97\x89\x82a@cV[\x88\x7f\xec)c\xab!\xc1\xe5\x0e\x1eX*\xa5B\xaf.K\xf7\xbf8\xe6\xe1@<'\xb4.\x1c]nb\x1e\xaa\x87`@Qa2\xc7\x91\x90aU\xe7V[`@Q\x80\x91\x03\x90\xa2`\x01`\x01`\x01`\xa0\x1b\x03\x8b\x16`\0\x90\x81R`\x99` R`@\x90 `\x01\x01T`\xff\x16`\x02\x81\x11\x15a3\x01Wa3\x01aK\xd9V[\x14a4\x1aW`@\x80Q\x80\x82\x01\x82R\x8a\x81R`\x01` \x80\x83\x01\x82\x81R`\x01`\x01`\xa0\x1b\x03\x8f\x16`\0\x90\x81R`\x99\x90\x92R\x93\x90 \x82Q\x81U\x92Q\x83\x82\x01\x80T\x93\x94\x93\x91\x92\x90\x91`\xff\x19\x16\x90\x83`\x02\x81\x11\x15a3\\Wa3\\aK\xd9V[\x02\x17\x90UPP`@Qc\x99&\xee}`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99&\xee}\x90a3\xb1\x90\x8d\x90\x89\x90`\x04\x01aYkV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a3\xcbW`\0\x80\xfd[PZ\xf1\x15\x80\x15a3\xdfW=`\0\x80>=`\0\xfd[PP`@Q\x8b\x92P`\x01`\x01`\xa0\x1b\x03\x8d\x16\x91P\x7f\xe8\xe6\x8c\xef\x1c:v\x1e\xd7\xbe~\x84c\xa3u\xf2\x7f{\xc35\xe5\x18$\"<\xac\xcecn\xc5\xc3\xfe\x90`\0\x90\xa3[`@Qc\x1f\xd9<\xa9`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c?\xb2yR\x90a4j\x90\x8d\x90\x8c\x90\x8c\x90`\x04\x01aY\xdfV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a4\x84W`\0\x80\xfd[PZ\xf1\x15\x80\x15a4\x98W=`\0\x80>=`\0\xfd[PP`@Qc%PGw`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc%PGw\x91Pa4\xee\x90\x8d\x90\x8d\x90\x8d\x90\x8d\x90`\x04\x01aZ\x04V[`\0`@Q\x80\x83\x03\x81`\0\x87Z\xf1\x15\x80\x15a5\rW=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra55\x91\x90\x81\x01\x90aZ\x90V[`@\x80\x87\x01\x91\x90\x91R` \x86\x01\x91\x90\x91RQb\xbf\xf0M`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90b\xbf\xf0M\x90a5\x92\x90\x8c\x90\x8c\x90\x8c\x90`\x04\x01aZ\xf3V[`\0`@Q\x80\x83\x03\x81`\0\x87Z\xf1\x15\x80\x15a5\xb1W=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra5\xd9\x91\x90\x81\x01\x90a[\rV[\x84RPPP\x96\x95PPPPPPV[` \x80\x83\x01Q`\x01`\x01`\xa0\x1b\x03\x80\x82\x16`\0\x81\x81R`\x99\x90\x94R`@\x90\x93 T\x91\x92\x90\x87\x16\x03a6gW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`5`$\x82\x01R`\0\x80Q` a]\x12\x839\x81Q\x91R`D\x82\x01Rt97\x1d\x101\xb0\xb777\xba\x101\xb4:\xb97\x109\xb2\xb63`Y\x1b`d\x82\x01R`\x84\x01a\x08HV[\x87`\xff\x16\x84`\0\x01Q`\xff\x16\x14a6\xe4W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R`\0\x80Q` a]\x12\x839\x81Q\x91R`D\x82\x01R\x7frn: quorumNumber not the same as`d\x82\x01Rf\x08\x1c\xdaY\xdb\x99Y`\xca\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`@QcT\x01\xed'`\xe0\x1b\x81R`\x04\x81\x01\x82\x90R`\xff\x89\x16`$\x82\x01R`\0\x90\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x90cT\x01\xed'\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a7UW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a7y\x91\x90a[\xa6V[\x90Pa7\x85\x81\x85aC\xdeV[`\x01`\x01``\x1b\x03\x16\x86`\x01`\x01``\x1b\x03\x16\x11a8\x18W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`V`$\x82\x01R`\0\x80Q` a]\x12\x839\x81Q\x91R`D\x82\x01R\x7frn: incoming operator has insuff`d\x82\x01Ru4\xb1\xb4\xb2\xb7:\x109\xba0\xb5\xb2\x9037\xb9\x101\xb4:\xb97`Q\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[a8\"\x88\x85aD\x02V[`\x01`\x01``\x1b\x03\x16\x81`\x01`\x01``\x1b\x03\x16\x10a \xf9W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\\`$\x82\x01R`\0\x80Q` a]\x12\x839\x81Q\x91R`D\x82\x01R\x7frn: cannot kick operator with mo`d\x82\x01R\x7fre than kickBIPsOfTotalStake\0\0\0\0`\x84\x82\x01R`\xa4\x01a\x08HV[`\0\x81\x81R`\x98` R`@\x81 T\x81[\x81\x81\x10\x15a9NW`\x01a8\xe1\x82\x84aX\x0fV[a8\xeb\x91\x90aX\x0fV[\x92P\x84c\xff\xff\xff\xff\x16`\x98`\0\x86\x81R` \x01\x90\x81R` \x01`\0 \x84c\xff\xff\xff\xff\x16\x81T\x81\x10a9\x1eWa9\x1eaU\\V[`\0\x91\x82R` \x90\x91 \x01Tc\xff\xff\xff\xff\x16\x11a9<WPPa\x0e\x8eV[\x80a9F\x81aU\x88V[\x91PPa8\xcdV[P`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`l`$\x82\x01R\x7fRegistryCoordinator.getQuorumBit`D\x82\x01R\x7fmapIndexAtBlockNumber: no bitmap`d\x82\x01R\x7f update found for operatorId at `\x84\x82\x01Rk167\xb1\xb5\x907:\xb6\xb12\xb9`\xa1\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[`\x96T`\xff\x16`\xc0\x81\x10a:lW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7fRegistryCoordinator.createQuorum`D\x82\x01Rt\x0e\x88\x1bX^\x08\x1c][\xdc\x9d[\\\xc8\x1c\x99XX\xda\x19Y`Z\x1b`d\x82\x01R`\x84\x01a\x08HV[a:w\x81`\x01a[\xc3V[`\x96\x80T`\xff\x19\x16`\xff\x92\x90\x92\x16\x91\x90\x91\x17\x90U\x80a:\x96\x81\x86a(\x9eV[`@Q`\x01b\x96\xb5\x89`\xe0\x1b\x03\x19\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xffiJw\x90a:\xe9\x90\x84\x90\x88\x90\x88\x90`\x04\x01a[\xdcV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a;\x03W`\0\x80\xfd[PZ\xf1\x15\x80\x15a;\x17W=`\0\x80>=`\0\xfd[PP`@Qc\x13l\xa0\xf9`\xe1\x1b\x81R`\xff\x84\x16`\x04\x82\x01R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x92Pc&\xd9A\xf2\x91P`$\x01`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a;\x7fW`\0\x80\xfd[PZ\xf1\x15\x80\x15a;\x93W=`\0\x80>=`\0\xfd[PP`@Qc\x13l\xa0\xf9`\xe1\x1b\x81R`\xff\x84\x16`\x04\x82\x01R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x92Pc&\xd9A\xf2\x91P`$\x01`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a;\xfbW`\0\x80\xfd[PZ\xf1\x15\x80\x15a \xf9W=`\0\x80>=`\0\xfd[`\0Tb\x01\0\0\x90\x04`\x01`\x01`\xa0\x1b\x03\x16\x15\x80\x15a<6WP`\x01`\x01`\xa0\x1b\x03\x82\x16\x15\x15[a<\xb8W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fPausable._initializePauser: _ini`D\x82\x01R\x7ftializePauser() can only be call`d\x82\x01Rfed once`\xc8\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\x01\x81\x90U`@Q\x81\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01`@Q\x80\x91\x03\x90\xa2a<\xfb\x82a$\xfaV[PPV[`\0\x80[\x82\x15a\x0e\x8eWa=\x14`\x01\x84aX\x0fV[\x90\x92\x16\x91\x80a=\"\x81a\\UV[\x91PPa=\x03V[`\00`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14\x80\x15a=\x83WP\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\x14[\x15a=\xadWP\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[P`@\x80Q\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x80\x83\x01\x91\x90\x91R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x84\x01R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0``\x83\x01RF`\x80\x83\x01R0`\xa0\x80\x84\x01\x91\x90\x91R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xc0\x90\x92\x01\x90\x92R\x80Q\x91\x01 \x90V[`\0\x80\x80`\0\x80Q` a]2\x839\x81Q\x91R`\x03`\0\x80Q` a]2\x839\x81Q\x91R\x86`\0\x80Q` a]2\x839\x81Q\x91R\x88\x89\t\t\x08\x90P`\0a>\xc7\x82\x7f\x0c\x19\x13\x9c\xb8Lh\nn\x14\x11m\xa0`V\x17e\xe0Z\xa4Z\x1cr\xa3O\x08#\x05\xb6\x1f?R`\0\x80Q` a]2\x839\x81Q\x91RaD\x1cV[\x91\x95\x91\x94P\x90\x92PPPV[`\0a\x01\0\x82Q\x11\x15a?\\W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R\x7fBitmapUtils.orderedBytesArrayToB\x90\x82\x01R\x7fitmap: orderedBytesArray is too `d\x82\x01Rclong`\xe0\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[\x81Q`\0\x03a?mWP`\0\x91\x90PV[`\0\x80\x83`\0\x81Q\x81\x10a?\x83Wa?\x83aU\\V[\x01` \x01Q`\x01`\xf8\x91\x90\x91\x1c\x81\x90\x1b\x92P[\x84Q\x81\x10\x15a@ZW\x84\x81\x81Q\x81\x10a?\xb1Wa?\xb1aU\\V[\x01` \x01Q`\x01`\xf8\x91\x90\x91\x1c\x1b\x91P\x82\x82\x11a@FW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fBitmapUtils.orderedBytesArrayToB`D\x82\x01R\x7fitmap: orderedBytesArray is not `d\x82\x01Rf\x1b\xdc\x99\x19\\\x99Y`\xca\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[\x91\x81\x17\x91a@S\x81aU\x88V[\x90Pa?\x96V[P\x90\x93\x92PPPV[`\0\x82\x81R`\x98` R`@\x81 T\x90\x81\x90\x03aA\x0bW`\0\x83\x81R`\x98` \x90\x81R`@\x80\x83 \x81Q``\x81\x01\x83Rc\xff\xff\xff\xffC\x81\x16\x82R\x81\x85\x01\x86\x81R`\x01`\x01`\xc0\x1b\x03\x80\x8a\x16\x95\x84\x01\x95\x86R\x84T`\x01\x81\x01\x86U\x94\x88R\x95\x90\x96 \x91Q\x91\x90\x92\x01\x80T\x95Q\x93Q\x90\x94\x16`\x01`@\x1b\x02`\x01`\x01`@\x1b\x03\x93\x83\x16`\x01` \x1b\x02g\xff\xff\xff\xff\xff\xff\xff\xff\x19\x90\x96\x16\x91\x90\x92\x16\x17\x93\x90\x93\x17\x16\x91\x90\x91\x17\x90UPPPV[`\0\x83\x81R`\x98` R`@\x81 aA$`\x01\x84aX\x0fV[\x81T\x81\x10aA4WaA4aU\\V[`\0\x91\x82R` \x90\x91 \x01\x80T\x90\x91Pc\xff\xff\xff\xffC\x81\x16\x91\x16\x03aAvW\x80T`\x01`\x01`@\x1b\x03\x16`\x01`@\x1b`\x01`\x01`\xc0\x1b\x03\x85\x16\x02\x17\x81Ua\t/V[\x80Tc\xff\xff\xff\xffC\x81\x16`\x01` \x1b\x81\x81\x02g\xff\xff\xff\xff\0\0\0\0\x19\x90\x94\x16\x93\x90\x93\x17\x84U`\0\x87\x81R`\x98` \x90\x81R`@\x80\x83 \x81Q``\x81\x01\x83R\x94\x85R\x84\x83\x01\x84\x81R`\x01`\x01`\xc0\x1b\x03\x80\x8c\x16\x93\x87\x01\x93\x84R\x82T`\x01\x81\x01\x84U\x92\x86R\x93\x90\x94 \x94Q\x94\x01\x80T\x93Q\x91Q\x90\x92\x16`\x01`@\x1b\x02`\x01`\x01`@\x1b\x03\x91\x86\x16\x90\x96\x02g\xff\xff\xff\xff\xff\xff\xff\xff\x19\x90\x93\x16\x93\x90\x94\x16\x92\x90\x92\x17\x17\x91\x90\x91\x16\x91\x90\x91\x17\x90UPPPPV[`\x01`\x01`\xa0\x1b\x03\x83\x16;\x15aC>W`@Qc\x0b\x13]?`\xe1\x1b\x80\x82R\x90`\x01`\x01`\xa0\x1b\x03\x85\x16\x90c\x16&\xba~\x90aBd\x90\x86\x90\x86\x90`\x04\x01aX\xc9V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15aB\x81W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aB\xa5\x91\x90a\\vV[`\x01`\x01`\xe0\x1b\x03\x19\x16\x14a\x16\xa3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`S`$\x82\x01R\x7fEIP1271SignatureUtils.checkSigna`D\x82\x01R\x7fture_EIP1271: ERC1271 signature `d\x82\x01Rr\x1d\x99\\\x9aY\x9aX\xd8]\x1a[\xdb\x88\x19\x98Z[\x19Y`j\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[\x82`\x01`\x01`\xa0\x1b\x03\x16aCR\x83\x83aD\xc5V[`\x01`\x01`\xa0\x1b\x03\x16\x14a\x16\xa3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fEIP1271SignatureUtils.checkSigna`D\x82\x01R\x7fture_EIP1271: signature not from`d\x82\x01Rf\x109\xb4\xb3\xb72\xb9`\xc9\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[` \x81\x01Q`\0\x90a'\x10\x90aC\xf8\x90a\xff\xff\x16\x85a\\\xa0V[a(\x97\x91\x90a\\\xcbV[`@\x81\x01Q`\0\x90a'\x10\x90aC\xf8\x90a\xff\xff\x16\x85a\\\xa0V[`\0\x80aD'aH+V[aD/aHIV[` \x80\x82R\x81\x81\x01\x81\x90R`@\x82\x01\x81\x90R``\x82\x01\x88\x90R`\x80\x82\x01\x87\x90R`\xa0\x82\x01\x86\x90R\x82`\xc0\x83`\x05a\x07\xd0Z\x03\xfa\x92P\x82\x80aDlW\xfe[P\x82aD\xbaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x1a`$\x82\x01R\x7fBN254.expMod: call failure\0\0\0\0\0\0`D\x82\x01R`d\x01a\x08HV[PQ\x95\x94PPPPPV[`\0\x80`\0aD\xd4\x85\x85aD\xe1V[\x91P\x91Pa\x1d\x7f\x81aEOV[`\0\x80\x82Q`A\x03aE\x17W` \x83\x01Q`@\x84\x01Q``\x85\x01Q`\0\x1aaE\x0b\x87\x82\x85\x85aG\x05V[\x94P\x94PPPPaEHV[\x82Q`@\x03aE@W` \x83\x01Q`@\x84\x01QaE5\x86\x83\x83aG\xf2V[\x93P\x93PPPaEHV[P`\0\x90P`\x02[\x92P\x92\x90PV[`\0\x81`\x04\x81\x11\x15aEcWaEcaK\xd9V[\x03aEkWPV[`\x01\x81`\x04\x81\x11\x15aE\x7fWaE\x7faK\xd9V[\x03aE\xccW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7fECDSA: invalid signature\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x08HV[`\x02\x81`\x04\x81\x11\x15aE\xe0WaE\xe0aK\xd9V[\x03aF-W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x1f`$\x82\x01R\x7fECDSA: invalid signature length\0`D\x82\x01R`d\x01a\x08HV[`\x03\x81`\x04\x81\x11\x15aFAWaFAaK\xd9V[\x03aF\x99W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7fECDSA: invalid signature 's' val`D\x82\x01Raue`\xf0\x1b`d\x82\x01R`\x84\x01a\x08HV[`\x04\x81`\x04\x81\x11\x15aF\xadWaF\xadaK\xd9V[\x03a\x0c\xc3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7fECDSA: invalid signature 'v' val`D\x82\x01Raue`\xf0\x1b`d\x82\x01R`\x84\x01a\x08HV[`\0\x80\x7f\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]WnsW\xa4P\x1d\xdf\xe9/Fh\x1b \xa0\x83\x11\x15aG<WP`\0\x90P`\x03aG\xe9V[\x84`\xff\x16`\x1b\x14\x15\x80\x15aGTWP\x84`\xff\x16`\x1c\x14\x15[\x15aGeWP`\0\x90P`\x04aG\xe9V[`@\x80Q`\0\x80\x82R` \x82\x01\x80\x84R\x89\x90R`\xff\x88\x16\x92\x82\x01\x92\x90\x92R``\x81\x01\x86\x90R`\x80\x81\x01\x85\x90R`\x01\x90`\xa0\x01` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xfa\x15\x80\x15aG\xb9W=`\0\x80>=`\0\xfd[PP`@Q`\x1f\x19\x01Q\x91PP`\x01`\x01`\xa0\x1b\x03\x81\x16aG\xe2W`\0`\x01\x92P\x92PPaG\xe9V[\x91P`\0\x90P[\x94P\x94\x92PPPV[`\0\x80`\x01`\x01`\xff\x1b\x03\x83\x16\x81aH\x0f`\xff\x86\x90\x1c`\x1baW1V[\x90PaH\x1d\x87\x82\x88\x85aG\x05V[\x93P\x93PPP\x93P\x93\x91PPV[`@Q\x80` \x01`@R\x80`\x01\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`\xc0\x01`@R\x80`\x06\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\0\x80\x83`\x1f\x84\x01\x12aHyW`\0\x80\xfd[P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aH\x90W`\0\x80\xfd[` \x83\x01\x91P\x83` \x82`\x05\x1b\x85\x01\x01\x11\x15aEHW`\0\x80\xfd[`\0\x80` \x83\x85\x03\x12\x15aH\xbeW`\0\x80\xfd[\x825`\x01`\x01`@\x1b\x03\x81\x11\x15aH\xd4W`\0\x80\xfd[aH\xe0\x85\x82\x86\x01aHgV[\x90\x96\x90\x95P\x93PPPPV[`\0` \x82\x84\x03\x12\x15aH\xfeW`\0\x80\xfd[P5\x91\x90PV[c\xff\xff\xff\xff\x81\x16\x81\x14a\x0c\xc3W`\0\x80\xfd[`\0\x80`\0``\x84\x86\x03\x12\x15aI,W`\0\x80\xfd[\x835\x92P` \x84\x015aI>\x81aI\x05V[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[cNH{q`\xe0\x1b`\0R`A`\x04R`$`\0\xfd[`@Q``\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aI\x87WaI\x87aIOV[`@R\x90V[`@\x80Q\x90\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aI\x87WaI\x87aIOV[`@Q`\x1f\x82\x01`\x1f\x19\x16\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aI\xd7WaI\xd7aIOV[`@R\x91\x90PV[`\0`\x01`\x01`@\x1b\x03\x83\x11\x15aI\xf8WaI\xf8aIOV[aJ\x0b`\x1f\x84\x01`\x1f\x19\x16` \x01aI\xafV[\x90P\x82\x81R\x83\x83\x83\x01\x11\x15aJ\x1fW`\0\x80\xfd[\x82\x82` \x83\x017`\0` \x84\x83\x01\x01R\x93\x92PPPV[`\0` \x82\x84\x03\x12\x15aJHW`\0\x80\xfd[\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aJ^W`\0\x80\xfd[\x82\x01`\x1f\x81\x01\x84\x13aJoW`\0\x80\xfd[aJ~\x84\x825` \x84\x01aI\xdfV[\x94\x93PPPPV[`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x14a\x0c\xc3W`\0\x80\xfd[\x805aJ\xa6\x81aJ\x86V[\x91\x90PV[`\0` \x82\x84\x03\x12\x15aJ\xbdW`\0\x80\xfd[\x815a(\x97\x81aJ\x86V[`\0\x80`@\x83\x85\x03\x12\x15aJ\xdbW`\0\x80\xfd[PP\x805\x92` \x90\x91\x015\x91PV[\x805`\xff\x81\x16\x81\x14aJ\xa6W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aK\rW`\0\x80\xfd[a(\x97\x82aJ\xeaV[\x81Q\x81R` \x80\x83\x01Q\x90\x82\x01R`@\x81\x01a\x0e\x8eV[`\0\x80\x83`\x1f\x84\x01\x12aK?W`\0\x80\xfd[P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aKVW`\0\x80\xfd[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15aEHW`\0\x80\xfd[`\0\x80`\0\x80`@\x85\x87\x03\x12\x15aK\x84W`\0\x80\xfd[\x845`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aK\x9bW`\0\x80\xfd[aK\xa7\x88\x83\x89\x01aHgV[\x90\x96P\x94P` \x87\x015\x91P\x80\x82\x11\x15aK\xc0W`\0\x80\xfd[PaK\xcd\x87\x82\x88\x01aK-V[\x95\x98\x94\x97P\x95PPPPV[cNH{q`\xe0\x1b`\0R`!`\x04R`$`\0\xfd[`\x03\x81\x10aL\rWcNH{q`\xe0\x1b`\0R`!`\x04R`$`\0\xfd[\x90RV[\x81Q\x81R` \x80\x83\x01Q`@\x83\x01\x91aL,\x90\x84\x01\x82aK\xefV[P\x92\x91PPV[\x805a\xff\xff\x81\x16\x81\x14aJ\xa6W`\0\x80\xfd[`\0``\x82\x84\x03\x12\x15aLWW`\0\x80\xfd[aL_aIeV[\x90P\x815aLl\x81aI\x05V[\x81RaLz` \x83\x01aL3V[` \x82\x01RaL\x8b`@\x83\x01aL3V[`@\x82\x01R\x92\x91PPV[`\0\x80`\x80\x83\x85\x03\x12\x15aL\xa9W`\0\x80\xfd[aL\xb2\x83aJ\xeaV[\x91PaL\xc1\x84` \x85\x01aLEV[\x90P\x92P\x92\x90PV[`\0\x80`\0`@\x84\x86\x03\x12\x15aL\xdfW`\0\x80\xfd[\x835aL\xea\x81aJ\x86V[\x92P` \x84\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aM\x05W`\0\x80\xfd[aM\x11\x86\x82\x87\x01aK-V[\x94\x97\x90\x96P\x93\x94PPPPV[`\0`\x01`\x01`@\x1b\x03\x82\x11\x15aM7WaM7aIOV[P`\x05\x1b` \x01\x90V[`\0`@\x82\x84\x03\x12\x15aMSW`\0\x80\xfd[aM[aI\x8dV[\x90PaMf\x82aJ\xeaV[\x81R` \x82\x015aMv\x81aJ\x86V[` \x82\x01R\x92\x91PPV[`\0\x80`\0\x80`\0`\xa0\x86\x88\x03\x12\x15aM\x99W`\0\x80\xfd[\x855aM\xa4\x81aJ\x86V[\x94P` \x86\x81\x015\x94P`@\x80\x88\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aM\xc8W`\0\x80\xfd[\x88\x01`\x1f\x81\x01\x8a\x13aM\xd9W`\0\x80\xfd[\x805aM\xecaM\xe7\x82aM\x1eV[aI\xafV[\x81\x81R`\x06\x91\x90\x91\x1b\x82\x01\x84\x01\x90\x84\x81\x01\x90\x8c\x83\x11\x15aN\x0bW`\0\x80\xfd[\x92\x85\x01\x92[\x82\x84\x10\x15aN1WaN\"\x8d\x85aMAV[\x82R\x92\x84\x01\x92\x90\x85\x01\x90aN\x10V[\x99\x9c\x98\x9bP\x98\x99``\x81\x015\x99P`\x80\x015\x97\x96PPPPPPPV[`\0a\x01\0\x82\x84\x03\x12\x15aNaW`\0\x80\xfd[P\x91\x90PV[`\0\x80\x83`\x1f\x84\x01\x12aNyW`\0\x80\xfd[P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aN\x90W`\0\x80\xfd[` \x83\x01\x91P\x83` \x82`\x06\x1b\x85\x01\x01\x11\x15aEHW`\0\x80\xfd[`\0``\x82\x84\x03\x12\x15aN\xbdW`\0\x80\xfd[aN\xc5aIeV[\x90P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aN\xddW`\0\x80\xfd[\x82\x01`\x1f\x81\x01\x84\x13aN\xeeW`\0\x80\xfd[aN\xfd\x84\x825` \x84\x01aI\xdfV[\x82RP` \x82\x015` \x82\x01R`@\x82\x015`@\x82\x01R\x92\x91PPV[`\0\x80`\0\x80`\0\x80`\0\x80`\0a\x01\xa0\x8a\x8c\x03\x12\x15aO9W`\0\x80\xfd[\x895`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aOPW`\0\x80\xfd[aO\\\x8d\x83\x8e\x01aK-V[\x90\x9bP\x99P` \x8c\x015\x91P\x80\x82\x11\x15aOuW`\0\x80\xfd[aO\x81\x8d\x83\x8e\x01aK-V[\x90\x99P\x97P\x87\x91PaO\x96\x8d`@\x8e\x01aNNV[\x96Pa\x01@\x8c\x015\x91P\x80\x82\x11\x15aO\xadW`\0\x80\xfd[aO\xb9\x8d\x83\x8e\x01aNgV[\x90\x96P\x94Pa\x01`\x8c\x015\x91P\x80\x82\x11\x15aO\xd3W`\0\x80\xfd[aO\xdf\x8d\x83\x8e\x01aN\xabV[\x93Pa\x01\x80\x8c\x015\x91P\x80\x82\x11\x15aO\xf6W`\0\x80\xfd[PaP\x03\x8c\x82\x8d\x01aN\xabV[\x91PP\x92\x95\x98P\x92\x95\x98P\x92\x95\x98V[`\0\x80`\0\x80`\0\x80a\x01`\x87\x89\x03\x12\x15aP-W`\0\x80\xfd[\x865`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aPDW`\0\x80\xfd[aPP\x8a\x83\x8b\x01aK-V[\x90\x98P\x96P` \x89\x015\x91P\x80\x82\x11\x15aPiW`\0\x80\xfd[aPu\x8a\x83\x8b\x01aK-V[\x90\x96P\x94P\x84\x91PaP\x8a\x8a`@\x8b\x01aNNV[\x93Pa\x01@\x89\x015\x91P\x80\x82\x11\x15aP\xa1W`\0\x80\xfd[PaP\xae\x89\x82\x8a\x01aN\xabV[\x91PP\x92\x95P\x92\x95P\x92\x95V[`\0\x80`@\x83\x85\x03\x12\x15aP\xceW`\0\x80\xfd[\x825aP\xd9\x81aI\x05V[\x91P` \x83\x81\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aP\xf5W`\0\x80\xfd[\x84\x01`\x1f\x81\x01\x86\x13aQ\x06W`\0\x80\xfd[\x805aQ\x14aM\xe7\x82aM\x1eV[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x88\x83\x11\x15aQ3W`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15aQQW\x835\x82R\x92\x84\x01\x92\x90\x84\x01\x90aQ8V[\x80\x95PPPPPP\x92P\x92\x90PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R`\0\x91\x90\x84\x82\x01\x90`@\x85\x01\x90\x84[\x81\x81\x10\x15aQ\x9eW\x83Qc\xff\xff\xff\xff\x16\x83R\x92\x84\x01\x92\x91\x84\x01\x91`\x01\x01aQ|V[P\x90\x96\x95PPPPPPV[`\0\x80` \x83\x85\x03\x12\x15aQ\xbdW`\0\x80\xfd[\x825`\x01`\x01`@\x1b\x03\x81\x11\x15aQ\xd3W`\0\x80\xfd[aH\xe0\x85\x82\x86\x01aK-V[`\x01`\x01``\x1b\x03\x81\x16\x81\x14a\x0c\xc3W`\0\x80\xfd[`\0\x82`\x1f\x83\x01\x12aR\x05W`\0\x80\xfd[\x815` aR\x15aM\xe7\x83aM\x1eV[\x82\x81R`\x06\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aR4W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aR\x85W`@\x81\x89\x03\x12\x15aRQW`\0\x80\x81\xfd[aRYaI\x8dV[\x815aRd\x81aJ\x86V[\x81R\x81\x85\x015aRs\x81aQ\xdfV[\x81\x86\x01R\x83R\x91\x83\x01\x91`@\x01aR8V[P\x96\x95PPPPPPV[`\0\x80`\0`\xa0\x84\x86\x03\x12\x15aR\xa5W`\0\x80\xfd[aR\xaf\x85\x85aLEV[\x92P``\x84\x015aR\xbf\x81aQ\xdfV[\x91P`\x80\x84\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aR\xdaW`\0\x80\xfd[aR\xe6\x86\x82\x87\x01aQ\xf4V[\x91PP\x92P\x92P\x92V[`\0\x82`\x1f\x83\x01\x12aS\x01W`\0\x80\xfd[\x815` aS\x11aM\xe7\x83aM\x1eV[\x82\x81R``\x92\x83\x02\x85\x01\x82\x01\x92\x82\x82\x01\x91\x90\x87\x85\x11\x15aS0W`\0\x80\xfd[\x83\x87\x01[\x85\x81\x10\x15aSSWaSF\x89\x82aLEV[\x84R\x92\x84\x01\x92\x81\x01aS4V[P\x90\x97\x96PPPPPPPV[`\0\x82`\x1f\x83\x01\x12aSqW`\0\x80\xfd[\x815` aS\x81aM\xe7\x83aM\x1eV[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aS\xa0W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aR\x85W\x805aS\xb7\x81aQ\xdfV[\x83R\x91\x83\x01\x91\x83\x01aS\xa4V[`\0\x82`\x1f\x83\x01\x12aS\xd5W`\0\x80\xfd[\x815` aS\xe5aM\xe7\x83aM\x1eV[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aT\x04W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aR\x85W\x805`\x01`\x01`@\x1b\x03\x81\x11\x15aT'W`\0\x80\x81\xfd[aT5\x89\x86\x83\x8b\x01\x01aQ\xf4V[\x84RP\x91\x83\x01\x91\x83\x01aT\x08V[`\0\x80`\0\x80`\0\x80`\0\x80a\x01\0\x89\x8b\x03\x12\x15aT`W`\0\x80\xfd[aTi\x89aJ\x9bV[\x97PaTw` \x8a\x01aJ\x9bV[\x96PaT\x85`@\x8a\x01aJ\x9bV[\x95PaT\x93``\x8a\x01aJ\x9bV[\x94P`\x80\x89\x015\x93P`\xa0\x89\x015`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aT\xb6W`\0\x80\xfd[aT\xc2\x8c\x83\x8d\x01aR\xf0V[\x94P`\xc0\x8b\x015\x91P\x80\x82\x11\x15aT\xd8W`\0\x80\xfd[aT\xe4\x8c\x83\x8d\x01aS`V[\x93P`\xe0\x8b\x015\x91P\x80\x82\x11\x15aT\xfaW`\0\x80\xfd[PaU\x07\x8b\x82\x8c\x01aS\xc4V[\x91PP\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[` \x81\x01a\x0e\x8e\x82\x84aK\xefV[` \x80\x82R`\x19\x90\x82\x01R\x7fPausable: index is paused\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[cNH{q`\xe0\x1b`\0R`2`\x04R`$`\0\xfd[cNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[`\0`\x01\x82\x01aU\x9aWaU\x9aaUrV[P`\x01\x01\x90V[`\0\x81Q\x80\x84R`\0[\x81\x81\x10\x15aU\xc7W` \x81\x85\x01\x81\x01Q\x86\x83\x01\x82\x01R\x01aU\xabV[P`\0` \x82\x86\x01\x01R` `\x1f\x19`\x1f\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R`\0a(\x97` \x83\x01\x84aU\xa1V[`\0` \x82\x84\x03\x12\x15aV\x0cW`\0\x80\xfd[\x81Qa(\x97\x81aJ\x86V[` \x80\x82R`*\x90\x82\x01R\x7fmsg.sender is not permissioned a`@\x82\x01Ri9\x90:\xb780\xba\xb9\xb2\xb9`\xb1\x1b``\x82\x01R`\x80\x01\x90V[`\0` \x82\x84\x03\x12\x15aVsW`\0\x80\xfd[\x81Q\x80\x15\x15\x81\x14a(\x97W`\0\x80\xfd[` \x80\x82R`(\x90\x82\x01R\x7fmsg.sender is not permissioned a`@\x82\x01Rg9\x9080\xba\xb9\xb2\xb9`\xc1\x1b``\x82\x01R`\x80\x01\x90V[`\0\x80\x835`\x1e\x19\x846\x03\x01\x81\x12aV\xe2W`\0\x80\xfd[\x83\x01\x805\x91P`\x01`\x01`@\x1b\x03\x82\x11\x15aV\xfcW`\0\x80\xfd[` \x01\x91P`\x05\x81\x90\x1b6\x03\x82\x13\x15aEHW`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aW&W`\0\x80\xfd[\x81Qa(\x97\x81aI\x05V[\x80\x82\x01\x80\x82\x11\x15a\x0e\x8eWa\x0e\x8eaUrV[`\0\x80\x85\x85\x11\x15aWTW`\0\x80\xfd[\x83\x86\x11\x15aWaW`\0\x80\xfd[PP\x82\x01\x93\x91\x90\x92\x03\x91PV[`\0`\xc0\x82\x01\x88\x83R` `\x01\x80`\xa0\x1b\x03\x80\x8a\x16\x82\x86\x01R`@\x89\x81\x87\x01R`\xc0``\x87\x01R\x83\x89Q\x80\x86R`\xe0\x88\x01\x91P\x84\x8b\x01\x95P`\0[\x81\x81\x10\x15aW\xd3W\x86Q\x80Q`\xff\x16\x84R\x86\x01Q\x85\x16\x86\x84\x01R\x95\x85\x01\x95\x91\x83\x01\x91`\x01\x01aW\xa9V[PP`\x80\x87\x01\x98\x90\x98RPPPP`\xa0\x90\x91\x01\x91\x90\x91RP\x94\x93PPPPV[`\0`@\x82\x84\x03\x12\x15aX\x05W`\0\x80\xfd[a(\x97\x83\x83aMAV[\x81\x81\x03\x81\x81\x11\x15a\x0e\x8eWa\x0e\x8eaUrV[`\x01\x80`\xa0\x1b\x03\x84\x16\x81R\x82` \x82\x01R```@\x82\x01R`\0aXI``\x83\x01\x84aU\xa1V[\x95\x94PPPPPV[`\0` \x82\x84\x03\x12\x15aXdW`\0\x80\xfd[\x81Q`\x01`\x01`\xc0\x1b\x03\x81\x16\x81\x14a(\x97W`\0\x80\xfd[cNH{q`\xe0\x1b`\0R`\x12`\x04R`$`\0\xfd[`\0\x82aX\xa0WaX\xa0aX{V[P\x06\x90V[`\x01`\x01`\xa0\x1b\x03\x83\x16\x81R`@` \x82\x01\x81\x90R`\0\x90aJ~\x90\x83\x01\x84aU\xa1V[\x82\x81R`@` \x82\x01R`\0aJ~`@\x83\x01\x84aU\xa1V[`\0` \x82\x84\x03\x12\x15aX\xf4W`\0\x80\xfd[PQ\x91\x90PV[`\x01`\x01`\xa0\x1b\x03\x84\x16\x81Ra\x01`\x81\x01aY#` \x83\x01\x85\x805\x82R` \x90\x81\x015\x91\x01RV[aY=``\x83\x01`@\x86\x01\x805\x82R` \x90\x81\x015\x91\x01RV[`@`\x80\x85\x01`\xa0\x84\x017`@`\xc0\x85\x01`\xe0\x84\x017\x82Qa\x01 \x83\x01R` \x83\x01Qa\x01@\x83\x01RaJ~V[`\x01\x80`\xa0\x1b\x03\x83\x16\x81R`@` \x82\x01R`\0\x82Q```@\x84\x01RaY\x95`\xa0\x84\x01\x82aU\xa1V[\x90P` \x84\x01Q``\x84\x01R`@\x84\x01Q`\x80\x84\x01R\x80\x91PP\x93\x92PPPV[\x81\x83R\x81\x81` \x85\x017P`\0\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1f\x90\x91\x01`\x1f\x19\x16\x90\x91\x01\x01\x90V[`\x01`\x01`\xa0\x1b\x03\x84\x16\x81R`@` \x82\x01\x81\x90R`\0\x90aXI\x90\x83\x01\x84\x86aY\xb6V[`\x01\x80`\xa0\x1b\x03\x85\x16\x81R\x83` \x82\x01R```@\x82\x01R`\0a\x17\xe6``\x83\x01\x84\x86aY\xb6V[`\0\x82`\x1f\x83\x01\x12aZ=W`\0\x80\xfd[\x81Q` aZMaM\xe7\x83aM\x1eV[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aZlW`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aR\x85W\x80QaZ\x83\x81aQ\xdfV[\x83R\x91\x83\x01\x91\x83\x01aZpV[`\0\x80`@\x83\x85\x03\x12\x15aZ\xa3W`\0\x80\xfd[\x82Q`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aZ\xbaW`\0\x80\xfd[aZ\xc6\x86\x83\x87\x01aZ,V[\x93P` \x85\x01Q\x91P\x80\x82\x11\x15aZ\xdcW`\0\x80\xfd[PaZ\xe9\x85\x82\x86\x01aZ,V[\x91PP\x92P\x92\x90PV[\x83\x81R`@` \x82\x01R`\0aXI`@\x83\x01\x84\x86aY\xb6V[`\0` \x80\x83\x85\x03\x12\x15a[ W`\0\x80\xfd[\x82Q`\x01`\x01`@\x1b\x03\x81\x11\x15a[6W`\0\x80\xfd[\x83\x01`\x1f\x81\x01\x85\x13a[GW`\0\x80\xfd[\x80Qa[UaM\xe7\x82aM\x1eV[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15a[tW`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15a[\x9bW\x83Qa[\x8c\x81aI\x05V[\x82R\x92\x84\x01\x92\x90\x84\x01\x90a[yV[\x97\x96PPPPPPPV[`\0` \x82\x84\x03\x12\x15a[\xb8W`\0\x80\xfd[\x81Qa(\x97\x81aQ\xdfV[`\xff\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x0e\x8eWa\x0e\x8eaUrV[`\0``\x82\x01`\xff\x86\x16\x83R` `\x01`\x01``\x1b\x03\x80\x87\x16\x82\x86\x01R`@``\x81\x87\x01R\x83\x87Q\x80\x86R`\x80\x88\x01\x91P\x84\x89\x01\x95P`\0[\x81\x81\x10\x15a\\EW\x86Q\x80Q`\x01`\x01`\xa0\x1b\x03\x16\x84R\x86\x01Q\x85\x16\x86\x84\x01R\x95\x85\x01\x95\x91\x83\x01\x91`\x01\x01a\\\x15V[P\x90\x9a\x99PPPPPPPPPPV[`\0a\xff\xff\x80\x83\x16\x81\x81\x03a\\lWa\\laUrV[`\x01\x01\x93\x92PPPV[`\0` \x82\x84\x03\x12\x15a\\\x88W`\0\x80\xfd[\x81Q`\x01`\x01`\xe0\x1b\x03\x19\x81\x16\x81\x14a(\x97W`\0\x80\xfd[`\x01`\x01``\x1b\x03\x81\x81\x16\x83\x82\x16\x02\x80\x82\x16\x91\x90\x82\x81\x14a\\\xc3Wa\\\xc3aUrV[PP\x92\x91PPV[`\0`\x01`\x01``\x1b\x03\x80\x84\x16\x80a\\\xe5Wa\\\xe5aX{V[\x92\x16\x91\x90\x91\x04\x92\x91PPV\xfeRegistryCoordinator.updateOperatRegistryCoordinator._validateChu0dNr\xe11\xa0)\xb8PE\xb6\x81\x81X]\x97\x81j\x91hq\xca\x8d< \x8c\x16\xd8|\xfdG\xa2dipfsX\"\x12 \x8d\x8bM\xfd\xe0S\xd8X7\xf1EJ\xd3)\xa5\x13C\xc7]q\x8d\x88\xd96*\x8d\"\xcc\xe0$c\xb6dsolcC\0\x08\x14\03");
    #[doc = r" The runtime bytecode of the contract, as deployed on the network."]
    #[doc = r""]
    #[doc = r" ```text"]
    #[doc = "0x608060405234801561001057600080fd5b50600436106102945760003560e01c80635df45946116101675780639feab859116100ce578063d75b4c8811610087578063d75b4c88146106f5578063dd8283f314610708578063e65797ad1461071b578063f2fde38b146107be578063fabc1cbc146107d1578063fd39105a146107e457600080fd5b80639feab85914610659578063a50857bf14610680578063c391425e14610693578063ca0de882146106b3578063ca4f2d97146106da578063d72d8dd6146106ed57600080fd5b8063871ef04911610120578063871ef049146105cc578063886f1195146105df5780638da5cb5b146105f85780639aa1653d146106005780639b5d177b1461061f5780639e9923c21461063257600080fd5b80635df459461461053d5780636347c9001461056457806368304835146105775780636e3b17db1461059e578063715018a6146105b157806384ca5213146105b957600080fd5b806328f61b311161020b5780635140a548116101c45780635140a548146104c85780635865c60c146104db578063595c6a67146104fb5780635ac86ab7146105035780635b0b829f146105225780635c975abb1461053557600080fd5b806328f61b3114610435578063296bb0641461044857806329d1e0c31461045b5780632cdd1e861461046e5780633998fdd3146104815780633c2a7f4c146104a857600080fd5b806310d67a2f1161025d57806310d67a2f1461034a57806313542a4e1461035d578063136439dd146103865780631478851f146103995780631eb812da146103cc578063249a0c421461041557600080fd5b8062cf2ab51461029957806303fd3492146102ae57806304ec6351146102e1578063054310e61461030c5780630cf4b76714610337575b600080fd5b6102ac6102a73660046148ab565b610820565b005b6102ce6102bc3660046148ec565b60009081526098602052604090205490565b6040519081526020015b60405180910390f35b6102f46102ef366004614917565b610935565b6040516001600160c01b0390911681526020016102d8565b609d5461031f906001600160a01b031681565b6040516001600160a01b0390911681526020016102d8565b6102ac610345366004614a36565b610b2b565b6102ac610358366004614aab565b610c13565b6102ce61036b366004614aab565b6001600160a01b031660009081526099602052604090205490565b6102ac6103943660046148ec565b610cc6565b6103bc6103a73660046148ec565b609a6020526000908152604090205460ff1681565b60405190151581526020016102d8565b6103df6103da366004614ac8565b610e03565b60408051825163ffffffff908116825260208085015190911690820152918101516001600160c01b0316908201526060016102d8565b6102ce610423366004614afb565b609b6020526000908152604090205481565b609e5461031f906001600160a01b031681565b61031f6104563660046148ec565b610e94565b6102ac610469366004614aab565b610f20565b6102ac61047c366004614aab565b610f31565b61031f7f000000000000000000000000000000000000000000000000000000000000000081565b6104bb6104b6366004614aab565b610f42565b6040516102d89190614b16565b6102ac6104d6366004614b6e565b610fc1565b6104ee6104e9366004614aab565b6114d1565b6040516102d89190614c11565b6102ac611545565b6103bc610511366004614afb565b6001805460ff9092161b9081161490565b6102ac610530366004614c96565b611611565b6001546102ce565b61031f7f000000000000000000000000000000000000000000000000000000000000000081565b61031f6105723660046148ec565b6116a8565b61031f7f000000000000000000000000000000000000000000000000000000000000000081565b6102ac6105ac366004614cca565b6116d2565b6102ac611792565b6102ce6105c7366004614d81565b6117a6565b6102f46105da3660046148ec565b6117f0565b60005461031f906201000090046001600160a01b031681565b61031f6117fb565b60965461060d9060ff1681565b60405160ff90911681526020016102d8565b6102ac61062d366004614f1a565b611814565b61031f7f000000000000000000000000000000000000000000000000000000000000000081565b6102ce7f2bd82124057f0913bc3b772ce7b83e8057c1ad1f3510fc83778be20f10ec5de681565b6102ac61068e366004615013565b611b4b565b6106a66106a13660046150bb565b611cce565b6040516102d89190615160565b6102ce7f4d404e3276e7ac2163d8ee476afa6a41d1f68fb71f2d8b6546b24e55ce01b72a81565b6102ac6106e83660046151aa565b611d87565b609c546102ce565b6102ac610703366004615290565b611ded565b6102ac610716366004615443565b611e00565b61078a610729366004614afb565b60408051606080820183526000808352602080840182905292840181905260ff9490941684526097825292829020825193840183525463ffffffff8116845261ffff600160201b8204811692850192909252600160301b9004169082015290565b60408051825163ffffffff16815260208084015161ffff9081169183019190915292820151909216908201526060016102d8565b6102ac6107cc366004614aab565b612104565b6102ac6107df3660046148ec565b61217a565b6108136107f2366004614aab565b6001600160a01b031660009081526099602052604090206001015460ff1690565b6040516102d89190615517565b6001546002906004908116036108515760405162461bcd60e51b815260040161084890615525565b60405180910390fd5b60005b8281101561092f5760008484838181106108705761087061555c565b90506020020160208101906108859190614aab565b6001600160a01b03811660009081526099602090815260408083208151808301909252805482526001810154949550929390929183019060ff1660028111156108d0576108d0614bd9565b60028111156108e1576108e1614bd9565b905250805190915060006108f4826122d6565b9050600061090a826001600160c01b0316612341565b905061091785858361240d565b5050505050808061092790615588565b915050610854565b50505050565b60008381526098602052604081208054829190849081106109585761095861555c565b600091825260209182902060408051606081018252929091015463ffffffff808216808552600160201b8304821695850195909552600160401b9091046001600160c01b03169183019190915290925085161015610a525760405162461bcd60e51b815260206004820152606560248201527f5265676973747279436f6f7264696e61746f722e67657451756f72756d42697460448201527f6d61704174426c6f636b4e756d6265724279496e6465783a2071756f72756d4260648201527f69746d61705570646174652069732066726f6d20616674657220626c6f636b4e6084820152643ab6b132b960d91b60a482015260c401610848565b602081015163ffffffff161580610a785750806020015163ffffffff168463ffffffff16105b610b1f5760405162461bcd60e51b815260206004820152606660248201527f5265676973747279436f6f7264696e61746f722e67657451756f72756d42697460448201527f6d61704174426c6f636b4e756d6265724279496e6465783a2071756f72756d4260648201527f69746d61705570646174652069732066726f6d206265666f726520626c6f636b608482015265273ab6b132b960d11b60a482015260c401610848565b60400151949350505050565b60013360009081526099602052604090206001015460ff166002811115610b5457610b54614bd9565b14610bc75760405162461bcd60e51b815260206004820152603c60248201527f5265676973747279436f6f7264696e61746f722e757064617465536f636b657460448201527f3a206f70657261746f72206973206e6f742072656769737465726564000000006064820152608401610848565b33600090815260996020526040908190205490517fec2963ab21c1e50e1e582aa542af2e4bf7bf38e6e1403c27b42e1c5d6e621eaa90610c089084906155e7565b60405180910390a250565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8a91906155fa565b6001600160a01b0316336001600160a01b031614610cba5760405162461bcd60e51b815260040161084890615617565b610cc3816124fa565b50565b60005460405163237dfb4760e11b8152336004820152620100009091046001600160a01b0316906346fbf68e90602401602060405180830381865afa158015610d13573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d379190615661565b610d535760405162461bcd60e51b815260040161084890615683565b60015481811614610dcc5760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e70617573653a20696e76616c696420617474656d70742060448201527f746f20756e70617573652066756e6374696f6e616c69747900000000000000006064820152608401610848565b600181905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d90602001610c08565b60408051606081018252600080825260208201819052918101919091526000838152609860205260409020805483908110610e4057610e4061555c565b600091825260209182902060408051606081018252919092015463ffffffff8082168352600160201b820416938201939093526001600160c01b03600160401b909304929092169082015290505b92915050565b6040516308f6629d60e31b8152600481018290526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316906347b314e890602401602060405180830381865afa158015610efc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8e91906155fa565b610f286125ff565b610cc38161265e565b610f396125ff565b610cc3816126c7565b6040805180820190915260008082526020820152610e8e610fbc7f2bd82124057f0913bc3b772ce7b83e8057c1ad1f3510fc83778be20f10ec5de684604051602001610fa19291909182526001600160a01b0316602082015260400190565b60405160208183030381529060405280519060200120612730565b61277e565b600154600290600490811603610fe95760405162461bcd60e51b815260040161084890615525565b600061103184848080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505060965460ff16915061280d9050565b90508483146110a25760405162461bcd60e51b81526020600482015260436024820152600080516020615cf283398151915260448201527f6f7273466f7251756f72756d3a20696e707574206c656e677468206d69736d616064820152620e8c6d60eb1b608482015260a401610848565b60005b838110156114c85760008585838181106110c1576110c161555c565b919091013560f81c915036905060008989858181106110e2576110e261555c565b90506020028101906110f491906156cb565b6040516379a0849160e11b815260ff8616600482015291935091507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f341092290602401602060405180830381865afa158015611160573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111849190615714565b63ffffffff1681146112205760405162461bcd60e51b81526020600482015260656024820152600080516020615cf283398151915260448201527f6f7273466f7251756f72756d3a206e756d626572206f6620757064617465642060648201527f6f70657261746f727320646f6573206e6f74206d617463682071756f72756d206084820152641d1bdd185b60da1b60a482015260c401610848565b6000805b828110156114675760008484838181106112405761124061555c565b90506020020160208101906112559190614aab565b6001600160a01b03811660009081526099602090815260408083208151808301909252805482526001810154949550929390929183019060ff1660028111156112a0576112a0614bd9565b60028111156112b1576112b1614bd9565b905250805190915060006112c4826122d6565b905060016001600160c01b03821660ff8b161c8116146113485760405162461bcd60e51b815260206004820152604460248201819052600080516020615cf2833981519152908201527f6f7273466f7251756f72756d3a206f70657261746f72206e6f7420696e2071756064820152636f72756d60e01b608482015260a401610848565b856001600160a01b0316846001600160a01b0316116113f35760405162461bcd60e51b81526020600482015260676024820152600080516020615cf283398151915260448201527f6f7273466f7251756f72756d3a206f70657261746f7273206172726179206d7560648201527f737420626520736f7274656420696e20617363656e64696e6720616464726573608482015266399037b93232b960c91b60a482015260c401610848565b5061145183838f8f8d908e600161140a9190615731565b9261141793929190615744565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061240d92505050565b50909250611460905081615588565b9050611224565b5060ff84166000818152609b6020908152604091829020439081905591519182527f46077d55330763f16269fd75e5761663f4192d2791747c0189b16ad31db07db4910160405180910390a250505050806114c190615588565b90506110a5565b50505050505050565b60408051808201909152600080825260208201526001600160a01b0382166000908152609960209081526040918290208251808401909352805483526001810154909183019060ff16600281111561152b5761152b614bd9565b600281111561153c5761153c614bd9565b90525092915050565b60005460405163237dfb4760e11b8152336004820152620100009091046001600160a01b0316906346fbf68e90602401602060405180830381865afa158015611592573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115b69190615661565b6115d25760405162461bcd60e51b815260040161084890615683565b600019600181905560405190815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2565b6116196125ff565b609654829060ff908116908216106116995760405162461bcd60e51b815260206004820152603760248201527f5265676973747279436f6f7264696e61746f722e71756f72756d45786973747360448201527f3a2071756f72756d20646f6573206e6f742065786973740000000000000000006064820152608401610848565b6116a3838361289e565b505050565b609c81815481106116b857600080fd5b6000918252602090912001546001600160a01b0316905081565b609e546001600160a01b031633146117525760405162461bcd60e51b815260206004820152603a60248201527f5265676973747279436f6f7264696e61746f722e6f6e6c79456a6563746f723a60448201527f2063616c6c6572206973206e6f742074686520656a6563746f720000000000006064820152608401610848565b6116a38383838080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061294b92505050565b61179a6125ff565b6117a46000612dbd565b565b60006117e67f4d404e3276e7ac2163d8ee476afa6a41d1f68fb71f2d8b6546b24e55ce01b72a8787878787604051602001610fa19695949392919061576e565b9695505050505050565b6000610e8e826122d6565b600061180f6064546001600160a01b031690565b905090565b600180546000919081160361183b5760405162461bcd60e51b815260040161084890615525565b8389146118be5760405162461bcd60e51b8152602060048201526044602482018190527f5265676973747279436f6f7264696e61746f722e72656769737465724f706572908201527f61746f7257697468436875726e3a20696e707574206c656e677468206d69736d6064820152630c2e8c6d60e31b608482015260a401610848565b60006118ca3388612e0f565b905061192a33828888808060200260200160405190810160405280939291908181526020016000905b8282101561191f57611910604083028601368190038101906157f3565b815260200190600101906118f3565b505050505087612f44565b600061197133838e8e8e8e8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92506130d1915050565b905060005b8b811015611b3c576000609760008f8f858181106119965761199661555c565b919091013560f81c82525060208082019290925260409081016000208151606081018352905463ffffffff811680835261ffff600160201b8304811695840195909552600160301b90910490931691810191909152845180519193509084908110611a0357611a0361555c565b602002602001015163ffffffff161115611b2957611aa48e8e84818110611a2c57611a2c61555c565b9050013560f81c60f81b60f81c84604001518481518110611a4f57611a4f61555c565b60200260200101513386602001518681518110611a6e57611a6e61555c565b60200260200101518d8d88818110611a8857611a8861555c565b905060400201803603810190611a9e91906157f3565b866135e8565b611b29898984818110611ab957611ab961555c565b9050604002016020016020810190611ad19190614aab565b8f8f8590866001611ae29190615731565b92611aef93929190615744565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061294b92505050565b5080611b3481615588565b915050611976565b50505050505050505050505050565b6001805460009190811603611b725760405162461bcd60e51b815260040161084890615525565b6000611b7e3385612e0f565b90506000611bc733838b8b8b8b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152508c92506130d1915050565b51905060005b88811015611cc25760008a8a83818110611be957611be961555c565b919091013560f81c600081815260976020526040902054855191935063ffffffff169150849084908110611c1f57611c1f61555c565b602002602001015163ffffffff161115611caf5760405162461bcd60e51b8152602060048201526044602482018190527f5265676973747279436f6f7264696e61746f722e72656769737465724f706572908201527f61746f723a206f70657261746f7220636f756e742065786365656473206d6178606482015263696d756d60e01b608482015260a401610848565b5080611cba81615588565b915050611bcd565b50505050505050505050565b6060600082516001600160401b03811115611ceb57611ceb61494f565b604051908082528060200260200182016040528015611d14578160200160208202803683370190505b50905060005b8351811015611d7f57611d4685858381518110611d3957611d3961555c565b60200260200101516138bc565b828281518110611d5857611d5861555c565b63ffffffff9092166020928302919091019091015280611d7781615588565b915050611d1a565b509392505050565b60018054600290811603611dad5760405162461bcd60e51b815260040161084890615525565b6116a33384848080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061294b92505050565b611df56125ff565b6116a38383836139f8565b600054610100900460ff1615808015611e205750600054600160ff909116105b80611e3a5750303b158015611e3a575060005460ff166001145b611e9d5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608401610848565b6000805460ff191660011790558015611ec0576000805461ff0019166101001790555b82518451148015611ed2575081518351145b611f3c5760405162461bcd60e51b815260206004820152603560248201527f5265676973747279436f6f7264696e61746f722e696e697469616c697a653a206044820152740d2dce0eae840d8cadccee8d040dad2e6dac2e8c6d605b1b6064820152608401610848565b611f4589612dbd565b611f4f8686613c0f565b611f588861265e565b611f61876126c7565b609c80546001818101835560008381527faf85b9071dfafeac1409d3f1d19bafc9bc7c37974cde8df0ee6168f0086e539c92830180546001600160a01b037f000000000000000000000000000000000000000000000000000000000000000081166001600160a01b03199283161790925585548085018755850180547f0000000000000000000000000000000000000000000000000000000000000000841690831617905585549384019095559190920180547f000000000000000000000000000000000000000000000000000000000000000090921691909316179091555b84518110156120b2576120a085828151811061205f5761205f61555c565b60200260200101518583815181106120795761207961555c565b60200260200101518584815181106120935761209361555c565b60200260200101516139f8565b806120aa81615588565b915050612041565b5080156120f9576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b505050505050505050565b61210c6125ff565b6001600160a01b0381166121715760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608401610848565b610cc381612dbd565b600060029054906101000a90046001600160a01b03166001600160a01b031663eab66d7a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156121cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121f191906155fa565b6001600160a01b0316336001600160a01b0316146122215760405162461bcd60e51b815260040161084890615617565b60015419811960015419161461229f5760405162461bcd60e51b815260206004820152603860248201527f5061757361626c652e756e70617573653a20696e76616c696420617474656d7060448201527f7420746f2070617573652066756e6374696f6e616c69747900000000000000006064820152608401610848565b600181905560405181815233907f3582d1828e26bf56bd801502bc021ac0bc8afb57c826e4986b45593c8fad389c90602001610c08565b6000818152609860205260408120548082036122f55750600092915050565b600083815260986020526040902061230e60018361580f565b8154811061231e5761231e61555c565b600091825260209091200154600160401b90046001600160c01b03169392505050565b606060008061234f84613cff565b61ffff166001600160401b0381111561236a5761236a61494f565b6040519080825280601f01601f191660200182016040528015612394576020820181803683370190505b5090506000805b8251821080156123ac575061010081105b15612403576001811b9350858416156123f3578060f81b8383815181106123d5576123d561555c565b60200101906001600160f81b031916908160001a9053508160010191505b6123fc81615588565b905061239b565b5090949350505050565b60018260200151600281111561242557612425614bd9565b1461242f57505050565b81516040516333567f7f60e11b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906366acfefe9061248490889086908890600401615822565b6020604051808303816000875af11580156124a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124c79190615852565b90506001600160c01b038116156124f3576124f3856124ee836001600160c01b0316612341565b61294b565b5050505050565b6001600160a01b0381166125885760405162461bcd60e51b815260206004820152604960248201527f5061757361626c652e5f73657450617573657252656769737472793a206e657760448201527f50617573657252656769737472792063616e6e6f7420626520746865207a65726064820152686f206164647265737360b81b608482015260a401610848565b600054604080516001600160a01b03620100009093048316815291831660208301527f6e9fcd539896fca60e8b0f01dd580233e48a6b0f7df013b89ba7f565869acdb6910160405180910390a1600080546001600160a01b03909216620100000262010000600160b01b0319909216919091179055565b336126086117fb565b6001600160a01b0316146117a45760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610848565b609d54604080516001600160a01b03928316815291831660208301527f315457d8a8fe60f04af17c16e2f5a5e1db612b31648e58030360759ef8f3528c910160405180910390a1609d80546001600160a01b0319166001600160a01b0392909216919091179055565b609e54604080516001600160a01b03928316815291831660208301527f8f30ab09f43a6c157d7fce7e0a13c003042c1c95e8a72e7a146a21c0caa24dc9910160405180910390a1609e80546001600160a01b0319166001600160a01b0392909216919091179055565b6000610e8e61273d613d2a565b8360405161190160f01b6020820152602281018390526042810182905260009060620160405160208183030381529060405280519060200120905092915050565b6040805180820190915260008082526020820152600080806127ae600080516020615d3283398151915286615891565b90505b6127ba81613e51565b9093509150600080516020615d3283398151915282830983036127f3576040805180820190915290815260208101919091529392505050565b600080516020615d328339815191526001820890506127b1565b60008061281984613ed3565b9050808360ff166001901b116128975760405162461bcd60e51b815260206004820152603f60248201527f4269746d61705574696c732e6f72646572656442797465734172726179546f4260448201527f69746d61703a206269746d61702065786365656473206d61782076616c7565006064820152608401610848565b9392505050565b60ff8216600081815260976020908152604091829020845181548684018051888701805163ffffffff90951665ffffffffffff199094168417600160201b61ffff938416021767ffff0000000000001916600160301b95831695909502949094179094558551918252518316938101939093525116918101919091527f3ee6fe8d54610244c3e9d3c066ae4aee997884aa28f10616ae821925401318ac9060600160405180910390a25050565b6001600160a01b0382166000908152609960205260409020805460018083015460ff16600281111561297f5761297f614bd9565b146129fe5760405162461bcd60e51b815260206004820152604360248201527f5265676973747279436f6f7264696e61746f722e5f646572656769737465724f60448201527f70657261746f723a206f70657261746f72206973206e6f7420726567697374656064820152621c995960ea1b608482015260a401610848565b609654600090612a1290859060ff1661280d565b90506000612a1f836122d6565b90506001600160c01b038216612a9d5760405162461bcd60e51b815260206004820152603b60248201527f5265676973747279436f6f7264696e61746f722e5f646572656769737465724f60448201527f70657261746f723a206269746d61702063616e6e6f74206265203000000000006064820152608401610848565b612ab46001600160c01b0383811690831681161490565b612b4c5760405162461bcd60e51b815260206004820152605960248201527f5265676973747279436f6f7264696e61746f722e5f646572656769737465724f60448201527f70657261746f723a206f70657261746f72206973206e6f74207265676973746560648201527f72656420666f72207370656369666965642071756f72756d7300000000000000608482015260a401610848565b6001600160c01b0382811619821616612b658482614063565b6001600160c01b038116612c345760018501805460ff191660021790556040516351b27a6d60e11b81526001600160a01b0388811660048301527f0000000000000000000000000000000000000000000000000000000000000000169063a364f4da90602401600060405180830381600087803b158015612be557600080fd5b505af1158015612bf9573d6000803e3d6000fd5b50506040518692506001600160a01b038a1691507f396fdcb180cb0fea26928113fb0fd1c3549863f9cd563e6a184f1d578116c8e490600090a35b60405163f4e24fe560e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063f4e24fe590612c82908a908a906004016158a5565b600060405180830381600087803b158015612c9c57600080fd5b505af1158015612cb0573d6000803e3d6000fd5b505060405163bd29b8cd60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016925063bd29b8cd9150612d029087908a906004016158c9565b600060405180830381600087803b158015612d1c57600080fd5b505af1158015612d30573d6000803e3d6000fd5b505060405163bd29b8cd60e01b81526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016925063bd29b8cd9150612d829087908a906004016158c9565b600060405180830381600087803b158015612d9c57600080fd5b505af1158015612db0573d6000803e3d6000fd5b5050505050505050505050565b606480546001600160a01b038381166001600160a01b0319831681179093556040519116919082907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a35050565b6040516309aa152760e11b81526001600160a01b0383811660048301526000917f0000000000000000000000000000000000000000000000000000000000000000909116906313542a4e90602401602060405180830381865afa158015612e7a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e9e91906158e2565b90506000819003610e8e577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663bf79ce588484612ee387610f42565b6040518463ffffffff1660e01b8152600401612f01939291906158fb565b6020604051808303816000875af1158015612f20573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061289791906158e2565b6020808201516000908152609a909152604090205460ff1615612fea5760405162461bcd60e51b815260206004820152605260248201527f5265676973747279436f6f7264696e61746f722e5f766572696679436875726e60448201527f417070726f7665725369676e61747572653a20636875726e417070726f766572606482015271081cd85b1d08185b1c9958591e481d5cd95960721b608482015260a401610848565b428160400151101561307f5760405162461bcd60e51b815260206004820152605260248201527f5265676973747279436f6f7264696e61746f722e5f766572696679436875726e60448201527f417070726f7665725369676e61747572653a20636875726e417070726f766572606482015271081cda59db985d1d5c9948195e1c1a5c995960721b608482015260a401610848565b602080820180516000908152609a909252604091829020805460ff19166001179055609d5490519183015161092f926001600160a01b03909216916130ca91889188918891906117a6565b8351614224565b6130f560405180606001604052806060815260200160608152602001606081525090565b600061313d86868080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505060965460ff16915061280d9050565b9050600061314a886122d6565b90506001600160c01b0382166131c85760405162461bcd60e51b815260206004820152603960248201527f5265676973747279436f6f7264696e61746f722e5f72656769737465724f706560448201527f7261746f723a206269746d61702063616e6e6f742062652030000000000000006064820152608401610848565b8082166001600160c01b03161561327e5760405162461bcd60e51b815260206004820152606860248201527f5265676973747279436f6f7264696e61746f722e5f72656769737465724f706560448201527f7261746f723a206f70657261746f7220616c726561647920726567697374657260648201527f656420666f7220736f6d652071756f72756d73206265696e672072656769737460848201526732b932b2103337b960c11b60a482015260c401610848565b6001600160c01b03818116908316176132978982614063565b887fec2963ab21c1e50e1e582aa542af2e4bf7bf38e6e1403c27b42e1c5d6e621eaa876040516132c791906155e7565b60405180910390a260016001600160a01b038b1660009081526099602052604090206001015460ff16600281111561330157613301614bd9565b1461341a576040805180820182528a8152600160208083018281526001600160a01b038f166000908152609990925293902082518155925183820180549394939192909160ff19169083600281111561335c5761335c614bd9565b021790555050604051639926ee7d60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169150639926ee7d906133b1908d90899060040161596b565b600060405180830381600087803b1580156133cb57600080fd5b505af11580156133df573d6000803e3d6000fd5b50506040518b92506001600160a01b038d1691507fe8e68cef1c3a761ed7be7e8463a375f27f7bc335e51824223cacce636ec5c3fe90600090a35b604051631fd93ca960e11b81526001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690633fb279529061346a908d908c908c906004016159df565b600060405180830381600087803b15801561348457600080fd5b505af1158015613498573d6000803e3d6000fd5b5050604051632550477760e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169250632550477791506134ee908d908d908d908d90600401615a04565b6000604051808303816000875af115801561350d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526135359190810190615a90565b60408087019190915260208601919091525162bff04d60e01b81526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169062bff04d90613592908c908c908c90600401615af3565b6000604051808303816000875af11580156135b1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526135d99190810190615b0d565b84525050509695505050505050565b6020808301516001600160a01b03808216600081815260999094526040909320549192908716036136675760405162461bcd60e51b81526020600482015260356024820152600080516020615d1283398151915260448201527439371d1031b0b73737ba1031b43ab9371039b2b63360591b6064820152608401610848565b8760ff16846000015160ff16146136e45760405162461bcd60e51b81526020600482015260476024820152600080516020615d1283398151915260448201527f726e3a2071756f72756d4e756d626572206e6f74207468652073616d65206173606482015266081cda59db995960ca1b608482015260a401610848565b604051635401ed2760e01b81526004810182905260ff891660248201526000907f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635401ed2790604401602060405180830381865afa158015613755573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137799190615ba6565b905061378581856143de565b6001600160601b0316866001600160601b0316116138185760405162461bcd60e51b81526020600482015260566024820152600080516020615d1283398151915260448201527f726e3a20696e636f6d696e67206f70657261746f722068617320696e7375666660648201527534b1b4b2b73a1039ba30b5b2903337b91031b43ab93760511b608482015260a401610848565b6138228885614402565b6001600160601b0316816001600160601b0316106120f95760405162461bcd60e51b815260206004820152605c6024820152600080516020615d1283398151915260448201527f726e3a2063616e6e6f74206b69636b206f70657261746f722077697468206d6f60648201527f7265207468616e206b69636b424950734f66546f74616c5374616b6500000000608482015260a401610848565b600081815260986020526040812054815b8181101561394e5760016138e1828461580f565b6138eb919061580f565b92508463ffffffff16609860008681526020019081526020016000208463ffffffff168154811061391e5761391e61555c565b60009182526020909120015463ffffffff161161393c575050610e8e565b8061394681615588565b9150506138cd565b5060405162461bcd60e51b815260206004820152606c60248201527f5265676973747279436f6f7264696e61746f722e67657451756f72756d42697460448201527f6d6170496e6465784174426c6f636b4e756d6265723a206e6f206269746d617060648201527f2075706461746520666f756e6420666f72206f70657261746f7249642061742060848201526b313637b1b590373ab6b132b960a11b60a482015260c401610848565b60965460ff1660c08110613a6c5760405162461bcd60e51b815260206004820152603560248201527f5265676973747279436f6f7264696e61746f722e63726561746551756f72756d6044820152740e881b585e081c5d5bdc9d5b5cc81c995858da1959605a1b6064820152608401610848565b613a77816001615bc3565b6096805460ff191660ff9290921691909117905580613a96818661289e565b60405160016296b58960e01b031981526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063ff694a7790613ae990849088908890600401615bdc565b600060405180830381600087803b158015613b0357600080fd5b505af1158015613b17573d6000803e3d6000fd5b505060405163136ca0f960e11b815260ff841660048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031692506326d941f29150602401600060405180830381600087803b158015613b7f57600080fd5b505af1158015613b93573d6000803e3d6000fd5b505060405163136ca0f960e11b815260ff841660048201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031692506326d941f29150602401600060405180830381600087803b158015613bfb57600080fd5b505af11580156120f9573d6000803e3d6000fd5b6000546201000090046001600160a01b0316158015613c3657506001600160a01b03821615155b613cb85760405162461bcd60e51b815260206004820152604760248201527f5061757361626c652e5f696e697469616c697a655061757365723a205f696e6960448201527f7469616c697a6550617573657228292063616e206f6e6c792062652063616c6c6064820152666564206f6e636560c81b608482015260a401610848565b600181905560405181815233907fab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d9060200160405180910390a2613cfb826124fa565b5050565b6000805b8215610e8e57613d1460018461580f565b9092169180613d2281615c55565b915050613d03565b6000306001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016148015613d8357507f000000000000000000000000000000000000000000000000000000000000000046145b15613dad57507f000000000000000000000000000000000000000000000000000000000000000090565b50604080517f00000000000000000000000000000000000000000000000000000000000000006020808301919091527f0000000000000000000000000000000000000000000000000000000000000000828401527f000000000000000000000000000000000000000000000000000000000000000060608301524660808301523060a0808401919091528351808403909101815260c0909201909252805191012090565b60008080600080516020615d328339815191526003600080516020615d3283398151915286600080516020615d32833981519152888909090890506000613ec7827f0c19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52600080516020615d3283398151915261441c565b91959194509092505050565b600061010082511115613f5c5760405162461bcd60e51b8152602060048201526044602482018190527f4269746d61705574696c732e6f72646572656442797465734172726179546f42908201527f69746d61703a206f7264657265644279746573417272617920697320746f6f206064820152636c6f6e6760e01b608482015260a401610848565b8151600003613f6d57506000919050565b60008083600081518110613f8357613f8361555c565b0160200151600160f89190911c81901b92505b845181101561405a57848181518110613fb157613fb161555c565b0160200151600160f89190911c1b91508282116140465760405162461bcd60e51b815260206004820152604760248201527f4269746d61705574696c732e6f72646572656442797465734172726179546f4260448201527f69746d61703a206f72646572656442797465734172726179206973206e6f74206064820152661bdc99195c995960ca1b608482015260a401610848565b9181179161405381615588565b9050613f96565b50909392505050565b6000828152609860205260408120549081900361410b576000838152609860209081526040808320815160608101835263ffffffff43811682528185018681526001600160c01b03808a16958401958652845460018101865594885295909620915191909201805495519351909416600160401b026001600160401b03938316600160201b0267ffffffffffffffff1990961691909216179390931716919091179055505050565b600083815260986020526040812061412460018461580f565b815481106141345761413461555c565b6000918252602090912001805490915063ffffffff4381169116036141765780546001600160401b0316600160401b6001600160c01b0385160217815561092f565b805463ffffffff438116600160201b81810267ffffffff0000000019909416939093178455600087815260986020908152604080832081516060810183529485528483018481526001600160c01b03808c1693870193845282546001810184559286529390942094519401805493519151909216600160401b026001600160401b0391861690960267ffffffffffffffff199093169390941692909217179190911691909117905550505050565b6001600160a01b0383163b1561433e57604051630b135d3f60e11b808252906001600160a01b03851690631626ba7e9061426490869086906004016158c9565b602060405180830381865afa158015614281573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906142a59190615c76565b6001600160e01b031916146116a35760405162461bcd60e51b815260206004820152605360248201527f454950313237315369676e61747572655574696c732e636865636b5369676e6160448201527f747572655f454950313237313a2045524331323731207369676e6174757265206064820152721d995c9a599a58d85d1a5bdb8819985a5b1959606a1b608482015260a401610848565b826001600160a01b031661435283836144c5565b6001600160a01b0316146116a35760405162461bcd60e51b815260206004820152604760248201527f454950313237315369676e61747572655574696c732e636865636b5369676e6160448201527f747572655f454950313237313a207369676e6174757265206e6f742066726f6d6064820152661039b4b3b732b960c91b608482015260a401610848565b6020810151600090612710906143f89061ffff1685615ca0565b6128979190615ccb565b6040810151600090612710906143f89061ffff1685615ca0565b60008061442761482b565b61442f614849565b602080825281810181905260408201819052606082018890526080820187905260a082018690528260c08360056107d05a03fa9250828061446c57fe5b50826144ba5760405162461bcd60e51b815260206004820152601a60248201527f424e3235342e6578704d6f643a2063616c6c206661696c7572650000000000006044820152606401610848565b505195945050505050565b60008060006144d485856144e1565b91509150611d7f8161454f565b60008082516041036145175760208301516040840151606085015160001a61450b87828585614705565b94509450505050614548565b825160400361454057602083015160408401516145358683836147f2565b935093505050614548565b506000905060025b9250929050565b600081600481111561456357614563614bd9565b0361456b5750565b600181600481111561457f5761457f614bd9565b036145cc5760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610848565b60028160048111156145e0576145e0614bd9565b0361462d5760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610848565b600381600481111561464157614641614bd9565b036146995760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608401610848565b60048160048111156146ad576146ad614bd9565b03610cc35760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b6064820152608401610848565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561473c57506000905060036147e9565b8460ff16601b1415801561475457508460ff16601c14155b1561476557506000905060046147e9565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa1580156147b9573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b0381166147e2576000600192509250506147e9565b9150600090505b94509492505050565b6000806001600160ff1b0383168161480f60ff86901c601b615731565b905061481d87828885614705565b935093505050935093915050565b60405180602001604052806001906020820280368337509192915050565b6040518060c001604052806006906020820280368337509192915050565b60008083601f84011261487957600080fd5b5081356001600160401b0381111561489057600080fd5b6020830191508360208260051b850101111561454857600080fd5b600080602083850312156148be57600080fd5b82356001600160401b038111156148d457600080fd5b6148e085828601614867565b90969095509350505050565b6000602082840312156148fe57600080fd5b5035919050565b63ffffffff81168114610cc357600080fd5b60008060006060848603121561492c57600080fd5b83359250602084013561493e81614905565b929592945050506040919091013590565b634e487b7160e01b600052604160045260246000fd5b604051606081016001600160401b03811182821017156149875761498761494f565b60405290565b604080519081016001600160401b03811182821017156149875761498761494f565b604051601f8201601f191681016001600160401b03811182821017156149d7576149d761494f565b604052919050565b60006001600160401b038311156149f8576149f861494f565b614a0b601f8401601f19166020016149af565b9050828152838383011115614a1f57600080fd5b828260208301376000602084830101529392505050565b600060208284031215614a4857600080fd5b81356001600160401b03811115614a5e57600080fd5b8201601f81018413614a6f57600080fd5b614a7e848235602084016149df565b949350505050565b6001600160a01b0381168114610cc357600080fd5b8035614aa681614a86565b919050565b600060208284031215614abd57600080fd5b813561289781614a86565b60008060408385031215614adb57600080fd5b50508035926020909101359150565b803560ff81168114614aa657600080fd5b600060208284031215614b0d57600080fd5b61289782614aea565b815181526020808301519082015260408101610e8e565b60008083601f840112614b3f57600080fd5b5081356001600160401b03811115614b5657600080fd5b60208301915083602082850101111561454857600080fd5b60008060008060408587031215614b8457600080fd5b84356001600160401b0380821115614b9b57600080fd5b614ba788838901614867565b90965094506020870135915080821115614bc057600080fd5b50614bcd87828801614b2d565b95989497509550505050565b634e487b7160e01b600052602160045260246000fd5b60038110614c0d57634e487b7160e01b600052602160045260246000fd5b9052565b815181526020808301516040830191614c2c90840182614bef565b5092915050565b803561ffff81168114614aa657600080fd5b600060608284031215614c5757600080fd5b614c5f614965565b90508135614c6c81614905565b8152614c7a60208301614c33565b6020820152614c8b60408301614c33565b604082015292915050565b60008060808385031215614ca957600080fd5b614cb283614aea565b9150614cc18460208501614c45565b90509250929050565b600080600060408486031215614cdf57600080fd5b8335614cea81614a86565b925060208401356001600160401b03811115614d0557600080fd5b614d1186828701614b2d565b9497909650939450505050565b60006001600160401b03821115614d3757614d3761494f565b5060051b60200190565b600060408284031215614d5357600080fd5b614d5b61498d565b9050614d6682614aea565b81526020820135614d7681614a86565b602082015292915050565b600080600080600060a08688031215614d9957600080fd5b8535614da481614a86565b945060208681013594506040808801356001600160401b03811115614dc857600080fd5b8801601f81018a13614dd957600080fd5b8035614dec614de782614d1e565b6149af565b81815260069190911b8201840190848101908c831115614e0b57600080fd5b928501925b82841015614e3157614e228d85614d41565b82529284019290850190614e10565b999c989b5098996060810135995060800135979650505050505050565b60006101008284031215614e6157600080fd5b50919050565b60008083601f840112614e7957600080fd5b5081356001600160401b03811115614e9057600080fd5b6020830191508360208260061b850101111561454857600080fd5b600060608284031215614ebd57600080fd5b614ec5614965565b905081356001600160401b03811115614edd57600080fd5b8201601f81018413614eee57600080fd5b614efd848235602084016149df565b825250602082013560208201526040820135604082015292915050565b60008060008060008060008060006101a08a8c031215614f3957600080fd5b89356001600160401b0380821115614f5057600080fd5b614f5c8d838e01614b2d565b909b50995060208c0135915080821115614f7557600080fd5b614f818d838e01614b2d565b9099509750879150614f968d60408e01614e4e565b96506101408c0135915080821115614fad57600080fd5b614fb98d838e01614e67565b90965094506101608c0135915080821115614fd357600080fd5b614fdf8d838e01614eab565b93506101808c0135915080821115614ff657600080fd5b506150038c828d01614eab565b9150509295985092959850929598565b600080600080600080610160878903121561502d57600080fd5b86356001600160401b038082111561504457600080fd5b6150508a838b01614b2d565b9098509650602089013591508082111561506957600080fd5b6150758a838b01614b2d565b909650945084915061508a8a60408b01614e4e565b93506101408901359150808211156150a157600080fd5b506150ae89828a01614eab565b9150509295509295509295565b600080604083850312156150ce57600080fd5b82356150d981614905565b91506020838101356001600160401b038111156150f557600080fd5b8401601f8101861361510657600080fd5b8035615114614de782614d1e565b81815260059190911b8201830190838101908883111561513357600080fd5b928401925b8284101561515157833582529284019290840190615138565b80955050505050509250929050565b6020808252825182820181905260009190848201906040850190845b8181101561519e57835163ffffffff168352928401929184019160010161517c565b50909695505050505050565b600080602083850312156151bd57600080fd5b82356001600160401b038111156151d357600080fd5b6148e085828601614b2d565b6001600160601b0381168114610cc357600080fd5b600082601f83011261520557600080fd5b81356020615215614de783614d1e565b82815260069290921b8401810191818101908684111561523457600080fd5b8286015b8481101561528557604081890312156152515760008081fd5b61525961498d565b813561526481614a86565b815281850135615273816151df565b81860152835291830191604001615238565b509695505050505050565b600080600060a084860312156152a557600080fd5b6152af8585614c45565b925060608401356152bf816151df565b915060808401356001600160401b038111156152da57600080fd5b6152e6868287016151f4565b9150509250925092565b600082601f83011261530157600080fd5b81356020615311614de783614d1e565b8281526060928302850182019282820191908785111561533057600080fd5b8387015b85811015615353576153468982614c45565b8452928401928101615334565b5090979650505050505050565b600082601f83011261537157600080fd5b81356020615381614de783614d1e565b82815260059290921b840181019181810190868411156153a057600080fd5b8286015b848110156152855780356153b7816151df565b83529183019183016153a4565b600082601f8301126153d557600080fd5b813560206153e5614de783614d1e565b82815260059290921b8401810191818101908684111561540457600080fd5b8286015b848110156152855780356001600160401b038111156154275760008081fd5b6154358986838b01016151f4565b845250918301918301615408565b600080600080600080600080610100898b03121561546057600080fd5b61546989614a9b565b975061547760208a01614a9b565b965061548560408a01614a9b565b955061549360608a01614a9b565b94506080890135935060a08901356001600160401b03808211156154b657600080fd5b6154c28c838d016152f0565b945060c08b01359150808211156154d857600080fd5b6154e48c838d01615360565b935060e08b01359150808211156154fa57600080fd5b506155078b828c016153c4565b9150509295985092959890939650565b60208101610e8e8284614bef565b60208082526019908201527f5061757361626c653a20696e6465782069732070617573656400000000000000604082015260600190565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b60006001820161559a5761559a615572565b5060010190565b6000815180845260005b818110156155c7576020818501810151868301820152016155ab565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061289760208301846155a1565b60006020828403121561560c57600080fd5b815161289781614a86565b6020808252602a908201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160408201526939903ab73830bab9b2b960b11b606082015260800190565b60006020828403121561567357600080fd5b8151801515811461289757600080fd5b60208082526028908201527f6d73672e73656e646572206973206e6f74207065726d697373696f6e6564206160408201526739903830bab9b2b960c11b606082015260800190565b6000808335601e198436030181126156e257600080fd5b8301803591506001600160401b038211156156fc57600080fd5b6020019150600581901b360382131561454857600080fd5b60006020828403121561572657600080fd5b815161289781614905565b80820180821115610e8e57610e8e615572565b6000808585111561575457600080fd5b8386111561576157600080fd5b5050820193919092039150565b600060c08201888352602060018060a01b03808a16828601526040898187015260c0606087015283895180865260e088019150848b01955060005b818110156157d3578651805160ff16845286015185168684015295850195918301916001016157a9565b505060808701989098525050505060a09091019190915250949350505050565b60006040828403121561580557600080fd5b6128978383614d41565b81810381811115610e8e57610e8e615572565b60018060a01b038416815282602082015260606040820152600061584960608301846155a1565b95945050505050565b60006020828403121561586457600080fd5b81516001600160c01b038116811461289757600080fd5b634e487b7160e01b600052601260045260246000fd5b6000826158a0576158a061587b565b500690565b6001600160a01b0383168152604060208201819052600090614a7e908301846155a1565b828152604060208201526000614a7e60408301846155a1565b6000602082840312156158f457600080fd5b5051919050565b6001600160a01b03841681526101608101615923602083018580358252602090810135910152565b61593d606083016040860180358252602090810135910152565b60406080850160a0840137604060c0850160e084013782516101208301526020830151610140830152614a7e565b60018060a01b038316815260406020820152600082516060604084015261599560a08401826155a1565b90506020840151606084015260408401516080840152809150509392505050565b81835281816020850137506000828201602090810191909152601f909101601f19169091010190565b6001600160a01b038416815260406020820181905260009061584990830184866159b6565b60018060a01b03851681528360208201526060604082015260006117e66060830184866159b6565b600082601f830112615a3d57600080fd5b81516020615a4d614de783614d1e565b82815260059290921b84018101918181019086841115615a6c57600080fd5b8286015b84811015615285578051615a83816151df565b8352918301918301615a70565b60008060408385031215615aa357600080fd5b82516001600160401b0380821115615aba57600080fd5b615ac686838701615a2c565b93506020850151915080821115615adc57600080fd5b50615ae985828601615a2c565b9150509250929050565b8381526040602082015260006158496040830184866159b6565b60006020808385031215615b2057600080fd5b82516001600160401b03811115615b3657600080fd5b8301601f81018513615b4757600080fd5b8051615b55614de782614d1e565b81815260059190911b82018301908381019087831115615b7457600080fd5b928401925b82841015615b9b578351615b8c81614905565b82529284019290840190615b79565b979650505050505050565b600060208284031215615bb857600080fd5b8151612897816151df565b60ff8181168382160190811115610e8e57610e8e615572565b60006060820160ff8616835260206001600160601b03808716828601526040606081870152838751808652608088019150848901955060005b81811015615c4557865180516001600160a01b031684528601518516868401529585019591830191600101615c15565b50909a9950505050505050505050565b600061ffff808316818103615c6c57615c6c615572565b6001019392505050565b600060208284031215615c8857600080fd5b81516001600160e01b03198116811461289757600080fd5b6001600160601b03818116838216028082169190828114615cc357615cc3615572565b505092915050565b60006001600160601b0380841680615ce557615ce561587b565b9216919091049291505056fe5265676973747279436f6f7264696e61746f722e7570646174654f70657261745265676973747279436f6f7264696e61746f722e5f76616c696461746543687530644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47a26469706673582212208d8b4dfde053d85837f1454ad329a51343c75d718d88d9362a8d22cce02463b664736f6c63430008140033"]
    #[doc = r" ```"]
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(b"`\x80`@R4\x80\x15a\0\x10W`\0\x80\xfd[P`\x046\x10a\x02\x94W`\05`\xe0\x1c\x80c]\xf4YF\x11a\x01gW\x80c\x9f\xea\xb8Y\x11a\0\xceW\x80c\xd7[L\x88\x11a\0\x87W\x80c\xd7[L\x88\x14a\x06\xf5W\x80c\xdd\x82\x83\xf3\x14a\x07\x08W\x80c\xe6W\x97\xad\x14a\x07\x1bW\x80c\xf2\xfd\xe3\x8b\x14a\x07\xbeW\x80c\xfa\xbc\x1c\xbc\x14a\x07\xd1W\x80c\xfd9\x10Z\x14a\x07\xe4W`\0\x80\xfd[\x80c\x9f\xea\xb8Y\x14a\x06YW\x80c\xa5\x08W\xbf\x14a\x06\x80W\x80c\xc3\x91B^\x14a\x06\x93W\x80c\xca\r\xe8\x82\x14a\x06\xb3W\x80c\xcaO-\x97\x14a\x06\xdaW\x80c\xd7-\x8d\xd6\x14a\x06\xedW`\0\x80\xfd[\x80c\x87\x1e\xf0I\x11a\x01 W\x80c\x87\x1e\xf0I\x14a\x05\xccW\x80c\x88o\x11\x95\x14a\x05\xdfW\x80c\x8d\xa5\xcb[\x14a\x05\xf8W\x80c\x9a\xa1e=\x14a\x06\0W\x80c\x9b]\x17{\x14a\x06\x1fW\x80c\x9e\x99#\xc2\x14a\x062W`\0\x80\xfd[\x80c]\xf4YF\x14a\x05=W\x80ccG\xc9\0\x14a\x05dW\x80ch0H5\x14a\x05wW\x80cn;\x17\xdb\x14a\x05\x9eW\x80cqP\x18\xa6\x14a\x05\xb1W\x80c\x84\xcaR\x13\x14a\x05\xb9W`\0\x80\xfd[\x80c(\xf6\x1b1\x11a\x02\x0bW\x80cQ@\xa5H\x11a\x01\xc4W\x80cQ@\xa5H\x14a\x04\xc8W\x80cXe\xc6\x0c\x14a\x04\xdbW\x80cY\\jg\x14a\x04\xfbW\x80cZ\xc8j\xb7\x14a\x05\x03W\x80c[\x0b\x82\x9f\x14a\x05\"W\x80c\\\x97Z\xbb\x14a\x055W`\0\x80\xfd[\x80c(\xf6\x1b1\x14a\x045W\x80c)k\xb0d\x14a\x04HW\x80c)\xd1\xe0\xc3\x14a\x04[W\x80c,\xdd\x1e\x86\x14a\x04nW\x80c9\x98\xfd\xd3\x14a\x04\x81W\x80c<*\x7fL\x14a\x04\xa8W`\0\x80\xfd[\x80c\x10\xd6z/\x11a\x02]W\x80c\x10\xd6z/\x14a\x03JW\x80c\x13T*N\x14a\x03]W\x80c\x13d9\xdd\x14a\x03\x86W\x80c\x14x\x85\x1f\x14a\x03\x99W\x80c\x1e\xb8\x12\xda\x14a\x03\xccW\x80c$\x9a\x0cB\x14a\x04\x15W`\0\x80\xfd[\x80b\xcf*\xb5\x14a\x02\x99W\x80c\x03\xfd4\x92\x14a\x02\xaeW\x80c\x04\xeccQ\x14a\x02\xe1W\x80c\x05C\x10\xe6\x14a\x03\x0cW\x80c\x0c\xf4\xb7g\x14a\x037W[`\0\x80\xfd[a\x02\xaca\x02\xa76`\x04aH\xabV[a\x08 V[\0[a\x02\xcea\x02\xbc6`\x04aH\xecV[`\0\x90\x81R`\x98` R`@\x90 T\x90V[`@Q\x90\x81R` \x01[`@Q\x80\x91\x03\x90\xf3[a\x02\xf4a\x02\xef6`\x04aI\x17V[a\t5V[`@Q`\x01`\x01`\xc0\x1b\x03\x90\x91\x16\x81R` \x01a\x02\xd8V[`\x9dTa\x03\x1f\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[`@Q`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x81R` \x01a\x02\xd8V[a\x02\xaca\x03E6`\x04aJ6V[a\x0b+V[a\x02\xaca\x03X6`\x04aJ\xabV[a\x0c\x13V[a\x02\xcea\x03k6`\x04aJ\xabV[`\x01`\x01`\xa0\x1b\x03\x16`\0\x90\x81R`\x99` R`@\x90 T\x90V[a\x02\xaca\x03\x946`\x04aH\xecV[a\x0c\xc6V[a\x03\xbca\x03\xa76`\x04aH\xecV[`\x9a` R`\0\x90\x81R`@\x90 T`\xff\x16\x81V[`@Q\x90\x15\x15\x81R` \x01a\x02\xd8V[a\x03\xdfa\x03\xda6`\x04aJ\xc8V[a\x0e\x03V[`@\x80Q\x82Qc\xff\xff\xff\xff\x90\x81\x16\x82R` \x80\x85\x01Q\x90\x91\x16\x90\x82\x01R\x91\x81\x01Q`\x01`\x01`\xc0\x1b\x03\x16\x90\x82\x01R``\x01a\x02\xd8V[a\x02\xcea\x04#6`\x04aJ\xfbV[`\x9b` R`\0\x90\x81R`@\x90 T\x81V[`\x9eTa\x03\x1f\x90`\x01`\x01`\xa0\x1b\x03\x16\x81V[a\x03\x1fa\x04V6`\x04aH\xecV[a\x0e\x94V[a\x02\xaca\x04i6`\x04aJ\xabV[a\x0f V[a\x02\xaca\x04|6`\x04aJ\xabV[a\x0f1V[a\x03\x1f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x04\xbba\x04\xb66`\x04aJ\xabV[a\x0fBV[`@Qa\x02\xd8\x91\x90aK\x16V[a\x02\xaca\x04\xd66`\x04aKnV[a\x0f\xc1V[a\x04\xeea\x04\xe96`\x04aJ\xabV[a\x14\xd1V[`@Qa\x02\xd8\x91\x90aL\x11V[a\x02\xaca\x15EV[a\x03\xbca\x05\x116`\x04aJ\xfbV[`\x01\x80T`\xff\x90\x92\x16\x1b\x90\x81\x16\x14\x90V[a\x02\xaca\x0506`\x04aL\x96V[a\x16\x11V[`\x01Ta\x02\xceV[a\x03\x1f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x03\x1fa\x05r6`\x04aH\xecV[a\x16\xa8V[a\x03\x1f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\xaca\x05\xac6`\x04aL\xcaV[a\x16\xd2V[a\x02\xaca\x17\x92V[a\x02\xcea\x05\xc76`\x04aM\x81V[a\x17\xa6V[a\x02\xf4a\x05\xda6`\x04aH\xecV[a\x17\xf0V[`\0Ta\x03\x1f\x90b\x01\0\0\x90\x04`\x01`\x01`\xa0\x1b\x03\x16\x81V[a\x03\x1fa\x17\xfbV[`\x96Ta\x06\r\x90`\xff\x16\x81V[`@Q`\xff\x90\x91\x16\x81R` \x01a\x02\xd8V[a\x02\xaca\x06-6`\x04aO\x1aV[a\x18\x14V[a\x03\x1f\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81V[a\x02\xce\x7f+\xd8!$\x05\x7f\t\x13\xbc;w,\xe7\xb8>\x80W\xc1\xad\x1f5\x10\xfc\x83w\x8b\xe2\x0f\x10\xec]\xe6\x81V[a\x02\xaca\x06\x8e6`\x04aP\x13V[a\x1bKV[a\x06\xa6a\x06\xa16`\x04aP\xbbV[a\x1c\xceV[`@Qa\x02\xd8\x91\x90aQ`V[a\x02\xce\x7fM@N2v\xe7\xac!c\xd8\xeeGj\xfajA\xd1\xf6\x8f\xb7\x1f-\x8beF\xb2NU\xce\x01\xb7*\x81V[a\x02\xaca\x06\xe86`\x04aQ\xaaV[a\x1d\x87V[`\x9cTa\x02\xceV[a\x02\xaca\x07\x036`\x04aR\x90V[a\x1d\xedV[a\x02\xaca\x07\x166`\x04aTCV[a\x1e\0V[a\x07\x8aa\x07)6`\x04aJ\xfbV[`@\x80Q``\x80\x82\x01\x83R`\0\x80\x83R` \x80\x84\x01\x82\x90R\x92\x84\x01\x81\x90R`\xff\x94\x90\x94\x16\x84R`\x97\x82R\x92\x82\x90 \x82Q\x93\x84\x01\x83RTc\xff\xff\xff\xff\x81\x16\x84Ra\xff\xff`\x01` \x1b\x82\x04\x81\x16\x92\x85\x01\x92\x90\x92R`\x01`0\x1b\x90\x04\x16\x90\x82\x01R\x90V[`@\x80Q\x82Qc\xff\xff\xff\xff\x16\x81R` \x80\x84\x01Qa\xff\xff\x90\x81\x16\x91\x83\x01\x91\x90\x91R\x92\x82\x01Q\x90\x92\x16\x90\x82\x01R``\x01a\x02\xd8V[a\x02\xaca\x07\xcc6`\x04aJ\xabV[a!\x04V[a\x02\xaca\x07\xdf6`\x04aH\xecV[a!zV[a\x08\x13a\x07\xf26`\x04aJ\xabV[`\x01`\x01`\xa0\x1b\x03\x16`\0\x90\x81R`\x99` R`@\x90 `\x01\x01T`\xff\x16\x90V[`@Qa\x02\xd8\x91\x90aU\x17V[`\x01T`\x02\x90`\x04\x90\x81\x16\x03a\x08QW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[`@Q\x80\x91\x03\x90\xfd[`\0[\x82\x81\x10\x15a\t/W`\0\x84\x84\x83\x81\x81\x10a\x08pWa\x08paU\\V[\x90P` \x02\x01` \x81\x01\x90a\x08\x85\x91\x90aJ\xabV[`\x01`\x01`\xa0\x1b\x03\x81\x16`\0\x90\x81R`\x99` \x90\x81R`@\x80\x83 \x81Q\x80\x83\x01\x90\x92R\x80T\x82R`\x01\x81\x01T\x94\x95P\x92\x93\x90\x92\x91\x83\x01\x90`\xff\x16`\x02\x81\x11\x15a\x08\xd0Wa\x08\xd0aK\xd9V[`\x02\x81\x11\x15a\x08\xe1Wa\x08\xe1aK\xd9V[\x90RP\x80Q\x90\x91P`\0a\x08\xf4\x82a\"\xd6V[\x90P`\0a\t\n\x82`\x01`\x01`\xc0\x1b\x03\x16a#AV[\x90Pa\t\x17\x85\x85\x83a$\rV[PPPPP\x80\x80a\t'\x90aU\x88V[\x91PPa\x08TV[PPPPV[`\0\x83\x81R`\x98` R`@\x81 \x80T\x82\x91\x90\x84\x90\x81\x10a\tXWa\tXaU\\V[`\0\x91\x82R` \x91\x82\x90 `@\x80Q``\x81\x01\x82R\x92\x90\x91\x01Tc\xff\xff\xff\xff\x80\x82\x16\x80\x85R`\x01` \x1b\x83\x04\x82\x16\x95\x85\x01\x95\x90\x95R`\x01`@\x1b\x90\x91\x04`\x01`\x01`\xc0\x1b\x03\x16\x91\x83\x01\x91\x90\x91R\x90\x92P\x85\x16\x10\x15a\nRW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`e`$\x82\x01R\x7fRegistryCoordinator.getQuorumBit`D\x82\x01R\x7fmapAtBlockNumberByIndex: quorumB`d\x82\x01R\x7fitmapUpdate is from after blockN`\x84\x82\x01Rd:\xb6\xb12\xb9`\xd9\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[` \x81\x01Qc\xff\xff\xff\xff\x16\x15\x80a\nxWP\x80` \x01Qc\xff\xff\xff\xff\x16\x84c\xff\xff\xff\xff\x16\x10[a\x0b\x1fW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`f`$\x82\x01R\x7fRegistryCoordinator.getQuorumBit`D\x82\x01R\x7fmapAtBlockNumberByIndex: quorumB`d\x82\x01R\x7fitmapUpdate is from before block`\x84\x82\x01Re':\xb6\xb12\xb9`\xd1\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[`@\x01Q\x94\x93PPPPV[`\x013`\0\x90\x81R`\x99` R`@\x90 `\x01\x01T`\xff\x16`\x02\x81\x11\x15a\x0bTWa\x0bTaK\xd9V[\x14a\x0b\xc7W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`<`$\x82\x01R\x7fRegistryCoordinator.updateSocket`D\x82\x01R\x7f: operator is not registered\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[3`\0\x90\x81R`\x99` R`@\x90\x81\x90 T\x90Q\x7f\xec)c\xab!\xc1\xe5\x0e\x1eX*\xa5B\xaf.K\xf7\xbf8\xe6\xe1@<'\xb4.\x1c]nb\x1e\xaa\x90a\x0c\x08\x90\x84\x90aU\xe7V[`@Q\x80\x91\x03\x90\xa2PV[`\0`\x02\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xa0\x1b\x03\x16`\x01`\x01`\xa0\x1b\x03\x16c\xea\xb6mz`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0cfW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0c\x8a\x91\x90aU\xfaV[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a\x0c\xbaW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aV\x17V[a\x0c\xc3\x81a$\xfaV[PV[`\0T`@Qc#}\xfbG`\xe1\x1b\x81R3`\x04\x82\x01Rb\x01\0\0\x90\x91\x04`\x01`\x01`\xa0\x1b\x03\x16\x90cF\xfb\xf6\x8e\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\r\x13W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\r7\x91\x90aVaV[a\rSW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aV\x83V[`\x01T\x81\x81\x16\x14a\r\xccW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7fPausable.pause: invalid attempt `D\x82\x01R\x7fto unpause functionality\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[`\x01\x81\x90U`@Q\x81\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01a\x0c\x08V[`@\x80Q``\x81\x01\x82R`\0\x80\x82R` \x82\x01\x81\x90R\x91\x81\x01\x91\x90\x91R`\0\x83\x81R`\x98` R`@\x90 \x80T\x83\x90\x81\x10a\x0e@Wa\x0e@aU\\V[`\0\x91\x82R` \x91\x82\x90 `@\x80Q``\x81\x01\x82R\x91\x90\x92\x01Tc\xff\xff\xff\xff\x80\x82\x16\x83R`\x01` \x1b\x82\x04\x16\x93\x82\x01\x93\x90\x93R`\x01`\x01`\xc0\x1b\x03`\x01`@\x1b\x90\x93\x04\x92\x90\x92\x16\x90\x82\x01R\x90P[\x92\x91PPV[`@Qc\x08\xf6b\x9d`\xe3\x1b\x81R`\x04\x81\x01\x82\x90R`\0\x90\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x90cG\xb3\x14\xe8\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x0e\xfcW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x0e\x8e\x91\x90aU\xfaV[a\x0f(a%\xffV[a\x0c\xc3\x81a&^V[a\x0f9a%\xffV[a\x0c\xc3\x81a&\xc7V[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01Ra\x0e\x8ea\x0f\xbc\x7f+\xd8!$\x05\x7f\t\x13\xbc;w,\xe7\xb8>\x80W\xc1\xad\x1f5\x10\xfc\x83w\x8b\xe2\x0f\x10\xec]\xe6\x84`@Q` \x01a\x0f\xa1\x92\x91\x90\x91\x82R`\x01`\x01`\xa0\x1b\x03\x16` \x82\x01R`@\x01\x90V[`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 a'0V[a'~V[`\x01T`\x02\x90`\x04\x90\x81\x16\x03a\x0f\xe9W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[`\0a\x101\x84\x84\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPP`\x96T`\xff\x16\x91Pa(\r\x90PV[\x90P\x84\x83\x14a\x10\xa2W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`C`$\x82\x01R`\0\x80Q` a\\\xf2\x839\x81Q\x91R`D\x82\x01R\x7forsForQuorum: input length misma`d\x82\x01Rb\x0e\x8cm`\xeb\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\0[\x83\x81\x10\x15a\x14\xc8W`\0\x85\x85\x83\x81\x81\x10a\x10\xc1Wa\x10\xc1aU\\V[\x91\x90\x91\x015`\xf8\x1c\x91P6\x90P`\0\x89\x89\x85\x81\x81\x10a\x10\xe2Wa\x10\xe2aU\\V[\x90P` \x02\x81\x01\x90a\x10\xf4\x91\x90aV\xcbV[`@Qcy\xa0\x84\x91`\xe1\x1b\x81R`\xff\x86\x16`\x04\x82\x01R\x91\x93P\x91P\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x90c\xf3A\t\"\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x11`W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x11\x84\x91\x90aW\x14V[c\xff\xff\xff\xff\x16\x81\x14a\x12 W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`e`$\x82\x01R`\0\x80Q` a\\\xf2\x839\x81Q\x91R`D\x82\x01R\x7forsForQuorum: number of updated `d\x82\x01R\x7foperators does not match quorum `\x84\x82\x01Rd\x1d\x1b\xdd\x18[`\xda\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[`\0\x80[\x82\x81\x10\x15a\x14gW`\0\x84\x84\x83\x81\x81\x10a\x12@Wa\x12@aU\\V[\x90P` \x02\x01` \x81\x01\x90a\x12U\x91\x90aJ\xabV[`\x01`\x01`\xa0\x1b\x03\x81\x16`\0\x90\x81R`\x99` \x90\x81R`@\x80\x83 \x81Q\x80\x83\x01\x90\x92R\x80T\x82R`\x01\x81\x01T\x94\x95P\x92\x93\x90\x92\x91\x83\x01\x90`\xff\x16`\x02\x81\x11\x15a\x12\xa0Wa\x12\xa0aK\xd9V[`\x02\x81\x11\x15a\x12\xb1Wa\x12\xb1aK\xd9V[\x90RP\x80Q\x90\x91P`\0a\x12\xc4\x82a\"\xd6V[\x90P`\x01`\x01`\x01`\xc0\x1b\x03\x82\x16`\xff\x8b\x16\x1c\x81\x16\x14a\x13HW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R`\0\x80Q` a\\\xf2\x839\x81Q\x91R\x90\x82\x01R\x7forsForQuorum: operator not in qu`d\x82\x01Rcorum`\xe0\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[\x85`\x01`\x01`\xa0\x1b\x03\x16\x84`\x01`\x01`\xa0\x1b\x03\x16\x11a\x13\xf3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`g`$\x82\x01R`\0\x80Q` a\\\xf2\x839\x81Q\x91R`D\x82\x01R\x7forsForQuorum: operators array mu`d\x82\x01R\x7fst be sorted in ascending addres`\x84\x82\x01Rf9\x907\xb922\xb9`\xc9\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[Pa\x14Q\x83\x83\x8f\x8f\x8d\x90\x8e`\x01a\x14\n\x91\x90aW1V[\x92a\x14\x17\x93\x92\x91\x90aWDV[\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa$\r\x92PPPV[P\x90\x92Pa\x14`\x90P\x81aU\x88V[\x90Pa\x12$V[P`\xff\x84\x16`\0\x81\x81R`\x9b` \x90\x81R`@\x91\x82\x90 C\x90\x81\x90U\x91Q\x91\x82R\x7fF\x07}U3\x07c\xf1bi\xfdu\xe5v\x16c\xf4\x19-'\x91t|\x01\x89\xb1j\xd3\x1d\xb0}\xb4\x91\x01`@Q\x80\x91\x03\x90\xa2PPPP\x80a\x14\xc1\x90aU\x88V[\x90Pa\x10\xa5V[PPPPPPPV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R`\x01`\x01`\xa0\x1b\x03\x82\x16`\0\x90\x81R`\x99` \x90\x81R`@\x91\x82\x90 \x82Q\x80\x84\x01\x90\x93R\x80T\x83R`\x01\x81\x01T\x90\x91\x83\x01\x90`\xff\x16`\x02\x81\x11\x15a\x15+Wa\x15+aK\xd9V[`\x02\x81\x11\x15a\x15<Wa\x15<aK\xd9V[\x90RP\x92\x91PPV[`\0T`@Qc#}\xfbG`\xe1\x1b\x81R3`\x04\x82\x01Rb\x01\0\0\x90\x91\x04`\x01`\x01`\xa0\x1b\x03\x16\x90cF\xfb\xf6\x8e\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a\x15\x92W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a\x15\xb6\x91\x90aVaV[a\x15\xd2W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aV\x83V[`\0\x19`\x01\x81\x90U`@Q\x90\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01`@Q\x80\x91\x03\x90\xa2V[a\x16\x19a%\xffV[`\x96T\x82\x90`\xff\x90\x81\x16\x90\x82\x16\x10a\x16\x99W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`7`$\x82\x01R\x7fRegistryCoordinator.quorumExists`D\x82\x01R\x7f: quorum does not exist\0\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[a\x16\xa3\x83\x83a(\x9eV[PPPV[`\x9c\x81\x81T\x81\x10a\x16\xb8W`\0\x80\xfd[`\0\x91\x82R` \x90\x91 \x01T`\x01`\x01`\xa0\x1b\x03\x16\x90P\x81V[`\x9eT`\x01`\x01`\xa0\x1b\x03\x163\x14a\x17RW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`:`$\x82\x01R\x7fRegistryCoordinator.onlyEjector:`D\x82\x01R\x7f caller is not the ejector\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[a\x16\xa3\x83\x83\x83\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa)K\x92PPPV[a\x17\x9aa%\xffV[a\x17\xa4`\0a-\xbdV[V[`\0a\x17\xe6\x7fM@N2v\xe7\xac!c\xd8\xeeGj\xfajA\xd1\xf6\x8f\xb7\x1f-\x8beF\xb2NU\xce\x01\xb7*\x87\x87\x87\x87\x87`@Q` \x01a\x0f\xa1\x96\x95\x94\x93\x92\x91\x90aWnV[\x96\x95PPPPPPV[`\0a\x0e\x8e\x82a\"\xd6V[`\0a\x18\x0f`dT`\x01`\x01`\xa0\x1b\x03\x16\x90V[\x90P\x90V[`\x01\x80T`\0\x91\x90\x81\x16\x03a\x18;W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[\x83\x89\x14a\x18\xbeW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R\x7fRegistryCoordinator.registerOper\x90\x82\x01R\x7fatorWithChurn: input length mism`d\x82\x01Rc\x0c.\x8cm`\xe3\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\0a\x18\xca3\x88a.\x0fV[\x90Pa\x19*3\x82\x88\x88\x80\x80` \x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01`\0\x90[\x82\x82\x10\x15a\x19\x1fWa\x19\x10`@\x83\x02\x86\x016\x81\x90\x03\x81\x01\x90aW\xf3V[\x81R` \x01\x90`\x01\x01\x90a\x18\xf3V[PPPPP\x87a/DV[`\0a\x19q3\x83\x8e\x8e\x8e\x8e\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP\x8c\x92Pa0\xd1\x91PPV[\x90P`\0[\x8b\x81\x10\x15a\x1b<W`\0`\x97`\0\x8f\x8f\x85\x81\x81\x10a\x19\x96Wa\x19\x96aU\\V[\x91\x90\x91\x015`\xf8\x1c\x82RP` \x80\x82\x01\x92\x90\x92R`@\x90\x81\x01`\0 \x81Q``\x81\x01\x83R\x90Tc\xff\xff\xff\xff\x81\x16\x80\x83Ra\xff\xff`\x01` \x1b\x83\x04\x81\x16\x95\x84\x01\x95\x90\x95R`\x01`0\x1b\x90\x91\x04\x90\x93\x16\x91\x81\x01\x91\x90\x91R\x84Q\x80Q\x91\x93P\x90\x84\x90\x81\x10a\x1a\x03Wa\x1a\x03aU\\V[` \x02` \x01\x01Qc\xff\xff\xff\xff\x16\x11\x15a\x1b)Wa\x1a\xa4\x8e\x8e\x84\x81\x81\x10a\x1a,Wa\x1a,aU\\V[\x90P\x015`\xf8\x1c`\xf8\x1b`\xf8\x1c\x84`@\x01Q\x84\x81Q\x81\x10a\x1aOWa\x1aOaU\\V[` \x02` \x01\x01Q3\x86` \x01Q\x86\x81Q\x81\x10a\x1anWa\x1anaU\\V[` \x02` \x01\x01Q\x8d\x8d\x88\x81\x81\x10a\x1a\x88Wa\x1a\x88aU\\V[\x90P`@\x02\x01\x806\x03\x81\x01\x90a\x1a\x9e\x91\x90aW\xf3V[\x86a5\xe8V[a\x1b)\x89\x89\x84\x81\x81\x10a\x1a\xb9Wa\x1a\xb9aU\\V[\x90P`@\x02\x01` \x01` \x81\x01\x90a\x1a\xd1\x91\x90aJ\xabV[\x8f\x8f\x85\x90\x86`\x01a\x1a\xe2\x91\x90aW1V[\x92a\x1a\xef\x93\x92\x91\x90aWDV[\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa)K\x92PPPV[P\x80a\x1b4\x81aU\x88V[\x91PPa\x19vV[PPPPPPPPPPPPPV[`\x01\x80T`\0\x91\x90\x81\x16\x03a\x1brW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[`\0a\x1b~3\x85a.\x0fV[\x90P`\0a\x1b\xc73\x83\x8b\x8b\x8b\x8b\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RP\x8c\x92Pa0\xd1\x91PPV[Q\x90P`\0[\x88\x81\x10\x15a\x1c\xc2W`\0\x8a\x8a\x83\x81\x81\x10a\x1b\xe9Wa\x1b\xe9aU\\V[\x91\x90\x91\x015`\xf8\x1c`\0\x81\x81R`\x97` R`@\x90 T\x85Q\x91\x93Pc\xff\xff\xff\xff\x16\x91P\x84\x90\x84\x90\x81\x10a\x1c\x1fWa\x1c\x1faU\\V[` \x02` \x01\x01Qc\xff\xff\xff\xff\x16\x11\x15a\x1c\xafW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R\x7fRegistryCoordinator.registerOper\x90\x82\x01R\x7fator: operator count exceeds max`d\x82\x01Rcimum`\xe0\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[P\x80a\x1c\xba\x81aU\x88V[\x91PPa\x1b\xcdV[PPPPPPPPPPV[```\0\x82Q`\x01`\x01`@\x1b\x03\x81\x11\x15a\x1c\xebWa\x1c\xebaIOV[`@Q\x90\x80\x82R\x80` \x02` \x01\x82\x01`@R\x80\x15a\x1d\x14W\x81` \x01` \x82\x02\x806\x837\x01\x90P[P\x90P`\0[\x83Q\x81\x10\x15a\x1d\x7fWa\x1dF\x85\x85\x83\x81Q\x81\x10a\x1d9Wa\x1d9aU\\V[` \x02` \x01\x01Qa8\xbcV[\x82\x82\x81Q\x81\x10a\x1dXWa\x1dXaU\\V[c\xff\xff\xff\xff\x90\x92\x16` \x92\x83\x02\x91\x90\x91\x01\x90\x91\x01R\x80a\x1dw\x81aU\x88V[\x91PPa\x1d\x1aV[P\x93\x92PPPV[`\x01\x80T`\x02\x90\x81\x16\x03a\x1d\xadW`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aU%V[a\x16\xa33\x84\x84\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPa)K\x92PPPV[a\x1d\xf5a%\xffV[a\x16\xa3\x83\x83\x83a9\xf8V[`\0Ta\x01\0\x90\x04`\xff\x16\x15\x80\x80\x15a\x1e WP`\0T`\x01`\xff\x90\x91\x16\x10[\x80a\x1e:WP0;\x15\x80\x15a\x1e:WP`\0T`\xff\x16`\x01\x14[a\x1e\x9dW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`.`$\x82\x01R\x7fInitializable: contract is alrea`D\x82\x01Rm\x19\x1eH\x1a[\x9a]\x1aX[\x1a^\x99Y`\x92\x1b`d\x82\x01R`\x84\x01a\x08HV[`\0\x80T`\xff\x19\x16`\x01\x17\x90U\x80\x15a\x1e\xc0W`\0\x80Ta\xff\0\x19\x16a\x01\0\x17\x90U[\x82Q\x84Q\x14\x80\x15a\x1e\xd2WP\x81Q\x83Q\x14[a\x1f<W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7fRegistryCoordinator.initialize: `D\x82\x01Rt\r-\xce\x0e\xae\x84\r\x8c\xad\xcc\xee\x8d\x04\r\xad.m\xac.\x8cm`[\x1b`d\x82\x01R`\x84\x01a\x08HV[a\x1fE\x89a-\xbdV[a\x1fO\x86\x86a<\x0fV[a\x1fX\x88a&^V[a\x1fa\x87a&\xc7V[`\x9c\x80T`\x01\x81\x81\x01\x83U`\0\x83\x81R\x7f\xaf\x85\xb9\x07\x1d\xfa\xfe\xac\x14\t\xd3\xf1\xd1\x9b\xaf\xc9\xbc|7\x97L\xde\x8d\xf0\xeeah\xf0\x08nS\x9c\x92\x83\x01\x80T`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x81\x16`\x01`\x01`\xa0\x1b\x03\x19\x92\x83\x16\x17\x90\x92U\x85T\x80\x85\x01\x87U\x85\x01\x80T\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x84\x16\x90\x83\x16\x17\x90U\x85T\x93\x84\x01\x90\x95U\x91\x90\x92\x01\x80T\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x92\x16\x91\x90\x93\x16\x17\x90\x91U[\x84Q\x81\x10\x15a \xb2Wa \xa0\x85\x82\x81Q\x81\x10a _Wa _aU\\V[` \x02` \x01\x01Q\x85\x83\x81Q\x81\x10a yWa yaU\\V[` \x02` \x01\x01Q\x85\x84\x81Q\x81\x10a \x93Wa \x93aU\\V[` \x02` \x01\x01Qa9\xf8V[\x80a \xaa\x81aU\x88V[\x91PPa AV[P\x80\x15a \xf9W`\0\x80Ta\xff\0\x19\x16\x90U`@Q`\x01\x81R\x7f\x7f&\xb8?\xf9n\x1f+jh/\x138R\xf6y\x8a\t\xc4e\xda\x95\x92\x14`\xce\xfb8G@$\x98\x90` \x01`@Q\x80\x91\x03\x90\xa1[PPPPPPPPPV[a!\x0ca%\xffV[`\x01`\x01`\xa0\x1b\x03\x81\x16a!qW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7fOwnable: new owner is the zero a`D\x82\x01Reddress`\xd0\x1b`d\x82\x01R`\x84\x01a\x08HV[a\x0c\xc3\x81a-\xbdV[`\0`\x02\x90T\x90a\x01\0\n\x90\x04`\x01`\x01`\xa0\x1b\x03\x16`\x01`\x01`\xa0\x1b\x03\x16c\xea\xb6mz`@Q\x81c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a!\xcdW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a!\xf1\x91\x90aU\xfaV[`\x01`\x01`\xa0\x1b\x03\x163`\x01`\x01`\xa0\x1b\x03\x16\x14a\"!W`@QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x01a\x08H\x90aV\x17V[`\x01T\x19\x81\x19`\x01T\x19\x16\x14a\"\x9fW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`8`$\x82\x01R\x7fPausable.unpause: invalid attemp`D\x82\x01R\x7ft to pause functionality\0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[`\x01\x81\x90U`@Q\x81\x81R3\x90\x7f5\x82\xd1\x82\x8e&\xbfV\xbd\x80\x15\x02\xbc\x02\x1a\xc0\xbc\x8a\xfbW\xc8&\xe4\x98kEY<\x8f\xad8\x9c\x90` \x01a\x0c\x08V[`\0\x81\x81R`\x98` R`@\x81 T\x80\x82\x03a\"\xf5WP`\0\x92\x91PPV[`\0\x83\x81R`\x98` R`@\x90 a#\x0e`\x01\x83aX\x0fV[\x81T\x81\x10a#\x1eWa#\x1eaU\\V[`\0\x91\x82R` \x90\x91 \x01T`\x01`@\x1b\x90\x04`\x01`\x01`\xc0\x1b\x03\x16\x93\x92PPPV[```\0\x80a#O\x84a<\xffV[a\xff\xff\x16`\x01`\x01`@\x1b\x03\x81\x11\x15a#jWa#jaIOV[`@Q\x90\x80\x82R\x80`\x1f\x01`\x1f\x19\x16` \x01\x82\x01`@R\x80\x15a#\x94W` \x82\x01\x81\x806\x837\x01\x90P[P\x90P`\0\x80[\x82Q\x82\x10\x80\x15a#\xacWPa\x01\0\x81\x10[\x15a$\x03W`\x01\x81\x1b\x93P\x85\x84\x16\x15a#\xf3W\x80`\xf8\x1b\x83\x83\x81Q\x81\x10a#\xd5Wa#\xd5aU\\V[` \x01\x01\x90`\x01`\x01`\xf8\x1b\x03\x19\x16\x90\x81`\0\x1a\x90SP\x81`\x01\x01\x91P[a#\xfc\x81aU\x88V[\x90Pa#\x9bV[P\x90\x94\x93PPPPV[`\x01\x82` \x01Q`\x02\x81\x11\x15a$%Wa$%aK\xd9V[\x14a$/WPPPV[\x81Q`@Qc3V\x7f\x7f`\xe1\x1b\x81R`\0\x90`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90cf\xac\xfe\xfe\x90a$\x84\x90\x88\x90\x86\x90\x88\x90`\x04\x01aX\"V[` `@Q\x80\x83\x03\x81`\0\x87Z\xf1\x15\x80\x15a$\xa3W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a$\xc7\x91\x90aXRV[\x90P`\x01`\x01`\xc0\x1b\x03\x81\x16\x15a$\xf3Wa$\xf3\x85a$\xee\x83`\x01`\x01`\xc0\x1b\x03\x16a#AV[a)KV[PPPPPV[`\x01`\x01`\xa0\x1b\x03\x81\x16a%\x88W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`I`$\x82\x01R\x7fPausable._setPauserRegistry: new`D\x82\x01R\x7fPauserRegistry cannot be the zer`d\x82\x01Rho address`\xb8\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\0T`@\x80Q`\x01`\x01`\xa0\x1b\x03b\x01\0\0\x90\x93\x04\x83\x16\x81R\x91\x83\x16` \x83\x01R\x7fn\x9f\xcdS\x98\x96\xfc\xa6\x0e\x8b\x0f\x01\xddX\x023\xe4\x8ak\x0f}\xf0\x13\xb8\x9b\xa7\xf5e\x86\x9a\xcd\xb6\x91\x01`@Q\x80\x91\x03\x90\xa1`\0\x80T`\x01`\x01`\xa0\x1b\x03\x90\x92\x16b\x01\0\0\x02b\x01\0\0`\x01`\xb0\x1b\x03\x19\x90\x92\x16\x91\x90\x91\x17\x90UV[3a&\x08a\x17\xfbV[`\x01`\x01`\xa0\x1b\x03\x16\x14a\x17\xa4W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01\x81\x90R`$\x82\x01R\x7fOwnable: caller is not the owner`D\x82\x01R`d\x01a\x08HV[`\x9dT`@\x80Q`\x01`\x01`\xa0\x1b\x03\x92\x83\x16\x81R\x91\x83\x16` \x83\x01R\x7f1TW\xd8\xa8\xfe`\xf0J\xf1|\x16\xe2\xf5\xa5\xe1\xdba+1d\x8eX\x03\x03`u\x9e\xf8\xf3R\x8c\x91\x01`@Q\x80\x91\x03\x90\xa1`\x9d\x80T`\x01`\x01`\xa0\x1b\x03\x19\x16`\x01`\x01`\xa0\x1b\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`\x9eT`@\x80Q`\x01`\x01`\xa0\x1b\x03\x92\x83\x16\x81R\x91\x83\x16` \x83\x01R\x7f\x8f0\xab\t\xf4:l\x15}\x7f\xce~\n\x13\xc0\x03\x04,\x1c\x95\xe8\xa7.z\x14j!\xc0\xca\xa2M\xc9\x91\x01`@Q\x80\x91\x03\x90\xa1`\x9e\x80T`\x01`\x01`\xa0\x1b\x03\x19\x16`\x01`\x01`\xa0\x1b\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`\0a\x0e\x8ea'=a=*V[\x83`@Qa\x19\x01`\xf0\x1b` \x82\x01R`\"\x81\x01\x83\x90R`B\x81\x01\x82\x90R`\0\x90`b\x01`@Q` \x81\x83\x03\x03\x81R\x90`@R\x80Q\x90` \x01 \x90P\x92\x91PPV[`@\x80Q\x80\x82\x01\x90\x91R`\0\x80\x82R` \x82\x01R`\0\x80\x80a'\xae`\0\x80Q` a]2\x839\x81Q\x91R\x86aX\x91V[\x90P[a'\xba\x81a>QV[\x90\x93P\x91P`\0\x80Q` a]2\x839\x81Q\x91R\x82\x83\t\x83\x03a'\xf3W`@\x80Q\x80\x82\x01\x90\x91R\x90\x81R` \x81\x01\x91\x90\x91R\x93\x92PPPV[`\0\x80Q` a]2\x839\x81Q\x91R`\x01\x82\x08\x90Pa'\xb1V[`\0\x80a(\x19\x84a>\xd3V[\x90P\x80\x83`\xff\x16`\x01\x90\x1b\x11a(\x97W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`?`$\x82\x01R\x7fBitmapUtils.orderedBytesArrayToB`D\x82\x01R\x7fitmap: bitmap exceeds max value\0`d\x82\x01R`\x84\x01a\x08HV[\x93\x92PPPV[`\xff\x82\x16`\0\x81\x81R`\x97` \x90\x81R`@\x91\x82\x90 \x84Q\x81T\x86\x84\x01\x80Q\x88\x87\x01\x80Qc\xff\xff\xff\xff\x90\x95\x16e\xff\xff\xff\xff\xff\xff\x19\x90\x94\x16\x84\x17`\x01` \x1ba\xff\xff\x93\x84\x16\x02\x17g\xff\xff\0\0\0\0\0\0\x19\x16`\x01`0\x1b\x95\x83\x16\x95\x90\x95\x02\x94\x90\x94\x17\x90\x94U\x85Q\x91\x82RQ\x83\x16\x93\x81\x01\x93\x90\x93RQ\x16\x91\x81\x01\x91\x90\x91R\x7f>\xe6\xfe\x8dTa\x02D\xc3\xe9\xd3\xc0f\xaeJ\xee\x99x\x84\xaa(\xf1\x06\x16\xae\x82\x19%@\x13\x18\xac\x90``\x01`@Q\x80\x91\x03\x90\xa2PPV[`\x01`\x01`\xa0\x1b\x03\x82\x16`\0\x90\x81R`\x99` R`@\x90 \x80T`\x01\x80\x83\x01T`\xff\x16`\x02\x81\x11\x15a)\x7fWa)\x7faK\xd9V[\x14a)\xfeW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`C`$\x82\x01R\x7fRegistryCoordinator._deregisterO`D\x82\x01R\x7fperator: operator is not registe`d\x82\x01Rb\x1c\x99Y`\xea\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\x96T`\0\x90a*\x12\x90\x85\x90`\xff\x16a(\rV[\x90P`\0a*\x1f\x83a\"\xd6V[\x90P`\x01`\x01`\xc0\x1b\x03\x82\x16a*\x9dW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`;`$\x82\x01R\x7fRegistryCoordinator._deregisterO`D\x82\x01R\x7fperator: bitmap cannot be 0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[a*\xb4`\x01`\x01`\xc0\x1b\x03\x83\x81\x16\x90\x83\x16\x81\x16\x14\x90V[a+LW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`Y`$\x82\x01R\x7fRegistryCoordinator._deregisterO`D\x82\x01R\x7fperator: operator is not registe`d\x82\x01R\x7fred for specified quorums\0\0\0\0\0\0\0`\x84\x82\x01R`\xa4\x01a\x08HV[`\x01`\x01`\xc0\x1b\x03\x82\x81\x16\x19\x82\x16\x16a+e\x84\x82a@cV[`\x01`\x01`\xc0\x1b\x03\x81\x16a,4W`\x01\x85\x01\x80T`\xff\x19\x16`\x02\x17\x90U`@QcQ\xb2zm`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x88\x81\x16`\x04\x83\x01R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xa3d\xf4\xda\x90`$\x01`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a+\xe5W`\0\x80\xfd[PZ\xf1\x15\x80\x15a+\xf9W=`\0\x80>=`\0\xfd[PP`@Q\x86\x92P`\x01`\x01`\xa0\x1b\x03\x8a\x16\x91P\x7f9o\xdc\xb1\x80\xcb\x0f\xea&\x92\x81\x13\xfb\x0f\xd1\xc3T\x98c\xf9\xcdV>j\x18O\x1dW\x81\x16\xc8\xe4\x90`\0\x90\xa3[`@Qc\xf4\xe2O\xe5`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xf4\xe2O\xe5\x90a,\x82\x90\x8a\x90\x8a\x90`\x04\x01aX\xa5V[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a,\x9cW`\0\x80\xfd[PZ\xf1\x15\x80\x15a,\xb0W=`\0\x80>=`\0\xfd[PP`@Qc\xbd)\xb8\xcd`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc\xbd)\xb8\xcd\x91Pa-\x02\x90\x87\x90\x8a\x90`\x04\x01aX\xc9V[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a-\x1cW`\0\x80\xfd[PZ\xf1\x15\x80\x15a-0W=`\0\x80>=`\0\xfd[PP`@Qc\xbd)\xb8\xcd`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc\xbd)\xb8\xcd\x91Pa-\x82\x90\x87\x90\x8a\x90`\x04\x01aX\xc9V[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a-\x9cW`\0\x80\xfd[PZ\xf1\x15\x80\x15a-\xb0W=`\0\x80>=`\0\xfd[PPPPPPPPPPPV[`d\x80T`\x01`\x01`\xa0\x1b\x03\x83\x81\x16`\x01`\x01`\xa0\x1b\x03\x19\x83\x16\x81\x17\x90\x93U`@Q\x91\x16\x91\x90\x82\x90\x7f\x8b\xe0\x07\x9cS\x16Y\x14\x13D\xcd\x1f\xd0\xa4\xf2\x84\x19I\x7f\x97\"\xa3\xda\xaf\xe3\xb4\x18okdW\xe0\x90`\0\x90\xa3PPV[`@Qc\t\xaa\x15'`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x83\x81\x16`\x04\x83\x01R`\0\x91\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90\x91\x16\x90c\x13T*N\x90`$\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a.zW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a.\x9e\x91\x90aX\xe2V[\x90P`\0\x81\x90\x03a\x0e\x8eW\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16c\xbfy\xceX\x84\x84a.\xe3\x87a\x0fBV[`@Q\x84c\xff\xff\xff\xff\x16`\xe0\x1b\x81R`\x04\x01a/\x01\x93\x92\x91\x90aX\xfbV[` `@Q\x80\x83\x03\x81`\0\x87Z\xf1\x15\x80\x15a/ W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a(\x97\x91\x90aX\xe2V[` \x80\x82\x01Q`\0\x90\x81R`\x9a\x90\x91R`@\x90 T`\xff\x16\x15a/\xeaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`R`$\x82\x01R\x7fRegistryCoordinator._verifyChurn`D\x82\x01R\x7fApproverSignature: churnApprover`d\x82\x01Rq\x08\x1c\xd8[\x1d\x08\x18[\x1c\x99XY\x1eH\x1d\\\xd9Y`r\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[B\x81`@\x01Q\x10\x15a0\x7fW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`R`$\x82\x01R\x7fRegistryCoordinator._verifyChurn`D\x82\x01R\x7fApproverSignature: churnApprover`d\x82\x01Rq\x08\x1c\xdaY\xdb\x98]\x1d\\\x99H\x19^\x1c\x1a\\\x99Y`r\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[` \x80\x82\x01\x80Q`\0\x90\x81R`\x9a\x90\x92R`@\x91\x82\x90 \x80T`\xff\x19\x16`\x01\x17\x90U`\x9dT\x90Q\x91\x83\x01Qa\t/\x92`\x01`\x01`\xa0\x1b\x03\x90\x92\x16\x91a0\xca\x91\x88\x91\x88\x91\x88\x91\x90a\x17\xa6V[\x83QaB$V[a0\xf5`@Q\x80``\x01`@R\x80``\x81R` \x01``\x81R` \x01``\x81RP\x90V[`\0a1=\x86\x86\x80\x80`\x1f\x01` \x80\x91\x04\x02` \x01`@Q\x90\x81\x01`@R\x80\x93\x92\x91\x90\x81\x81R` \x01\x83\x83\x80\x82\x847`\0\x92\x01\x91\x90\x91RPP`\x96T`\xff\x16\x91Pa(\r\x90PV[\x90P`\0a1J\x88a\"\xd6V[\x90P`\x01`\x01`\xc0\x1b\x03\x82\x16a1\xc8W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`9`$\x82\x01R\x7fRegistryCoordinator._registerOpe`D\x82\x01R\x7frator: bitmap cannot be 0\0\0\0\0\0\0\0`d\x82\x01R`\x84\x01a\x08HV[\x80\x82\x16`\x01`\x01`\xc0\x1b\x03\x16\x15a2~W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`h`$\x82\x01R\x7fRegistryCoordinator._registerOpe`D\x82\x01R\x7frator: operator already register`d\x82\x01R\x7fed for some quorums being regist`\x84\x82\x01Rg2\xb92\xb2\x1037\xb9`\xc1\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[`\x01`\x01`\xc0\x1b\x03\x81\x81\x16\x90\x83\x16\x17a2\x97\x89\x82a@cV[\x88\x7f\xec)c\xab!\xc1\xe5\x0e\x1eX*\xa5B\xaf.K\xf7\xbf8\xe6\xe1@<'\xb4.\x1c]nb\x1e\xaa\x87`@Qa2\xc7\x91\x90aU\xe7V[`@Q\x80\x91\x03\x90\xa2`\x01`\x01`\x01`\xa0\x1b\x03\x8b\x16`\0\x90\x81R`\x99` R`@\x90 `\x01\x01T`\xff\x16`\x02\x81\x11\x15a3\x01Wa3\x01aK\xd9V[\x14a4\x1aW`@\x80Q\x80\x82\x01\x82R\x8a\x81R`\x01` \x80\x83\x01\x82\x81R`\x01`\x01`\xa0\x1b\x03\x8f\x16`\0\x90\x81R`\x99\x90\x92R\x93\x90 \x82Q\x81U\x92Q\x83\x82\x01\x80T\x93\x94\x93\x91\x92\x90\x91`\xff\x19\x16\x90\x83`\x02\x81\x11\x15a3\\Wa3\\aK\xd9V[\x02\x17\x90UPP`@Qc\x99&\xee}`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x91Pc\x99&\xee}\x90a3\xb1\x90\x8d\x90\x89\x90`\x04\x01aYkV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a3\xcbW`\0\x80\xfd[PZ\xf1\x15\x80\x15a3\xdfW=`\0\x80>=`\0\xfd[PP`@Q\x8b\x92P`\x01`\x01`\xa0\x1b\x03\x8d\x16\x91P\x7f\xe8\xe6\x8c\xef\x1c:v\x1e\xd7\xbe~\x84c\xa3u\xf2\x7f{\xc35\xe5\x18$\"<\xac\xcecn\xc5\xc3\xfe\x90`\0\x90\xa3[`@Qc\x1f\xd9<\xa9`\xe1\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c?\xb2yR\x90a4j\x90\x8d\x90\x8c\x90\x8c\x90`\x04\x01aY\xdfV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a4\x84W`\0\x80\xfd[PZ\xf1\x15\x80\x15a4\x98W=`\0\x80>=`\0\xfd[PP`@Qc%PGw`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x92Pc%PGw\x91Pa4\xee\x90\x8d\x90\x8d\x90\x8d\x90\x8d\x90`\x04\x01aZ\x04V[`\0`@Q\x80\x83\x03\x81`\0\x87Z\xf1\x15\x80\x15a5\rW=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra55\x91\x90\x81\x01\x90aZ\x90V[`@\x80\x87\x01\x91\x90\x91R` \x86\x01\x91\x90\x91RQb\xbf\xf0M`\xe0\x1b\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90b\xbf\xf0M\x90a5\x92\x90\x8c\x90\x8c\x90\x8c\x90`\x04\x01aZ\xf3V[`\0`@Q\x80\x83\x03\x81`\0\x87Z\xf1\x15\x80\x15a5\xb1W=`\0\x80>=`\0\xfd[PPPP`@Q=`\0\x82>`\x1f=\x90\x81\x01`\x1f\x19\x16\x82\x01`@Ra5\xd9\x91\x90\x81\x01\x90a[\rV[\x84RPPP\x96\x95PPPPPPV[` \x80\x83\x01Q`\x01`\x01`\xa0\x1b\x03\x80\x82\x16`\0\x81\x81R`\x99\x90\x94R`@\x90\x93 T\x91\x92\x90\x87\x16\x03a6gW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`5`$\x82\x01R`\0\x80Q` a]\x12\x839\x81Q\x91R`D\x82\x01Rt97\x1d\x101\xb0\xb777\xba\x101\xb4:\xb97\x109\xb2\xb63`Y\x1b`d\x82\x01R`\x84\x01a\x08HV[\x87`\xff\x16\x84`\0\x01Q`\xff\x16\x14a6\xe4W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R`\0\x80Q` a]\x12\x839\x81Q\x91R`D\x82\x01R\x7frn: quorumNumber not the same as`d\x82\x01Rf\x08\x1c\xdaY\xdb\x99Y`\xca\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`@QcT\x01\xed'`\xe0\x1b\x81R`\x04\x81\x01\x82\x90R`\xff\x89\x16`$\x82\x01R`\0\x90\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x90cT\x01\xed'\x90`D\x01` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15a7UW=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90a7y\x91\x90a[\xa6V[\x90Pa7\x85\x81\x85aC\xdeV[`\x01`\x01``\x1b\x03\x16\x86`\x01`\x01``\x1b\x03\x16\x11a8\x18W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`V`$\x82\x01R`\0\x80Q` a]\x12\x839\x81Q\x91R`D\x82\x01R\x7frn: incoming operator has insuff`d\x82\x01Ru4\xb1\xb4\xb2\xb7:\x109\xba0\xb5\xb2\x9037\xb9\x101\xb4:\xb97`Q\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[a8\"\x88\x85aD\x02V[`\x01`\x01``\x1b\x03\x16\x81`\x01`\x01``\x1b\x03\x16\x10a \xf9W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\\`$\x82\x01R`\0\x80Q` a]\x12\x839\x81Q\x91R`D\x82\x01R\x7frn: cannot kick operator with mo`d\x82\x01R\x7fre than kickBIPsOfTotalStake\0\0\0\0`\x84\x82\x01R`\xa4\x01a\x08HV[`\0\x81\x81R`\x98` R`@\x81 T\x81[\x81\x81\x10\x15a9NW`\x01a8\xe1\x82\x84aX\x0fV[a8\xeb\x91\x90aX\x0fV[\x92P\x84c\xff\xff\xff\xff\x16`\x98`\0\x86\x81R` \x01\x90\x81R` \x01`\0 \x84c\xff\xff\xff\xff\x16\x81T\x81\x10a9\x1eWa9\x1eaU\\V[`\0\x91\x82R` \x90\x91 \x01Tc\xff\xff\xff\xff\x16\x11a9<WPPa\x0e\x8eV[\x80a9F\x81aU\x88V[\x91PPa8\xcdV[P`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`l`$\x82\x01R\x7fRegistryCoordinator.getQuorumBit`D\x82\x01R\x7fmapIndexAtBlockNumber: no bitmap`d\x82\x01R\x7f update found for operatorId at `\x84\x82\x01Rk167\xb1\xb5\x907:\xb6\xb12\xb9`\xa1\x1b`\xa4\x82\x01R`\xc4\x01a\x08HV[`\x96T`\xff\x16`\xc0\x81\x10a:lW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`5`$\x82\x01R\x7fRegistryCoordinator.createQuorum`D\x82\x01Rt\x0e\x88\x1bX^\x08\x1c][\xdc\x9d[\\\xc8\x1c\x99XX\xda\x19Y`Z\x1b`d\x82\x01R`\x84\x01a\x08HV[a:w\x81`\x01a[\xc3V[`\x96\x80T`\xff\x19\x16`\xff\x92\x90\x92\x16\x91\x90\x91\x17\x90U\x80a:\x96\x81\x86a(\x9eV[`@Q`\x01b\x96\xb5\x89`\xe0\x1b\x03\x19\x81R`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x90c\xffiJw\x90a:\xe9\x90\x84\x90\x88\x90\x88\x90`\x04\x01a[\xdcV[`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a;\x03W`\0\x80\xfd[PZ\xf1\x15\x80\x15a;\x17W=`\0\x80>=`\0\xfd[PP`@Qc\x13l\xa0\xf9`\xe1\x1b\x81R`\xff\x84\x16`\x04\x82\x01R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x92Pc&\xd9A\xf2\x91P`$\x01`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a;\x7fW`\0\x80\xfd[PZ\xf1\x15\x80\x15a;\x93W=`\0\x80>=`\0\xfd[PP`@Qc\x13l\xa0\xf9`\xe1\x1b\x81R`\xff\x84\x16`\x04\x82\x01R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xa0\x1b\x03\x16\x92Pc&\xd9A\xf2\x91P`$\x01`\0`@Q\x80\x83\x03\x81`\0\x87\x80;\x15\x80\x15a;\xfbW`\0\x80\xfd[PZ\xf1\x15\x80\x15a \xf9W=`\0\x80>=`\0\xfd[`\0Tb\x01\0\0\x90\x04`\x01`\x01`\xa0\x1b\x03\x16\x15\x80\x15a<6WP`\x01`\x01`\xa0\x1b\x03\x82\x16\x15\x15[a<\xb8W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fPausable._initializePauser: _ini`D\x82\x01R\x7ftializePauser() can only be call`d\x82\x01Rfed once`\xc8\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[`\x01\x81\x90U`@Q\x81\x81R3\x90\x7f\xab@\xa3t\xbcQ\xde7\"\0\xa8\xbc\x98\x1a\xf8\xc9\xec\xdc\x08\xdf\xda\xef\x0b\xb6\xe0\x9f\x88\xf3\xc6\x16\xef=\x90` \x01`@Q\x80\x91\x03\x90\xa2a<\xfb\x82a$\xfaV[PPV[`\0\x80[\x82\x15a\x0e\x8eWa=\x14`\x01\x84aX\x0fV[\x90\x92\x16\x91\x80a=\"\x81a\\UV[\x91PPa=\x03V[`\00`\x01`\x01`\xa0\x1b\x03\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16\x14\x80\x15a=\x83WP\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0F\x14[\x15a=\xadWP\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x90V[P`@\x80Q\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0` \x80\x83\x01\x91\x90\x91R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x82\x84\x01R\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0``\x83\x01RF`\x80\x83\x01R0`\xa0\x80\x84\x01\x91\x90\x91R\x83Q\x80\x84\x03\x90\x91\x01\x81R`\xc0\x90\x92\x01\x90\x92R\x80Q\x91\x01 \x90V[`\0\x80\x80`\0\x80Q` a]2\x839\x81Q\x91R`\x03`\0\x80Q` a]2\x839\x81Q\x91R\x86`\0\x80Q` a]2\x839\x81Q\x91R\x88\x89\t\t\x08\x90P`\0a>\xc7\x82\x7f\x0c\x19\x13\x9c\xb8Lh\nn\x14\x11m\xa0`V\x17e\xe0Z\xa4Z\x1cr\xa3O\x08#\x05\xb6\x1f?R`\0\x80Q` a]2\x839\x81Q\x91RaD\x1cV[\x91\x95\x91\x94P\x90\x92PPPV[`\0a\x01\0\x82Q\x11\x15a?\\W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`D`$\x82\x01\x81\x90R\x7fBitmapUtils.orderedBytesArrayToB\x90\x82\x01R\x7fitmap: orderedBytesArray is too `d\x82\x01Rclong`\xe0\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[\x81Q`\0\x03a?mWP`\0\x91\x90PV[`\0\x80\x83`\0\x81Q\x81\x10a?\x83Wa?\x83aU\\V[\x01` \x01Q`\x01`\xf8\x91\x90\x91\x1c\x81\x90\x1b\x92P[\x84Q\x81\x10\x15a@ZW\x84\x81\x81Q\x81\x10a?\xb1Wa?\xb1aU\\V[\x01` \x01Q`\x01`\xf8\x91\x90\x91\x1c\x1b\x91P\x82\x82\x11a@FW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fBitmapUtils.orderedBytesArrayToB`D\x82\x01R\x7fitmap: orderedBytesArray is not `d\x82\x01Rf\x1b\xdc\x99\x19\\\x99Y`\xca\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[\x91\x81\x17\x91a@S\x81aU\x88V[\x90Pa?\x96V[P\x90\x93\x92PPPV[`\0\x82\x81R`\x98` R`@\x81 T\x90\x81\x90\x03aA\x0bW`\0\x83\x81R`\x98` \x90\x81R`@\x80\x83 \x81Q``\x81\x01\x83Rc\xff\xff\xff\xffC\x81\x16\x82R\x81\x85\x01\x86\x81R`\x01`\x01`\xc0\x1b\x03\x80\x8a\x16\x95\x84\x01\x95\x86R\x84T`\x01\x81\x01\x86U\x94\x88R\x95\x90\x96 \x91Q\x91\x90\x92\x01\x80T\x95Q\x93Q\x90\x94\x16`\x01`@\x1b\x02`\x01`\x01`@\x1b\x03\x93\x83\x16`\x01` \x1b\x02g\xff\xff\xff\xff\xff\xff\xff\xff\x19\x90\x96\x16\x91\x90\x92\x16\x17\x93\x90\x93\x17\x16\x91\x90\x91\x17\x90UPPPV[`\0\x83\x81R`\x98` R`@\x81 aA$`\x01\x84aX\x0fV[\x81T\x81\x10aA4WaA4aU\\V[`\0\x91\x82R` \x90\x91 \x01\x80T\x90\x91Pc\xff\xff\xff\xffC\x81\x16\x91\x16\x03aAvW\x80T`\x01`\x01`@\x1b\x03\x16`\x01`@\x1b`\x01`\x01`\xc0\x1b\x03\x85\x16\x02\x17\x81Ua\t/V[\x80Tc\xff\xff\xff\xffC\x81\x16`\x01` \x1b\x81\x81\x02g\xff\xff\xff\xff\0\0\0\0\x19\x90\x94\x16\x93\x90\x93\x17\x84U`\0\x87\x81R`\x98` \x90\x81R`@\x80\x83 \x81Q``\x81\x01\x83R\x94\x85R\x84\x83\x01\x84\x81R`\x01`\x01`\xc0\x1b\x03\x80\x8c\x16\x93\x87\x01\x93\x84R\x82T`\x01\x81\x01\x84U\x92\x86R\x93\x90\x94 \x94Q\x94\x01\x80T\x93Q\x91Q\x90\x92\x16`\x01`@\x1b\x02`\x01`\x01`@\x1b\x03\x91\x86\x16\x90\x96\x02g\xff\xff\xff\xff\xff\xff\xff\xff\x19\x90\x93\x16\x93\x90\x94\x16\x92\x90\x92\x17\x17\x91\x90\x91\x16\x91\x90\x91\x17\x90UPPPPV[`\x01`\x01`\xa0\x1b\x03\x83\x16;\x15aC>W`@Qc\x0b\x13]?`\xe1\x1b\x80\x82R\x90`\x01`\x01`\xa0\x1b\x03\x85\x16\x90c\x16&\xba~\x90aBd\x90\x86\x90\x86\x90`\x04\x01aX\xc9V[` `@Q\x80\x83\x03\x81\x86Z\xfa\x15\x80\x15aB\x81W=`\0\x80>=`\0\xfd[PPPP`@Q=`\x1f\x19`\x1f\x82\x01\x16\x82\x01\x80`@RP\x81\x01\x90aB\xa5\x91\x90a\\vV[`\x01`\x01`\xe0\x1b\x03\x19\x16\x14a\x16\xa3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`S`$\x82\x01R\x7fEIP1271SignatureUtils.checkSigna`D\x82\x01R\x7fture_EIP1271: ERC1271 signature `d\x82\x01Rr\x1d\x99\\\x9aY\x9aX\xd8]\x1a[\xdb\x88\x19\x98Z[\x19Y`j\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[\x82`\x01`\x01`\xa0\x1b\x03\x16aCR\x83\x83aD\xc5V[`\x01`\x01`\xa0\x1b\x03\x16\x14a\x16\xa3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`G`$\x82\x01R\x7fEIP1271SignatureUtils.checkSigna`D\x82\x01R\x7fture_EIP1271: signature not from`d\x82\x01Rf\x109\xb4\xb3\xb72\xb9`\xc9\x1b`\x84\x82\x01R`\xa4\x01a\x08HV[` \x81\x01Q`\0\x90a'\x10\x90aC\xf8\x90a\xff\xff\x16\x85a\\\xa0V[a(\x97\x91\x90a\\\xcbV[`@\x81\x01Q`\0\x90a'\x10\x90aC\xf8\x90a\xff\xff\x16\x85a\\\xa0V[`\0\x80aD'aH+V[aD/aHIV[` \x80\x82R\x81\x81\x01\x81\x90R`@\x82\x01\x81\x90R``\x82\x01\x88\x90R`\x80\x82\x01\x87\x90R`\xa0\x82\x01\x86\x90R\x82`\xc0\x83`\x05a\x07\xd0Z\x03\xfa\x92P\x82\x80aDlW\xfe[P\x82aD\xbaW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x1a`$\x82\x01R\x7fBN254.expMod: call failure\0\0\0\0\0\0`D\x82\x01R`d\x01a\x08HV[PQ\x95\x94PPPPPV[`\0\x80`\0aD\xd4\x85\x85aD\xe1V[\x91P\x91Pa\x1d\x7f\x81aEOV[`\0\x80\x82Q`A\x03aE\x17W` \x83\x01Q`@\x84\x01Q``\x85\x01Q`\0\x1aaE\x0b\x87\x82\x85\x85aG\x05V[\x94P\x94PPPPaEHV[\x82Q`@\x03aE@W` \x83\x01Q`@\x84\x01QaE5\x86\x83\x83aG\xf2V[\x93P\x93PPPaEHV[P`\0\x90P`\x02[\x92P\x92\x90PV[`\0\x81`\x04\x81\x11\x15aEcWaEcaK\xd9V[\x03aEkWPV[`\x01\x81`\x04\x81\x11\x15aE\x7fWaE\x7faK\xd9V[\x03aE\xccW`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x18`$\x82\x01R\x7fECDSA: invalid signature\0\0\0\0\0\0\0\0`D\x82\x01R`d\x01a\x08HV[`\x02\x81`\x04\x81\x11\x15aE\xe0WaE\xe0aK\xd9V[\x03aF-W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\x1f`$\x82\x01R\x7fECDSA: invalid signature length\0`D\x82\x01R`d\x01a\x08HV[`\x03\x81`\x04\x81\x11\x15aFAWaFAaK\xd9V[\x03aF\x99W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7fECDSA: invalid signature 's' val`D\x82\x01Raue`\xf0\x1b`d\x82\x01R`\x84\x01a\x08HV[`\x04\x81`\x04\x81\x11\x15aF\xadWaF\xadaK\xd9V[\x03a\x0c\xc3W`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`\"`$\x82\x01R\x7fECDSA: invalid signature 'v' val`D\x82\x01Raue`\xf0\x1b`d\x82\x01R`\x84\x01a\x08HV[`\0\x80\x7f\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]WnsW\xa4P\x1d\xdf\xe9/Fh\x1b \xa0\x83\x11\x15aG<WP`\0\x90P`\x03aG\xe9V[\x84`\xff\x16`\x1b\x14\x15\x80\x15aGTWP\x84`\xff\x16`\x1c\x14\x15[\x15aGeWP`\0\x90P`\x04aG\xe9V[`@\x80Q`\0\x80\x82R` \x82\x01\x80\x84R\x89\x90R`\xff\x88\x16\x92\x82\x01\x92\x90\x92R``\x81\x01\x86\x90R`\x80\x81\x01\x85\x90R`\x01\x90`\xa0\x01` `@Q` \x81\x03\x90\x80\x84\x03\x90\x85Z\xfa\x15\x80\x15aG\xb9W=`\0\x80>=`\0\xfd[PP`@Q`\x1f\x19\x01Q\x91PP`\x01`\x01`\xa0\x1b\x03\x81\x16aG\xe2W`\0`\x01\x92P\x92PPaG\xe9V[\x91P`\0\x90P[\x94P\x94\x92PPPV[`\0\x80`\x01`\x01`\xff\x1b\x03\x83\x16\x81aH\x0f`\xff\x86\x90\x1c`\x1baW1V[\x90PaH\x1d\x87\x82\x88\x85aG\x05V[\x93P\x93PPP\x93P\x93\x91PPV[`@Q\x80` \x01`@R\x80`\x01\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`@Q\x80`\xc0\x01`@R\x80`\x06\x90` \x82\x02\x806\x837P\x91\x92\x91PPV[`\0\x80\x83`\x1f\x84\x01\x12aHyW`\0\x80\xfd[P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aH\x90W`\0\x80\xfd[` \x83\x01\x91P\x83` \x82`\x05\x1b\x85\x01\x01\x11\x15aEHW`\0\x80\xfd[`\0\x80` \x83\x85\x03\x12\x15aH\xbeW`\0\x80\xfd[\x825`\x01`\x01`@\x1b\x03\x81\x11\x15aH\xd4W`\0\x80\xfd[aH\xe0\x85\x82\x86\x01aHgV[\x90\x96\x90\x95P\x93PPPPV[`\0` \x82\x84\x03\x12\x15aH\xfeW`\0\x80\xfd[P5\x91\x90PV[c\xff\xff\xff\xff\x81\x16\x81\x14a\x0c\xc3W`\0\x80\xfd[`\0\x80`\0``\x84\x86\x03\x12\x15aI,W`\0\x80\xfd[\x835\x92P` \x84\x015aI>\x81aI\x05V[\x92\x95\x92\x94PPP`@\x91\x90\x91\x015\x90V[cNH{q`\xe0\x1b`\0R`A`\x04R`$`\0\xfd[`@Q``\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aI\x87WaI\x87aIOV[`@R\x90V[`@\x80Q\x90\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aI\x87WaI\x87aIOV[`@Q`\x1f\x82\x01`\x1f\x19\x16\x81\x01`\x01`\x01`@\x1b\x03\x81\x11\x82\x82\x10\x17\x15aI\xd7WaI\xd7aIOV[`@R\x91\x90PV[`\0`\x01`\x01`@\x1b\x03\x83\x11\x15aI\xf8WaI\xf8aIOV[aJ\x0b`\x1f\x84\x01`\x1f\x19\x16` \x01aI\xafV[\x90P\x82\x81R\x83\x83\x83\x01\x11\x15aJ\x1fW`\0\x80\xfd[\x82\x82` \x83\x017`\0` \x84\x83\x01\x01R\x93\x92PPPV[`\0` \x82\x84\x03\x12\x15aJHW`\0\x80\xfd[\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aJ^W`\0\x80\xfd[\x82\x01`\x1f\x81\x01\x84\x13aJoW`\0\x80\xfd[aJ~\x84\x825` \x84\x01aI\xdfV[\x94\x93PPPPV[`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x14a\x0c\xc3W`\0\x80\xfd[\x805aJ\xa6\x81aJ\x86V[\x91\x90PV[`\0` \x82\x84\x03\x12\x15aJ\xbdW`\0\x80\xfd[\x815a(\x97\x81aJ\x86V[`\0\x80`@\x83\x85\x03\x12\x15aJ\xdbW`\0\x80\xfd[PP\x805\x92` \x90\x91\x015\x91PV[\x805`\xff\x81\x16\x81\x14aJ\xa6W`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aK\rW`\0\x80\xfd[a(\x97\x82aJ\xeaV[\x81Q\x81R` \x80\x83\x01Q\x90\x82\x01R`@\x81\x01a\x0e\x8eV[`\0\x80\x83`\x1f\x84\x01\x12aK?W`\0\x80\xfd[P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aKVW`\0\x80\xfd[` \x83\x01\x91P\x83` \x82\x85\x01\x01\x11\x15aEHW`\0\x80\xfd[`\0\x80`\0\x80`@\x85\x87\x03\x12\x15aK\x84W`\0\x80\xfd[\x845`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aK\x9bW`\0\x80\xfd[aK\xa7\x88\x83\x89\x01aHgV[\x90\x96P\x94P` \x87\x015\x91P\x80\x82\x11\x15aK\xc0W`\0\x80\xfd[PaK\xcd\x87\x82\x88\x01aK-V[\x95\x98\x94\x97P\x95PPPPV[cNH{q`\xe0\x1b`\0R`!`\x04R`$`\0\xfd[`\x03\x81\x10aL\rWcNH{q`\xe0\x1b`\0R`!`\x04R`$`\0\xfd[\x90RV[\x81Q\x81R` \x80\x83\x01Q`@\x83\x01\x91aL,\x90\x84\x01\x82aK\xefV[P\x92\x91PPV[\x805a\xff\xff\x81\x16\x81\x14aJ\xa6W`\0\x80\xfd[`\0``\x82\x84\x03\x12\x15aLWW`\0\x80\xfd[aL_aIeV[\x90P\x815aLl\x81aI\x05V[\x81RaLz` \x83\x01aL3V[` \x82\x01RaL\x8b`@\x83\x01aL3V[`@\x82\x01R\x92\x91PPV[`\0\x80`\x80\x83\x85\x03\x12\x15aL\xa9W`\0\x80\xfd[aL\xb2\x83aJ\xeaV[\x91PaL\xc1\x84` \x85\x01aLEV[\x90P\x92P\x92\x90PV[`\0\x80`\0`@\x84\x86\x03\x12\x15aL\xdfW`\0\x80\xfd[\x835aL\xea\x81aJ\x86V[\x92P` \x84\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aM\x05W`\0\x80\xfd[aM\x11\x86\x82\x87\x01aK-V[\x94\x97\x90\x96P\x93\x94PPPPV[`\0`\x01`\x01`@\x1b\x03\x82\x11\x15aM7WaM7aIOV[P`\x05\x1b` \x01\x90V[`\0`@\x82\x84\x03\x12\x15aMSW`\0\x80\xfd[aM[aI\x8dV[\x90PaMf\x82aJ\xeaV[\x81R` \x82\x015aMv\x81aJ\x86V[` \x82\x01R\x92\x91PPV[`\0\x80`\0\x80`\0`\xa0\x86\x88\x03\x12\x15aM\x99W`\0\x80\xfd[\x855aM\xa4\x81aJ\x86V[\x94P` \x86\x81\x015\x94P`@\x80\x88\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aM\xc8W`\0\x80\xfd[\x88\x01`\x1f\x81\x01\x8a\x13aM\xd9W`\0\x80\xfd[\x805aM\xecaM\xe7\x82aM\x1eV[aI\xafV[\x81\x81R`\x06\x91\x90\x91\x1b\x82\x01\x84\x01\x90\x84\x81\x01\x90\x8c\x83\x11\x15aN\x0bW`\0\x80\xfd[\x92\x85\x01\x92[\x82\x84\x10\x15aN1WaN\"\x8d\x85aMAV[\x82R\x92\x84\x01\x92\x90\x85\x01\x90aN\x10V[\x99\x9c\x98\x9bP\x98\x99``\x81\x015\x99P`\x80\x015\x97\x96PPPPPPPV[`\0a\x01\0\x82\x84\x03\x12\x15aNaW`\0\x80\xfd[P\x91\x90PV[`\0\x80\x83`\x1f\x84\x01\x12aNyW`\0\x80\xfd[P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aN\x90W`\0\x80\xfd[` \x83\x01\x91P\x83` \x82`\x06\x1b\x85\x01\x01\x11\x15aEHW`\0\x80\xfd[`\0``\x82\x84\x03\x12\x15aN\xbdW`\0\x80\xfd[aN\xc5aIeV[\x90P\x815`\x01`\x01`@\x1b\x03\x81\x11\x15aN\xddW`\0\x80\xfd[\x82\x01`\x1f\x81\x01\x84\x13aN\xeeW`\0\x80\xfd[aN\xfd\x84\x825` \x84\x01aI\xdfV[\x82RP` \x82\x015` \x82\x01R`@\x82\x015`@\x82\x01R\x92\x91PPV[`\0\x80`\0\x80`\0\x80`\0\x80`\0a\x01\xa0\x8a\x8c\x03\x12\x15aO9W`\0\x80\xfd[\x895`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aOPW`\0\x80\xfd[aO\\\x8d\x83\x8e\x01aK-V[\x90\x9bP\x99P` \x8c\x015\x91P\x80\x82\x11\x15aOuW`\0\x80\xfd[aO\x81\x8d\x83\x8e\x01aK-V[\x90\x99P\x97P\x87\x91PaO\x96\x8d`@\x8e\x01aNNV[\x96Pa\x01@\x8c\x015\x91P\x80\x82\x11\x15aO\xadW`\0\x80\xfd[aO\xb9\x8d\x83\x8e\x01aNgV[\x90\x96P\x94Pa\x01`\x8c\x015\x91P\x80\x82\x11\x15aO\xd3W`\0\x80\xfd[aO\xdf\x8d\x83\x8e\x01aN\xabV[\x93Pa\x01\x80\x8c\x015\x91P\x80\x82\x11\x15aO\xf6W`\0\x80\xfd[PaP\x03\x8c\x82\x8d\x01aN\xabV[\x91PP\x92\x95\x98P\x92\x95\x98P\x92\x95\x98V[`\0\x80`\0\x80`\0\x80a\x01`\x87\x89\x03\x12\x15aP-W`\0\x80\xfd[\x865`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aPDW`\0\x80\xfd[aPP\x8a\x83\x8b\x01aK-V[\x90\x98P\x96P` \x89\x015\x91P\x80\x82\x11\x15aPiW`\0\x80\xfd[aPu\x8a\x83\x8b\x01aK-V[\x90\x96P\x94P\x84\x91PaP\x8a\x8a`@\x8b\x01aNNV[\x93Pa\x01@\x89\x015\x91P\x80\x82\x11\x15aP\xa1W`\0\x80\xfd[PaP\xae\x89\x82\x8a\x01aN\xabV[\x91PP\x92\x95P\x92\x95P\x92\x95V[`\0\x80`@\x83\x85\x03\x12\x15aP\xceW`\0\x80\xfd[\x825aP\xd9\x81aI\x05V[\x91P` \x83\x81\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aP\xf5W`\0\x80\xfd[\x84\x01`\x1f\x81\x01\x86\x13aQ\x06W`\0\x80\xfd[\x805aQ\x14aM\xe7\x82aM\x1eV[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x88\x83\x11\x15aQ3W`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15aQQW\x835\x82R\x92\x84\x01\x92\x90\x84\x01\x90aQ8V[\x80\x95PPPPPP\x92P\x92\x90PV[` \x80\x82R\x82Q\x82\x82\x01\x81\x90R`\0\x91\x90\x84\x82\x01\x90`@\x85\x01\x90\x84[\x81\x81\x10\x15aQ\x9eW\x83Qc\xff\xff\xff\xff\x16\x83R\x92\x84\x01\x92\x91\x84\x01\x91`\x01\x01aQ|V[P\x90\x96\x95PPPPPPV[`\0\x80` \x83\x85\x03\x12\x15aQ\xbdW`\0\x80\xfd[\x825`\x01`\x01`@\x1b\x03\x81\x11\x15aQ\xd3W`\0\x80\xfd[aH\xe0\x85\x82\x86\x01aK-V[`\x01`\x01``\x1b\x03\x81\x16\x81\x14a\x0c\xc3W`\0\x80\xfd[`\0\x82`\x1f\x83\x01\x12aR\x05W`\0\x80\xfd[\x815` aR\x15aM\xe7\x83aM\x1eV[\x82\x81R`\x06\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aR4W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aR\x85W`@\x81\x89\x03\x12\x15aRQW`\0\x80\x81\xfd[aRYaI\x8dV[\x815aRd\x81aJ\x86V[\x81R\x81\x85\x015aRs\x81aQ\xdfV[\x81\x86\x01R\x83R\x91\x83\x01\x91`@\x01aR8V[P\x96\x95PPPPPPV[`\0\x80`\0`\xa0\x84\x86\x03\x12\x15aR\xa5W`\0\x80\xfd[aR\xaf\x85\x85aLEV[\x92P``\x84\x015aR\xbf\x81aQ\xdfV[\x91P`\x80\x84\x015`\x01`\x01`@\x1b\x03\x81\x11\x15aR\xdaW`\0\x80\xfd[aR\xe6\x86\x82\x87\x01aQ\xf4V[\x91PP\x92P\x92P\x92V[`\0\x82`\x1f\x83\x01\x12aS\x01W`\0\x80\xfd[\x815` aS\x11aM\xe7\x83aM\x1eV[\x82\x81R``\x92\x83\x02\x85\x01\x82\x01\x92\x82\x82\x01\x91\x90\x87\x85\x11\x15aS0W`\0\x80\xfd[\x83\x87\x01[\x85\x81\x10\x15aSSWaSF\x89\x82aLEV[\x84R\x92\x84\x01\x92\x81\x01aS4V[P\x90\x97\x96PPPPPPPV[`\0\x82`\x1f\x83\x01\x12aSqW`\0\x80\xfd[\x815` aS\x81aM\xe7\x83aM\x1eV[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aS\xa0W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aR\x85W\x805aS\xb7\x81aQ\xdfV[\x83R\x91\x83\x01\x91\x83\x01aS\xa4V[`\0\x82`\x1f\x83\x01\x12aS\xd5W`\0\x80\xfd[\x815` aS\xe5aM\xe7\x83aM\x1eV[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aT\x04W`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aR\x85W\x805`\x01`\x01`@\x1b\x03\x81\x11\x15aT'W`\0\x80\x81\xfd[aT5\x89\x86\x83\x8b\x01\x01aQ\xf4V[\x84RP\x91\x83\x01\x91\x83\x01aT\x08V[`\0\x80`\0\x80`\0\x80`\0\x80a\x01\0\x89\x8b\x03\x12\x15aT`W`\0\x80\xfd[aTi\x89aJ\x9bV[\x97PaTw` \x8a\x01aJ\x9bV[\x96PaT\x85`@\x8a\x01aJ\x9bV[\x95PaT\x93``\x8a\x01aJ\x9bV[\x94P`\x80\x89\x015\x93P`\xa0\x89\x015`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aT\xb6W`\0\x80\xfd[aT\xc2\x8c\x83\x8d\x01aR\xf0V[\x94P`\xc0\x8b\x015\x91P\x80\x82\x11\x15aT\xd8W`\0\x80\xfd[aT\xe4\x8c\x83\x8d\x01aS`V[\x93P`\xe0\x8b\x015\x91P\x80\x82\x11\x15aT\xfaW`\0\x80\xfd[PaU\x07\x8b\x82\x8c\x01aS\xc4V[\x91PP\x92\x95\x98P\x92\x95\x98\x90\x93\x96PV[` \x81\x01a\x0e\x8e\x82\x84aK\xefV[` \x80\x82R`\x19\x90\x82\x01R\x7fPausable: index is paused\0\0\0\0\0\0\0`@\x82\x01R``\x01\x90V[cNH{q`\xe0\x1b`\0R`2`\x04R`$`\0\xfd[cNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[`\0`\x01\x82\x01aU\x9aWaU\x9aaUrV[P`\x01\x01\x90V[`\0\x81Q\x80\x84R`\0[\x81\x81\x10\x15aU\xc7W` \x81\x85\x01\x81\x01Q\x86\x83\x01\x82\x01R\x01aU\xabV[P`\0` \x82\x86\x01\x01R` `\x1f\x19`\x1f\x83\x01\x16\x85\x01\x01\x91PP\x92\x91PPV[` \x81R`\0a(\x97` \x83\x01\x84aU\xa1V[`\0` \x82\x84\x03\x12\x15aV\x0cW`\0\x80\xfd[\x81Qa(\x97\x81aJ\x86V[` \x80\x82R`*\x90\x82\x01R\x7fmsg.sender is not permissioned a`@\x82\x01Ri9\x90:\xb780\xba\xb9\xb2\xb9`\xb1\x1b``\x82\x01R`\x80\x01\x90V[`\0` \x82\x84\x03\x12\x15aVsW`\0\x80\xfd[\x81Q\x80\x15\x15\x81\x14a(\x97W`\0\x80\xfd[` \x80\x82R`(\x90\x82\x01R\x7fmsg.sender is not permissioned a`@\x82\x01Rg9\x9080\xba\xb9\xb2\xb9`\xc1\x1b``\x82\x01R`\x80\x01\x90V[`\0\x80\x835`\x1e\x19\x846\x03\x01\x81\x12aV\xe2W`\0\x80\xfd[\x83\x01\x805\x91P`\x01`\x01`@\x1b\x03\x82\x11\x15aV\xfcW`\0\x80\xfd[` \x01\x91P`\x05\x81\x90\x1b6\x03\x82\x13\x15aEHW`\0\x80\xfd[`\0` \x82\x84\x03\x12\x15aW&W`\0\x80\xfd[\x81Qa(\x97\x81aI\x05V[\x80\x82\x01\x80\x82\x11\x15a\x0e\x8eWa\x0e\x8eaUrV[`\0\x80\x85\x85\x11\x15aWTW`\0\x80\xfd[\x83\x86\x11\x15aWaW`\0\x80\xfd[PP\x82\x01\x93\x91\x90\x92\x03\x91PV[`\0`\xc0\x82\x01\x88\x83R` `\x01\x80`\xa0\x1b\x03\x80\x8a\x16\x82\x86\x01R`@\x89\x81\x87\x01R`\xc0``\x87\x01R\x83\x89Q\x80\x86R`\xe0\x88\x01\x91P\x84\x8b\x01\x95P`\0[\x81\x81\x10\x15aW\xd3W\x86Q\x80Q`\xff\x16\x84R\x86\x01Q\x85\x16\x86\x84\x01R\x95\x85\x01\x95\x91\x83\x01\x91`\x01\x01aW\xa9V[PP`\x80\x87\x01\x98\x90\x98RPPPP`\xa0\x90\x91\x01\x91\x90\x91RP\x94\x93PPPPV[`\0`@\x82\x84\x03\x12\x15aX\x05W`\0\x80\xfd[a(\x97\x83\x83aMAV[\x81\x81\x03\x81\x81\x11\x15a\x0e\x8eWa\x0e\x8eaUrV[`\x01\x80`\xa0\x1b\x03\x84\x16\x81R\x82` \x82\x01R```@\x82\x01R`\0aXI``\x83\x01\x84aU\xa1V[\x95\x94PPPPPV[`\0` \x82\x84\x03\x12\x15aXdW`\0\x80\xfd[\x81Q`\x01`\x01`\xc0\x1b\x03\x81\x16\x81\x14a(\x97W`\0\x80\xfd[cNH{q`\xe0\x1b`\0R`\x12`\x04R`$`\0\xfd[`\0\x82aX\xa0WaX\xa0aX{V[P\x06\x90V[`\x01`\x01`\xa0\x1b\x03\x83\x16\x81R`@` \x82\x01\x81\x90R`\0\x90aJ~\x90\x83\x01\x84aU\xa1V[\x82\x81R`@` \x82\x01R`\0aJ~`@\x83\x01\x84aU\xa1V[`\0` \x82\x84\x03\x12\x15aX\xf4W`\0\x80\xfd[PQ\x91\x90PV[`\x01`\x01`\xa0\x1b\x03\x84\x16\x81Ra\x01`\x81\x01aY#` \x83\x01\x85\x805\x82R` \x90\x81\x015\x91\x01RV[aY=``\x83\x01`@\x86\x01\x805\x82R` \x90\x81\x015\x91\x01RV[`@`\x80\x85\x01`\xa0\x84\x017`@`\xc0\x85\x01`\xe0\x84\x017\x82Qa\x01 \x83\x01R` \x83\x01Qa\x01@\x83\x01RaJ~V[`\x01\x80`\xa0\x1b\x03\x83\x16\x81R`@` \x82\x01R`\0\x82Q```@\x84\x01RaY\x95`\xa0\x84\x01\x82aU\xa1V[\x90P` \x84\x01Q``\x84\x01R`@\x84\x01Q`\x80\x84\x01R\x80\x91PP\x93\x92PPPV[\x81\x83R\x81\x81` \x85\x017P`\0\x82\x82\x01` \x90\x81\x01\x91\x90\x91R`\x1f\x90\x91\x01`\x1f\x19\x16\x90\x91\x01\x01\x90V[`\x01`\x01`\xa0\x1b\x03\x84\x16\x81R`@` \x82\x01\x81\x90R`\0\x90aXI\x90\x83\x01\x84\x86aY\xb6V[`\x01\x80`\xa0\x1b\x03\x85\x16\x81R\x83` \x82\x01R```@\x82\x01R`\0a\x17\xe6``\x83\x01\x84\x86aY\xb6V[`\0\x82`\x1f\x83\x01\x12aZ=W`\0\x80\xfd[\x81Q` aZMaM\xe7\x83aM\x1eV[\x82\x81R`\x05\x92\x90\x92\x1b\x84\x01\x81\x01\x91\x81\x81\x01\x90\x86\x84\x11\x15aZlW`\0\x80\xfd[\x82\x86\x01[\x84\x81\x10\x15aR\x85W\x80QaZ\x83\x81aQ\xdfV[\x83R\x91\x83\x01\x91\x83\x01aZpV[`\0\x80`@\x83\x85\x03\x12\x15aZ\xa3W`\0\x80\xfd[\x82Q`\x01`\x01`@\x1b\x03\x80\x82\x11\x15aZ\xbaW`\0\x80\xfd[aZ\xc6\x86\x83\x87\x01aZ,V[\x93P` \x85\x01Q\x91P\x80\x82\x11\x15aZ\xdcW`\0\x80\xfd[PaZ\xe9\x85\x82\x86\x01aZ,V[\x91PP\x92P\x92\x90PV[\x83\x81R`@` \x82\x01R`\0aXI`@\x83\x01\x84\x86aY\xb6V[`\0` \x80\x83\x85\x03\x12\x15a[ W`\0\x80\xfd[\x82Q`\x01`\x01`@\x1b\x03\x81\x11\x15a[6W`\0\x80\xfd[\x83\x01`\x1f\x81\x01\x85\x13a[GW`\0\x80\xfd[\x80Qa[UaM\xe7\x82aM\x1eV[\x81\x81R`\x05\x91\x90\x91\x1b\x82\x01\x83\x01\x90\x83\x81\x01\x90\x87\x83\x11\x15a[tW`\0\x80\xfd[\x92\x84\x01\x92[\x82\x84\x10\x15a[\x9bW\x83Qa[\x8c\x81aI\x05V[\x82R\x92\x84\x01\x92\x90\x84\x01\x90a[yV[\x97\x96PPPPPPPV[`\0` \x82\x84\x03\x12\x15a[\xb8W`\0\x80\xfd[\x81Qa(\x97\x81aQ\xdfV[`\xff\x81\x81\x16\x83\x82\x16\x01\x90\x81\x11\x15a\x0e\x8eWa\x0e\x8eaUrV[`\0``\x82\x01`\xff\x86\x16\x83R` `\x01`\x01``\x1b\x03\x80\x87\x16\x82\x86\x01R`@``\x81\x87\x01R\x83\x87Q\x80\x86R`\x80\x88\x01\x91P\x84\x89\x01\x95P`\0[\x81\x81\x10\x15a\\EW\x86Q\x80Q`\x01`\x01`\xa0\x1b\x03\x16\x84R\x86\x01Q\x85\x16\x86\x84\x01R\x95\x85\x01\x95\x91\x83\x01\x91`\x01\x01a\\\x15V[P\x90\x9a\x99PPPPPPPPPPV[`\0a\xff\xff\x80\x83\x16\x81\x81\x03a\\lWa\\laUrV[`\x01\x01\x93\x92PPPV[`\0` \x82\x84\x03\x12\x15a\\\x88W`\0\x80\xfd[\x81Q`\x01`\x01`\xe0\x1b\x03\x19\x81\x16\x81\x14a(\x97W`\0\x80\xfd[`\x01`\x01``\x1b\x03\x81\x81\x16\x83\x82\x16\x02\x80\x82\x16\x91\x90\x82\x81\x14a\\\xc3Wa\\\xc3aUrV[PP\x92\x91PPV[`\0`\x01`\x01``\x1b\x03\x80\x84\x16\x80a\\\xe5Wa\\\xe5aX{V[\x92\x16\x91\x90\x91\x04\x92\x91PPV\xfeRegistryCoordinator.updateOperatRegistryCoordinator._validateChu0dNr\xe11\xa0)\xb8PE\xb6\x81\x81X]\x97\x81j\x91hq\xca\x8d< \x8c\x16\xd8|\xfdG\xa2dipfsX\"\x12 \x8d\x8bM\xfd\xe0S\xd8X7\xf1EJ\xd3)\xa5\x13C\xc7]q\x8d\x88\xd96*\x8d\"\xcc\xe0$c\xb6dsolcC\0\x08\x14\03");
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OperatorStatus(u8);
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<OperatorStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::Token<'_>
            {
                alloy_sol_types::private::SolTypeValue::<::alloy_sol_types::sol_data::Uint<8>>::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(self).0
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::abi_encoded_size(
                    self,
                )
            }
        }
        #[automatically_derived]
        impl OperatorStatus {
            #[doc = r" The Solidity type name."]
            pub const NAME: &'static str = "@name";
            #[doc = r" Convert from the underlying value type."]
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            #[doc = r" Return the underlying value."]
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            #[doc = r" Return the single encoding of this value, delegating to the"]
            #[doc = r" underlying type."]
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            #[doc = r" Return the packed encoding of this value, delegating to the"]
            #[doc = r" underlying type."]
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorStatus {
            type RustType = u8;
            type Token<'a> =
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> =
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::type_check(
                    token,
                )
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::detokenize(
                    token,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::encode_topic(
                    rust,
                )
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct G1Point { uint256 X; uint256 Y; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct G1Point {
        pub X: ::alloy_sol_types::private::U256,
        pub Y: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<256>,
            ::alloy_sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::U256,
            ::alloy_sol_types::private::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<G1Point> for UnderlyingRustTuple<'_> {
            fn from(value: G1Point) -> Self {
                (value.X, value.Y)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for G1Point {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    X: tuple.0,
                    Y: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for G1Point {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for G1Point {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.X,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.Y,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for G1Point {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for G1Point {
            const NAME: &'static str = "G1Point";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("G1Point(uint256 X,uint256 Y)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::eip712_data_word(&self.X).0, <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::eip712_data_word(&self.Y).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for G1Point {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.X) + <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.Y)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.X, out);
                <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.Y, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct G2Point { uint256[2] X; uint256[2] Y; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct G2Point {
        pub X: [::alloy_sol_types::private::U256; 2usize],
        pub Y: [::alloy_sol_types::private::U256; 2usize],
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::FixedArray<::alloy_sol_types::sol_data::Uint<256>, 2usize>,
            ::alloy_sol_types::sol_data::FixedArray<::alloy_sol_types::sol_data::Uint<256>, 2usize>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            [::alloy_sol_types::private::U256; 2usize],
            [::alloy_sol_types::private::U256; 2usize],
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<G2Point> for UnderlyingRustTuple<'_> {
            fn from(value: G2Point) -> Self {
                (value.X, value.Y)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for G2Point {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    X: tuple.0,
                    Y: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for G2Point {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for G2Point {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.X),
                    <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.Y),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for G2Point {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for G2Point {
            const NAME: &'static str = "G2Point";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("G2Point(uint256[2] X,uint256[2] Y)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.X)
                    .0,
                    <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.Y)
                    .0,
                ]
                .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for G2Point {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.X
                    )
                    + <::alloy_sol_types::sol_data::FixedArray<
                        ::alloy_sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.Y
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::FixedArray<
                    ::alloy_sol_types::sol_data::Uint<256>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.X, out
                );
                <::alloy_sol_types::sol_data::FixedArray<
                    ::alloy_sol_types::sol_data::Uint<256>,
                    2usize,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.Y, out
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct OperatorInfo { bytes32 operatorId; OperatorStatus status; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OperatorInfo {
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        pub status: <OperatorStatus as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>, OperatorStatus);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::FixedBytes<32>,
            <OperatorStatus as ::alloy_sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorInfo> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorInfo) -> Self {
                (value.operatorId, value.status)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorInfo {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operatorId: tuple.0,
                    status: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OperatorInfo {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OperatorInfo {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.operatorId), <OperatorStatus as alloy_sol_types::SolType>::tokenize(&self.status),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorInfo {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OperatorInfo {
            const NAME: &'static str = "OperatorInfo";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OperatorInfo(bytes32 operatorId,uint8 status)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::eip712_data_word(&self.operatorId).0, <OperatorStatus as alloy_sol_types::SolType>::eip712_data_word(&self.status).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorInfo {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.operatorId) + <OperatorStatus as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.status)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.operatorId, out);
                <OperatorStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.status,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct OperatorKickParam { uint8 quorumNumber; address operator; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OperatorKickParam {
        pub quorumNumber: u8,
        pub operator: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<8>,
            ::alloy_sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u8, ::alloy_sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorKickParam> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorKickParam) -> Self {
                (value.quorumNumber, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorKickParam {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    quorumNumber: tuple.0,
                    operator: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OperatorKickParam {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OperatorKickParam {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumber,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorKickParam {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OperatorKickParam {
            const NAME: &'static str = "OperatorKickParam";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OperatorKickParam(uint8 quorumNumber,address operator)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::eip712_data_word(&self.quorumNumber).0, <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(&self.operator).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorKickParam {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.quorumNumber) + <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.operator)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.quorumNumber, out);
                <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.operator, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct OperatorSetParam { uint32 maxOperatorCount; uint16 kickBIPsOfOperatorStake; uint16 kickBIPsOfTotalStake; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OperatorSetParam {
        pub maxOperatorCount: u32,
        pub kickBIPsOfOperatorStake: u16,
        pub kickBIPsOfTotalStake: u16,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<32>,
            ::alloy_sol_types::sol_data::Uint<16>,
            ::alloy_sol_types::sol_data::Uint<16>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u32, u16, u16);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorSetParam> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorSetParam) -> Self {
                (
                    value.maxOperatorCount,
                    value.kickBIPsOfOperatorStake,
                    value.kickBIPsOfTotalStake,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorSetParam {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    maxOperatorCount: tuple.0,
                    kickBIPsOfOperatorStake: tuple.1,
                    kickBIPsOfTotalStake: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OperatorSetParam {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OperatorSetParam {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.maxOperatorCount,
                    ),
                    <::alloy_sol_types::sol_data::Uint<16> as alloy_sol_types::SolType>::tokenize(
                        &self.kickBIPsOfOperatorStake,
                    ),
                    <::alloy_sol_types::sol_data::Uint<16> as alloy_sol_types::SolType>::tokenize(
                        &self.kickBIPsOfTotalStake,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorSetParam {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OperatorSetParam {
            const NAME: &'static str = "OperatorSetParam";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("OperatorSetParam(uint32 maxOperatorCount,uint16 kickBIPsOfOperatorStake,uint16 kickBIPsOfTotalStake)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::eip712_data_word(&self.maxOperatorCount).0, <::alloy_sol_types::sol_data::Uint<16> as alloy_sol_types::SolType>::eip712_data_word(&self.kickBIPsOfOperatorStake).0, <::alloy_sol_types::sol_data::Uint<16> as alloy_sol_types::SolType>::eip712_data_word(&self.kickBIPsOfTotalStake).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorSetParam {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.maxOperatorCount) + <::alloy_sol_types::sol_data::Uint<16> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.kickBIPsOfOperatorStake) + <::alloy_sol_types::sol_data::Uint<16> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.kickBIPsOfTotalStake)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.maxOperatorCount, out);
                <::alloy_sol_types::sol_data::Uint<16> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.kickBIPsOfOperatorStake, out);
                <::alloy_sol_types::sol_data::Uint<16> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.kickBIPsOfTotalStake, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct PubkeyRegistrationParams { G1Point pubkeyRegistrationSignature; G1Point pubkeyG1; G2Point pubkeyG2; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PubkeyRegistrationParams {
        pub pubkeyRegistrationSignature: <G1Point as ::alloy_sol_types::SolType>::RustType,
        pub pubkeyG1: <G1Point as ::alloy_sol_types::SolType>::RustType,
        pub pubkeyG2: <G2Point as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (G1Point, G1Point, G2Point);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <G1Point as ::alloy_sol_types::SolType>::RustType,
            <G1Point as ::alloy_sol_types::SolType>::RustType,
            <G2Point as ::alloy_sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PubkeyRegistrationParams> for UnderlyingRustTuple<'_> {
            fn from(value: PubkeyRegistrationParams) -> Self {
                (
                    value.pubkeyRegistrationSignature,
                    value.pubkeyG1,
                    value.pubkeyG2,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PubkeyRegistrationParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    pubkeyRegistrationSignature: tuple.0,
                    pubkeyG1: tuple.1,
                    pubkeyG2: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PubkeyRegistrationParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PubkeyRegistrationParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <G1Point as alloy_sol_types::SolType>::tokenize(
                        &self.pubkeyRegistrationSignature,
                    ),
                    <G1Point as alloy_sol_types::SolType>::tokenize(&self.pubkeyG1),
                    <G2Point as alloy_sol_types::SolType>::tokenize(&self.pubkeyG2),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PubkeyRegistrationParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PubkeyRegistrationParams {
            const NAME: &'static str = "PubkeyRegistrationParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("PubkeyRegistrationParams(G1Point pubkeyRegistrationSignature,G1Point pubkeyG1,G2Point pubkeyG2)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                let mut components = alloy_sol_types::private::Vec::with_capacity(3);
                components.push(<G1Point as alloy_sol_types::SolStruct>::eip712_root_type());
                components.extend(<G1Point as alloy_sol_types::SolStruct>::eip712_components());
                components.push(<G1Point as alloy_sol_types::SolStruct>::eip712_root_type());
                components.extend(<G1Point as alloy_sol_types::SolStruct>::eip712_components());
                components.push(<G2Point as alloy_sol_types::SolStruct>::eip712_root_type());
                components.extend(<G2Point as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <G1Point as alloy_sol_types::SolType>::eip712_data_word(
                        &self.pubkeyRegistrationSignature,
                    )
                    .0,
                    <G1Point as alloy_sol_types::SolType>::eip712_data_word(&self.pubkeyG1).0,
                    <G2Point as alloy_sol_types::SolType>::eip712_data_word(&self.pubkeyG2).0,
                ]
                .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PubkeyRegistrationParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <G1Point as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.pubkeyRegistrationSignature,
                    )
                    + <G1Point as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.pubkeyG1,
                    )
                    + <G2Point as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.pubkeyG2,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <G1Point as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.pubkeyRegistrationSignature,
                    out,
                );
                <G1Point as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.pubkeyG1,
                    out,
                );
                <G2Point as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.pubkeyG2,
                    out,
                );
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct QuorumBitmapUpdate { uint32 updateBlockNumber; uint32 nextUpdateBlockNumber; uint192 quorumBitmap; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct QuorumBitmapUpdate {
        pub updateBlockNumber: u32,
        pub nextUpdateBlockNumber: u32,
        pub quorumBitmap:
            <::alloy_sol_types::sol_data::Uint<192> as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Uint<32>,
            ::alloy_sol_types::sol_data::Uint<32>,
            ::alloy_sol_types::sol_data::Uint<192>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u32,
            u32,
            <::alloy_sol_types::sol_data::Uint<192> as ::alloy_sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QuorumBitmapUpdate> for UnderlyingRustTuple<'_> {
            fn from(value: QuorumBitmapUpdate) -> Self {
                (
                    value.updateBlockNumber,
                    value.nextUpdateBlockNumber,
                    value.quorumBitmap,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QuorumBitmapUpdate {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    updateBlockNumber: tuple.0,
                    nextUpdateBlockNumber: tuple.1,
                    quorumBitmap: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QuorumBitmapUpdate {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QuorumBitmapUpdate {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.updateBlockNumber,
                    ),
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self.nextUpdateBlockNumber,
                    ),
                    <::alloy_sol_types::sol_data::Uint<192> as alloy_sol_types::SolType>::tokenize(
                        &self.quorumBitmap,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QuorumBitmapUpdate {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QuorumBitmapUpdate {
            const NAME: &'static str = "QuorumBitmapUpdate";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("QuorumBitmapUpdate(uint32 updateBlockNumber,uint32 nextUpdateBlockNumber,uint192 quorumBitmap)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::eip712_data_word(&self.updateBlockNumber).0, <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::eip712_data_word(&self.nextUpdateBlockNumber).0, <::alloy_sol_types::sol_data::Uint<192> as alloy_sol_types::SolType>::eip712_data_word(&self.quorumBitmap).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QuorumBitmapUpdate {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.updateBlockNumber) + <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.nextUpdateBlockNumber) + <::alloy_sol_types::sol_data::Uint<192> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.quorumBitmap)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.updateBlockNumber, out);
                <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.nextUpdateBlockNumber, out);
                <::alloy_sol_types::sol_data::Uint<192> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.quorumBitmap, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct SignatureWithSaltAndExpiry { bytes signature; bytes32 salt; uint256 expiry; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SignatureWithSaltAndExpiry {
        pub signature: ::alloy_sol_types::private::Bytes,
        pub salt: ::alloy_sol_types::private::FixedBytes<32>,
        pub expiry: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Bytes,
            ::alloy_sol_types::sol_data::FixedBytes<32>,
            ::alloy_sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Bytes,
            ::alloy_sol_types::private::FixedBytes<32>,
            ::alloy_sol_types::private::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SignatureWithSaltAndExpiry> for UnderlyingRustTuple<'_> {
            fn from(value: SignatureWithSaltAndExpiry) -> Self {
                (value.signature, value.salt, value.expiry)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SignatureWithSaltAndExpiry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signature: tuple.0,
                    salt: tuple.1,
                    expiry: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SignatureWithSaltAndExpiry {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SignatureWithSaltAndExpiry {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(&self.signature), <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.salt), <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.expiry),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SignatureWithSaltAndExpiry {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SignatureWithSaltAndExpiry {
            const NAME: &'static str = "SignatureWithSaltAndExpiry";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SignatureWithSaltAndExpiry(bytes signature,bytes32 salt,uint256 expiry)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(&self.signature).0, <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::eip712_data_word(&self.salt).0, <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::eip712_data_word(&self.expiry).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SignatureWithSaltAndExpiry {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.signature) + <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.salt) + <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.expiry)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.signature, out);
                <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.salt, out);
                <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.expiry, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "```solidity\nstruct StrategyParams { address strategy; uint96 multiplier; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct StrategyParams {
        pub strategy: ::alloy_sol_types::private::Address,
        pub multiplier:
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Address,
            ::alloy_sol_types::sol_data::Uint<96>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Address,
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StrategyParams> for UnderlyingRustTuple<'_> {
            fn from(value: StrategyParams) -> Self {
                (value.strategy, value.multiplier)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StrategyParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    strategy: tuple.0,
                    multiplier: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for StrategyParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for StrategyParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.strategy,
                    ),
                    <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::SolType>::tokenize(
                        &self.multiplier,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for StrategyParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for StrategyParams {
            const NAME: &'static str = "StrategyParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "StrategyParams(address strategy,uint96 multiplier)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(&self.strategy).0, <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::SolType>::eip712_data_word(&self.multiplier).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for StrategyParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.strategy) + <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.multiplier)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.strategy, out);
                <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.multiplier, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `ChurnApproverUpdated(address,address)` and selector `0x315457d8a8fe60f04af17c16e2f5a5e1db612b31648e58030360759ef8f3528c`.\n```solidity\nevent ChurnApproverUpdated(address prevChurnApprover, address newChurnApprover);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct ChurnApproverUpdated {
        #[allow(missing_docs)]
        pub prevChurnApprover: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newChurnApprover: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ChurnApproverUpdated {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ChurnApproverUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    49u8, 84u8, 87u8, 216u8, 168u8, 254u8, 96u8, 240u8, 74u8, 241u8, 124u8, 22u8,
                    226u8, 245u8, 165u8, 225u8, 219u8, 97u8, 43u8, 49u8, 100u8, 142u8, 88u8, 3u8,
                    3u8, 96u8, 117u8, 158u8, 248u8, 243u8, 82u8, 140u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    prevChurnApprover: data.0,
                    newChurnApprover: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.prevChurnApprover,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newChurnApprover,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ChurnApproverUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ChurnApproverUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ChurnApproverUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `EjectorUpdated(address,address)` and selector `0x8f30ab09f43a6c157d7fce7e0a13c003042c1c95e8a72e7a146a21c0caa24dc9`.\n```solidity\nevent EjectorUpdated(address prevEjector, address newEjector);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct EjectorUpdated {
        #[allow(missing_docs)]
        pub prevEjector: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newEjector: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EjectorUpdated {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "EjectorUpdated(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    143u8, 48u8, 171u8, 9u8, 244u8, 58u8, 108u8, 21u8, 125u8, 127u8, 206u8, 126u8,
                    10u8, 19u8, 192u8, 3u8, 4u8, 44u8, 28u8, 149u8, 232u8, 167u8, 46u8, 122u8,
                    20u8, 106u8, 33u8, 192u8, 202u8, 162u8, 77u8, 201u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    prevEjector: data.0,
                    newEjector: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.prevEjector,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newEjector,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EjectorUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EjectorUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EjectorUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.\n```solidity\nevent Initialized(uint8 version);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    127u8, 38u8, 184u8, 63u8, 249u8, 110u8, 31u8, 43u8, 106u8, 104u8, 47u8, 19u8,
                    56u8, 82u8, 246u8, 121u8, 138u8, 9u8, 196u8, 101u8, 218u8, 149u8, 146u8, 20u8,
                    96u8, 206u8, 251u8, 56u8, 71u8, 64u8, 36u8, 152u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self.version,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `OperatorDeregistered(address,bytes32)` and selector `0x396fdcb180cb0fea26928113fb0fd1c3549863f9cd563e6a184f1d578116c8e4`.\n```solidity\nevent OperatorDeregistered(address indexed operator, bytes32 indexed operatorId);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorDeregistered {
        #[allow(missing_docs)]
        pub operator: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorDeregistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "OperatorDeregistered(address,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    57u8, 111u8, 220u8, 177u8, 128u8, 203u8, 15u8, 234u8, 38u8, 146u8, 129u8, 19u8,
                    251u8, 15u8, 209u8, 195u8, 84u8, 152u8, 99u8, 249u8, 205u8, 86u8, 62u8, 106u8,
                    24u8, 79u8, 29u8, 87u8, 129u8, 22u8, 200u8, 228u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    operatorId: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.operatorId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.operator);
                out[2usize] = <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::encode_topic(&self.operatorId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorDeregistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorDeregistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorDeregistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `OperatorRegistered(address,bytes32)` and selector `0xe8e68cef1c3a761ed7be7e8463a375f27f7bc335e51824223cacce636ec5c3fe`.\n```solidity\nevent OperatorRegistered(address indexed operator, bytes32 indexed operatorId);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorRegistered {
        #[allow(missing_docs)]
        pub operator: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorRegistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "OperatorRegistered(address,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    232u8, 230u8, 140u8, 239u8, 28u8, 58u8, 118u8, 30u8, 215u8, 190u8, 126u8,
                    132u8, 99u8, 163u8, 117u8, 242u8, 127u8, 123u8, 195u8, 53u8, 229u8, 24u8, 36u8,
                    34u8, 60u8, 172u8, 206u8, 99u8, 110u8, 197u8, 195u8, 254u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    operatorId: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.operatorId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.operator);
                out[2usize] = <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::encode_topic(&self.operatorId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `OperatorSetParamsUpdated(uint8,(uint32,uint16,uint16))` and selector `0x3ee6fe8d54610244c3e9d3c066ae4aee997884aa28f10616ae821925401318ac`.\n```solidity\nevent OperatorSetParamsUpdated(uint8 indexed quorumNumber, OperatorSetParam operatorSetParams);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorSetParamsUpdated {
        #[allow(missing_docs)]
        pub quorumNumber: u8,
        #[allow(missing_docs)]
        pub operatorSetParams: <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorSetParamsUpdated {
            type DataTuple<'a> = (OperatorSetParam,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<8>,
            );
            const SIGNATURE: &'static str =
                "OperatorSetParamsUpdated(uint8,(uint32,uint16,uint16))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    62u8, 230u8, 254u8, 141u8, 84u8, 97u8, 2u8, 68u8, 195u8, 233u8, 211u8, 192u8,
                    102u8, 174u8, 74u8, 238u8, 153u8, 120u8, 132u8, 170u8, 40u8, 241u8, 6u8, 22u8,
                    174u8, 130u8, 25u8, 37u8, 64u8, 19u8, 24u8, 172u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    quorumNumber: topics.1,
                    operatorSetParams: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (<OperatorSetParam as alloy_sol_types::SolType>::tokenize(
                    &self.operatorSetParams,
                ),)
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.quorumNumber.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::encode_topic(&self.quorumNumber);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorSetParamsUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorSetParamsUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorSetParamsUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `OperatorSocketUpdate(bytes32,string)` and selector `0xec2963ab21c1e50e1e582aa542af2e4bf7bf38e6e1403c27b42e1c5d6e621eaa`.\n```solidity\nevent OperatorSocketUpdate(bytes32 indexed operatorId, string socket);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorSocketUpdate {
        #[allow(missing_docs)]
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub socket: ::alloy_sol_types::private::String,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorSocketUpdate {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "OperatorSocketUpdate(bytes32,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    236u8, 41u8, 99u8, 171u8, 33u8, 193u8, 229u8, 14u8, 30u8, 88u8, 42u8, 165u8,
                    66u8, 175u8, 46u8, 75u8, 247u8, 191u8, 56u8, 230u8, 225u8, 64u8, 60u8, 39u8,
                    180u8, 46u8, 28u8, 93u8, 110u8, 98u8, 30u8, 170u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operatorId: topics.1,
                    socket: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.socket,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.operatorId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::encode_topic(&self.operatorId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorSocketUpdate {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorSocketUpdate> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorSocketUpdate) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.\n```solidity\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8, 31u8,
                    208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8, 218u8,
                    175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.previousOwner);
                out[2usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.newOwner);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `Paused(address,uint256)` and selector `0xab40a374bc51de372200a8bc981af8c9ecdc08dfdaef0bb6e09f88f3c616ef3d`.\n```solidity\nevent Paused(address indexed account, uint256 newPausedStatus);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newPausedStatus: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Paused(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    171u8, 64u8, 163u8, 116u8, 188u8, 81u8, 222u8, 55u8, 34u8, 0u8, 168u8, 188u8,
                    152u8, 26u8, 248u8, 201u8, 236u8, 220u8, 8u8, 223u8, 218u8, 239u8, 11u8, 182u8,
                    224u8, 159u8, 136u8, 243u8, 198u8, 22u8, 239u8, 61u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    newPausedStatus: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newPausedStatus,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.account);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `PauserRegistrySet(address,address)` and selector `0x6e9fcd539896fca60e8b0f01dd580233e48a6b0f7df013b89ba7f565869acdb6`.\n```solidity\nevent PauserRegistrySet(address pauserRegistry, address newPauserRegistry);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct PauserRegistrySet {
        #[allow(missing_docs)]
        pub pauserRegistry: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newPauserRegistry: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for PauserRegistrySet {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "PauserRegistrySet(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    110u8, 159u8, 205u8, 83u8, 152u8, 150u8, 252u8, 166u8, 14u8, 139u8, 15u8, 1u8,
                    221u8, 88u8, 2u8, 51u8, 228u8, 138u8, 107u8, 15u8, 125u8, 240u8, 19u8, 184u8,
                    155u8, 167u8, 245u8, 101u8, 134u8, 154u8, 205u8, 182u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    pauserRegistry: data.0,
                    newPauserRegistry: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.pauserRegistry,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newPauserRegistry,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for PauserRegistrySet {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&PauserRegistrySet> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &PauserRegistrySet) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `QuorumBlockNumberUpdated(uint8,uint256)` and selector `0x46077d55330763f16269fd75e5761663f4192d2791747c0189b16ad31db07db4`.\n```solidity\nevent QuorumBlockNumberUpdated(uint8 indexed quorumNumber, uint256 blocknumber);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct QuorumBlockNumberUpdated {
        #[allow(missing_docs)]
        pub quorumNumber: u8,
        #[allow(missing_docs)]
        pub blocknumber: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for QuorumBlockNumberUpdated {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<8>,
            );
            const SIGNATURE: &'static str = "QuorumBlockNumberUpdated(uint8,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    70u8, 7u8, 125u8, 85u8, 51u8, 7u8, 99u8, 241u8, 98u8, 105u8, 253u8, 117u8,
                    229u8, 118u8, 22u8, 99u8, 244u8, 25u8, 45u8, 39u8, 145u8, 116u8, 124u8, 1u8,
                    137u8, 177u8, 106u8, 211u8, 29u8, 176u8, 125u8, 180u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    quorumNumber: topics.1,
                    blocknumber: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.blocknumber,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.quorumNumber.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::EventTopic>::encode_topic(&self.quorumNumber);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for QuorumBlockNumberUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&QuorumBlockNumberUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &QuorumBlockNumberUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Event with signature `Unpaused(address,uint256)` and selector `0x3582d1828e26bf56bd801502bc021ac0bc8afb57c826e4986b45593c8fad389c`.\n```solidity\nevent Unpaused(address indexed account, uint256 newPausedStatus);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newPausedStatus: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Unpaused(address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    53u8, 130u8, 209u8, 130u8, 142u8, 38u8, 191u8, 86u8, 189u8, 128u8, 21u8, 2u8,
                    188u8, 2u8, 26u8, 192u8, 188u8, 138u8, 251u8, 87u8, 200u8, 38u8, 228u8, 152u8,
                    107u8, 69u8, 89u8, 60u8, 143u8, 173u8, 56u8, 156u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    newPausedStatus: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newPausedStatus,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.account);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Constructor`.\n```solidity\nconstructor(address _serviceManager, address _stakeRegistry, address _blsApkRegistry, address _indexRegistry);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub _serviceManager: ::alloy_sol_types::private::Address,
        pub _stakeRegistry: ::alloy_sol_types::private::Address,
        pub _blsApkRegistry: ::alloy_sol_types::private::Address,
        pub _indexRegistry: ::alloy_sol_types::private::Address,
    }
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (
                        value._serviceManager,
                        value._stakeRegistry,
                        value._blsApkRegistry,
                        value._indexRegistry,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _serviceManager: tuple.0,
                        _stakeRegistry: tuple.1,
                        _blsApkRegistry: tuple.2,
                        _indexRegistry: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._serviceManager,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._stakeRegistry,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._blsApkRegistry,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._indexRegistry,
                    ),
                )
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `OPERATOR_CHURN_APPROVAL_TYPEHASH()` and selector `0xca0de882`.\n```solidity\nfunction OPERATOR_CHURN_APPROVAL_TYPEHASH() external view returns (bytes32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OPERATOR_CHURN_APPROVAL_TYPEHASHCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`OPERATOR_CHURN_APPROVAL_TYPEHASH()`](OPERATOR_CHURN_APPROVAL_TYPEHASHCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OPERATOR_CHURN_APPROVAL_TYPEHASHReturn {
        pub _0: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OPERATOR_CHURN_APPROVAL_TYPEHASHCall> for UnderlyingRustTuple<'_> {
                fn from(value: OPERATOR_CHURN_APPROVAL_TYPEHASHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OPERATOR_CHURN_APPROVAL_TYPEHASHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<OPERATOR_CHURN_APPROVAL_TYPEHASHReturn> for UnderlyingRustTuple<'_> {
                fn from(value: OPERATOR_CHURN_APPROVAL_TYPEHASHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for OPERATOR_CHURN_APPROVAL_TYPEHASHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for OPERATOR_CHURN_APPROVAL_TYPEHASHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = OPERATOR_CHURN_APPROVAL_TYPEHASHReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OPERATOR_CHURN_APPROVAL_TYPEHASH()";
            const SELECTOR: [u8; 4] = [202u8, 13u8, 232u8, 130u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `PUBKEY_REGISTRATION_TYPEHASH()` and selector `0x9feab859`.\n```solidity\nfunction PUBKEY_REGISTRATION_TYPEHASH() external view returns (bytes32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PUBKEY_REGISTRATION_TYPEHASHCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`PUBKEY_REGISTRATION_TYPEHASH()`](PUBKEY_REGISTRATION_TYPEHASHCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct PUBKEY_REGISTRATION_TYPEHASHReturn {
        pub _0: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PUBKEY_REGISTRATION_TYPEHASHCall> for UnderlyingRustTuple<'_> {
                fn from(value: PUBKEY_REGISTRATION_TYPEHASHCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PUBKEY_REGISTRATION_TYPEHASHCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PUBKEY_REGISTRATION_TYPEHASHReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PUBKEY_REGISTRATION_TYPEHASHReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PUBKEY_REGISTRATION_TYPEHASHReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PUBKEY_REGISTRATION_TYPEHASHCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = PUBKEY_REGISTRATION_TYPEHASHReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PUBKEY_REGISTRATION_TYPEHASH()";
            const SELECTOR: [u8; 4] = [159u8, 234u8, 184u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `blsApkRegistry()` and selector `0x5df45946`.\n```solidity\nfunction blsApkRegistry() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct blsApkRegistryCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`blsApkRegistry()`](blsApkRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct blsApkRegistryReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blsApkRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: blsApkRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for blsApkRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blsApkRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: blsApkRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for blsApkRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blsApkRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = blsApkRegistryReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blsApkRegistry()";
            const SELECTOR: [u8; 4] = [93u8, 244u8, 89u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `calculateOperatorChurnApprovalDigestHash(address,bytes32,(uint8,address)[],bytes32,uint256)` and selector `0x84ca5213`.\n```solidity\nfunction calculateOperatorChurnApprovalDigestHash(address registeringOperator, bytes32 registeringOperatorId, OperatorKickParam[] memory operatorKickParams, bytes32 salt, uint256 expiry) external view returns (bytes32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct calculateOperatorChurnApprovalDigestHashCall {
        pub registeringOperator: ::alloy_sol_types::private::Address,
        pub registeringOperatorId: ::alloy_sol_types::private::FixedBytes<32>,
        pub operatorKickParams: ::alloy_sol_types::private::Vec<
            <OperatorKickParam as ::alloy_sol_types::SolType>::RustType,
        >,
        pub salt: ::alloy_sol_types::private::FixedBytes<32>,
        pub expiry: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`calculateOperatorChurnApprovalDigestHash(address,bytes32,(uint8,address)[],bytes32,uint256)`](calculateOperatorChurnApprovalDigestHashCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct calculateOperatorChurnApprovalDigestHashReturn {
        pub _0: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Array<OperatorKickParam>,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::FixedBytes<32>,
                ::alloy_sol_types::private::Vec<
                    <OperatorKickParam as ::alloy_sol_types::SolType>::RustType,
                >,
                ::alloy_sol_types::private::FixedBytes<32>,
                ::alloy_sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateOperatorChurnApprovalDigestHashCall>
                for UnderlyingRustTuple<'_>
            {
                fn from(value: calculateOperatorChurnApprovalDigestHashCall) -> Self {
                    (
                        value.registeringOperator,
                        value.registeringOperatorId,
                        value.operatorKickParams,
                        value.salt,
                        value.expiry,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
                for calculateOperatorChurnApprovalDigestHashCall
            {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        registeringOperator: tuple.0,
                        registeringOperatorId: tuple.1,
                        operatorKickParams: tuple.2,
                        salt: tuple.3,
                        expiry: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<calculateOperatorChurnApprovalDigestHashReturn>
                for UnderlyingRustTuple<'_>
            {
                fn from(value: calculateOperatorChurnApprovalDigestHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
                for calculateOperatorChurnApprovalDigestHashReturn
            {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for calculateOperatorChurnApprovalDigestHashCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Array<OperatorKickParam>,
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = calculateOperatorChurnApprovalDigestHashReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "calculateOperatorChurnApprovalDigestHash(address,bytes32,(uint8,address)[],bytes32,uint256)";
            const SELECTOR: [u8; 4] = [132u8, 202u8, 82u8, 19u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self.registeringOperator), <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.registeringOperatorId), <::alloy_sol_types::sol_data::Array<OperatorKickParam> as alloy_sol_types::SolType>::tokenize(&self.operatorKickParams), <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.salt), <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.expiry),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `churnApprover()` and selector `0x054310e6`.\n```solidity\nfunction churnApprover() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct churnApproverCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`churnApprover()`](churnApproverCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct churnApproverReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<churnApproverCall> for UnderlyingRustTuple<'_> {
                fn from(value: churnApproverCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for churnApproverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<churnApproverReturn> for UnderlyingRustTuple<'_> {
                fn from(value: churnApproverReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for churnApproverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for churnApproverCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = churnApproverReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "churnApprover()";
            const SELECTOR: [u8; 4] = [5u8, 67u8, 16u8, 230u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `createQuorum((uint32,uint16,uint16),uint96,(address,uint96)[])` and selector `0xd75b4c88`.\n```solidity\nfunction createQuorum(OperatorSetParam memory operatorSetParams, uint96 minimumStake, StrategyParams[] memory strategyParams) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct createQuorumCall {
        pub operatorSetParams: <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
        pub minimumStake:
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
        pub strategyParams: ::alloy_sol_types::private::Vec<
            <StrategyParams as ::alloy_sol_types::SolType>::RustType,
        >,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`createQuorum((uint32,uint16,uint16),uint96,(address,uint96)[])`](createQuorumCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct createQuorumReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                OperatorSetParam,
                ::alloy_sol_types::sol_data::Uint<96>,
                ::alloy_sol_types::sol_data::Array<StrategyParams>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
                <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
                ::alloy_sol_types::private::Vec<
                    <StrategyParams as ::alloy_sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createQuorumCall> for UnderlyingRustTuple<'_> {
                fn from(value: createQuorumCall) -> Self {
                    (
                        value.operatorSetParams,
                        value.minimumStake,
                        value.strategyParams,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createQuorumCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorSetParams: tuple.0,
                        minimumStake: tuple.1,
                        strategyParams: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createQuorumReturn> for UnderlyingRustTuple<'_> {
                fn from(value: createQuorumReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createQuorumReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createQuorumCall {
            type Parameters<'a> = (
                OperatorSetParam,
                ::alloy_sol_types::sol_data::Uint<96>,
                ::alloy_sol_types::sol_data::Array<StrategyParams>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = createQuorumReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "createQuorum((uint32,uint16,uint16),uint96,(address,uint96)[])";
            const SELECTOR: [u8; 4] = [215u8, 91u8, 76u8, 136u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<OperatorSetParam as alloy_sol_types::SolType>::tokenize(&self.operatorSetParams), <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::SolType>::tokenize(&self.minimumStake), <::alloy_sol_types::sol_data::Array<StrategyParams> as alloy_sol_types::SolType>::tokenize(&self.strategyParams),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `deregisterOperator(bytes)` and selector `0xca4f2d97`.\n```solidity\nfunction deregisterOperator(bytes memory quorumNumbers) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct deregisterOperatorCall {
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`deregisterOperator(bytes)`](deregisterOperatorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct deregisterOperatorReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Bytes,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Bytes,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deregisterOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: deregisterOperatorCall) -> Self {
                    (value.quorumNumbers,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deregisterOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        quorumNumbers: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deregisterOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: deregisterOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deregisterOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deregisterOperatorCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Bytes,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = deregisterOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deregisterOperator(bytes)";
            const SELECTOR: [u8; 4] = [202u8, 79u8, 45u8, 151u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `ejectOperator(address,bytes)` and selector `0x6e3b17db`.\n```solidity\nfunction ejectOperator(address operator, bytes memory quorumNumbers) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ejectOperatorCall {
        pub operator: ::alloy_sol_types::private::Address,
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`ejectOperator(address,bytes)`](ejectOperatorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ejectOperatorReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ejectOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: ejectOperatorCall) -> Self {
                    (value.operator, value.quorumNumbers)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ejectOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operator: tuple.0,
                        quorumNumbers: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ejectOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ejectOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ejectOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ejectOperatorCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = ejectOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ejectOperator(address,bytes)";
            const SELECTOR: [u8; 4] = [110u8, 59u8, 23u8, 219u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `ejector()` and selector `0x28f61b31`.\n```solidity\nfunction ejector() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ejectorCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`ejector()`](ejectorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ejectorReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ejectorCall> for UnderlyingRustTuple<'_> {
                fn from(value: ejectorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ejectorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ejectorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ejectorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ejectorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ejectorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = ejectorReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ejector()";
            const SELECTOR: [u8; 4] = [40u8, 246u8, 27u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getCurrentQuorumBitmap(bytes32)` and selector `0x871ef049`.\n```solidity\nfunction getCurrentQuorumBitmap(bytes32 operatorId) external view returns (uint192);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getCurrentQuorumBitmapCall {
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getCurrentQuorumBitmap(bytes32)`](getCurrentQuorumBitmapCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getCurrentQuorumBitmapReturn {
        pub _0: <::alloy_sol_types::sol_data::Uint<192> as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentQuorumBitmapCall> for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentQuorumBitmapCall) -> Self {
                    (value.operatorId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCurrentQuorumBitmapCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorId: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<192>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <::alloy_sol_types::sol_data::Uint<192> as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getCurrentQuorumBitmapReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getCurrentQuorumBitmapReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getCurrentQuorumBitmapReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getCurrentQuorumBitmapCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getCurrentQuorumBitmapReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<192>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getCurrentQuorumBitmap(bytes32)";
            const SELECTOR: [u8; 4] = [135u8, 30u8, 240u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.operatorId),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getOperator(address)` and selector `0x5865c60c`.\n```solidity\nfunction getOperator(address operator) external view returns (OperatorInfo memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorCall {
        pub operator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getOperator(address)`](getOperatorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorReturn {
        pub _0: <OperatorInfo as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (OperatorInfo,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<OperatorInfo as ::alloy_sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorReturn;
            type ReturnTuple<'a> = (OperatorInfo,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperator(address)";
            const SELECTOR: [u8; 4] = [88u8, 101u8, 198u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getOperatorFromId(bytes32)` and selector `0x296bb064`.\n```solidity\nfunction getOperatorFromId(bytes32 operatorId) external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorFromIdCall {
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getOperatorFromId(bytes32)`](getOperatorFromIdCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorFromIdReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorFromIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorFromIdCall) -> Self {
                    (value.operatorId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorFromIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorId: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorFromIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorFromIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorFromIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorFromIdCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorFromIdReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorFromId(bytes32)";
            const SELECTOR: [u8; 4] = [41u8, 107u8, 176u8, 100u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.operatorId),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getOperatorId(address)` and selector `0x13542a4e`.\n```solidity\nfunction getOperatorId(address operator) external view returns (bytes32);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorIdCall {
        pub operator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getOperatorId(address)`](getOperatorIdCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorIdReturn {
        pub _0: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorIdCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorIdCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorIdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorIdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorIdReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorIdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorIdCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorIdReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorId(address)";
            const SELECTOR: [u8; 4] = [19u8, 84u8, 42u8, 78u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getOperatorSetParams(uint8)` and selector `0xe65797ad`.\n```solidity\nfunction getOperatorSetParams(uint8 quorumNumber) external view returns (OperatorSetParam memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorSetParamsCall {
        pub quorumNumber: u8,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getOperatorSetParams(uint8)`](getOperatorSetParamsCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorSetParamsReturn {
        pub _0: <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorSetParamsCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorSetParamsCall) -> Self {
                    (value.quorumNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorSetParamsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        quorumNumber: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (OperatorSetParam,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<OperatorSetParam as ::alloy_sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorSetParamsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorSetParamsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorSetParamsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorSetParamsCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorSetParamsReturn;
            type ReturnTuple<'a> = (OperatorSetParam,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorSetParams(uint8)";
            const SELECTOR: [u8; 4] = [230u8, 87u8, 151u8, 173u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumber,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getOperatorStatus(address)` and selector `0xfd39105a`.\n```solidity\nfunction getOperatorStatus(address operator) external view returns (OperatorStatus);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorStatusCall {
        pub operator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getOperatorStatus(address)`](getOperatorStatusCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorStatusReturn {
        pub _0: <OperatorStatus as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorStatusCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorStatusCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorStatusCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (OperatorStatus,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<OperatorStatus as ::alloy_sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorStatusReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorStatusReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorStatusReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorStatusCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorStatusReturn;
            type ReturnTuple<'a> = (OperatorStatus,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorStatus(address)";
            const SELECTOR: [u8; 4] = [253u8, 57u8, 16u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getQuorumBitmapAtBlockNumberByIndex(bytes32,uint32,uint256)` and selector `0x04ec6351`.\n```solidity\nfunction getQuorumBitmapAtBlockNumberByIndex(bytes32 operatorId, uint32 blockNumber, uint256 index) external view returns (uint192);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapAtBlockNumberByIndexCall {
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        pub blockNumber: u32,
        pub index: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getQuorumBitmapAtBlockNumberByIndex(bytes32,uint32,uint256)`](getQuorumBitmapAtBlockNumberByIndexCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapAtBlockNumberByIndexReturn {
        pub _0: <::alloy_sol_types::sol_data::Uint<192> as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::FixedBytes<32>,
                u32,
                ::alloy_sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapAtBlockNumberByIndexCall> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapAtBlockNumberByIndexCall) -> Self {
                    (value.operatorId, value.blockNumber, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapAtBlockNumberByIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorId: tuple.0,
                        blockNumber: tuple.1,
                        index: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<192>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <::alloy_sol_types::sol_data::Uint<192> as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapAtBlockNumberByIndexReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapAtBlockNumberByIndexReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapAtBlockNumberByIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getQuorumBitmapAtBlockNumberByIndexCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getQuorumBitmapAtBlockNumberByIndexReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<192>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "getQuorumBitmapAtBlockNumberByIndex(bytes32,uint32,uint256)";
            const SELECTOR: [u8; 4] = [4u8, 236u8, 99u8, 81u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.operatorId), <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(&self.blockNumber), <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.index),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getQuorumBitmapHistoryLength(bytes32)` and selector `0x03fd3492`.\n```solidity\nfunction getQuorumBitmapHistoryLength(bytes32 operatorId) external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapHistoryLengthCall {
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getQuorumBitmapHistoryLength(bytes32)`](getQuorumBitmapHistoryLengthCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapHistoryLengthReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapHistoryLengthCall> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapHistoryLengthCall) -> Self {
                    (value.operatorId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapHistoryLengthCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorId: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapHistoryLengthReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapHistoryLengthReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapHistoryLengthReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getQuorumBitmapHistoryLengthCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getQuorumBitmapHistoryLengthReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getQuorumBitmapHistoryLength(bytes32)";
            const SELECTOR: [u8; 4] = [3u8, 253u8, 52u8, 146u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.operatorId),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getQuorumBitmapIndicesAtBlockNumber(uint32,bytes32[])` and selector `0xc391425e`.\n```solidity\nfunction getQuorumBitmapIndicesAtBlockNumber(uint32 blockNumber, bytes32[] memory operatorIds) external view returns (uint32[] memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapIndicesAtBlockNumberCall {
        pub blockNumber: u32,
        pub operatorIds:
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::FixedBytes<32>>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getQuorumBitmapIndicesAtBlockNumber(uint32,bytes32[])`](getQuorumBitmapIndicesAtBlockNumberCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapIndicesAtBlockNumberReturn {
        pub _0: ::alloy_sol_types::private::Vec<u32>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u32,
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::FixedBytes<32>>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapIndicesAtBlockNumberCall> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapIndicesAtBlockNumberCall) -> Self {
                    (value.blockNumber, value.operatorIds)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapIndicesAtBlockNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blockNumber: tuple.0,
                        operatorIds: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Vec<u32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapIndicesAtBlockNumberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapIndicesAtBlockNumberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapIndicesAtBlockNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getQuorumBitmapIndicesAtBlockNumberCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Uint<32>,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getQuorumBitmapIndicesAtBlockNumberReturn;
            type ReturnTuple<'a> =
                (::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<32>>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getQuorumBitmapIndicesAtBlockNumber(uint32,bytes32[])";
            const SELECTOR: [u8; 4] = [195u8, 145u8, 66u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(&self.blockNumber), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::FixedBytes<32>> as alloy_sol_types::SolType>::tokenize(&self.operatorIds),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `getQuorumBitmapUpdateByIndex(bytes32,uint256)` and selector `0x1eb812da`.\n```solidity\nfunction getQuorumBitmapUpdateByIndex(bytes32 operatorId, uint256 index) external view returns (QuorumBitmapUpdate memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapUpdateByIndexCall {
        pub operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        pub index: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`getQuorumBitmapUpdateByIndex(bytes32,uint256)`](getQuorumBitmapUpdateByIndexCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getQuorumBitmapUpdateByIndexReturn {
        pub _0: <QuorumBitmapUpdate as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::FixedBytes<32>,
                ::alloy_sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapUpdateByIndexCall> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapUpdateByIndexCall) -> Self {
                    (value.operatorId, value.index)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapUpdateByIndexCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorId: tuple.0,
                        index: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (QuorumBitmapUpdate,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (<QuorumBitmapUpdate as ::alloy_sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getQuorumBitmapUpdateByIndexReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getQuorumBitmapUpdateByIndexReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getQuorumBitmapUpdateByIndexReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getQuorumBitmapUpdateByIndexCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getQuorumBitmapUpdateByIndexReturn;
            type ReturnTuple<'a> = (QuorumBitmapUpdate,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getQuorumBitmapUpdateByIndex(bytes32,uint256)";
            const SELECTOR: [u8; 4] = [30u8, 184u8, 18u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.operatorId), <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.index),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `indexRegistry()` and selector `0x9e9923c2`.\n```solidity\nfunction indexRegistry() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct indexRegistryCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`indexRegistry()`](indexRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct indexRegistryReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<indexRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: indexRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for indexRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<indexRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: indexRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for indexRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for indexRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = indexRegistryReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "indexRegistry()";
            const SELECTOR: [u8; 4] = [158u8, 153u8, 35u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `initialize(address,address,address,address,uint256,(uint32,uint16,uint16)[],uint96[],(address,uint96)[][])` and selector `0xdd8283f3`.\n```solidity\nfunction initialize(address _initialOwner, address _churnApprover, address _ejector, address _pauserRegistry, uint256 _initialPausedStatus, OperatorSetParam[] memory _operatorSetParams, uint96[] memory _minimumStakes, StrategyParams[][] memory _strategyParams) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeCall {
        pub _initialOwner: ::alloy_sol_types::private::Address,
        pub _churnApprover: ::alloy_sol_types::private::Address,
        pub _ejector: ::alloy_sol_types::private::Address,
        pub _pauserRegistry: ::alloy_sol_types::private::Address,
        pub _initialPausedStatus: ::alloy_sol_types::private::U256,
        pub _operatorSetParams: ::alloy_sol_types::private::Vec<
            <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
        >,
        pub _minimumStakes: ::alloy_sol_types::private::Vec<
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
        >,
        pub _strategyParams: ::alloy_sol_types::private::Vec<
            ::alloy_sol_types::private::Vec<
                <StrategyParams as ::alloy_sol_types::SolType>::RustType,
            >,
        >,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`initialize(address,address,address,address,uint256,(uint32,uint16,uint16)[],uint96[],(address,uint96)[][])`](initializeCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Array<OperatorSetParam>,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>>,
                ::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Array<StrategyParams>,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::U256,
                ::alloy_sol_types::private::Vec<
                    <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
                >,
                ::alloy_sol_types::private::Vec<
                    <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
                >,
                ::alloy_sol_types::private::Vec<
                    ::alloy_sol_types::private::Vec<
                        <StrategyParams as ::alloy_sol_types::SolType>::RustType,
                    >,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (
                        value._initialOwner,
                        value._churnApprover,
                        value._ejector,
                        value._pauserRegistry,
                        value._initialPausedStatus,
                        value._operatorSetParams,
                        value._minimumStakes,
                        value._strategyParams,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _initialOwner: tuple.0,
                        _churnApprover: tuple.1,
                        _ejector: tuple.2,
                        _pauserRegistry: tuple.3,
                        _initialPausedStatus: tuple.4,
                        _operatorSetParams: tuple.5,
                        _minimumStakes: tuple.6,
                        _strategyParams: tuple.7,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Array<OperatorSetParam>,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>>,
                ::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Array<StrategyParams>,
                >,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,address,address,address,uint256,(uint32,uint16,uint16)[],uint96[],(address,uint96)[][])";
            const SELECTOR: [u8; 4] = [221u8, 130u8, 131u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self._initialOwner), <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self._churnApprover), <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self._ejector), <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(&self._pauserRegistry), <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self._initialPausedStatus), <::alloy_sol_types::sol_data::Array<OperatorSetParam> as alloy_sol_types::SolType>::tokenize(&self._operatorSetParams), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Uint<96>> as alloy_sol_types::SolType>::tokenize(&self._minimumStakes), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Array<StrategyParams>> as alloy_sol_types::SolType>::tokenize(&self._strategyParams),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `isChurnApproverSaltUsed(bytes32)` and selector `0x1478851f`.\n```solidity\nfunction isChurnApproverSaltUsed(bytes32) external view returns (bool);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct isChurnApproverSaltUsedCall {
        pub _0: ::alloy_sol_types::private::FixedBytes<32>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`isChurnApproverSaltUsed(bytes32)`](isChurnApproverSaltUsedCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct isChurnApproverSaltUsedReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChurnApproverSaltUsedCall> for UnderlyingRustTuple<'_> {
                fn from(value: isChurnApproverSaltUsedCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isChurnApproverSaltUsedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isChurnApproverSaltUsedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isChurnApproverSaltUsedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isChurnApproverSaltUsedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isChurnApproverSaltUsedCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = isChurnApproverSaltUsedReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isChurnApproverSaltUsed(bytes32)";
            const SELECTOR: [u8; 4] = [20u8, 120u8, 133u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self._0),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `numRegistries()` and selector `0xd72d8dd6`.\n```solidity\nfunction numRegistries() external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct numRegistriesCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`numRegistries()`](numRegistriesCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct numRegistriesReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numRegistriesCall> for UnderlyingRustTuple<'_> {
                fn from(value: numRegistriesCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numRegistriesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<numRegistriesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: numRegistriesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for numRegistriesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for numRegistriesCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = numRegistriesReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "numRegistries()";
            const SELECTOR: [u8; 4] = [215u8, 45u8, 141u8, 214u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `owner()` and selector `0x8da5cb5b`.\n```solidity\nfunction owner() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`owner()`](ownerCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `pause(uint256)` and selector `0x136439dd`.\n```solidity\nfunction pause(uint256 newPausedStatus) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauseCall {
        pub newPausedStatus: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`pause(uint256)`](pauseCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    (value.newPausedStatus,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPausedStatus: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause(uint256)";
            const SELECTOR: [u8; 4] = [19u8, 100u8, 57u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newPausedStatus,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `pauseAll()` and selector `0x595c6a67`.\n```solidity\nfunction pauseAll() external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauseAllCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`pauseAll()`](pauseAllCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauseAllReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseAllCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseAllCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseAllCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseAllReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseAllReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseAllReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseAllCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseAllReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauseAll()";
            const SELECTOR: [u8; 4] = [89u8, 92u8, 106u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `paused(uint8)` and selector `0x5ac86ab7`.\n```solidity\nfunction paused(uint8 index) external view returns (bool);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct paused_0Call {
        pub index: u8,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`paused(uint8)`](paused_0Call) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct paused_0Return {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paused_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: paused_0Call) -> Self {
                    (value.index,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paused_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { index: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paused_0Return> for UnderlyingRustTuple<'_> {
                fn from(value: paused_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paused_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for paused_0Call {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = paused_0Return;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused(uint8)";
            const SELECTOR: [u8; 4] = [90u8, 200u8, 106u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self.index,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `paused()` and selector `0x5c975abb`.\n```solidity\nfunction paused() external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct paused_1Call {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`paused()`](paused_1Call) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct paused_1Return {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paused_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: paused_1Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paused_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paused_1Return> for UnderlyingRustTuple<'_> {
                fn from(value: paused_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paused_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for paused_1Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = paused_1Return;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `pauserRegistry()` and selector `0x886f1195`.\n```solidity\nfunction pauserRegistry() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauserRegistryCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`pauserRegistry()`](pauserRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pauserRegistryReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauserRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauserRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauserRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauserRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauserRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauserRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauserRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauserRegistryReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pauserRegistry()";
            const SELECTOR: [u8; 4] = [136u8, 111u8, 17u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `pubkeyRegistrationMessageHash(address)` and selector `0x3c2a7f4c`.\n```solidity\nfunction pubkeyRegistrationMessageHash(address operator) external view returns (G1Point memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pubkeyRegistrationMessageHashCall {
        pub operator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`pubkeyRegistrationMessageHash(address)`](pubkeyRegistrationMessageHashCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct pubkeyRegistrationMessageHashReturn {
        pub _0: <G1Point as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pubkeyRegistrationMessageHashCall> for UnderlyingRustTuple<'_> {
                fn from(value: pubkeyRegistrationMessageHashCall) -> Self {
                    (value.operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pubkeyRegistrationMessageHashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (G1Point,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<G1Point as ::alloy_sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pubkeyRegistrationMessageHashReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pubkeyRegistrationMessageHashReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pubkeyRegistrationMessageHashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pubkeyRegistrationMessageHashCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = pubkeyRegistrationMessageHashReturn;
            type ReturnTuple<'a> = (G1Point,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pubkeyRegistrationMessageHash(address)";
            const SELECTOR: [u8; 4] = [60u8, 42u8, 127u8, 76u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `quorumCount()` and selector `0x9aa1653d`.\n```solidity\nfunction quorumCount() external view returns (uint8);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct quorumCountCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`quorumCount()`](quorumCountCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct quorumCountReturn {
        pub _0: u8,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<quorumCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: quorumCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for quorumCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<quorumCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: quorumCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for quorumCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for quorumCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = quorumCountReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "quorumCount()";
            const SELECTOR: [u8; 4] = [154u8, 161u8, 101u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `quorumUpdateBlockNumber(uint8)` and selector `0x249a0c42`.\n```solidity\nfunction quorumUpdateBlockNumber(uint8) external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct quorumUpdateBlockNumberCall {
        pub _0: u8,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`quorumUpdateBlockNumber(uint8)`](quorumUpdateBlockNumberCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct quorumUpdateBlockNumberReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u8,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<quorumUpdateBlockNumberCall> for UnderlyingRustTuple<'_> {
                fn from(value: quorumUpdateBlockNumberCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for quorumUpdateBlockNumberCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<quorumUpdateBlockNumberReturn> for UnderlyingRustTuple<'_> {
                fn from(value: quorumUpdateBlockNumberReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for quorumUpdateBlockNumberReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for quorumUpdateBlockNumberCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = quorumUpdateBlockNumberReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "quorumUpdateBlockNumber(uint8)";
            const SELECTOR: [u8; 4] = [36u8, 154u8, 12u8, 66u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `registerOperator(bytes,string,((uint256,uint256),(uint256,uint256),(uint256[2],uint256[2])),(bytes,bytes32,uint256))` and selector `0xa50857bf`.\n```solidity\nfunction registerOperator(bytes memory quorumNumbers, string memory socket, PubkeyRegistrationParams memory params, SignatureWithSaltAndExpiry memory operatorSignature) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registerOperatorCall {
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
        pub socket: ::alloy_sol_types::private::String,
        pub params: <PubkeyRegistrationParams as ::alloy_sol_types::SolType>::RustType,
        pub operatorSignature: <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`registerOperator(bytes,string,((uint256,uint256),(uint256,uint256),(uint256[2],uint256[2])),(bytes,bytes32,uint256))`](registerOperatorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registerOperatorReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::String,
                PubkeyRegistrationParams,
                SignatureWithSaltAndExpiry,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Bytes,
                ::alloy_sol_types::private::String,
                <PubkeyRegistrationParams as ::alloy_sol_types::SolType>::RustType,
                <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorCall) -> Self {
                    (
                        value.quorumNumbers,
                        value.socket,
                        value.params,
                        value.operatorSignature,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        quorumNumbers: tuple.0,
                        socket: tuple.1,
                        params: tuple.2,
                        operatorSignature: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerOperatorCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::String,
                PubkeyRegistrationParams,
                SignatureWithSaltAndExpiry,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerOperator(bytes,string,((uint256,uint256),(uint256,uint256),(uint256[2],uint256[2])),(bytes,bytes32,uint256))";
            const SELECTOR: [u8; 4] = [165u8, 8u8, 87u8, 191u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                    <::alloy_sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.socket,
                    ),
                    <PubkeyRegistrationParams as alloy_sol_types::SolType>::tokenize(&self.params),
                    <SignatureWithSaltAndExpiry as alloy_sol_types::SolType>::tokenize(
                        &self.operatorSignature,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `registerOperatorWithChurn(bytes,string,((uint256,uint256),(uint256,uint256),(uint256[2],uint256[2])),(uint8,address)[],(bytes,bytes32,uint256),(bytes,bytes32,uint256))` and selector `0x9b5d177b`.\n```solidity\nfunction registerOperatorWithChurn(bytes memory quorumNumbers, string memory socket, PubkeyRegistrationParams memory params, OperatorKickParam[] memory operatorKickParams, SignatureWithSaltAndExpiry memory churnApproverSignature, SignatureWithSaltAndExpiry memory operatorSignature) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registerOperatorWithChurnCall {
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
        pub socket: ::alloy_sol_types::private::String,
        pub params: <PubkeyRegistrationParams as ::alloy_sol_types::SolType>::RustType,
        pub operatorKickParams: ::alloy_sol_types::private::Vec<
            <OperatorKickParam as ::alloy_sol_types::SolType>::RustType,
        >,
        pub churnApproverSignature:
            <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
        pub operatorSignature: <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`registerOperatorWithChurn(bytes,string,((uint256,uint256),(uint256,uint256),(uint256[2],uint256[2])),(uint8,address)[],(bytes,bytes32,uint256),(bytes,bytes32,uint256))`](registerOperatorWithChurnCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registerOperatorWithChurnReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::String,
                PubkeyRegistrationParams,
                ::alloy_sol_types::sol_data::Array<OperatorKickParam>,
                SignatureWithSaltAndExpiry,
                SignatureWithSaltAndExpiry,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Bytes,
                ::alloy_sol_types::private::String,
                <PubkeyRegistrationParams as ::alloy_sol_types::SolType>::RustType,
                ::alloy_sol_types::private::Vec<
                    <OperatorKickParam as ::alloy_sol_types::SolType>::RustType,
                >,
                <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
                <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorWithChurnCall> for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorWithChurnCall) -> Self {
                    (
                        value.quorumNumbers,
                        value.socket,
                        value.params,
                        value.operatorKickParams,
                        value.churnApproverSignature,
                        value.operatorSignature,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerOperatorWithChurnCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        quorumNumbers: tuple.0,
                        socket: tuple.1,
                        params: tuple.2,
                        operatorKickParams: tuple.3,
                        churnApproverSignature: tuple.4,
                        operatorSignature: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorWithChurnReturn> for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorWithChurnReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerOperatorWithChurnReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerOperatorWithChurnCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Bytes,
                ::alloy_sol_types::sol_data::String,
                PubkeyRegistrationParams,
                ::alloy_sol_types::sol_data::Array<OperatorKickParam>,
                SignatureWithSaltAndExpiry,
                SignatureWithSaltAndExpiry,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerOperatorWithChurnReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerOperatorWithChurn(bytes,string,((uint256,uint256),(uint256,uint256),(uint256[2],uint256[2])),(uint8,address)[],(bytes,bytes32,uint256),(bytes,bytes32,uint256))";
            const SELECTOR: [u8; 4] = [155u8, 93u8, 23u8, 123u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(&self.quorumNumbers), <::alloy_sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(&self.socket), <PubkeyRegistrationParams as alloy_sol_types::SolType>::tokenize(&self.params), <::alloy_sol_types::sol_data::Array<OperatorKickParam> as alloy_sol_types::SolType>::tokenize(&self.operatorKickParams), <SignatureWithSaltAndExpiry as alloy_sol_types::SolType>::tokenize(&self.churnApproverSignature), <SignatureWithSaltAndExpiry as alloy_sol_types::SolType>::tokenize(&self.operatorSignature),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `registries(uint256)` and selector `0x6347c900`.\n```solidity\nfunction registries(uint256) external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registriesCall {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`registries(uint256)`](registriesCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registriesReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registriesCall> for UnderlyingRustTuple<'_> {
                fn from(value: registriesCall) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registriesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registriesReturn> for UnderlyingRustTuple<'_> {
                fn from(value: registriesReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registriesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registriesCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = registriesReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registries(uint256)";
            const SELECTOR: [u8; 4] = [99u8, 71u8, 201u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._0,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `renounceOwnership()` and selector `0x715018a6`.\n```solidity\nfunction renounceOwnership() external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `serviceManager()` and selector `0x3998fdd3`.\n```solidity\nfunction serviceManager() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct serviceManagerCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`serviceManager()`](serviceManagerCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct serviceManagerReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceManagerCall> for UnderlyingRustTuple<'_> {
                fn from(value: serviceManagerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serviceManagerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceManagerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: serviceManagerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serviceManagerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serviceManagerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = serviceManagerReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serviceManager()";
            const SELECTOR: [u8; 4] = [57u8, 152u8, 253u8, 211u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `setChurnApprover(address)` and selector `0x29d1e0c3`.\n```solidity\nfunction setChurnApprover(address _churnApprover) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setChurnApproverCall {
        pub _churnApprover: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`setChurnApprover(address)`](setChurnApproverCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setChurnApproverReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChurnApproverCall> for UnderlyingRustTuple<'_> {
                fn from(value: setChurnApproverCall) -> Self {
                    (value._churnApprover,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setChurnApproverCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _churnApprover: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setChurnApproverReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setChurnApproverReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setChurnApproverReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setChurnApproverCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setChurnApproverReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setChurnApprover(address)";
            const SELECTOR: [u8; 4] = [41u8, 209u8, 224u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._churnApprover,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `setEjector(address)` and selector `0x2cdd1e86`.\n```solidity\nfunction setEjector(address _ejector) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setEjectorCall {
        pub _ejector: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`setEjector(address)`](setEjectorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setEjectorReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setEjectorCall> for UnderlyingRustTuple<'_> {
                fn from(value: setEjectorCall) -> Self {
                    (value._ejector,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setEjectorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _ejector: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setEjectorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setEjectorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setEjectorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setEjectorCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setEjectorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setEjector(address)";
            const SELECTOR: [u8; 4] = [44u8, 221u8, 30u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._ejector,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `setOperatorSetParams(uint8,(uint32,uint16,uint16))` and selector `0x5b0b829f`.\n```solidity\nfunction setOperatorSetParams(uint8 quorumNumber, OperatorSetParam memory operatorSetParams) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setOperatorSetParamsCall {
        pub quorumNumber: u8,
        pub operatorSetParams: <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`setOperatorSetParams(uint8,(uint32,uint16,uint16))`](setOperatorSetParamsCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setOperatorSetParamsReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>, OperatorSetParam);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u8,
                <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorSetParamsCall> for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorSetParamsCall) -> Self {
                    (value.quorumNumber, value.operatorSetParams)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOperatorSetParamsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        quorumNumber: tuple.0,
                        operatorSetParams: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorSetParamsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorSetParamsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setOperatorSetParamsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setOperatorSetParamsCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<8>, OperatorSetParam);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setOperatorSetParamsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setOperatorSetParams(uint8,(uint32,uint16,uint16))";
            const SELECTOR: [u8; 4] = [91u8, 11u8, 130u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumber,
                    ),
                    <OperatorSetParam as alloy_sol_types::SolType>::tokenize(
                        &self.operatorSetParams,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `setPauserRegistry(address)` and selector `0x10d67a2f`.\n```solidity\nfunction setPauserRegistry(address newPauserRegistry) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setPauserRegistryCall {
        pub newPauserRegistry: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`setPauserRegistry(address)`](setPauserRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct setPauserRegistryReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPauserRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: setPauserRegistryCall) -> Self {
                    (value.newPauserRegistry,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setPauserRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPauserRegistry: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPauserRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setPauserRegistryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setPauserRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setPauserRegistryCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = setPauserRegistryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setPauserRegistry(address)";
            const SELECTOR: [u8; 4] = [16u8, 214u8, 122u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newPauserRegistry,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `stakeRegistry()` and selector `0x68304835`.\n```solidity\nfunction stakeRegistry() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct stakeRegistryCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`stakeRegistry()`](stakeRegistryCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct stakeRegistryReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeRegistryCall> for UnderlyingRustTuple<'_> {
                fn from(value: stakeRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<stakeRegistryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: stakeRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for stakeRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for stakeRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = stakeRegistryReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "stakeRegistry()";
            const SELECTOR: [u8; 4] = [104u8, 48u8, 72u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.\n```solidity\nfunction transferOwnership(address newOwner) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        pub newOwner: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `unpause(uint256)` and selector `0xfabc1cbc`.\n```solidity\nfunction unpause(uint256 newPausedStatus) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct unpauseCall {
        pub newPausedStatus: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`unpause(uint256)`](unpauseCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    (value.newPausedStatus,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newPausedStatus: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause(uint256)";
            const SELECTOR: [u8; 4] = [250u8, 188u8, 28u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newPausedStatus,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `updateOperators(address[])` and selector `0x00cf2ab5`.\n```solidity\nfunction updateOperators(address[] memory operators) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorsCall {
        pub operators: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`updateOperators(address[])`](updateOperatorsCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorsReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorsCall) -> Self {
                    (value.operators,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { operators: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateOperatorsCall {
            type Parameters<'a> =
                (::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateOperatorsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateOperators(address[])";
            const SELECTOR: [u8; 4] = [0u8, 207u8, 42u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Address,
                > as alloy_sol_types::SolType>::tokenize(
                    &self.operators
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `updateOperatorsForQuorum(address[][],bytes)` and selector `0x5140a548`.\n```solidity\nfunction updateOperatorsForQuorum(address[][] memory operatorsPerQuorum, bytes memory quorumNumbers) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorsForQuorumCall {
        pub operatorsPerQuorum: ::alloy_sol_types::private::Vec<
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
        >,
        pub quorumNumbers: ::alloy_sol_types::private::Bytes,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`updateOperatorsForQuorum(address[][],bytes)`](updateOperatorsForQuorumCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorsForQuorumReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
                >,
                ::alloy_sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Vec<
                    ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
                >,
                ::alloy_sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorsForQuorumCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorsForQuorumCall) -> Self {
                    (value.operatorsPerQuorum, value.quorumNumbers)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorsForQuorumCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorsPerQuorum: tuple.0,
                        quorumNumbers: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorsForQuorumReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorsForQuorumReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorsForQuorumReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateOperatorsForQuorumCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
                >,
                ::alloy_sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateOperatorsForQuorumReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateOperatorsForQuorum(address[][],bytes)";
            const SELECTOR: [u8; 4] = [81u8, 64u8, 165u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Array<
                        ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.operatorsPerQuorum
                    ),
                    <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.quorumNumbers,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Function with signature `updateSocket(string)` and selector `0x0cf4b767`.\n```solidity\nfunction updateSocket(string memory socket) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateSocketCall {
        pub socket: ::alloy_sol_types::private::String,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container type for the return parameters of the [`updateSocket(string)`](updateSocketCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateSocketReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateSocketCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateSocketCall) -> Self {
                    (value.socket,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateSocketCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { socket: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateSocketReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateSocketReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateSocketReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateSocketCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::String,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateSocketReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateSocket(string)";
            const SELECTOR: [u8; 4] = [12u8, 244u8, 183u8, 103u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.socket,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container for all the [`RegistryCoordinator`](self) function calls."]
    pub enum RegistryCoordinatorCalls {
        OPERATOR_CHURN_APPROVAL_TYPEHASH(OPERATOR_CHURN_APPROVAL_TYPEHASHCall),
        PUBKEY_REGISTRATION_TYPEHASH(PUBKEY_REGISTRATION_TYPEHASHCall),
        blsApkRegistry(blsApkRegistryCall),
        calculateOperatorChurnApprovalDigestHash(calculateOperatorChurnApprovalDigestHashCall),
        churnApprover(churnApproverCall),
        createQuorum(createQuorumCall),
        deregisterOperator(deregisterOperatorCall),
        ejectOperator(ejectOperatorCall),
        ejector(ejectorCall),
        getCurrentQuorumBitmap(getCurrentQuorumBitmapCall),
        getOperator(getOperatorCall),
        getOperatorFromId(getOperatorFromIdCall),
        getOperatorId(getOperatorIdCall),
        getOperatorSetParams(getOperatorSetParamsCall),
        getOperatorStatus(getOperatorStatusCall),
        getQuorumBitmapAtBlockNumberByIndex(getQuorumBitmapAtBlockNumberByIndexCall),
        getQuorumBitmapHistoryLength(getQuorumBitmapHistoryLengthCall),
        getQuorumBitmapIndicesAtBlockNumber(getQuorumBitmapIndicesAtBlockNumberCall),
        getQuorumBitmapUpdateByIndex(getQuorumBitmapUpdateByIndexCall),
        indexRegistry(indexRegistryCall),
        initialize(initializeCall),
        isChurnApproverSaltUsed(isChurnApproverSaltUsedCall),
        numRegistries(numRegistriesCall),
        owner(ownerCall),
        pause(pauseCall),
        pauseAll(pauseAllCall),
        paused_0(paused_0Call),
        paused_1(paused_1Call),
        pauserRegistry(pauserRegistryCall),
        pubkeyRegistrationMessageHash(pubkeyRegistrationMessageHashCall),
        quorumCount(quorumCountCall),
        quorumUpdateBlockNumber(quorumUpdateBlockNumberCall),
        registerOperator(registerOperatorCall),
        registerOperatorWithChurn(registerOperatorWithChurnCall),
        registries(registriesCall),
        renounceOwnership(renounceOwnershipCall),
        serviceManager(serviceManagerCall),
        setChurnApprover(setChurnApproverCall),
        setEjector(setEjectorCall),
        setOperatorSetParams(setOperatorSetParamsCall),
        setPauserRegistry(setPauserRegistryCall),
        stakeRegistry(stakeRegistryCall),
        transferOwnership(transferOwnershipCall),
        unpause(unpauseCall),
        updateOperators(updateOperatorsCall),
        updateOperatorsForQuorum(updateOperatorsForQuorumCall),
        updateSocket(updateSocketCall),
    }
    #[automatically_derived]
    impl RegistryCoordinatorCalls {
        #[doc = r" All the selectors of this enum."]
        #[doc = r""]
        #[doc = r" Note that the selectors might not be in the same order as the variants."]
        #[doc = r" No guarantees are made about the order of the selectors."]
        #[doc = r""]
        #[doc = r" Prefer using `SolInterface` methods instead."]
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 207u8, 42u8, 181u8],
            [3u8, 253u8, 52u8, 146u8],
            [4u8, 236u8, 99u8, 81u8],
            [5u8, 67u8, 16u8, 230u8],
            [12u8, 244u8, 183u8, 103u8],
            [16u8, 214u8, 122u8, 47u8],
            [19u8, 84u8, 42u8, 78u8],
            [19u8, 100u8, 57u8, 221u8],
            [20u8, 120u8, 133u8, 31u8],
            [30u8, 184u8, 18u8, 218u8],
            [36u8, 154u8, 12u8, 66u8],
            [40u8, 246u8, 27u8, 49u8],
            [41u8, 107u8, 176u8, 100u8],
            [41u8, 209u8, 224u8, 195u8],
            [44u8, 221u8, 30u8, 134u8],
            [57u8, 152u8, 253u8, 211u8],
            [60u8, 42u8, 127u8, 76u8],
            [81u8, 64u8, 165u8, 72u8],
            [88u8, 101u8, 198u8, 12u8],
            [89u8, 92u8, 106u8, 103u8],
            [90u8, 200u8, 106u8, 183u8],
            [91u8, 11u8, 130u8, 159u8],
            [92u8, 151u8, 90u8, 187u8],
            [93u8, 244u8, 89u8, 70u8],
            [99u8, 71u8, 201u8, 0u8],
            [104u8, 48u8, 72u8, 53u8],
            [110u8, 59u8, 23u8, 219u8],
            [113u8, 80u8, 24u8, 166u8],
            [132u8, 202u8, 82u8, 19u8],
            [135u8, 30u8, 240u8, 73u8],
            [136u8, 111u8, 17u8, 149u8],
            [141u8, 165u8, 203u8, 91u8],
            [154u8, 161u8, 101u8, 61u8],
            [155u8, 93u8, 23u8, 123u8],
            [158u8, 153u8, 35u8, 194u8],
            [159u8, 234u8, 184u8, 89u8],
            [165u8, 8u8, 87u8, 191u8],
            [195u8, 145u8, 66u8, 94u8],
            [202u8, 13u8, 232u8, 130u8],
            [202u8, 79u8, 45u8, 151u8],
            [215u8, 45u8, 141u8, 214u8],
            [215u8, 91u8, 76u8, 136u8],
            [221u8, 130u8, 131u8, 243u8],
            [230u8, 87u8, 151u8, 173u8],
            [242u8, 253u8, 227u8, 139u8],
            [250u8, 188u8, 28u8, 188u8],
            [253u8, 57u8, 16u8, 90u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for RegistryCoordinatorCalls {
        const NAME: &'static str = "RegistryCoordinatorCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 47usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::OPERATOR_CHURN_APPROVAL_TYPEHASH(_) => <OPERATOR_CHURN_APPROVAL_TYPEHASHCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::PUBKEY_REGISTRATION_TYPEHASH(_) => <PUBKEY_REGISTRATION_TYPEHASHCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::blsApkRegistry(_) => <blsApkRegistryCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::calculateOperatorChurnApprovalDigestHash(_) => <calculateOperatorChurnApprovalDigestHashCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::churnApprover(_) => <churnApproverCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::createQuorum(_) => <createQuorumCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::deregisterOperator(_) => <deregisterOperatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::ejectOperator(_) => <ejectOperatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::ejector(_) => <ejectorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getCurrentQuorumBitmap(_) => <getCurrentQuorumBitmapCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperator(_) => <getOperatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperatorFromId(_) => <getOperatorFromIdCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperatorId(_) => <getOperatorIdCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperatorSetParams(_) => <getOperatorSetParamsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperatorStatus(_) => <getOperatorStatusCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getQuorumBitmapAtBlockNumberByIndex(_) => <getQuorumBitmapAtBlockNumberByIndexCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getQuorumBitmapHistoryLength(_) => <getQuorumBitmapHistoryLengthCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getQuorumBitmapIndicesAtBlockNumber(_) => <getQuorumBitmapIndicesAtBlockNumberCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getQuorumBitmapUpdateByIndex(_) => <getQuorumBitmapUpdateByIndexCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::indexRegistry(_) => <indexRegistryCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => <initializeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isChurnApproverSaltUsed(_) => <isChurnApproverSaltUsedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::numRegistries(_) => <numRegistriesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauseAll(_) => <pauseAllCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused_0(_) => <paused_0Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused_1(_) => <paused_1Call as alloy_sol_types::SolCall>::SELECTOR,
                Self::pauserRegistry(_) => <pauserRegistryCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::pubkeyRegistrationMessageHash(_) => <pubkeyRegistrationMessageHashCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::quorumCount(_) => <quorumCountCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::quorumUpdateBlockNumber(_) => <quorumUpdateBlockNumberCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::registerOperator(_) => <registerOperatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::registerOperatorWithChurn(_) => <registerOperatorWithChurnCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::registries(_) => <registriesCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceOwnership(_) => <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::serviceManager(_) => <serviceManagerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setChurnApprover(_) => <setChurnApproverCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setEjector(_) => <setEjectorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setOperatorSetParams(_) => <setOperatorSetParamsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::setPauserRegistry(_) => <setPauserRegistryCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::stakeRegistry(_) => <stakeRegistryCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferOwnership(_) => <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateOperators(_) => <updateOperatorsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateOperatorsForQuorum(_) => <updateOperatorsForQuorumCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateSocket(_) => <updateSocketCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            )
                -> alloy_sol_types::Result<RegistryCoordinatorCalls>] = &[
                {
                    fn updateOperators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <updateOperatorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::updateOperators)
                    }
                    updateOperators
                },
                {
                    fn getQuorumBitmapHistoryLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getQuorumBitmapHistoryLengthCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(RegistryCoordinatorCalls::getQuorumBitmapHistoryLength)
                    }
                    getQuorumBitmapHistoryLength
                },
                {
                    fn getQuorumBitmapAtBlockNumberByIndex(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getQuorumBitmapAtBlockNumberByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(RegistryCoordinatorCalls::getQuorumBitmapAtBlockNumberByIndex)
                    }
                    getQuorumBitmapAtBlockNumberByIndex
                },
                {
                    fn churnApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <churnApproverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::churnApprover)
                    }
                    churnApprover
                },
                {
                    fn updateSocket(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <updateSocketCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::updateSocket)
                    }
                    updateSocket
                },
                {
                    fn setPauserRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <setPauserRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::setPauserRegistry)
                    }
                    setPauserRegistry
                },
                {
                    fn getOperatorId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getOperatorIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::getOperatorId)
                    }
                    getOperatorId
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::pause)
                    }
                    pause
                },
                {
                    fn isChurnApproverSaltUsed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <isChurnApproverSaltUsedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::isChurnApproverSaltUsed)
                    }
                    isChurnApproverSaltUsed
                },
                {
                    fn getQuorumBitmapUpdateByIndex(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getQuorumBitmapUpdateByIndexCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(RegistryCoordinatorCalls::getQuorumBitmapUpdateByIndex)
                    }
                    getQuorumBitmapUpdateByIndex
                },
                {
                    fn quorumUpdateBlockNumber(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <quorumUpdateBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::quorumUpdateBlockNumber)
                    }
                    quorumUpdateBlockNumber
                },
                {
                    fn ejector(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <ejectorCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::ejector)
                    }
                    ejector
                },
                {
                    fn getOperatorFromId(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getOperatorFromIdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::getOperatorFromId)
                    }
                    getOperatorFromId
                },
                {
                    fn setChurnApprover(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <setChurnApproverCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::setChurnApprover)
                    }
                    setChurnApprover
                },
                {
                    fn setEjector(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <setEjectorCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::setEjector)
                    }
                    setEjector
                },
                {
                    fn serviceManager(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <serviceManagerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::serviceManager)
                    }
                    serviceManager
                },
                {
                    fn pubkeyRegistrationMessageHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <pubkeyRegistrationMessageHashCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(RegistryCoordinatorCalls::pubkeyRegistrationMessageHash)
                    }
                    pubkeyRegistrationMessageHash
                },
                {
                    fn updateOperatorsForQuorum(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <updateOperatorsForQuorumCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::updateOperatorsForQuorum)
                    }
                    updateOperatorsForQuorum
                },
                {
                    fn getOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::getOperator)
                    }
                    getOperator
                },
                {
                    fn pauseAll(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <pauseAllCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::pauseAll)
                    }
                    pauseAll
                },
                {
                    fn paused_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <paused_0Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::paused_0)
                    }
                    paused_0
                },
                {
                    fn setOperatorSetParams(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <setOperatorSetParamsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::setOperatorSetParams)
                    }
                    setOperatorSetParams
                },
                {
                    fn paused_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <paused_1Call as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::paused_1)
                    }
                    paused_1
                },
                {
                    fn blsApkRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <blsApkRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::blsApkRegistry)
                    }
                    blsApkRegistry
                },
                {
                    fn registries(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <registriesCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::registries)
                    }
                    registries
                },
                {
                    fn stakeRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <stakeRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::stakeRegistry)
                    }
                    stakeRegistry
                },
                {
                    fn ejectOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <ejectOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::ejectOperator)
                    }
                    ejectOperator
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn calculateOperatorChurnApprovalDigestHash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <calculateOperatorChurnApprovalDigestHashCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(RegistryCoordinatorCalls::calculateOperatorChurnApprovalDigestHash)
                    }
                    calculateOperatorChurnApprovalDigestHash
                },
                {
                    fn getCurrentQuorumBitmap(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getCurrentQuorumBitmapCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::getCurrentQuorumBitmap)
                    }
                    getCurrentQuorumBitmap
                },
                {
                    fn pauserRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <pauserRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::pauserRegistry)
                    }
                    pauserRegistry
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::owner)
                    }
                    owner
                },
                {
                    fn quorumCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <quorumCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::quorumCount)
                    }
                    quorumCount
                },
                {
                    fn registerOperatorWithChurn(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <registerOperatorWithChurnCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::registerOperatorWithChurn)
                    }
                    registerOperatorWithChurn
                },
                {
                    fn indexRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <indexRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::indexRegistry)
                    }
                    indexRegistry
                },
                {
                    fn PUBKEY_REGISTRATION_TYPEHASH(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <PUBKEY_REGISTRATION_TYPEHASHCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(RegistryCoordinatorCalls::PUBKEY_REGISTRATION_TYPEHASH)
                    }
                    PUBKEY_REGISTRATION_TYPEHASH
                },
                {
                    fn registerOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <registerOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::registerOperator)
                    }
                    registerOperator
                },
                {
                    fn getQuorumBitmapIndicesAtBlockNumber(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getQuorumBitmapIndicesAtBlockNumberCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(RegistryCoordinatorCalls::getQuorumBitmapIndicesAtBlockNumber)
                    }
                    getQuorumBitmapIndicesAtBlockNumber
                },
                {
                    fn OPERATOR_CHURN_APPROVAL_TYPEHASH(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <OPERATOR_CHURN_APPROVAL_TYPEHASHCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(RegistryCoordinatorCalls::OPERATOR_CHURN_APPROVAL_TYPEHASH)
                    }
                    OPERATOR_CHURN_APPROVAL_TYPEHASH
                },
                {
                    fn deregisterOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <deregisterOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::deregisterOperator)
                    }
                    deregisterOperator
                },
                {
                    fn numRegistries(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <numRegistriesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::numRegistries)
                    }
                    numRegistries
                },
                {
                    fn createQuorum(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <createQuorumCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::createQuorum)
                    }
                    createQuorum
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::initialize)
                    }
                    initialize
                },
                {
                    fn getOperatorSetParams(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getOperatorSetParamsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::getOperatorSetParams)
                    }
                    getOperatorSetParams
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::transferOwnership)
                    }
                    transferOwnership
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(RegistryCoordinatorCalls::unpause)
                    }
                    unpause
                },
                {
                    fn getOperatorStatus(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<RegistryCoordinatorCalls> {
                        <getOperatorStatusCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(RegistryCoordinatorCalls::getOperatorStatus)
                    }
                    getOperatorStatus
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::OPERATOR_CHURN_APPROVAL_TYPEHASH(inner) => <OPERATOR_CHURN_APPROVAL_TYPEHASHCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::PUBKEY_REGISTRATION_TYPEHASH(inner) => <PUBKEY_REGISTRATION_TYPEHASHCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::blsApkRegistry(inner) => <blsApkRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::calculateOperatorChurnApprovalDigestHash(inner) => <calculateOperatorChurnApprovalDigestHashCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::churnApprover(inner) => <churnApproverCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::createQuorum(inner) => <createQuorumCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::deregisterOperator(inner) => <deregisterOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::ejectOperator(inner) => <ejectOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::ejector(inner) => <ejectorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getCurrentQuorumBitmap(inner) => <getCurrentQuorumBitmapCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperator(inner) => <getOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorFromId(inner) => <getOperatorFromIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorId(inner) => <getOperatorIdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorSetParams(inner) => <getOperatorSetParamsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorStatus(inner) => <getOperatorStatusCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getQuorumBitmapAtBlockNumberByIndex(inner) => <getQuorumBitmapAtBlockNumberByIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getQuorumBitmapHistoryLength(inner) => <getQuorumBitmapHistoryLengthCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getQuorumBitmapIndicesAtBlockNumber(inner) => <getQuorumBitmapIndicesAtBlockNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getQuorumBitmapUpdateByIndex(inner) => <getQuorumBitmapUpdateByIndexCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::indexRegistry(inner) => <indexRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::isChurnApproverSaltUsed(inner) => <isChurnApproverSaltUsedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::numRegistries(inner) => <numRegistriesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::owner(inner) => <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::pause(inner) => <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::pauseAll(inner) => <pauseAllCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::paused_0(inner) => <paused_0Call as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::paused_1(inner) => <paused_1Call as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::pauserRegistry(inner) => <pauserRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::pubkeyRegistrationMessageHash(inner) => <pubkeyRegistrationMessageHashCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::quorumCount(inner) => <quorumCountCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::quorumUpdateBlockNumber(inner) => <quorumUpdateBlockNumberCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::registerOperator(inner) => <registerOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::registerOperatorWithChurn(inner) => <registerOperatorWithChurnCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::registries(inner) => <registriesCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::renounceOwnership(inner) => <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::serviceManager(inner) => <serviceManagerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::setChurnApprover(inner) => <setChurnApproverCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::setEjector(inner) => <setEjectorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::setOperatorSetParams(inner) => <setOperatorSetParamsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::setPauserRegistry(inner) => <setPauserRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::stakeRegistry(inner) => <stakeRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::transferOwnership(inner) => <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::unpause(inner) => <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateOperators(inner) => <updateOperatorsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateOperatorsForQuorum(inner) => <updateOperatorsForQuorumCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateSocket(inner) => <updateSocketCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::OPERATOR_CHURN_APPROVAL_TYPEHASH(inner) => <OPERATOR_CHURN_APPROVAL_TYPEHASHCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::PUBKEY_REGISTRATION_TYPEHASH(inner) => <PUBKEY_REGISTRATION_TYPEHASHCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::blsApkRegistry(inner) => <blsApkRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::calculateOperatorChurnApprovalDigestHash(inner) => <calculateOperatorChurnApprovalDigestHashCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::churnApprover(inner) => <churnApproverCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::createQuorum(inner) => <createQuorumCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::deregisterOperator(inner) => <deregisterOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::ejectOperator(inner) => <ejectOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::ejector(inner) => <ejectorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getCurrentQuorumBitmap(inner) => <getCurrentQuorumBitmapCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getOperator(inner) => <getOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getOperatorFromId(inner) => <getOperatorFromIdCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getOperatorId(inner) => <getOperatorIdCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getOperatorSetParams(inner) => <getOperatorSetParamsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getOperatorStatus(inner) => <getOperatorStatusCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getQuorumBitmapAtBlockNumberByIndex(inner) => <getQuorumBitmapAtBlockNumberByIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getQuorumBitmapHistoryLength(inner) => <getQuorumBitmapHistoryLengthCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getQuorumBitmapIndicesAtBlockNumber(inner) => <getQuorumBitmapIndicesAtBlockNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getQuorumBitmapUpdateByIndex(inner) => <getQuorumBitmapUpdateByIndexCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::indexRegistry(inner) => <indexRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::isChurnApproverSaltUsed(inner) => <isChurnApproverSaltUsedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::numRegistries(inner) => <numRegistriesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::owner(inner) => <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::pause(inner) => <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::pauseAll(inner) => <pauseAllCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::paused_0(inner) => <paused_0Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::paused_1(inner) => <paused_1Call as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::pauserRegistry(inner) => <pauserRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::pubkeyRegistrationMessageHash(inner) => <pubkeyRegistrationMessageHashCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::quorumCount(inner) => <quorumCountCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::quorumUpdateBlockNumber(inner) => <quorumUpdateBlockNumberCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::registerOperator(inner) => <registerOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::registerOperatorWithChurn(inner) => <registerOperatorWithChurnCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::registries(inner) => <registriesCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::renounceOwnership(inner) => <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::serviceManager(inner) => <serviceManagerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::setChurnApprover(inner) => <setChurnApproverCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::setEjector(inner) => <setEjectorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::setOperatorSetParams(inner) => <setOperatorSetParamsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::setPauserRegistry(inner) => <setPauserRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::stakeRegistry(inner) => <stakeRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::transferOwnership(inner) => <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::unpause(inner) => <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateOperators(inner) => <updateOperatorsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateOperatorsForQuorum(inner) => <updateOperatorsForQuorumCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateSocket(inner) => <updateSocketCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
            }
        }
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[derive(Debug)]
    #[doc = "Container for all the [`RegistryCoordinator`](self) events."]
    pub enum RegistryCoordinatorEvents {
        ChurnApproverUpdated(ChurnApproverUpdated),
        EjectorUpdated(EjectorUpdated),
        Initialized(Initialized),
        OperatorDeregistered(OperatorDeregistered),
        OperatorRegistered(OperatorRegistered),
        OperatorSetParamsUpdated(OperatorSetParamsUpdated),
        OperatorSocketUpdate(OperatorSocketUpdate),
        OwnershipTransferred(OwnershipTransferred),
        Paused(Paused),
        PauserRegistrySet(PauserRegistrySet),
        QuorumBlockNumberUpdated(QuorumBlockNumberUpdated),
        Unpaused(Unpaused),
    }
    #[automatically_derived]
    impl RegistryCoordinatorEvents {
        #[doc = r" All the selectors of this enum."]
        #[doc = r""]
        #[doc = r" Note that the selectors might not be in the same order as the variants."]
        #[doc = r" No guarantees are made about the order of the selectors."]
        #[doc = r""]
        #[doc = r" Prefer using `SolInterface` methods instead."]
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                49u8, 84u8, 87u8, 216u8, 168u8, 254u8, 96u8, 240u8, 74u8, 241u8, 124u8, 22u8,
                226u8, 245u8, 165u8, 225u8, 219u8, 97u8, 43u8, 49u8, 100u8, 142u8, 88u8, 3u8, 3u8,
                96u8, 117u8, 158u8, 248u8, 243u8, 82u8, 140u8,
            ],
            [
                53u8, 130u8, 209u8, 130u8, 142u8, 38u8, 191u8, 86u8, 189u8, 128u8, 21u8, 2u8,
                188u8, 2u8, 26u8, 192u8, 188u8, 138u8, 251u8, 87u8, 200u8, 38u8, 228u8, 152u8,
                107u8, 69u8, 89u8, 60u8, 143u8, 173u8, 56u8, 156u8,
            ],
            [
                57u8, 111u8, 220u8, 177u8, 128u8, 203u8, 15u8, 234u8, 38u8, 146u8, 129u8, 19u8,
                251u8, 15u8, 209u8, 195u8, 84u8, 152u8, 99u8, 249u8, 205u8, 86u8, 62u8, 106u8,
                24u8, 79u8, 29u8, 87u8, 129u8, 22u8, 200u8, 228u8,
            ],
            [
                62u8, 230u8, 254u8, 141u8, 84u8, 97u8, 2u8, 68u8, 195u8, 233u8, 211u8, 192u8,
                102u8, 174u8, 74u8, 238u8, 153u8, 120u8, 132u8, 170u8, 40u8, 241u8, 6u8, 22u8,
                174u8, 130u8, 25u8, 37u8, 64u8, 19u8, 24u8, 172u8,
            ],
            [
                70u8, 7u8, 125u8, 85u8, 51u8, 7u8, 99u8, 241u8, 98u8, 105u8, 253u8, 117u8, 229u8,
                118u8, 22u8, 99u8, 244u8, 25u8, 45u8, 39u8, 145u8, 116u8, 124u8, 1u8, 137u8, 177u8,
                106u8, 211u8, 29u8, 176u8, 125u8, 180u8,
            ],
            [
                110u8, 159u8, 205u8, 83u8, 152u8, 150u8, 252u8, 166u8, 14u8, 139u8, 15u8, 1u8,
                221u8, 88u8, 2u8, 51u8, 228u8, 138u8, 107u8, 15u8, 125u8, 240u8, 19u8, 184u8,
                155u8, 167u8, 245u8, 101u8, 134u8, 154u8, 205u8, 182u8,
            ],
            [
                127u8, 38u8, 184u8, 63u8, 249u8, 110u8, 31u8, 43u8, 106u8, 104u8, 47u8, 19u8, 56u8,
                82u8, 246u8, 121u8, 138u8, 9u8, 196u8, 101u8, 218u8, 149u8, 146u8, 20u8, 96u8,
                206u8, 251u8, 56u8, 71u8, 64u8, 36u8, 152u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8, 31u8, 208u8,
                164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8, 218u8, 175u8, 227u8,
                180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                143u8, 48u8, 171u8, 9u8, 244u8, 58u8, 108u8, 21u8, 125u8, 127u8, 206u8, 126u8,
                10u8, 19u8, 192u8, 3u8, 4u8, 44u8, 28u8, 149u8, 232u8, 167u8, 46u8, 122u8, 20u8,
                106u8, 33u8, 192u8, 202u8, 162u8, 77u8, 201u8,
            ],
            [
                171u8, 64u8, 163u8, 116u8, 188u8, 81u8, 222u8, 55u8, 34u8, 0u8, 168u8, 188u8,
                152u8, 26u8, 248u8, 201u8, 236u8, 220u8, 8u8, 223u8, 218u8, 239u8, 11u8, 182u8,
                224u8, 159u8, 136u8, 243u8, 198u8, 22u8, 239u8, 61u8,
            ],
            [
                232u8, 230u8, 140u8, 239u8, 28u8, 58u8, 118u8, 30u8, 215u8, 190u8, 126u8, 132u8,
                99u8, 163u8, 117u8, 242u8, 127u8, 123u8, 195u8, 53u8, 229u8, 24u8, 36u8, 34u8,
                60u8, 172u8, 206u8, 99u8, 110u8, 197u8, 195u8, 254u8,
            ],
            [
                236u8, 41u8, 99u8, 171u8, 33u8, 193u8, 229u8, 14u8, 30u8, 88u8, 42u8, 165u8, 66u8,
                175u8, 46u8, 75u8, 247u8, 191u8, 56u8, 230u8, 225u8, 64u8, 60u8, 39u8, 180u8, 46u8,
                28u8, 93u8, 110u8, 98u8, 30u8, 170u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for RegistryCoordinatorEvents {
        const NAME: &'static str = "RegistryCoordinatorEvents";
        const COUNT: usize = 12usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<ChurnApproverUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ChurnApproverUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::ChurnApproverUpdated)
                }
                Some(<EjectorUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EjectorUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::EjectorUpdated)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::Initialized)
                }
                Some(<OperatorDeregistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorDeregistered as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OperatorDeregistered)
                }
                Some(<OperatorRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OperatorRegistered)
                }
                Some(<OperatorSetParamsUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorSetParamsUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OperatorSetParamsUpdated)
                }
                Some(<OperatorSocketUpdate as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorSocketUpdate as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OperatorSocketUpdate)
                }
                Some(<OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OwnershipTransferred)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::Paused)
                }
                Some(<PauserRegistrySet as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <PauserRegistrySet as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::PauserRegistrySet)
                }
                Some(<QuorumBlockNumberUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <QuorumBlockNumberUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::QuorumBlockNumberUpdated)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(topics, data, validate)
                        .map(Self::Unpaused)
                }
                _ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                    name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                    log: alloy_sol_types::private::Box::new(
                        alloy_sol_types::private::LogData::new_unchecked(
                            topics.to_vec(),
                            data.to_vec().into(),
                        ),
                    ),
                }),
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for RegistryCoordinatorEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChurnApproverUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EjectorUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorDeregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorSetParamsUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorSocketUpdate(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
                Self::PauserRegistrySet(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::QuorumBlockNumberUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => alloy_sol_types::private::IntoLogData::to_log_data(inner),
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::ChurnApproverUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EjectorUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorDeregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorSetParamsUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorSocketUpdate(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => alloy_sol_types::private::IntoLogData::into_log_data(inner),
                Self::PauserRegistrySet(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::QuorumBlockNumberUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use ::alloy_contract;
    #[doc = "Creates a new wrapper around an on-chain [`RegistryCoordinator`](self) contract instance.\n\nSee the [wrapper's documentation](`RegistryCoordinatorInstance`) for more details."]
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> RegistryCoordinatorInstance<T, P, N> {
        RegistryCoordinatorInstance::<T, P, N>::new(address, provider)
    }
    #[doc = "Deploys this contract using the given `provider` and constructor arguments, if any.\n\nReturns a new instance of the contract, if the deployment was successful.\n\nFor more fine-grained control over the deployment process, use [`deploy_builder`] instead."]
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _serviceManager: ::alloy_sol_types::private::Address,
        _stakeRegistry: ::alloy_sol_types::private::Address,
        _blsApkRegistry: ::alloy_sol_types::private::Address,
        _indexRegistry: ::alloy_sol_types::private::Address,
    ) -> impl ::core::future::Future<Output = alloy_contract::Result<RegistryCoordinatorInstance<T, P, N>>>
    {
        RegistryCoordinatorInstance::<T, P, N>::deploy(
            provider,
            _serviceManager,
            _stakeRegistry,
            _blsApkRegistry,
            _indexRegistry,
        )
    }
    #[doc = "Creates a `RawCallBuilder` for deploying this contract using the given `provider`\nand constructor arguments, if any.\n\nThis is a simple wrapper around creating a `RawCallBuilder` with the data set to\nthe bytecode concatenated with the constructor's ABI-encoded arguments."]
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _serviceManager: ::alloy_sol_types::private::Address,
        _stakeRegistry: ::alloy_sol_types::private::Address,
        _blsApkRegistry: ::alloy_sol_types::private::Address,
        _indexRegistry: ::alloy_sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        RegistryCoordinatorInstance::<T, P, N>::deploy_builder(
            provider,
            _serviceManager,
            _stakeRegistry,
            _blsApkRegistry,
            _indexRegistry,
        )
    }
    #[doc = "A [`RegistryCoordinator`](self) instance.\n\nContains type-safe methods for interacting with an on-chain instance of the\n[`RegistryCoordinator`](self) contract located at a given `address`, using a given\nprovider `P`.\n\nIf the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)\ndocumentation on how to provide it), the `deploy` and `deploy_builder` methods can\nbe used to deploy a new instance of the contract.\n\nSee the [module-level documentation](self) for all the available methods."]
    #[derive(Clone)]
    pub struct RegistryCoordinatorInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for RegistryCoordinatorInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("RegistryCoordinatorInstance")
                .field(&self.address)
                .finish()
        }
    }
    #[doc = r" Instantiation and getters/setters."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > RegistryCoordinatorInstance<T, P, N>
    {
        #[doc = "Creates a new wrapper around an on-chain [`RegistryCoordinator`](self) contract instance.\n\nSee the [wrapper's documentation](`RegistryCoordinatorInstance`) for more details."]
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, provider: P) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        #[doc = "Deploys this contract using the given `provider` and constructor arguments, if any.\n\nReturns a new instance of the contract, if the deployment was successful.\n\nFor more fine-grained control over the deployment process, use [`deploy_builder`] instead."]
        #[inline]
        pub async fn deploy(
            provider: P,
            _serviceManager: ::alloy_sol_types::private::Address,
            _stakeRegistry: ::alloy_sol_types::private::Address,
            _blsApkRegistry: ::alloy_sol_types::private::Address,
            _indexRegistry: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::Result<RegistryCoordinatorInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(
                provider,
                _serviceManager,
                _stakeRegistry,
                _blsApkRegistry,
                _indexRegistry,
            );
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        #[doc = "Creates a `RawCallBuilder` for deploying this contract using the given `provider`\nand constructor arguments, if any.\n\nThis is a simple wrapper around creating a `RawCallBuilder` with the data set to\nthe bytecode concatenated with the constructor's ABI-encoded arguments."]
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _serviceManager: ::alloy_sol_types::private::Address,
            _stakeRegistry: ::alloy_sol_types::private::Address,
            _blsApkRegistry: ::alloy_sol_types::private::Address,
            _indexRegistry: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(&constructorCall {
                        _serviceManager,
                        _stakeRegistry,
                        _blsApkRegistry,
                        _indexRegistry,
                    })[..],
                ]
                .concat()
                .into(),
            )
        }
        #[doc = r" Returns a reference to the address."]
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        #[doc = r" Sets the address."]
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        #[doc = r" Sets the address and returns `self`."]
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        #[doc = r" Returns a reference to the provider."]
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> RegistryCoordinatorInstance<T, &P, N> {
        #[doc = r" Clones the provider and returns a new instance with the cloned provider."]
        #[inline]
        pub fn with_cloned_provider(self) -> RegistryCoordinatorInstance<T, P, N> {
            RegistryCoordinatorInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    #[doc = r" Function calls."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > RegistryCoordinatorInstance<T, P, N>
    {
        #[doc = r" Creates a new call builder using this contract instance's provider and address."]
        #[doc = r""]
        #[doc = r" Note that the call can be any function call, not just those defined in this"]
        #[doc = r" contract. Prefer using the other methods for building type-safe contract calls."]
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        #[doc = "Creates a new call builder for the [`OPERATOR_CHURN_APPROVAL_TYPEHASH`] function."]
        pub fn OPERATOR_CHURN_APPROVAL_TYPEHASH(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, OPERATOR_CHURN_APPROVAL_TYPEHASHCall, N>
        {
            self.call_builder(&OPERATOR_CHURN_APPROVAL_TYPEHASHCall {})
        }
        #[doc = "Creates a new call builder for the [`PUBKEY_REGISTRATION_TYPEHASH`] function."]
        pub fn PUBKEY_REGISTRATION_TYPEHASH(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PUBKEY_REGISTRATION_TYPEHASHCall, N> {
            self.call_builder(&PUBKEY_REGISTRATION_TYPEHASHCall {})
        }
        #[doc = "Creates a new call builder for the [`blsApkRegistry`] function."]
        pub fn blsApkRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, blsApkRegistryCall, N> {
            self.call_builder(&blsApkRegistryCall {})
        }
        #[doc = "Creates a new call builder for the [`calculateOperatorChurnApprovalDigestHash`] function."]
        pub fn calculateOperatorChurnApprovalDigestHash(
            &self,
            registeringOperator: ::alloy_sol_types::private::Address,
            registeringOperatorId: ::alloy_sol_types::private::FixedBytes<32>,
            operatorKickParams: ::alloy_sol_types::private::Vec<
                <OperatorKickParam as ::alloy_sol_types::SolType>::RustType,
            >,
            salt: ::alloy_sol_types::private::FixedBytes<32>,
            expiry: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, calculateOperatorChurnApprovalDigestHashCall, N>
        {
            self.call_builder(&calculateOperatorChurnApprovalDigestHashCall {
                registeringOperator,
                registeringOperatorId,
                operatorKickParams,
                salt,
                expiry,
            })
        }
        #[doc = "Creates a new call builder for the [`churnApprover`] function."]
        pub fn churnApprover(&self) -> alloy_contract::SolCallBuilder<T, &P, churnApproverCall, N> {
            self.call_builder(&churnApproverCall {})
        }
        #[doc = "Creates a new call builder for the [`createQuorum`] function."]
        pub fn createQuorum(
            &self,
            operatorSetParams: <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
            minimumStake: <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
            strategyParams: ::alloy_sol_types::private::Vec<
                <StrategyParams as ::alloy_sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, createQuorumCall, N> {
            self.call_builder(&createQuorumCall {
                operatorSetParams,
                minimumStake,
                strategyParams,
            })
        }
        #[doc = "Creates a new call builder for the [`deregisterOperator`] function."]
        pub fn deregisterOperator(
            &self,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, deregisterOperatorCall, N> {
            self.call_builder(&deregisterOperatorCall { quorumNumbers })
        }
        #[doc = "Creates a new call builder for the [`ejectOperator`] function."]
        pub fn ejectOperator(
            &self,
            operator: ::alloy_sol_types::private::Address,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, ejectOperatorCall, N> {
            self.call_builder(&ejectOperatorCall {
                operator,
                quorumNumbers,
            })
        }
        #[doc = "Creates a new call builder for the [`ejector`] function."]
        pub fn ejector(&self) -> alloy_contract::SolCallBuilder<T, &P, ejectorCall, N> {
            self.call_builder(&ejectorCall {})
        }
        #[doc = "Creates a new call builder for the [`getCurrentQuorumBitmap`] function."]
        pub fn getCurrentQuorumBitmap(
            &self,
            operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getCurrentQuorumBitmapCall, N> {
            self.call_builder(&getCurrentQuorumBitmapCall { operatorId })
        }
        #[doc = "Creates a new call builder for the [`getOperator`] function."]
        pub fn getOperator(
            &self,
            operator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorCall, N> {
            self.call_builder(&getOperatorCall { operator })
        }
        #[doc = "Creates a new call builder for the [`getOperatorFromId`] function."]
        pub fn getOperatorFromId(
            &self,
            operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorFromIdCall, N> {
            self.call_builder(&getOperatorFromIdCall { operatorId })
        }
        #[doc = "Creates a new call builder for the [`getOperatorId`] function."]
        pub fn getOperatorId(
            &self,
            operator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorIdCall, N> {
            self.call_builder(&getOperatorIdCall { operator })
        }
        #[doc = "Creates a new call builder for the [`getOperatorSetParams`] function."]
        pub fn getOperatorSetParams(
            &self,
            quorumNumber: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorSetParamsCall, N> {
            self.call_builder(&getOperatorSetParamsCall { quorumNumber })
        }
        #[doc = "Creates a new call builder for the [`getOperatorStatus`] function."]
        pub fn getOperatorStatus(
            &self,
            operator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorStatusCall, N> {
            self.call_builder(&getOperatorStatusCall { operator })
        }
        #[doc = "Creates a new call builder for the [`getQuorumBitmapAtBlockNumberByIndex`] function."]
        pub fn getQuorumBitmapAtBlockNumberByIndex(
            &self,
            operatorId: ::alloy_sol_types::private::FixedBytes<32>,
            blockNumber: u32,
            index: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getQuorumBitmapAtBlockNumberByIndexCall, N>
        {
            self.call_builder(&getQuorumBitmapAtBlockNumberByIndexCall {
                operatorId,
                blockNumber,
                index,
            })
        }
        #[doc = "Creates a new call builder for the [`getQuorumBitmapHistoryLength`] function."]
        pub fn getQuorumBitmapHistoryLength(
            &self,
            operatorId: ::alloy_sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getQuorumBitmapHistoryLengthCall, N> {
            self.call_builder(&getQuorumBitmapHistoryLengthCall { operatorId })
        }
        #[doc = "Creates a new call builder for the [`getQuorumBitmapIndicesAtBlockNumber`] function."]
        pub fn getQuorumBitmapIndicesAtBlockNumber(
            &self,
            blockNumber: u32,
            operatorIds: ::alloy_sol_types::private::Vec<
                ::alloy_sol_types::private::FixedBytes<32>,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, getQuorumBitmapIndicesAtBlockNumberCall, N>
        {
            self.call_builder(&getQuorumBitmapIndicesAtBlockNumberCall {
                blockNumber,
                operatorIds,
            })
        }
        #[doc = "Creates a new call builder for the [`getQuorumBitmapUpdateByIndex`] function."]
        pub fn getQuorumBitmapUpdateByIndex(
            &self,
            operatorId: ::alloy_sol_types::private::FixedBytes<32>,
            index: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getQuorumBitmapUpdateByIndexCall, N> {
            self.call_builder(&getQuorumBitmapUpdateByIndexCall { operatorId, index })
        }
        #[doc = "Creates a new call builder for the [`indexRegistry`] function."]
        pub fn indexRegistry(&self) -> alloy_contract::SolCallBuilder<T, &P, indexRegistryCall, N> {
            self.call_builder(&indexRegistryCall {})
        }
        #[doc = "Creates a new call builder for the [`initialize`] function."]
        pub fn initialize(
            &self,
            _initialOwner: ::alloy_sol_types::private::Address,
            _churnApprover: ::alloy_sol_types::private::Address,
            _ejector: ::alloy_sol_types::private::Address,
            _pauserRegistry: ::alloy_sol_types::private::Address,
            _initialPausedStatus: ::alloy_sol_types::private::U256,
            _operatorSetParams: ::alloy_sol_types::private::Vec<
                <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
            >,
            _minimumStakes: ::alloy_sol_types::private::Vec<
                <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
            >,
            _strategyParams: ::alloy_sol_types::private::Vec<
                ::alloy_sol_types::private::Vec<
                    <StrategyParams as ::alloy_sol_types::SolType>::RustType,
                >,
            >,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(&initializeCall {
                _initialOwner,
                _churnApprover,
                _ejector,
                _pauserRegistry,
                _initialPausedStatus,
                _operatorSetParams,
                _minimumStakes,
                _strategyParams,
            })
        }
        #[doc = "Creates a new call builder for the [`isChurnApproverSaltUsed`] function."]
        pub fn isChurnApproverSaltUsed(
            &self,
            _0: ::alloy_sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, isChurnApproverSaltUsedCall, N> {
            self.call_builder(&isChurnApproverSaltUsedCall { _0 })
        }
        #[doc = "Creates a new call builder for the [`numRegistries`] function."]
        pub fn numRegistries(&self) -> alloy_contract::SolCallBuilder<T, &P, numRegistriesCall, N> {
            self.call_builder(&numRegistriesCall {})
        }
        #[doc = "Creates a new call builder for the [`owner`] function."]
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        #[doc = "Creates a new call builder for the [`pause`] function."]
        pub fn pause(
            &self,
            newPausedStatus: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall { newPausedStatus })
        }
        #[doc = "Creates a new call builder for the [`pauseAll`] function."]
        pub fn pauseAll(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseAllCall, N> {
            self.call_builder(&pauseAllCall {})
        }
        #[doc = "Creates a new call builder for the [`paused_0`] function."]
        pub fn paused_0(
            &self,
            index: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, paused_0Call, N> {
            self.call_builder(&paused_0Call { index })
        }
        #[doc = "Creates a new call builder for the [`paused_1`] function."]
        pub fn paused_1(&self) -> alloy_contract::SolCallBuilder<T, &P, paused_1Call, N> {
            self.call_builder(&paused_1Call {})
        }
        #[doc = "Creates a new call builder for the [`pauserRegistry`] function."]
        pub fn pauserRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, pauserRegistryCall, N> {
            self.call_builder(&pauserRegistryCall {})
        }
        #[doc = "Creates a new call builder for the [`pubkeyRegistrationMessageHash`] function."]
        pub fn pubkeyRegistrationMessageHash(
            &self,
            operator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, pubkeyRegistrationMessageHashCall, N> {
            self.call_builder(&pubkeyRegistrationMessageHashCall { operator })
        }
        #[doc = "Creates a new call builder for the [`quorumCount`] function."]
        pub fn quorumCount(&self) -> alloy_contract::SolCallBuilder<T, &P, quorumCountCall, N> {
            self.call_builder(&quorumCountCall {})
        }
        #[doc = "Creates a new call builder for the [`quorumUpdateBlockNumber`] function."]
        pub fn quorumUpdateBlockNumber(
            &self,
            _0: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, quorumUpdateBlockNumberCall, N> {
            self.call_builder(&quorumUpdateBlockNumberCall { _0 })
        }
        #[doc = "Creates a new call builder for the [`registerOperator`] function."]
        pub fn registerOperator(
            &self,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
            socket: ::alloy_sol_types::private::String,
            params: <PubkeyRegistrationParams as ::alloy_sol_types::SolType>::RustType,
            operatorSignature: <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, registerOperatorCall, N> {
            self.call_builder(&registerOperatorCall {
                quorumNumbers,
                socket,
                params,
                operatorSignature,
            })
        }
        #[doc = "Creates a new call builder for the [`registerOperatorWithChurn`] function."]
        pub fn registerOperatorWithChurn(
            &self,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
            socket: ::alloy_sol_types::private::String,
            params: <PubkeyRegistrationParams as ::alloy_sol_types::SolType>::RustType,
            operatorKickParams: ::alloy_sol_types::private::Vec<
                <OperatorKickParam as ::alloy_sol_types::SolType>::RustType,
            >,
            churnApproverSignature: <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
            operatorSignature: <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, registerOperatorWithChurnCall, N> {
            self.call_builder(&registerOperatorWithChurnCall {
                quorumNumbers,
                socket,
                params,
                operatorKickParams,
                churnApproverSignature,
                operatorSignature,
            })
        }
        #[doc = "Creates a new call builder for the [`registries`] function."]
        pub fn registries(
            &self,
            _0: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, registriesCall, N> {
            self.call_builder(&registriesCall { _0 })
        }
        #[doc = "Creates a new call builder for the [`renounceOwnership`] function."]
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        #[doc = "Creates a new call builder for the [`serviceManager`] function."]
        pub fn serviceManager(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, serviceManagerCall, N> {
            self.call_builder(&serviceManagerCall {})
        }
        #[doc = "Creates a new call builder for the [`setChurnApprover`] function."]
        pub fn setChurnApprover(
            &self,
            _churnApprover: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setChurnApproverCall, N> {
            self.call_builder(&setChurnApproverCall { _churnApprover })
        }
        #[doc = "Creates a new call builder for the [`setEjector`] function."]
        pub fn setEjector(
            &self,
            _ejector: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setEjectorCall, N> {
            self.call_builder(&setEjectorCall { _ejector })
        }
        #[doc = "Creates a new call builder for the [`setOperatorSetParams`] function."]
        pub fn setOperatorSetParams(
            &self,
            quorumNumber: u8,
            operatorSetParams: <OperatorSetParam as ::alloy_sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, setOperatorSetParamsCall, N> {
            self.call_builder(&setOperatorSetParamsCall {
                quorumNumber,
                operatorSetParams,
            })
        }
        #[doc = "Creates a new call builder for the [`setPauserRegistry`] function."]
        pub fn setPauserRegistry(
            &self,
            newPauserRegistry: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setPauserRegistryCall, N> {
            self.call_builder(&setPauserRegistryCall { newPauserRegistry })
        }
        #[doc = "Creates a new call builder for the [`stakeRegistry`] function."]
        pub fn stakeRegistry(&self) -> alloy_contract::SolCallBuilder<T, &P, stakeRegistryCall, N> {
            self.call_builder(&stakeRegistryCall {})
        }
        #[doc = "Creates a new call builder for the [`transferOwnership`] function."]
        pub fn transferOwnership(
            &self,
            newOwner: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        #[doc = "Creates a new call builder for the [`unpause`] function."]
        pub fn unpause(
            &self,
            newPausedStatus: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall { newPausedStatus })
        }
        #[doc = "Creates a new call builder for the [`updateOperators`] function."]
        pub fn updateOperators(
            &self,
            operators: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateOperatorsCall, N> {
            self.call_builder(&updateOperatorsCall { operators })
        }
        #[doc = "Creates a new call builder for the [`updateOperatorsForQuorum`] function."]
        pub fn updateOperatorsForQuorum(
            &self,
            operatorsPerQuorum: ::alloy_sol_types::private::Vec<
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
            >,
            quorumNumbers: ::alloy_sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateOperatorsForQuorumCall, N> {
            self.call_builder(&updateOperatorsForQuorumCall {
                operatorsPerQuorum,
                quorumNumbers,
            })
        }
        #[doc = "Creates a new call builder for the [`updateSocket`] function."]
        pub fn updateSocket(
            &self,
            socket: ::alloy_sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateSocketCall, N> {
            self.call_builder(&updateSocketCall { socket })
        }
    }
    #[doc = r" Event filters."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > RegistryCoordinatorInstance<T, P, N>
    {
        #[doc = r" Creates a new event filter using this contract instance's provider and address."]
        #[doc = r""]
        #[doc = r" Note that the type can be any event, not just those defined in this contract."]
        #[doc = r" Prefer using the other methods for building type-safe event filters."]
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        #[doc = "Creates a new event filter for the [`ChurnApproverUpdated`] event."]
        pub fn ChurnApproverUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ChurnApproverUpdated, N> {
            self.event_filter::<ChurnApproverUpdated>()
        }
        #[doc = "Creates a new event filter for the [`EjectorUpdated`] event."]
        pub fn EjectorUpdated_filter(&self) -> alloy_contract::Event<T, &P, EjectorUpdated, N> {
            self.event_filter::<EjectorUpdated>()
        }
        #[doc = "Creates a new event filter for the [`Initialized`] event."]
        pub fn Initialized_filter(&self) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        #[doc = "Creates a new event filter for the [`OperatorDeregistered`] event."]
        pub fn OperatorDeregistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorDeregistered, N> {
            self.event_filter::<OperatorDeregistered>()
        }
        #[doc = "Creates a new event filter for the [`OperatorRegistered`] event."]
        pub fn OperatorRegistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorRegistered, N> {
            self.event_filter::<OperatorRegistered>()
        }
        #[doc = "Creates a new event filter for the [`OperatorSetParamsUpdated`] event."]
        pub fn OperatorSetParamsUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorSetParamsUpdated, N> {
            self.event_filter::<OperatorSetParamsUpdated>()
        }
        #[doc = "Creates a new event filter for the [`OperatorSocketUpdate`] event."]
        pub fn OperatorSocketUpdate_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorSocketUpdate, N> {
            self.event_filter::<OperatorSocketUpdate>()
        }
        #[doc = "Creates a new event filter for the [`OwnershipTransferred`] event."]
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        #[doc = "Creates a new event filter for the [`Paused`] event."]
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        #[doc = "Creates a new event filter for the [`PauserRegistrySet`] event."]
        pub fn PauserRegistrySet_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, PauserRegistrySet, N> {
            self.event_filter::<PauserRegistrySet>()
        }
        #[doc = "Creates a new event filter for the [`QuorumBlockNumberUpdated`] event."]
        pub fn QuorumBlockNumberUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, QuorumBlockNumberUpdated, N> {
            self.event_filter::<QuorumBlockNumberUpdated>()
        }
        #[doc = "Creates a new event filter for the [`Unpaused`] event."]
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
    }
}
