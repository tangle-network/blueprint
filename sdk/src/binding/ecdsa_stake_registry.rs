#![allow(clippy::all, warnings)]

#[doc = "\n\nGenerated by the following Solidity interface...\n```solidity\ninterface ECDSAStakeRegistry {\n    struct Quorum {\n        StrategyParams[] strategies;\n    }\n    struct SignatureWithSaltAndExpiry {\n        bytes signature;\n        bytes32 salt;\n        uint256 expiry;\n    }\n    struct StrategyParams {\n        address strategy;\n        uint96 multiplier;\n    }\n\n    error InsufficientSignedStake();\n    error InsufficientWeight();\n    error InvalidLength();\n    error InvalidQuorum();\n    error InvalidReferenceBlock();\n    error InvalidSignature();\n    error InvalidSignedWeight();\n    error InvalidThreshold();\n    error LengthMismatch();\n    error MustUpdateAllOperators();\n    error NotSorted();\n    error OperatorAlreadyRegistered();\n    error OperatorNotRegistered();\n\n    event Initialized(uint8 version);\n    event MinimumWeightUpdated(uint256 _old, uint256 _new);\n    event OperatorDeregistered(address indexed _operator, address indexed _avs);\n    event OperatorRegistered(address indexed _operator, address indexed _avs);\n    event OperatorWeightUpdated(address indexed _operator, uint256 oldWeight, uint256 newWeight);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event QuorumUpdated(Quorum _old, Quorum _new);\n    event SigningKeyUpdate(address indexed operator, uint256 indexed updateBlock, address indexed newSigningKey, address oldSigningKey);\n    event ThresholdWeightUpdated(uint256 _thresholdWeight);\n    event TotalWeightUpdated(uint256 oldTotalWeight, uint256 newTotalWeight);\n    event UpdateMinimumWeight(uint256 oldMinimumWeight, uint256 newMinimumWeight);\n\n    constructor(address _delegationManager);\n\n    function deregisterOperator() external;\n    function getLastCheckpointOperatorWeight(address _operator) external view returns (uint256);\n    function getLastCheckpointThresholdWeight() external view returns (uint256);\n    function getLastCheckpointThresholdWeightAtBlock(uint32 _blockNumber) external view returns (uint256);\n    function getLastCheckpointTotalWeight() external view returns (uint256);\n    function getLastCheckpointTotalWeightAtBlock(uint32 _blockNumber) external view returns (uint256);\n    function getLastestOperatorSigningKey(address _operator) external view returns (address);\n    function getOperatorSigningKeyAtBlock(address _operator, uint256 _blockNumber) external view returns (address);\n    function getOperatorWeight(address _operator) external view returns (uint256);\n    function getOperatorWeightAtBlock(address _operator, uint32 _blockNumber) external view returns (uint256);\n    function initialize(address _serviceManager, uint256 _thresholdWeight, Quorum memory _quorum) external;\n    function isValidSignature(bytes32 _dataHash, bytes memory _signatureData) external view returns (bytes4);\n    function minimumWeight() external view returns (uint256);\n    function operatorRegistered(address _operator) external view returns (bool);\n    function owner() external view returns (address);\n    function quorum() external view returns (Quorum memory);\n    function registerOperatorWithSignature(SignatureWithSaltAndExpiry memory _operatorSignature, address _signingKey) external;\n    function renounceOwnership() external;\n    function transferOwnership(address newOwner) external;\n    function updateMinimumWeight(uint256 _newMinimumWeight, address[] memory _operators) external;\n    function updateOperatorSigningKey(address _newSigningKey) external;\n    function updateOperators(address[] memory _operators) external;\n    function updateOperatorsForQuorum(address[][] memory operatorsPerQuorum, bytes memory) external;\n    function updateQuorumConfig(Quorum memory _quorum, address[] memory _operators) external;\n    function updateStakeThreshold(uint256 _thresholdWeight) external;\n}\n```\n\n...which was generated by the following JSON ABI:\n```json\n[\n  {\n    \"type\": \"constructor\",\n    \"inputs\": [\n      {\n        \"name\": \"_delegationManager\",\n        \"type\": \"address\",\n        \"internalType\": \"contract IDelegationManager\"\n      }\n    ],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"deregisterOperator\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointOperatorWeight\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointThresholdWeight\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointThresholdWeightAtBlock\",\n    \"inputs\": [\n      {\n        \"name\": \"_blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointTotalWeight\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastCheckpointTotalWeightAtBlock\",\n    \"inputs\": [\n      {\n        \"name\": \"_blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getLastestOperatorSigningKey\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorSigningKeyAtBlock\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_blockNumber\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorWeight\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"getOperatorWeightAtBlock\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_blockNumber\",\n        \"type\": \"uint32\",\n        \"internalType\": \"uint32\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"initialize\",\n    \"inputs\": [\n      {\n        \"name\": \"_serviceManager\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_thresholdWeight\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"_quorum\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"isValidSignature\",\n    \"inputs\": [\n      {\n        \"name\": \"_dataHash\",\n        \"type\": \"bytes32\",\n        \"internalType\": \"bytes32\"\n      },\n      {\n        \"name\": \"_signatureData\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes4\",\n        \"internalType\": \"bytes4\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"minimumWeight\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"operatorRegistered\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bool\",\n        \"internalType\": \"bool\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"owner\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"quorum\",\n    \"inputs\": [],\n    \"outputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"stateMutability\": \"view\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"registerOperatorWithSignature\",\n    \"inputs\": [\n      {\n        \"name\": \"_operatorSignature\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct ISignatureUtils.SignatureWithSaltAndExpiry\",\n        \"components\": [\n          {\n            \"name\": \"signature\",\n            \"type\": \"bytes\",\n            \"internalType\": \"bytes\"\n          },\n          {\n            \"name\": \"salt\",\n            \"type\": \"bytes32\",\n            \"internalType\": \"bytes32\"\n          },\n          {\n            \"name\": \"expiry\",\n            \"type\": \"uint256\",\n            \"internalType\": \"uint256\"\n          }\n        ]\n      },\n      {\n        \"name\": \"_signingKey\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"renounceOwnership\",\n    \"inputs\": [],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"transferOwnership\",\n    \"inputs\": [\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateMinimumWeight\",\n    \"inputs\": [\n      {\n        \"name\": \"_newMinimumWeight\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"_operators\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperatorSigningKey\",\n    \"inputs\": [\n      {\n        \"name\": \"_newSigningKey\",\n        \"type\": \"address\",\n        \"internalType\": \"address\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperators\",\n    \"inputs\": [\n      {\n        \"name\": \"_operators\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateOperatorsForQuorum\",\n    \"inputs\": [\n      {\n        \"name\": \"operatorsPerQuorum\",\n        \"type\": \"address[][]\",\n        \"internalType\": \"address[][]\"\n      },\n      {\n        \"name\": \"\",\n        \"type\": \"bytes\",\n        \"internalType\": \"bytes\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateQuorumConfig\",\n    \"inputs\": [\n      {\n        \"name\": \"_quorum\",\n        \"type\": \"tuple\",\n        \"internalType\": \"struct Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"name\": \"_operators\",\n        \"type\": \"address[]\",\n        \"internalType\": \"address[]\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"function\",\n    \"name\": \"updateStakeThreshold\",\n    \"inputs\": [\n      {\n        \"name\": \"_thresholdWeight\",\n        \"type\": \"uint256\",\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"outputs\": [],\n    \"stateMutability\": \"nonpayable\"\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"Initialized\",\n    \"inputs\": [\n      {\n        \"name\": \"version\",\n        \"type\": \"uint8\",\n        \"indexed\": false,\n        \"internalType\": \"uint8\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"MinimumWeightUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"_old\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"_new\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorDeregistered\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_avs\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorRegistered\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"_avs\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OperatorWeightUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"_operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"oldWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"newWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"OwnershipTransferred\",\n    \"inputs\": [\n      {\n        \"name\": \"previousOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"newOwner\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"QuorumUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"_old\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      },\n      {\n        \"name\": \"_new\",\n        \"type\": \"tuple\",\n        \"indexed\": false,\n        \"internalType\": \"struct Quorum\",\n        \"components\": [\n          {\n            \"name\": \"strategies\",\n            \"type\": \"tuple[]\",\n            \"internalType\": \"struct StrategyParams[]\",\n            \"components\": [\n              {\n                \"name\": \"strategy\",\n                \"type\": \"address\",\n                \"internalType\": \"contract IStrategy\"\n              },\n              {\n                \"name\": \"multiplier\",\n                \"type\": \"uint96\",\n                \"internalType\": \"uint96\"\n              }\n            ]\n          }\n        ]\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"SigningKeyUpdate\",\n    \"inputs\": [\n      {\n        \"name\": \"operator\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"updateBlock\",\n        \"type\": \"uint256\",\n        \"indexed\": true,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"newSigningKey\",\n        \"type\": \"address\",\n        \"indexed\": true,\n        \"internalType\": \"address\"\n      },\n      {\n        \"name\": \"oldSigningKey\",\n        \"type\": \"address\",\n        \"indexed\": false,\n        \"internalType\": \"address\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"ThresholdWeightUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"_thresholdWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"TotalWeightUpdated\",\n    \"inputs\": [\n      {\n        \"name\": \"oldTotalWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"newTotalWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"event\",\n    \"name\": \"UpdateMinimumWeight\",\n    \"inputs\": [\n      {\n        \"name\": \"oldMinimumWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      },\n      {\n        \"name\": \"newMinimumWeight\",\n        \"type\": \"uint256\",\n        \"indexed\": false,\n        \"internalType\": \"uint256\"\n      }\n    ],\n    \"anonymous\": false\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InsufficientSignedStake\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InsufficientWeight\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidLength\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidQuorum\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidReferenceBlock\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidSignature\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidSignedWeight\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"InvalidThreshold\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"LengthMismatch\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"MustUpdateAllOperators\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"NotSorted\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorAlreadyRegistered\",\n    \"inputs\": []\n  },\n  {\n    \"type\": \"error\",\n    \"name\": \"OperatorNotRegistered\",\n    \"inputs\": []\n  }\n]\n```"]
#[allow(missing_docs, clippy::too_many_arguments)]
#[allow(non_camel_case_types, non_snake_case, clippy::style)]
pub mod ECDSAStakeRegistry {
    use super::*;
    use ::alloy_sol_types;
    #[doc = r" The creation / init bytecode of the contract."]
    #[doc = r""]
    #[doc = r" ```text"]
    #[doc = "0x60a03461006a57601f61262d38819003918201601f19168301916001600160401b0383118484101761006f5780849260209460405283398101031261006a57516001600160a01b038116810361006a576080526040516125a790816100868239608051816117720152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe6040608081526004908136101561001557600080fd5b600091823560e01c8062cf2ab514610f125780630dba339414610ee65780631626ba7e14610bdd5780631703a01814610b275780631e4cd85e14610afb578063314f3a4914610ade5780633b242e4a14610aa55780633d5611f61461090457806340bf2fb7146108e55780635140a548146107ea5780635e1042e8146107ad5780635ef5332914610788578063696255be14610710578063715018a6146106b2578063743c31f41461066b578063857dc1901461055f5780638da5cb5b14610536578063955f2d90146104e957806398ec1ac9146104bc578063ab11899514610323578063b933fa74146102b1578063cdcd35811461026e578063dec5d1f614610209578063ec7fbb31146101c75763f2fde38b1461013357600080fd5b346101c35760203660031901126101c35761014c610fdc565b91610155611203565b6001600160a01b03831615610171578361016e8461125b565b80f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152fd5b8280fd5b5050346102055760203660031901126102055760209160ff9082906001600160a01b036101f2610fdc565b168152606e855220541690519015158152f35b5080fd5b5090346101c357366003190112610205576001600160401b0390803582811161026a576102399036908301611135565b9060243592831161026a576102576102659161016e94369101610ff2565b91610260611203565b611ce5565b611965565b8380fd5b505034610205576020366003190112610205576020916001600160a01b03906102a99083908361029c610fdc565b168152606a865220611431565b169051908152f35b50913461032057806003193601126103205750606c5491600090836102ea575050602091506000905b516001600160e01b039091168152f35b600019840193841161030d575050610303602092611346565b5054821c906102da565b634e487b7160e01b825260119052602490fd5b80fd5b50346101c35760603660031901126101c35761033d610fdc565b6044356001600160401b0381116104b85761035b9036908401611135565b90845460ff8160081c1615938480956104ab575b8015610494575b1561043a575060ff19811660011786556103c992919084610429575b506103a360ff875460081c166118e9565b60018060a01b03166001600160601b0360a01b60685416176068556102606024356119ba565b6103e260ff845460081c166103dd816118e9565b6118e9565b6103eb3361125b565b6103f3575080f35b60207f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989161ff001984541684555160018152a180f35b61ffff191661010117865538610392565b608490602087519162461bcd60e51b8352820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152fd5b50303b1580156103765750600160ff831614610376565b50600160ff83161061036f565b8480fd5b505034610205576020366003190112610205576020906104e26104dd610fdc565b6116a7565b9051908152f35b505034610205578060031936011261020557610503610fdc565b9160243563ffffffff811680910361053157826104e29260209560018060a01b03168152606d8652206115fa565b600080fd5b50503461020557816003193601126102055760335490516001600160a01b039091168152602090f35b50346101c357826003193601126101c357338352606e60205260ff82842054161561065d57606554801561064a5790839160001901606555338252606e60205282822060ff1981541690556105bb6105b633611f0f565b612144565b50506068546001600160a01b039390841691823b1561026a57839260248492845195869384926351b27a6d60e11b845233908401525af1908115610641575061062d575b505060685416337f31e0adfec71bccee37b6e83a90c2fedb17d8f1693fee863c4771e7bfe2aed5808380a380f35b61063690610f76565b6102055781386105ff565b513d84823e3d90fd5b634e487b7160e01b845260118252602484fd5b90516325ec6c1f60e01b8152fd5b50346101c35760203660031901126101c357610685610fdc565b91338452606e60205260ff8185205416156106a5578361016e8433611e7c565b516325ec6c1f60e01b8152fd5b83346103205780600319360112610320576106cb611203565b603380546001600160a01b031981169091556000906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b50346101c357816003193601126101c357803590602435926001600160401b0384116104b8576107677f713ca53b88d6eb63f5b1854cb8cbdd736ec51eda225e46791aa9298b0160648f9261016e95369101610ff2565b92610770611203565b606754908060675582519182526020820152a1611965565b8382346102055760203660031901126102055761016e906107a7611203565b356119ba565b5050346102055780600319360112610205576020916001600160a01b03906102a990826107d8610fdc565b168152606a85528360243591206115fa565b50346101c357816003193601126101c35780356001600160401b038082116104b857366023830112156104b857818301359061082582610fc5565b9061083286519283610fa4565b828252602080830194856024809660051b830101913683116108e157868101915b8383106108b757505050505082359081116108b357610875903690860161108e565b5051156108a057505191825160655403610893578361016e84611965565b5163169efb5b60e11b8152fd5b634e487b7160e01b600090815260328452fd5b8680fd5b82358681116108dd5785916108d283928b3691870101610ff2565b815201920191610853565b8c80fd5b8a80fd5b5050346102055781600319360112610205576020906067549051908152f35b50919034610205576003199080823601126101c3578335916001600160401b03908184116104b857606090843603011261026a578151906060820182811082821117610a92578352838601359081116104b8576109669086369186010161108e565b8152602081019060248401358252604483820194013584526024359560018060a01b039687811681036108b357338752606e60205260ff8588205416610a83576109e2906109b5606554611684565b606555338852606e602052858820600160ff198254161790556109da6105b633611f0f565b505033611e7c565b866068541692833b156108b3579186809492610a2894875198899687958694639926ee7d60e01b865233908601528a6024860152516060604486015260a4850190611e57565b9151606484015251608483015203925af19081156106415750610a74575b509060685416337fa453db612af59e5521d6ab9284dc3e2d06af286eb1b1b7b771fce4716c19f2c18380a380f35b610a7d90610f76565b38610a46565b5083516342ee68b560e01b8152fd5b634e487b7160e01b865260418752602486fd5b505034610205576020366003190112610205576020916104e29082906001600160a01b03610ad1610fdc565b168152606d855220611431565b5050346102055781600319360112610205576020906104e26113e2565b505034610205576020366003190112610205576020906104e263ffffffff610b21611060565b1661155d565b82843461032057806003193601126103205760608251610b4681610f45565b52815191610b5383610f45565b606654610b5f81610fc5565b90610b6c83519283610fa4565b80825260668452602093600080516020612552833981519152858085015b848410610baa57858952865182815280610ba68185018c6110d5565b0390f35b60019182918851610bba81610f89565b8554848060a01b038116825260a01c838201528152019201920191908690610b8a565b50346101c357816003193601126101c3576001600160401b039260243584811161020557610c0e903690840161108e565b938451850160209560608188840193031261026a57868101518381116104b85781019180603f840112156104b8578783015192610c4a84610fc5565b93610c5789519586610fa4565b808552888a86019160051b83010191838311610ee2578901905b828210610ec35750505086820151848111610ebf5782019080603f83011215610ebf578882015190610ca282610fc5565b95610caf8a519788610fa4565b828752898b88019360051b85010193828511610ebb578a8101935b858510610e5a57505050505050606001519163ffffffff831680930361026a5781519380819583518103610e47578015610e37579190819343871015958935925b858710610d765750505050505050610d6657610d2681611492565b8211610d5657610d359061155d565b11610d48575051630b135d3f60e11b8152f35b905163e121632f60e01b8152fd5b8351634b05a0f760e11b81528390fd5b835163e64f180f60e01b81528390fd5b60018060a09b9394959697989b1b0380610d908c86611693565b511698610e27578089918f8f8d90606a610daf93878e52528b206115fa565b1692161015610e1757610dce9085610dc78c87611693565b519161230c565b15610e075790610dff610df98d959493610df38b8f606d8d9a8c9e8d52528a206115fa565b9061146f565b99611684565b959493610d0b565b8a51638baa579f60e01b81528a90fd5b8b5163ba50f91160e01b81528b90fd5b8c5163e64f180f60e01b81528c90fd5b885163251f56a160e21b81528890fd5b88516001621398b960e31b031981528890fd5b84518381116108e157820184605f820112156108e1578c8101518d91610e8b610e8283611073565b93519384610fa4565b81835286606083830101116108dd57918f9391610eb0908594606086850191016112a4565b815201940193610cca565b8880fd5b8580fd5b81516001600160a01b0381168103610ebb578152908a01908a01610c71565b8780fd5b505034610205576020366003190112610205576020906104e263ffffffff610f0c611060565b16611492565b8382346102055760203660031901126102055780356001600160401b0381116101c35761016e9161026591369101610ff2565b602081019081106001600160401b03821117610f6057604052565b634e487b7160e01b600052604160045260246000fd5b6001600160401b038111610f6057604052565b604081019081106001600160401b03821117610f6057604052565b90601f801991011681019081106001600160401b03821117610f6057604052565b6001600160401b038111610f605760051b60200190565b600435906001600160a01b038216820361053157565b81601f820112156105315780359161100983610fc5565b926110176040519485610fa4565b808452602092838086019260051b820101928311610531578301905b828210611041575050505090565b81356001600160a01b0381168103610531578152908301908301611033565b6004359063ffffffff8216820361053157565b6001600160401b038111610f6057601f01601f191660200190565b81601f82011215610531578035906110a582611073565b926110b36040519485610fa4565b8284526020838301011161053157816000926020809301838601378301015290565b9060209182820190519280835283518092528060408094019401926000905b83821061110357505050505090565b845180516001600160a01b031687528301516001600160601b03168684015294850194938201936001909101906110f4565b91906020808483031261053157604080519161115083610f45565b82958035906001600160401b03821161053157019084601f8301121561053157813561117b81610fc5565b9561118885519788610fa4565b818752828088019260061b85010193818511610531578301915b8483106111b25750505050505052565b8583830312610531578551906111c782610f89565b83356001600160a01b038116810361053157825284840135906001600160601b038216820361053157828692838a9501528152019201916111a2565b6033546001600160a01b0316330361121757565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b603380546001600160a01b039283166001600160a01b0319821681179092559091167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b60005b8381106112b75750506000910152565b81810151838201526020016112a7565b606654906112d482610fc5565b9160406112e381519485610fa4565b818452836020809101916066600052600080516020612552833981519152906000935b85851061131557505050505050565b6001848192845161132581610f89565b8654848060a01b038116825260a01c83820152815201930194019391611306565b606c5481101561137d57606c6000527f2b4a51ab505fc96a0952efda2ba61bcd3078d4c02c39a186ec16f21883fbe0160190600090565b634e487b7160e01b600052603260045260246000fd5b606b5481101561137d57606b6000527fbd43cb8ece8cd1863bcd6082d65c5b0d25665b1ce17980f0da43c0ed545f98b40190600090565b805482101561137d5760005260206000200190600090565b606b546000816113fd57505060005b6001600160e01b031690565b600019820191821161141d575061141390611393565b505460201c6113f1565b634e487b7160e01b81526011600452602490fd5b8054600092918161144457506000925050565b600019820191821161145b576114139293506113ca565b634e487b7160e01b84526011600452602484fd5b9190820180921161147c57565b634e487b7160e01b600052601160045260246000fd5b4381101561151957606b54906000905b8282106114be575050600081156000146113fd57506000919050565b90916001906114d3818518831c82861661146f565b918363ffffffff6114e385611393565b50541611156114f6575050915b906114a2565b9093508101809111156114f057634e487b7160e01b600052601160045260246000fd5b606460405162461bcd60e51b815260206004820152602060248201527f436865636b706f696e74733a20626c6f636b206e6f7420796574206d696e65646044820152fd5b4381101561151957606c54906000905b82821061159f5750506000811560001461158957506000919050565b600019820191821161141d575061141390611346565b90916001906115b4818518831c82861661146f565b918363ffffffff6115c485611346565b50541611156115d7575050915b9061156d565b9093508101809111156115d157634e487b7160e01b600052601160045260246000fd5b919043811015611519578254906000905b828210611628575050600092811560001461144457506000925050565b909160019061163d818518831c82861661146f565b918363ffffffff61164e858a6113ca565b5054161115611661575050915b9061160b565b90935081018091111561165b57634e487b7160e01b600052601160045260246000fd5b600019811461147c5760010190565b805182101561137d5760209160051b010190565b6116af6112c7565b8051909260006116d76116c184610fc5565b936116cf6040519586610fa4565b808552610fc5565b60208481019591601f1901368737825b875181101561171e57611719906001600160a01b03611706828b611693565b5151166117138289611693565b52611684565b6116e7565b509091939294846040518092639004134760e01b8252604482019060018060a01b039182600498168885015260249860408a86015251809152606484019190855b888282106118cd575050505082809103917f0000000000000000000000000000000000000000000000000000000000000000165afa9081156118c2578591611832575b50845b875186101561180f576117b88683611693565b51906001600160601b03846117cd898c611693565b51015116918281029281840414901517156117fb576117f5916117ef9161146f565b95611684565b946117a5565b85601186634e487b7160e01b600052526000fd5b9450505050506127109192500460675481101560001461182c5790565b50600090565b90503d8086833e6118438183610fa4565b8101908281830312610ebf578051906001600160401b0382116108b357019080601f83011215610ebf57815161187881610fc5565b926118866040519485610fa4565b818452848085019260051b820101928311610ee25784809101915b8383106118b25750505050386117a2565b82518152918101918591016118a1565b6040513d87823e3d90fd5b8351861685528c9750889650938401939092019160010161175f565b156118f057565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b9190916000838201938412911290801582169115161761147c57565b906000805b83518210156119a9576119a39061199d906119976001600160a01b036119908689611693565b5116611f0f565b90611949565b91611684565b9061196a565b90506119b6919250612144565b5050565b606c549081151580611b73575b80611b4e575b15611a39576119db81611c7c565b90600019830192831161147c57611a30602092611a187f9324f7e5a7c0288808a634ccde44b8e979676474b22e29ee9dd569b55e791a4b95611346565b509063ffffffff82549181199060201b169116179055565b604051908152a1565b63ffffffff90814311611afa57611a4f81611c7c565b60405190611a5c82610f89565b43841682526001600160e01b039081166020830190815294600160401b811015610f6057806001611a909201606c55611346565b919091611ae4579151945163ffffffff95909416949094169216602090811b63ffffffff1916929092179092557f9324f7e5a7c0288808a634ccde44b8e979676474b22e29ee9dd569b55e791a4b91611a30565b634e487b7160e01b600052600060045260246000fd5b60405162461bcd60e51b815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203360448201526532206269747360d01b6064820152608490fd5b50600019820182811161147c57611b6963ffffffff91611346565b50541643146119cd565b600019830183811161147c57611b8890611346565b50506119c7565b9190918054611b9d82611431565b9181151580611c56575b15611bd357611bb585611c7c565b90600019830192831161147c57611bcf92611a18916113ca565b9190565b9063ffffffff90814311611afa57611bea86611c7c565b9060405193611bf885610f89565b43841685526001600160e01b039283166020860190815291600160401b811015610f6057611c2b916001820181556113ca565b939093611ae4579351905163ffffffff9190941616921660201b63ffffffff19169190911790559190565b50600019820182811161147c57611c7263ffffffff91836113ca565b5054164314611ba7565b6001600160e01b0390818111611c90571690565b60405162461bcd60e51b815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e20326044820152663234206269747360c81b6064820152608490fd5b611cee81612284565b15611e455760405190611d0082610f45565b611d086112c7565b825260669081549360009485845580611e16575b50845b82518051821015611dc05781611d3491611693565b51845490600160401b821015611dac5760018201808755821015611d9857858852805160209091015160a01b6001600160a01b0319166001600160a01b03919091161760008051602061255283398151915290910155611d9390611684565b611d1f565b634e487b7160e01b88526032600452602488fd5b634e487b7160e01b88526041600452602488fd5b50509350611e03915091611e117f23aad4e61744ece164130aa415c1616e80136b0f0770e56589438b90b269265e936040519384936040855260408501906110d5565b9083820360208501526110d5565b0390a1565b838652600080516020612552833981519152908101905b818110611e3a5750611d1c565b868155600101611e2d565b60405163d173577960e01b8152600490fd5b90602091611e70815180928185528580860191016112a4565b601f01601f1916010190565b9060018060a01b038092169182600052606a60205280611e9f6040600020611431565b16911691818314611ef15780600052606a602052611ec1836040600020611b8f565b50506040519182527fd061168252f441733658f09e4d8f5b2d998ed4ef24a2bbfd6ceca52ea131500260204393a4565b505050565b8181039291600013801582851316918412161761147c57565b6000809160018060a01b03811691828152602091606d8352604091611f35838220611431565b91858252606e855260ff8483205416156000146120e7575081611f5791611ef6565b9485156120df5784600052606d84528260002093845494611f7781611431565b50851515806120b9575b15611fd557600019860195861161147c577f88770dc862e47a7ed586907857eb1b75e4c5ffc8b707c7ee10eb74d6885fe59495611fbd916113ca565b5063ffffffff81541690555b8351928352820152a290565b63ffffffff9586431161206657855191611fee83610f89565b87431683528383019160008352600160401b811015610f6057612016916001820181556113ca565b919091611ae4579151915163ffffffff1960209190911b169690911663ffffffff16959095179094557f88770dc862e47a7ed586907857eb1b75e4c5ffc8b707c7ee10eb74d6885fe59493611fc9565b855162461bcd60e51b815260048101849052602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203360448201526532206269747360d01b6064820152608490fd5b50600019860186811161147c576120d563ffffffff91836113ca565b5054164314611f81565b505050505090565b90506120f49195506116a7565b936120ff8186611ef6565b9485156120df577f88770dc862e47a7ed586907857eb1b75e4c5ffc8b707c7ee10eb74d6885fe5949385600052606d815261213d8285600020611b8f565b5050611fc9565b906121576121506113e2565b9283611949565b90606b5480151580612268575b80612243575b156121c15761217883611c7c565b600019820191821161147c57611a1861219092611393565b7f86dcf86b12dfeedea74ae9300dbdaa193bcce5809369c8177ea2f4eaaa65729b60408051858152846020820152a1565b63ffffffff804311611afa576121d684611c7c565b604051926121e384610f89565b43831684526001600160e01b039182166020850190815290600160401b811015610f60578060016122179201606b55611393565b939093611ae4579351905163ffffffff9190941616921660201b63ffffffff1916919091179055612190565b50600019810181811161147c5761225e63ffffffff91611393565b505416431461216a565b600019820182811161147c5761227d90611393565b5050612164565b5190600080805b84518210156122f4576001600160a01b0390816122a88488611693565b5151169182911610156122e25761199d6122db91936001600160601b0360206122d1868a611693565b510151169061146f565b909161228b565b60405163ba50f91160e01b8152600490fd5b5091925061271014905061230757600090565b600190565b91612317818361242c565b600581101561241657159081612400575b506123f85760405161236c8161235e6020820194630b135d3f60e11b968787526024840152604060448401526064830190611e57565b03601f198101835282610fa4565b6000938492839251915afa913d156123f1573d61238881611073565b906123966040519283610fa4565b81523d82602083013e5b836123e5575b836123b2575b50505090565b9091925060208180518101031261020557602001516001600160e01b0319811691908290036103205750143880806123ac565b805160201493506123a6565b60606123a0565b505050600190565b6001600160a01b03858116911614905038612328565b634e487b7160e01b600052602160045260246000fd5b815160418103612459575090612455916020820151906060604084015193015160001a9061249c565b9091565b6040036124925760406020830151920151918260ff1c91601b830180931161147c57612455936001600160ff1b03169260ff169061249c565b5050600090600290565b9291907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083116125455760ff16601b8114158061253a575b61252e579160809493916020936040519384528484015260408301526060820152600093849182805260015afa156125215781516001600160a01b0381161561251b579190565b50600190565b50604051903d90823e3d90fd5b50505050600090600490565b50601c8114156124d4565b5050505060009060039056fe46501879b8ca8525e8c2fd519e2fbfcfa2ebea26501294aa02cbfcfb12e94354a264697066735822122094469d769ca0fc9272b48d5aa8be89698a211bb91dbc2c5eca9e2fbf1d61181b64736f6c63430008140033"]
    #[doc = r" ```"]
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(b"`\xa04a\0jW`\x1fa&-8\x81\x90\x03\x91\x82\x01`\x1f\x19\x16\x83\x01\x91`\x01`\x01`@\x1b\x03\x83\x11\x84\x84\x10\x17a\0oW\x80\x84\x92` \x94`@R\x839\x81\x01\x03\x12a\0jWQ`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x03a\0jW`\x80R`@Qa%\xa7\x90\x81a\0\x86\x829`\x80Q\x81a\x17r\x01R\xf3[`\0\x80\xfd[cNH{q`\xe0\x1b`\0R`A`\x04R`$`\0\xfd\xfe`@`\x80\x81R`\x04\x90\x816\x10\x15a\0\x15W`\0\x80\xfd[`\0\x91\x825`\xe0\x1c\x80b\xcf*\xb5\x14a\x0f\x12W\x80c\r\xba3\x94\x14a\x0e\xe6W\x80c\x16&\xba~\x14a\x0b\xddW\x80c\x17\x03\xa0\x18\x14a\x0b'W\x80c\x1eL\xd8^\x14a\n\xfbW\x80c1O:I\x14a\n\xdeW\x80c;$.J\x14a\n\xa5W\x80c=V\x11\xf6\x14a\t\x04W\x80c@\xbf/\xb7\x14a\x08\xe5W\x80cQ@\xa5H\x14a\x07\xeaW\x80c^\x10B\xe8\x14a\x07\xadW\x80c^\xf53)\x14a\x07\x88W\x80cibU\xbe\x14a\x07\x10W\x80cqP\x18\xa6\x14a\x06\xb2W\x80ct<1\xf4\x14a\x06kW\x80c\x85}\xc1\x90\x14a\x05_W\x80c\x8d\xa5\xcb[\x14a\x056W\x80c\x95_-\x90\x14a\x04\xe9W\x80c\x98\xec\x1a\xc9\x14a\x04\xbcW\x80c\xab\x11\x89\x95\x14a\x03#W\x80c\xb93\xfat\x14a\x02\xb1W\x80c\xcd\xcd5\x81\x14a\x02nW\x80c\xde\xc5\xd1\xf6\x14a\x02\tW\x80c\xec\x7f\xbb1\x14a\x01\xc7Wc\xf2\xfd\xe3\x8b\x14a\x013W`\0\x80\xfd[4a\x01\xc3W` 6`\x03\x19\x01\x12a\x01\xc3Wa\x01La\x0f\xdcV[\x91a\x01Ua\x12\x03V[`\x01`\x01`\xa0\x1b\x03\x83\x16\x15a\x01qW\x83a\x01n\x84a\x12[V[\x80\xf3[\x90` `\x84\x92Q\x91bF\x1b\xcd`\xe5\x1b\x83R\x82\x01R`&`$\x82\x01R\x7fOwnable: new owner is the zero a`D\x82\x01Reddress`\xd0\x1b`d\x82\x01R\xfd[\x82\x80\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x91`\xff\x90\x82\x90`\x01`\x01`\xa0\x1b\x03a\x01\xf2a\x0f\xdcV[\x16\x81R`n\x85R T\x16\x90Q\x90\x15\x15\x81R\xf3[P\x80\xfd[P\x904a\x01\xc3W6`\x03\x19\x01\x12a\x02\x05W`\x01`\x01`@\x1b\x03\x90\x805\x82\x81\x11a\x02jWa\x029\x906\x90\x83\x01a\x115V[\x90`$5\x92\x83\x11a\x02jWa\x02Wa\x02e\x91a\x01n\x946\x91\x01a\x0f\xf2V[\x91a\x02`a\x12\x03V[a\x1c\xe5V[a\x19eV[\x83\x80\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x91`\x01`\x01`\xa0\x1b\x03\x90a\x02\xa9\x90\x83\x90\x83a\x02\x9ca\x0f\xdcV[\x16\x81R`j\x86R a\x141V[\x16\x90Q\x90\x81R\xf3[P\x914a\x03 W\x80`\x03\x196\x01\x12a\x03 WP`lT\x91`\0\x90\x83a\x02\xeaWPP` \x91P`\0\x90[Q`\x01`\x01`\xe0\x1b\x03\x90\x91\x16\x81R\xf3[`\0\x19\x84\x01\x93\x84\x11a\x03\rWPPa\x03\x03` \x92a\x13FV[PT\x82\x1c\x90a\x02\xdaV[cNH{q`\xe0\x1b\x82R`\x11\x90R`$\x90\xfd[\x80\xfd[P4a\x01\xc3W``6`\x03\x19\x01\x12a\x01\xc3Wa\x03=a\x0f\xdcV[`D5`\x01`\x01`@\x1b\x03\x81\x11a\x04\xb8Wa\x03[\x906\x90\x84\x01a\x115V[\x90\x84T`\xff\x81`\x08\x1c\x16\x15\x93\x84\x80\x95a\x04\xabW[\x80\x15a\x04\x94W[\x15a\x04:WP`\xff\x19\x81\x16`\x01\x17\x86Ua\x03\xc9\x92\x91\x90\x84a\x04)W[Pa\x03\xa3`\xff\x87T`\x08\x1c\x16a\x18\xe9V[`\x01\x80`\xa0\x1b\x03\x16`\x01`\x01``\x1b\x03`\xa0\x1b`hT\x16\x17`hUa\x02``$5a\x19\xbaV[a\x03\xe2`\xff\x84T`\x08\x1c\x16a\x03\xdd\x81a\x18\xe9V[a\x18\xe9V[a\x03\xeb3a\x12[V[a\x03\xf3WP\x80\xf3[` \x7f\x7f&\xb8?\xf9n\x1f+jh/\x138R\xf6y\x8a\t\xc4e\xda\x95\x92\x14`\xce\xfb8G@$\x98\x91a\xff\0\x19\x84T\x16\x84UQ`\x01\x81R\xa1\x80\xf3[a\xff\xff\x19\x16a\x01\x01\x17\x86U8a\x03\x92V[`\x84\x90` \x87Q\x91bF\x1b\xcd`\xe5\x1b\x83R\x82\x01R`.`$\x82\x01R\x7fInitializable: contract is alrea`D\x82\x01Rm\x19\x1eH\x1a[\x9a]\x1aX[\x1a^\x99Y`\x92\x1b`d\x82\x01R\xfd[P0;\x15\x80\x15a\x03vWP`\x01`\xff\x83\x16\x14a\x03vV[P`\x01`\xff\x83\x16\x10a\x03oV[\x84\x80\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x90a\x04\xe2a\x04\xdda\x0f\xdcV[a\x16\xa7V[\x90Q\x90\x81R\xf3[PP4a\x02\x05W\x80`\x03\x196\x01\x12a\x02\x05Wa\x05\x03a\x0f\xdcV[\x91`$5c\xff\xff\xff\xff\x81\x16\x80\x91\x03a\x051W\x82a\x04\xe2\x92` \x95`\x01\x80`\xa0\x1b\x03\x16\x81R`m\x86R a\x15\xfaV[`\0\x80\xfd[PP4a\x02\x05W\x81`\x03\x196\x01\x12a\x02\x05W`3T\x90Q`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x81R` \x90\xf3[P4a\x01\xc3W\x82`\x03\x196\x01\x12a\x01\xc3W3\x83R`n` R`\xff\x82\x84 T\x16\x15a\x06]W`eT\x80\x15a\x06JW\x90\x83\x91`\0\x19\x01`eU3\x82R`n` R\x82\x82 `\xff\x19\x81T\x16\x90Ua\x05\xbba\x05\xb63a\x1f\x0fV[a!DV[PP`hT`\x01`\x01`\xa0\x1b\x03\x93\x90\x84\x16\x91\x82;\x15a\x02jW\x83\x92`$\x84\x92\x84Q\x95\x86\x93\x84\x92cQ\xb2zm`\xe1\x1b\x84R3\x90\x84\x01RZ\xf1\x90\x81\x15a\x06AWPa\x06-W[PP`hT\x163\x7f1\xe0\xad\xfe\xc7\x1b\xcc\xee7\xb6\xe8:\x90\xc2\xfe\xdb\x17\xd8\xf1i?\xee\x86<Gq\xe7\xbf\xe2\xae\xd5\x80\x83\x80\xa3\x80\xf3[a\x066\x90a\x0fvV[a\x02\x05W\x818a\x05\xffV[Q=\x84\x82>=\x90\xfd[cNH{q`\xe0\x1b\x84R`\x11\x82R`$\x84\xfd[\x90Qc%\xecl\x1f`\xe0\x1b\x81R\xfd[P4a\x01\xc3W` 6`\x03\x19\x01\x12a\x01\xc3Wa\x06\x85a\x0f\xdcV[\x913\x84R`n` R`\xff\x81\x85 T\x16\x15a\x06\xa5W\x83a\x01n\x843a\x1e|V[Qc%\xecl\x1f`\xe0\x1b\x81R\xfd[\x834a\x03 W\x80`\x03\x196\x01\x12a\x03 Wa\x06\xcba\x12\x03V[`3\x80T`\x01`\x01`\xa0\x1b\x03\x19\x81\x16\x90\x91U`\0\x90`\x01`\x01`\xa0\x1b\x03\x16\x7f\x8b\xe0\x07\x9cS\x16Y\x14\x13D\xcd\x1f\xd0\xa4\xf2\x84\x19I\x7f\x97\"\xa3\xda\xaf\xe3\xb4\x18okdW\xe0\x82\x80\xa3\x80\xf3[P4a\x01\xc3W\x81`\x03\x196\x01\x12a\x01\xc3W\x805\x90`$5\x92`\x01`\x01`@\x1b\x03\x84\x11a\x04\xb8Wa\x07g\x7fq<\xa5;\x88\xd6\xebc\xf5\xb1\x85L\xb8\xcb\xddsn\xc5\x1e\xda\"^Fy\x1a\xa9)\x8b\x01`d\x8f\x92a\x01n\x956\x91\x01a\x0f\xf2V[\x92a\x07pa\x12\x03V[`gT\x90\x80`gU\x82Q\x91\x82R` \x82\x01R\xa1a\x19eV[\x83\x824a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05Wa\x01n\x90a\x07\xa7a\x12\x03V[5a\x19\xbaV[PP4a\x02\x05W\x80`\x03\x196\x01\x12a\x02\x05W` \x91`\x01`\x01`\xa0\x1b\x03\x90a\x02\xa9\x90\x82a\x07\xd8a\x0f\xdcV[\x16\x81R`j\x85R\x83`$5\x91 a\x15\xfaV[P4a\x01\xc3W\x81`\x03\x196\x01\x12a\x01\xc3W\x805`\x01`\x01`@\x1b\x03\x80\x82\x11a\x04\xb8W6`#\x83\x01\x12\x15a\x04\xb8W\x81\x83\x015\x90a\x08%\x82a\x0f\xc5V[\x90a\x082\x86Q\x92\x83a\x0f\xa4V[\x82\x82R` \x80\x83\x01\x94\x85`$\x80\x96`\x05\x1b\x83\x01\x01\x916\x83\x11a\x08\xe1W\x86\x81\x01\x91[\x83\x83\x10a\x08\xb7WPPPPP\x825\x90\x81\x11a\x08\xb3Wa\x08u\x906\x90\x86\x01a\x10\x8eV[PQ\x15a\x08\xa0WPQ\x91\x82Q`eT\x03a\x08\x93W\x83a\x01n\x84a\x19eV[Qc\x16\x9e\xfb[`\xe1\x1b\x81R\xfd[cNH{q`\xe0\x1b`\0\x90\x81R`2\x84R\xfd[\x86\x80\xfd[\x825\x86\x81\x11a\x08\xddW\x85\x91a\x08\xd2\x83\x92\x8b6\x91\x87\x01\x01a\x0f\xf2V[\x81R\x01\x92\x01\x91a\x08SV[\x8c\x80\xfd[\x8a\x80\xfd[PP4a\x02\x05W\x81`\x03\x196\x01\x12a\x02\x05W` \x90`gT\x90Q\x90\x81R\xf3[P\x91\x904a\x02\x05W`\x03\x19\x90\x80\x826\x01\x12a\x01\xc3W\x835\x91`\x01`\x01`@\x1b\x03\x90\x81\x84\x11a\x04\xb8W``\x90\x846\x03\x01\x12a\x02jW\x81Q\x90``\x82\x01\x82\x81\x10\x82\x82\x11\x17a\n\x92W\x83R\x83\x86\x015\x90\x81\x11a\x04\xb8Wa\tf\x90\x866\x91\x86\x01\x01a\x10\x8eV[\x81R` \x81\x01\x90`$\x84\x015\x82R`D\x83\x82\x01\x94\x015\x84R`$5\x95`\x01\x80`\xa0\x1b\x03\x96\x87\x81\x16\x81\x03a\x08\xb3W3\x87R`n` R`\xff\x85\x88 T\x16a\n\x83Wa\t\xe2\x90a\t\xb5`eTa\x16\x84V[`eU3\x88R`n` R\x85\x88 `\x01`\xff\x19\x82T\x16\x17\x90Ua\t\xdaa\x05\xb63a\x1f\x0fV[PP3a\x1e|V[\x86`hT\x16\x92\x83;\x15a\x08\xb3W\x91\x86\x80\x94\x92a\n(\x94\x87Q\x98\x89\x96\x87\x95\x86\x94c\x99&\xee}`\xe0\x1b\x86R3\x90\x86\x01R\x8a`$\x86\x01RQ```D\x86\x01R`\xa4\x85\x01\x90a\x1eWV[\x91Q`d\x84\x01RQ`\x84\x83\x01R\x03\x92Z\xf1\x90\x81\x15a\x06AWPa\ntW[P\x90`hT\x163\x7f\xa4S\xdba*\xf5\x9eU!\xd6\xab\x92\x84\xdc>-\x06\xaf(n\xb1\xb1\xb7\xb7q\xfc\xe4ql\x19\xf2\xc1\x83\x80\xa3\x80\xf3[a\n}\x90a\x0fvV[8a\nFV[P\x83QcB\xeeh\xb5`\xe0\x1b\x81R\xfd[cNH{q`\xe0\x1b\x86R`A\x87R`$\x86\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x91a\x04\xe2\x90\x82\x90`\x01`\x01`\xa0\x1b\x03a\n\xd1a\x0f\xdcV[\x16\x81R`m\x85R a\x141V[PP4a\x02\x05W\x81`\x03\x196\x01\x12a\x02\x05W` \x90a\x04\xe2a\x13\xe2V[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x90a\x04\xe2c\xff\xff\xff\xffa\x0b!a\x10`V[\x16a\x15]V[\x82\x844a\x03 W\x80`\x03\x196\x01\x12a\x03 W``\x82Qa\x0bF\x81a\x0fEV[R\x81Q\x91a\x0bS\x83a\x0fEV[`fTa\x0b_\x81a\x0f\xc5V[\x90a\x0bl\x83Q\x92\x83a\x0f\xa4V[\x80\x82R`f\x84R` \x93`\0\x80Q` a%R\x839\x81Q\x91R\x85\x80\x85\x01[\x84\x84\x10a\x0b\xaaW\x85\x89R\x86Q\x82\x81R\x80a\x0b\xa6\x81\x85\x01\x8ca\x10\xd5V[\x03\x90\xf3[`\x01\x91\x82\x91\x88Qa\x0b\xba\x81a\x0f\x89V[\x85T\x84\x80`\xa0\x1b\x03\x81\x16\x82R`\xa0\x1c\x83\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90\x86\x90a\x0b\x8aV[P4a\x01\xc3W\x81`\x03\x196\x01\x12a\x01\xc3W`\x01`\x01`@\x1b\x03\x92`$5\x84\x81\x11a\x02\x05Wa\x0c\x0e\x906\x90\x84\x01a\x10\x8eV[\x93\x84Q\x85\x01` \x95``\x81\x88\x84\x01\x93\x03\x12a\x02jW\x86\x81\x01Q\x83\x81\x11a\x04\xb8W\x81\x01\x91\x80`?\x84\x01\x12\x15a\x04\xb8W\x87\x83\x01Q\x92a\x0cJ\x84a\x0f\xc5V[\x93a\x0cW\x89Q\x95\x86a\x0f\xa4V[\x80\x85R\x88\x8a\x86\x01\x91`\x05\x1b\x83\x01\x01\x91\x83\x83\x11a\x0e\xe2W\x89\x01\x90[\x82\x82\x10a\x0e\xc3WPPP\x86\x82\x01Q\x84\x81\x11a\x0e\xbfW\x82\x01\x90\x80`?\x83\x01\x12\x15a\x0e\xbfW\x88\x82\x01Q\x90a\x0c\xa2\x82a\x0f\xc5V[\x95a\x0c\xaf\x8aQ\x97\x88a\x0f\xa4V[\x82\x87R\x89\x8b\x88\x01\x93`\x05\x1b\x85\x01\x01\x93\x82\x85\x11a\x0e\xbbW\x8a\x81\x01\x93[\x85\x85\x10a\x0eZWPPPPPP``\x01Q\x91c\xff\xff\xff\xff\x83\x16\x80\x93\x03a\x02jW\x81Q\x93\x80\x81\x95\x83Q\x81\x03a\x0eGW\x80\x15a\x0e7W\x91\x90\x81\x93C\x87\x10\x15\x95\x895\x92[\x85\x87\x10a\rvWPPPPPPPa\rfWa\r&\x81a\x14\x92V[\x82\x11a\rVWa\r5\x90a\x15]V[\x11a\rHWPQc\x0b\x13]?`\xe1\x1b\x81R\xf3[\x90Qc\xe1!c/`\xe0\x1b\x81R\xfd[\x83QcK\x05\xa0\xf7`\xe1\x1b\x81R\x83\x90\xfd[\x83Qc\xe6O\x18\x0f`\xe0\x1b\x81R\x83\x90\xfd[`\x01\x80`\xa0\x9b\x93\x94\x95\x96\x97\x98\x9b\x1b\x03\x80a\r\x90\x8c\x86a\x16\x93V[Q\x16\x98a\x0e'W\x80\x89\x91\x8f\x8f\x8d\x90`ja\r\xaf\x93\x87\x8eRR\x8b a\x15\xfaV[\x16\x92\x16\x10\x15a\x0e\x17Wa\r\xce\x90\x85a\r\xc7\x8c\x87a\x16\x93V[Q\x91a#\x0cV[\x15a\x0e\x07W\x90a\r\xffa\r\xf9\x8d\x95\x94\x93a\r\xf3\x8b\x8f`m\x8d\x9a\x8c\x9e\x8dRR\x8a a\x15\xfaV[\x90a\x14oV[\x99a\x16\x84V[\x95\x94\x93a\r\x0bV[\x8aQc\x8b\xaaW\x9f`\xe0\x1b\x81R\x8a\x90\xfd[\x8bQc\xbaP\xf9\x11`\xe0\x1b\x81R\x8b\x90\xfd[\x8cQc\xe6O\x18\x0f`\xe0\x1b\x81R\x8c\x90\xfd[\x88Qc%\x1fV\xa1`\xe2\x1b\x81R\x88\x90\xfd[\x88Q`\x01b\x13\x98\xb9`\xe3\x1b\x03\x19\x81R\x88\x90\xfd[\x84Q\x83\x81\x11a\x08\xe1W\x82\x01\x84`_\x82\x01\x12\x15a\x08\xe1W\x8c\x81\x01Q\x8d\x91a\x0e\x8ba\x0e\x82\x83a\x10sV[\x93Q\x93\x84a\x0f\xa4V[\x81\x83R\x86``\x83\x83\x01\x01\x11a\x08\xddW\x91\x8f\x93\x91a\x0e\xb0\x90\x85\x94``\x86\x85\x01\x91\x01a\x12\xa4V[\x81R\x01\x94\x01\x93a\x0c\xcaV[\x88\x80\xfd[\x85\x80\xfd[\x81Q`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x03a\x0e\xbbW\x81R\x90\x8a\x01\x90\x8a\x01a\x0cqV[\x87\x80\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x90a\x04\xe2c\xff\xff\xff\xffa\x0f\x0ca\x10`V[\x16a\x14\x92V[\x83\x824a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W\x805`\x01`\x01`@\x1b\x03\x81\x11a\x01\xc3Wa\x01n\x91a\x02e\x916\x91\x01a\x0f\xf2V[` \x81\x01\x90\x81\x10`\x01`\x01`@\x1b\x03\x82\x11\x17a\x0f`W`@RV[cNH{q`\xe0\x1b`\0R`A`\x04R`$`\0\xfd[`\x01`\x01`@\x1b\x03\x81\x11a\x0f`W`@RV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1b\x03\x82\x11\x17a\x0f`W`@RV[\x90`\x1f\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1b\x03\x82\x11\x17a\x0f`W`@RV[`\x01`\x01`@\x1b\x03\x81\x11a\x0f`W`\x05\x1b` \x01\x90V[`\x045\x90`\x01`\x01`\xa0\x1b\x03\x82\x16\x82\x03a\x051WV[\x81`\x1f\x82\x01\x12\x15a\x051W\x805\x91a\x10\t\x83a\x0f\xc5V[\x92a\x10\x17`@Q\x94\x85a\x0f\xa4V[\x80\x84R` \x92\x83\x80\x86\x01\x92`\x05\x1b\x82\x01\x01\x92\x83\x11a\x051W\x83\x01\x90[\x82\x82\x10a\x10AWPPPP\x90V[\x815`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x03a\x051W\x81R\x90\x83\x01\x90\x83\x01a\x103V[`\x045\x90c\xff\xff\xff\xff\x82\x16\x82\x03a\x051WV[`\x01`\x01`@\x1b\x03\x81\x11a\x0f`W`\x1f\x01`\x1f\x19\x16` \x01\x90V[\x81`\x1f\x82\x01\x12\x15a\x051W\x805\x90a\x10\xa5\x82a\x10sV[\x92a\x10\xb3`@Q\x94\x85a\x0f\xa4V[\x82\x84R` \x83\x83\x01\x01\x11a\x051W\x81`\0\x92` \x80\x93\x01\x83\x86\x017\x83\x01\x01R\x90V[\x90` \x91\x82\x82\x01\x90Q\x92\x80\x83R\x83Q\x80\x92R\x80`@\x80\x94\x01\x94\x01\x92`\0\x90[\x83\x82\x10a\x11\x03WPPPPP\x90V[\x84Q\x80Q`\x01`\x01`\xa0\x1b\x03\x16\x87R\x83\x01Q`\x01`\x01``\x1b\x03\x16\x86\x84\x01R\x94\x85\x01\x94\x93\x82\x01\x93`\x01\x90\x91\x01\x90a\x10\xf4V[\x91\x90` \x80\x84\x83\x03\x12a\x051W`@\x80Q\x91a\x11P\x83a\x0fEV[\x82\x95\x805\x90`\x01`\x01`@\x1b\x03\x82\x11a\x051W\x01\x90\x84`\x1f\x83\x01\x12\x15a\x051W\x815a\x11{\x81a\x0f\xc5V[\x95a\x11\x88\x85Q\x97\x88a\x0f\xa4V[\x81\x87R\x82\x80\x88\x01\x92`\x06\x1b\x85\x01\x01\x93\x81\x85\x11a\x051W\x83\x01\x91[\x84\x83\x10a\x11\xb2WPPPPPPRV[\x85\x83\x83\x03\x12a\x051W\x85Q\x90a\x11\xc7\x82a\x0f\x89V[\x835`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x03a\x051W\x82R\x84\x84\x015\x90`\x01`\x01``\x1b\x03\x82\x16\x82\x03a\x051W\x82\x86\x92\x83\x8a\x95\x01R\x81R\x01\x92\x01\x91a\x11\xa2V[`3T`\x01`\x01`\xa0\x1b\x03\x163\x03a\x12\x17WV[`d`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R` `$\x82\x01R\x7fOwnable: caller is not the owner`D\x82\x01R\xfd[`3\x80T`\x01`\x01`\xa0\x1b\x03\x92\x83\x16`\x01`\x01`\xa0\x1b\x03\x19\x82\x16\x81\x17\x90\x92U\x90\x91\x16\x7f\x8b\xe0\x07\x9cS\x16Y\x14\x13D\xcd\x1f\xd0\xa4\xf2\x84\x19I\x7f\x97\"\xa3\xda\xaf\xe3\xb4\x18okdW\xe0`\0\x80\xa3V[`\0[\x83\x81\x10a\x12\xb7WPP`\0\x91\x01RV[\x81\x81\x01Q\x83\x82\x01R` \x01a\x12\xa7V[`fT\x90a\x12\xd4\x82a\x0f\xc5V[\x91`@a\x12\xe3\x81Q\x94\x85a\x0f\xa4V[\x81\x84R\x83` \x80\x91\x01\x91`f`\0R`\0\x80Q` a%R\x839\x81Q\x91R\x90`\0\x93[\x85\x85\x10a\x13\x15WPPPPPPV[`\x01\x84\x81\x92\x84Qa\x13%\x81a\x0f\x89V[\x86T\x84\x80`\xa0\x1b\x03\x81\x16\x82R`\xa0\x1c\x83\x82\x01R\x81R\x01\x93\x01\x94\x01\x93\x91a\x13\x06V[`lT\x81\x10\x15a\x13}W`l`\0R\x7f+JQ\xabP_\xc9j\tR\xef\xda+\xa6\x1b\xcd0x\xd4\xc0,9\xa1\x86\xec\x16\xf2\x18\x83\xfb\xe0\x16\x01\x90`\0\x90V[cNH{q`\xe0\x1b`\0R`2`\x04R`$`\0\xfd[`kT\x81\x10\x15a\x13}W`k`\0R\x7f\xbdC\xcb\x8e\xce\x8c\xd1\x86;\xcd`\x82\xd6\\[\r%f[\x1c\xe1y\x80\xf0\xdaC\xc0\xedT_\x98\xb4\x01\x90`\0\x90V[\x80T\x82\x10\x15a\x13}W`\0R` `\0 \x01\x90`\0\x90V[`kT`\0\x81a\x13\xfdWPP`\0[`\x01`\x01`\xe0\x1b\x03\x16\x90V[`\0\x19\x82\x01\x91\x82\x11a\x14\x1dWPa\x14\x13\x90a\x13\x93V[PT` \x1ca\x13\xf1V[cNH{q`\xe0\x1b\x81R`\x11`\x04R`$\x90\xfd[\x80T`\0\x92\x91\x81a\x14DWP`\0\x92PPV[`\0\x19\x82\x01\x91\x82\x11a\x14[Wa\x14\x13\x92\x93Pa\x13\xcaV[cNH{q`\xe0\x1b\x84R`\x11`\x04R`$\x84\xfd[\x91\x90\x82\x01\x80\x92\x11a\x14|WV[cNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[C\x81\x10\x15a\x15\x19W`kT\x90`\0\x90[\x82\x82\x10a\x14\xbeWPP`\0\x81\x15`\0\x14a\x13\xfdWP`\0\x91\x90PV[\x90\x91`\x01\x90a\x14\xd3\x81\x85\x18\x83\x1c\x82\x86\x16a\x14oV[\x91\x83c\xff\xff\xff\xffa\x14\xe3\x85a\x13\x93V[PT\x16\x11\x15a\x14\xf6WPP\x91[\x90a\x14\xa2V[\x90\x93P\x81\x01\x80\x91\x11\x15a\x14\xf0WcNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[`d`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R` `$\x82\x01R\x7fCheckpoints: block not yet mined`D\x82\x01R\xfd[C\x81\x10\x15a\x15\x19W`lT\x90`\0\x90[\x82\x82\x10a\x15\x9fWPP`\0\x81\x15`\0\x14a\x15\x89WP`\0\x91\x90PV[`\0\x19\x82\x01\x91\x82\x11a\x14\x1dWPa\x14\x13\x90a\x13FV[\x90\x91`\x01\x90a\x15\xb4\x81\x85\x18\x83\x1c\x82\x86\x16a\x14oV[\x91\x83c\xff\xff\xff\xffa\x15\xc4\x85a\x13FV[PT\x16\x11\x15a\x15\xd7WPP\x91[\x90a\x15mV[\x90\x93P\x81\x01\x80\x91\x11\x15a\x15\xd1WcNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[\x91\x90C\x81\x10\x15a\x15\x19W\x82T\x90`\0\x90[\x82\x82\x10a\x16(WPP`\0\x92\x81\x15`\0\x14a\x14DWP`\0\x92PPV[\x90\x91`\x01\x90a\x16=\x81\x85\x18\x83\x1c\x82\x86\x16a\x14oV[\x91\x83c\xff\xff\xff\xffa\x16N\x85\x8aa\x13\xcaV[PT\x16\x11\x15a\x16aWPP\x91[\x90a\x16\x0bV[\x90\x93P\x81\x01\x80\x91\x11\x15a\x16[WcNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[`\0\x19\x81\x14a\x14|W`\x01\x01\x90V[\x80Q\x82\x10\x15a\x13}W` \x91`\x05\x1b\x01\x01\x90V[a\x16\xafa\x12\xc7V[\x80Q\x90\x92`\0a\x16\xd7a\x16\xc1\x84a\x0f\xc5V[\x93a\x16\xcf`@Q\x95\x86a\x0f\xa4V[\x80\x85Ra\x0f\xc5V[` \x84\x81\x01\x95\x91`\x1f\x19\x016\x877\x82[\x87Q\x81\x10\x15a\x17\x1eWa\x17\x19\x90`\x01`\x01`\xa0\x1b\x03a\x17\x06\x82\x8ba\x16\x93V[QQ\x16a\x17\x13\x82\x89a\x16\x93V[Ra\x16\x84V[a\x16\xe7V[P\x90\x91\x93\x92\x94\x84`@Q\x80\x92c\x90\x04\x13G`\xe0\x1b\x82R`D\x82\x01\x90`\x01\x80`\xa0\x1b\x03\x91\x82`\x04\x98\x16\x88\x85\x01R`$\x98`@\x8a\x86\x01RQ\x80\x91R`d\x84\x01\x91\x90\x85[\x88\x82\x82\x10a\x18\xcdWPPPP\x82\x80\x91\x03\x91\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xfa\x90\x81\x15a\x18\xc2W\x85\x91a\x182W[P\x84[\x87Q\x86\x10\x15a\x18\x0fWa\x17\xb8\x86\x83a\x16\x93V[Q\x90`\x01`\x01``\x1b\x03\x84a\x17\xcd\x89\x8ca\x16\x93V[Q\x01Q\x16\x91\x82\x81\x02\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x17\xfbWa\x17\xf5\x91a\x17\xef\x91a\x14oV[\x95a\x16\x84V[\x94a\x17\xa5V[\x85`\x11\x86cNH{q`\xe0\x1b`\0RR`\0\xfd[\x94PPPPPa'\x10\x91\x92P\x04`gT\x81\x10\x15`\0\x14a\x18,W\x90V[P`\0\x90V[\x90P=\x80\x86\x83>a\x18C\x81\x83a\x0f\xa4V[\x81\x01\x90\x82\x81\x83\x03\x12a\x0e\xbfW\x80Q\x90`\x01`\x01`@\x1b\x03\x82\x11a\x08\xb3W\x01\x90\x80`\x1f\x83\x01\x12\x15a\x0e\xbfW\x81Qa\x18x\x81a\x0f\xc5V[\x92a\x18\x86`@Q\x94\x85a\x0f\xa4V[\x81\x84R\x84\x80\x85\x01\x92`\x05\x1b\x82\x01\x01\x92\x83\x11a\x0e\xe2W\x84\x80\x91\x01\x91[\x83\x83\x10a\x18\xb2WPPPP8a\x17\xa2V[\x82Q\x81R\x91\x81\x01\x91\x85\x91\x01a\x18\xa1V[`@Q=\x87\x82>=\x90\xfd[\x83Q\x86\x16\x85R\x8c\x97P\x88\x96P\x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x17_V[\x15a\x18\xf0WV[`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7fInitializable: contract is not i`D\x82\x01Rjnitializing`\xa8\x1b`d\x82\x01R`\x84\x90\xfd[\x91\x90\x91`\0\x83\x82\x01\x93\x84\x12\x91\x12\x90\x80\x15\x82\x16\x91\x15\x16\x17a\x14|WV[\x90`\0\x80[\x83Q\x82\x10\x15a\x19\xa9Wa\x19\xa3\x90a\x19\x9d\x90a\x19\x97`\x01`\x01`\xa0\x1b\x03a\x19\x90\x86\x89a\x16\x93V[Q\x16a\x1f\x0fV[\x90a\x19IV[\x91a\x16\x84V[\x90a\x19jV[\x90Pa\x19\xb6\x91\x92Pa!DV[PPV[`lT\x90\x81\x15\x15\x80a\x1bsW[\x80a\x1bNW[\x15a\x1a9Wa\x19\xdb\x81a\x1c|V[\x90`\0\x19\x83\x01\x92\x83\x11a\x14|Wa\x1a0` \x92a\x1a\x18\x7f\x93$\xf7\xe5\xa7\xc0(\x88\x08\xa64\xcc\xdeD\xb8\xe9ygdt\xb2.)\xee\x9d\xd5i\xb5^y\x1aK\x95a\x13FV[P\x90c\xff\xff\xff\xff\x82T\x91\x81\x19\x90` \x1b\x16\x91\x16\x17\x90UV[`@Q\x90\x81R\xa1V[c\xff\xff\xff\xff\x90\x81C\x11a\x1a\xfaWa\x1aO\x81a\x1c|V[`@Q\x90a\x1a\\\x82a\x0f\x89V[C\x84\x16\x82R`\x01`\x01`\xe0\x1b\x03\x90\x81\x16` \x83\x01\x90\x81R\x94`\x01`@\x1b\x81\x10\x15a\x0f`W\x80`\x01a\x1a\x90\x92\x01`lUa\x13FV[\x91\x90\x91a\x1a\xe4W\x91Q\x94Qc\xff\xff\xff\xff\x95\x90\x94\x16\x94\x90\x94\x16\x92\x16` \x90\x81\x1bc\xff\xff\xff\xff\x19\x16\x92\x90\x92\x17\x90\x92U\x7f\x93$\xf7\xe5\xa7\xc0(\x88\x08\xa64\xcc\xdeD\xb8\xe9ygdt\xb2.)\xee\x9d\xd5i\xb5^y\x1aK\x91a\x1a0V[cNH{q`\xe0\x1b`\0R`\0`\x04R`$`\0\xfd[`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7fSafeCast: value doesn't fit in 3`D\x82\x01Re2 bits`\xd0\x1b`d\x82\x01R`\x84\x90\xfd[P`\0\x19\x82\x01\x82\x81\x11a\x14|Wa\x1bic\xff\xff\xff\xff\x91a\x13FV[PT\x16C\x14a\x19\xcdV[`\0\x19\x83\x01\x83\x81\x11a\x14|Wa\x1b\x88\x90a\x13FV[PPa\x19\xc7V[\x91\x90\x91\x80Ta\x1b\x9d\x82a\x141V[\x91\x81\x15\x15\x80a\x1cVW[\x15a\x1b\xd3Wa\x1b\xb5\x85a\x1c|V[\x90`\0\x19\x83\x01\x92\x83\x11a\x14|Wa\x1b\xcf\x92a\x1a\x18\x91a\x13\xcaV[\x91\x90V[\x90c\xff\xff\xff\xff\x90\x81C\x11a\x1a\xfaWa\x1b\xea\x86a\x1c|V[\x90`@Q\x93a\x1b\xf8\x85a\x0f\x89V[C\x84\x16\x85R`\x01`\x01`\xe0\x1b\x03\x92\x83\x16` \x86\x01\x90\x81R\x91`\x01`@\x1b\x81\x10\x15a\x0f`Wa\x1c+\x91`\x01\x82\x01\x81Ua\x13\xcaV[\x93\x90\x93a\x1a\xe4W\x93Q\x90Qc\xff\xff\xff\xff\x91\x90\x94\x16\x16\x92\x16` \x1bc\xff\xff\xff\xff\x19\x16\x91\x90\x91\x17\x90U\x91\x90V[P`\0\x19\x82\x01\x82\x81\x11a\x14|Wa\x1crc\xff\xff\xff\xff\x91\x83a\x13\xcaV[PT\x16C\x14a\x1b\xa7V[`\x01`\x01`\xe0\x1b\x03\x90\x81\x81\x11a\x1c\x90W\x16\x90V[`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`'`$\x82\x01R\x7fSafeCast: value doesn't fit in 2`D\x82\x01Rf24 bits`\xc8\x1b`d\x82\x01R`\x84\x90\xfd[a\x1c\xee\x81a\"\x84V[\x15a\x1eEW`@Q\x90a\x1d\0\x82a\x0fEV[a\x1d\x08a\x12\xc7V[\x82R`f\x90\x81T\x93`\0\x94\x85\x84U\x80a\x1e\x16W[P\x84[\x82Q\x80Q\x82\x10\x15a\x1d\xc0W\x81a\x1d4\x91a\x16\x93V[Q\x84T\x90`\x01`@\x1b\x82\x10\x15a\x1d\xacW`\x01\x82\x01\x80\x87U\x82\x10\x15a\x1d\x98W\x85\x88R\x80Q` \x90\x91\x01Q`\xa0\x1b`\x01`\x01`\xa0\x1b\x03\x19\x16`\x01`\x01`\xa0\x1b\x03\x91\x90\x91\x16\x17`\0\x80Q` a%R\x839\x81Q\x91R\x90\x91\x01Ua\x1d\x93\x90a\x16\x84V[a\x1d\x1fV[cNH{q`\xe0\x1b\x88R`2`\x04R`$\x88\xfd[cNH{q`\xe0\x1b\x88R`A`\x04R`$\x88\xfd[PP\x93Pa\x1e\x03\x91P\x91a\x1e\x11\x7f#\xaa\xd4\xe6\x17D\xec\xe1d\x13\n\xa4\x15\xc1an\x80\x13k\x0f\x07p\xe5e\x89C\x8b\x90\xb2i&^\x93`@Q\x93\x84\x93`@\x85R`@\x85\x01\x90a\x10\xd5V[\x90\x83\x82\x03` \x85\x01Ra\x10\xd5V[\x03\x90\xa1V[\x83\x86R`\0\x80Q` a%R\x839\x81Q\x91R\x90\x81\x01\x90[\x81\x81\x10a\x1e:WPa\x1d\x1cV[\x86\x81U`\x01\x01a\x1e-V[`@Qc\xd1sWy`\xe0\x1b\x81R`\x04\x90\xfd[\x90` \x91a\x1ep\x81Q\x80\x92\x81\x85R\x85\x80\x86\x01\x91\x01a\x12\xa4V[`\x1f\x01`\x1f\x19\x16\x01\x01\x90V[\x90`\x01\x80`\xa0\x1b\x03\x80\x92\x16\x91\x82`\0R`j` R\x80a\x1e\x9f`@`\0 a\x141V[\x16\x91\x16\x91\x81\x83\x14a\x1e\xf1W\x80`\0R`j` Ra\x1e\xc1\x83`@`\0 a\x1b\x8fV[PP`@Q\x91\x82R\x7f\xd0a\x16\x82R\xf4As6X\xf0\x9eM\x8f[-\x99\x8e\xd4\xef$\xa2\xbb\xfdl\xec\xa5.\xa11P\x02` C\x93\xa4V[PPPV[\x81\x81\x03\x92\x91`\0\x13\x80\x15\x82\x85\x13\x16\x91\x84\x12\x16\x17a\x14|WV[`\0\x80\x91`\x01\x80`\xa0\x1b\x03\x81\x16\x91\x82\x81R` \x91`m\x83R`@\x91a\x1f5\x83\x82 a\x141V[\x91\x85\x82R`n\x85R`\xff\x84\x83 T\x16\x15`\0\x14a \xe7WP\x81a\x1fW\x91a\x1e\xf6V[\x94\x85\x15a \xdfW\x84`\0R`m\x84R\x82`\0 \x93\x84T\x94a\x1fw\x81a\x141V[P\x85\x15\x15\x80a \xb9W[\x15a\x1f\xd5W`\0\x19\x86\x01\x95\x86\x11a\x14|W\x7f\x88w\r\xc8b\xe4z~\xd5\x86\x90xW\xeb\x1bu\xe4\xc5\xff\xc8\xb7\x07\xc7\xee\x10\xebt\xd6\x88_\xe5\x94\x95a\x1f\xbd\x91a\x13\xcaV[Pc\xff\xff\xff\xff\x81T\x16\x90U[\x83Q\x92\x83R\x82\x01R\xa2\x90V[c\xff\xff\xff\xff\x95\x86C\x11a fW\x85Q\x91a\x1f\xee\x83a\x0f\x89V[\x87C\x16\x83R\x83\x83\x01\x91`\0\x83R`\x01`@\x1b\x81\x10\x15a\x0f`Wa \x16\x91`\x01\x82\x01\x81Ua\x13\xcaV[\x91\x90\x91a\x1a\xe4W\x91Q\x91Qc\xff\xff\xff\xff\x19` \x91\x90\x91\x1b\x16\x96\x90\x91\x16c\xff\xff\xff\xff\x16\x95\x90\x95\x17\x90\x94U\x7f\x88w\r\xc8b\xe4z~\xd5\x86\x90xW\xeb\x1bu\xe4\xc5\xff\xc8\xb7\x07\xc7\xee\x10\xebt\xd6\x88_\xe5\x94\x93a\x1f\xc9V[\x85QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x81\x01\x84\x90R`&`$\x82\x01R\x7fSafeCast: value doesn't fit in 3`D\x82\x01Re2 bits`\xd0\x1b`d\x82\x01R`\x84\x90\xfd[P`\0\x19\x86\x01\x86\x81\x11a\x14|Wa \xd5c\xff\xff\xff\xff\x91\x83a\x13\xcaV[PT\x16C\x14a\x1f\x81V[PPPPP\x90V[\x90Pa \xf4\x91\x95Pa\x16\xa7V[\x93a \xff\x81\x86a\x1e\xf6V[\x94\x85\x15a \xdfW\x7f\x88w\r\xc8b\xe4z~\xd5\x86\x90xW\xeb\x1bu\xe4\xc5\xff\xc8\xb7\x07\xc7\xee\x10\xebt\xd6\x88_\xe5\x94\x93\x85`\0R`m\x81Ra!=\x82\x85`\0 a\x1b\x8fV[PPa\x1f\xc9V[\x90a!Wa!Pa\x13\xe2V[\x92\x83a\x19IV[\x90`kT\x80\x15\x15\x80a\"hW[\x80a\"CW[\x15a!\xc1Wa!x\x83a\x1c|V[`\0\x19\x82\x01\x91\x82\x11a\x14|Wa\x1a\x18a!\x90\x92a\x13\x93V[\x7f\x86\xdc\xf8k\x12\xdf\xee\xde\xa7J\xe90\r\xbd\xaa\x19;\xcc\xe5\x80\x93i\xc8\x17~\xa2\xf4\xea\xaaer\x9b`@\x80Q\x85\x81R\x84` \x82\x01R\xa1V[c\xff\xff\xff\xff\x80C\x11a\x1a\xfaWa!\xd6\x84a\x1c|V[`@Q\x92a!\xe3\x84a\x0f\x89V[C\x83\x16\x84R`\x01`\x01`\xe0\x1b\x03\x91\x82\x16` \x85\x01\x90\x81R\x90`\x01`@\x1b\x81\x10\x15a\x0f`W\x80`\x01a\"\x17\x92\x01`kUa\x13\x93V[\x93\x90\x93a\x1a\xe4W\x93Q\x90Qc\xff\xff\xff\xff\x91\x90\x94\x16\x16\x92\x16` \x1bc\xff\xff\xff\xff\x19\x16\x91\x90\x91\x17\x90Ua!\x90V[P`\0\x19\x81\x01\x81\x81\x11a\x14|Wa\"^c\xff\xff\xff\xff\x91a\x13\x93V[PT\x16C\x14a!jV[`\0\x19\x82\x01\x82\x81\x11a\x14|Wa\"}\x90a\x13\x93V[PPa!dV[Q\x90`\0\x80\x80[\x84Q\x82\x10\x15a\"\xf4W`\x01`\x01`\xa0\x1b\x03\x90\x81a\"\xa8\x84\x88a\x16\x93V[QQ\x16\x91\x82\x91\x16\x10\x15a\"\xe2Wa\x19\x9da\"\xdb\x91\x93`\x01`\x01``\x1b\x03` a\"\xd1\x86\x8aa\x16\x93V[Q\x01Q\x16\x90a\x14oV[\x90\x91a\"\x8bV[`@Qc\xbaP\xf9\x11`\xe0\x1b\x81R`\x04\x90\xfd[P\x91\x92Pa'\x10\x14\x90Pa#\x07W`\0\x90V[`\x01\x90V[\x91a#\x17\x81\x83a$,V[`\x05\x81\x10\x15a$\x16W\x15\x90\x81a$\0W[Pa#\xf8W`@Qa#l\x81a#^` \x82\x01\x94c\x0b\x13]?`\xe1\x1b\x96\x87\x87R`$\x84\x01R`@`D\x84\x01R`d\x83\x01\x90a\x1eWV[\x03`\x1f\x19\x81\x01\x83R\x82a\x0f\xa4V[`\0\x93\x84\x92\x83\x92Q\x91Z\xfa\x91=\x15a#\xf1W=a#\x88\x81a\x10sV[\x90a#\x96`@Q\x92\x83a\x0f\xa4V[\x81R=\x82` \x83\x01>[\x83a#\xe5W[\x83a#\xb2W[PPP\x90V[\x90\x91\x92P` \x81\x80Q\x81\x01\x03\x12a\x02\x05W` \x01Q`\x01`\x01`\xe0\x1b\x03\x19\x81\x16\x91\x90\x82\x90\x03a\x03 WP\x148\x80\x80a#\xacV[\x80Q` \x14\x93Pa#\xa6V[``a#\xa0V[PPP`\x01\x90V[`\x01`\x01`\xa0\x1b\x03\x85\x81\x16\x91\x16\x14\x90P8a#(V[cNH{q`\xe0\x1b`\0R`!`\x04R`$`\0\xfd[\x81Q`A\x81\x03a$YWP\x90a$U\x91` \x82\x01Q\x90```@\x84\x01Q\x93\x01Q`\0\x1a\x90a$\x9cV[\x90\x91V[`@\x03a$\x92W`@` \x83\x01Q\x92\x01Q\x91\x82`\xff\x1c\x91`\x1b\x83\x01\x80\x93\x11a\x14|Wa$U\x93`\x01`\x01`\xff\x1b\x03\x16\x92`\xff\x16\x90a$\x9cV[PP`\0\x90`\x02\x90V[\x92\x91\x90\x7f\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]WnsW\xa4P\x1d\xdf\xe9/Fh\x1b \xa0\x83\x11a%EW`\xff\x16`\x1b\x81\x14\x15\x80a%:W[a%.W\x91`\x80\x94\x93\x91` \x93`@Q\x93\x84R\x84\x84\x01R`@\x83\x01R``\x82\x01R`\0\x93\x84\x91\x82\x80R`\x01Z\xfa\x15a%!W\x81Q`\x01`\x01`\xa0\x1b\x03\x81\x16\x15a%\x1bW\x91\x90V[P`\x01\x90V[P`@Q\x90=\x90\x82>=\x90\xfd[PPPP`\0\x90`\x04\x90V[P`\x1c\x81\x14\x15a$\xd4V[PPPP`\0\x90`\x03\x90V\xfeFP\x18y\xb8\xca\x85%\xe8\xc2\xfdQ\x9e/\xbf\xcf\xa2\xeb\xea&P\x12\x94\xaa\x02\xcb\xfc\xfb\x12\xe9CT\xa2dipfsX\"\x12 \x94F\x9dv\x9c\xa0\xfc\x92r\xb4\x8dZ\xa8\xbe\x89i\x8a!\x1b\xb9\x1d\xbc,^\xca\x9e/\xbf\x1da\x18\x1bdsolcC\0\x08\x14\03");
    #[doc = r" The runtime bytecode of the contract, as deployed on the network."]
    #[doc = r""]
    #[doc = r" ```text"]
    #[doc = "0x6040608081526004908136101561001557600080fd5b600091823560e01c8062cf2ab514610f125780630dba339414610ee65780631626ba7e14610bdd5780631703a01814610b275780631e4cd85e14610afb578063314f3a4914610ade5780633b242e4a14610aa55780633d5611f61461090457806340bf2fb7146108e55780635140a548146107ea5780635e1042e8146107ad5780635ef5332914610788578063696255be14610710578063715018a6146106b2578063743c31f41461066b578063857dc1901461055f5780638da5cb5b14610536578063955f2d90146104e957806398ec1ac9146104bc578063ab11899514610323578063b933fa74146102b1578063cdcd35811461026e578063dec5d1f614610209578063ec7fbb31146101c75763f2fde38b1461013357600080fd5b346101c35760203660031901126101c35761014c610fdc565b91610155611203565b6001600160a01b03831615610171578361016e8461125b565b80f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152fd5b8280fd5b5050346102055760203660031901126102055760209160ff9082906001600160a01b036101f2610fdc565b168152606e855220541690519015158152f35b5080fd5b5090346101c357366003190112610205576001600160401b0390803582811161026a576102399036908301611135565b9060243592831161026a576102576102659161016e94369101610ff2565b91610260611203565b611ce5565b611965565b8380fd5b505034610205576020366003190112610205576020916001600160a01b03906102a99083908361029c610fdc565b168152606a865220611431565b169051908152f35b50913461032057806003193601126103205750606c5491600090836102ea575050602091506000905b516001600160e01b039091168152f35b600019840193841161030d575050610303602092611346565b5054821c906102da565b634e487b7160e01b825260119052602490fd5b80fd5b50346101c35760603660031901126101c35761033d610fdc565b6044356001600160401b0381116104b85761035b9036908401611135565b90845460ff8160081c1615938480956104ab575b8015610494575b1561043a575060ff19811660011786556103c992919084610429575b506103a360ff875460081c166118e9565b60018060a01b03166001600160601b0360a01b60685416176068556102606024356119ba565b6103e260ff845460081c166103dd816118e9565b6118e9565b6103eb3361125b565b6103f3575080f35b60207f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989161ff001984541684555160018152a180f35b61ffff191661010117865538610392565b608490602087519162461bcd60e51b8352820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152fd5b50303b1580156103765750600160ff831614610376565b50600160ff83161061036f565b8480fd5b505034610205576020366003190112610205576020906104e26104dd610fdc565b6116a7565b9051908152f35b505034610205578060031936011261020557610503610fdc565b9160243563ffffffff811680910361053157826104e29260209560018060a01b03168152606d8652206115fa565b600080fd5b50503461020557816003193601126102055760335490516001600160a01b039091168152602090f35b50346101c357826003193601126101c357338352606e60205260ff82842054161561065d57606554801561064a5790839160001901606555338252606e60205282822060ff1981541690556105bb6105b633611f0f565b612144565b50506068546001600160a01b039390841691823b1561026a57839260248492845195869384926351b27a6d60e11b845233908401525af1908115610641575061062d575b505060685416337f31e0adfec71bccee37b6e83a90c2fedb17d8f1693fee863c4771e7bfe2aed5808380a380f35b61063690610f76565b6102055781386105ff565b513d84823e3d90fd5b634e487b7160e01b845260118252602484fd5b90516325ec6c1f60e01b8152fd5b50346101c35760203660031901126101c357610685610fdc565b91338452606e60205260ff8185205416156106a5578361016e8433611e7c565b516325ec6c1f60e01b8152fd5b83346103205780600319360112610320576106cb611203565b603380546001600160a01b031981169091556000906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b50346101c357816003193601126101c357803590602435926001600160401b0384116104b8576107677f713ca53b88d6eb63f5b1854cb8cbdd736ec51eda225e46791aa9298b0160648f9261016e95369101610ff2565b92610770611203565b606754908060675582519182526020820152a1611965565b8382346102055760203660031901126102055761016e906107a7611203565b356119ba565b5050346102055780600319360112610205576020916001600160a01b03906102a990826107d8610fdc565b168152606a85528360243591206115fa565b50346101c357816003193601126101c35780356001600160401b038082116104b857366023830112156104b857818301359061082582610fc5565b9061083286519283610fa4565b828252602080830194856024809660051b830101913683116108e157868101915b8383106108b757505050505082359081116108b357610875903690860161108e565b5051156108a057505191825160655403610893578361016e84611965565b5163169efb5b60e11b8152fd5b634e487b7160e01b600090815260328452fd5b8680fd5b82358681116108dd5785916108d283928b3691870101610ff2565b815201920191610853565b8c80fd5b8a80fd5b5050346102055781600319360112610205576020906067549051908152f35b50919034610205576003199080823601126101c3578335916001600160401b03908184116104b857606090843603011261026a578151906060820182811082821117610a92578352838601359081116104b8576109669086369186010161108e565b8152602081019060248401358252604483820194013584526024359560018060a01b039687811681036108b357338752606e60205260ff8588205416610a83576109e2906109b5606554611684565b606555338852606e602052858820600160ff198254161790556109da6105b633611f0f565b505033611e7c565b866068541692833b156108b3579186809492610a2894875198899687958694639926ee7d60e01b865233908601528a6024860152516060604486015260a4850190611e57565b9151606484015251608483015203925af19081156106415750610a74575b509060685416337fa453db612af59e5521d6ab9284dc3e2d06af286eb1b1b7b771fce4716c19f2c18380a380f35b610a7d90610f76565b38610a46565b5083516342ee68b560e01b8152fd5b634e487b7160e01b865260418752602486fd5b505034610205576020366003190112610205576020916104e29082906001600160a01b03610ad1610fdc565b168152606d855220611431565b5050346102055781600319360112610205576020906104e26113e2565b505034610205576020366003190112610205576020906104e263ffffffff610b21611060565b1661155d565b82843461032057806003193601126103205760608251610b4681610f45565b52815191610b5383610f45565b606654610b5f81610fc5565b90610b6c83519283610fa4565b80825260668452602093600080516020612552833981519152858085015b848410610baa57858952865182815280610ba68185018c6110d5565b0390f35b60019182918851610bba81610f89565b8554848060a01b038116825260a01c838201528152019201920191908690610b8a565b50346101c357816003193601126101c3576001600160401b039260243584811161020557610c0e903690840161108e565b938451850160209560608188840193031261026a57868101518381116104b85781019180603f840112156104b8578783015192610c4a84610fc5565b93610c5789519586610fa4565b808552888a86019160051b83010191838311610ee2578901905b828210610ec35750505086820151848111610ebf5782019080603f83011215610ebf578882015190610ca282610fc5565b95610caf8a519788610fa4565b828752898b88019360051b85010193828511610ebb578a8101935b858510610e5a57505050505050606001519163ffffffff831680930361026a5781519380819583518103610e47578015610e37579190819343871015958935925b858710610d765750505050505050610d6657610d2681611492565b8211610d5657610d359061155d565b11610d48575051630b135d3f60e11b8152f35b905163e121632f60e01b8152fd5b8351634b05a0f760e11b81528390fd5b835163e64f180f60e01b81528390fd5b60018060a09b9394959697989b1b0380610d908c86611693565b511698610e27578089918f8f8d90606a610daf93878e52528b206115fa565b1692161015610e1757610dce9085610dc78c87611693565b519161230c565b15610e075790610dff610df98d959493610df38b8f606d8d9a8c9e8d52528a206115fa565b9061146f565b99611684565b959493610d0b565b8a51638baa579f60e01b81528a90fd5b8b5163ba50f91160e01b81528b90fd5b8c5163e64f180f60e01b81528c90fd5b885163251f56a160e21b81528890fd5b88516001621398b960e31b031981528890fd5b84518381116108e157820184605f820112156108e1578c8101518d91610e8b610e8283611073565b93519384610fa4565b81835286606083830101116108dd57918f9391610eb0908594606086850191016112a4565b815201940193610cca565b8880fd5b8580fd5b81516001600160a01b0381168103610ebb578152908a01908a01610c71565b8780fd5b505034610205576020366003190112610205576020906104e263ffffffff610f0c611060565b16611492565b8382346102055760203660031901126102055780356001600160401b0381116101c35761016e9161026591369101610ff2565b602081019081106001600160401b03821117610f6057604052565b634e487b7160e01b600052604160045260246000fd5b6001600160401b038111610f6057604052565b604081019081106001600160401b03821117610f6057604052565b90601f801991011681019081106001600160401b03821117610f6057604052565b6001600160401b038111610f605760051b60200190565b600435906001600160a01b038216820361053157565b81601f820112156105315780359161100983610fc5565b926110176040519485610fa4565b808452602092838086019260051b820101928311610531578301905b828210611041575050505090565b81356001600160a01b0381168103610531578152908301908301611033565b6004359063ffffffff8216820361053157565b6001600160401b038111610f6057601f01601f191660200190565b81601f82011215610531578035906110a582611073565b926110b36040519485610fa4565b8284526020838301011161053157816000926020809301838601378301015290565b9060209182820190519280835283518092528060408094019401926000905b83821061110357505050505090565b845180516001600160a01b031687528301516001600160601b03168684015294850194938201936001909101906110f4565b91906020808483031261053157604080519161115083610f45565b82958035906001600160401b03821161053157019084601f8301121561053157813561117b81610fc5565b9561118885519788610fa4565b818752828088019260061b85010193818511610531578301915b8483106111b25750505050505052565b8583830312610531578551906111c782610f89565b83356001600160a01b038116810361053157825284840135906001600160601b038216820361053157828692838a9501528152019201916111a2565b6033546001600160a01b0316330361121757565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b603380546001600160a01b039283166001600160a01b0319821681179092559091167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3565b60005b8381106112b75750506000910152565b81810151838201526020016112a7565b606654906112d482610fc5565b9160406112e381519485610fa4565b818452836020809101916066600052600080516020612552833981519152906000935b85851061131557505050505050565b6001848192845161132581610f89565b8654848060a01b038116825260a01c83820152815201930194019391611306565b606c5481101561137d57606c6000527f2b4a51ab505fc96a0952efda2ba61bcd3078d4c02c39a186ec16f21883fbe0160190600090565b634e487b7160e01b600052603260045260246000fd5b606b5481101561137d57606b6000527fbd43cb8ece8cd1863bcd6082d65c5b0d25665b1ce17980f0da43c0ed545f98b40190600090565b805482101561137d5760005260206000200190600090565b606b546000816113fd57505060005b6001600160e01b031690565b600019820191821161141d575061141390611393565b505460201c6113f1565b634e487b7160e01b81526011600452602490fd5b8054600092918161144457506000925050565b600019820191821161145b576114139293506113ca565b634e487b7160e01b84526011600452602484fd5b9190820180921161147c57565b634e487b7160e01b600052601160045260246000fd5b4381101561151957606b54906000905b8282106114be575050600081156000146113fd57506000919050565b90916001906114d3818518831c82861661146f565b918363ffffffff6114e385611393565b50541611156114f6575050915b906114a2565b9093508101809111156114f057634e487b7160e01b600052601160045260246000fd5b606460405162461bcd60e51b815260206004820152602060248201527f436865636b706f696e74733a20626c6f636b206e6f7420796574206d696e65646044820152fd5b4381101561151957606c54906000905b82821061159f5750506000811560001461158957506000919050565b600019820191821161141d575061141390611346565b90916001906115b4818518831c82861661146f565b918363ffffffff6115c485611346565b50541611156115d7575050915b9061156d565b9093508101809111156115d157634e487b7160e01b600052601160045260246000fd5b919043811015611519578254906000905b828210611628575050600092811560001461144457506000925050565b909160019061163d818518831c82861661146f565b918363ffffffff61164e858a6113ca565b5054161115611661575050915b9061160b565b90935081018091111561165b57634e487b7160e01b600052601160045260246000fd5b600019811461147c5760010190565b805182101561137d5760209160051b010190565b6116af6112c7565b8051909260006116d76116c184610fc5565b936116cf6040519586610fa4565b808552610fc5565b60208481019591601f1901368737825b875181101561171e57611719906001600160a01b03611706828b611693565b5151166117138289611693565b52611684565b6116e7565b509091939294846040518092639004134760e01b8252604482019060018060a01b039182600498168885015260249860408a86015251809152606484019190855b888282106118cd575050505082809103917f0000000000000000000000000000000000000000000000000000000000000000165afa9081156118c2578591611832575b50845b875186101561180f576117b88683611693565b51906001600160601b03846117cd898c611693565b51015116918281029281840414901517156117fb576117f5916117ef9161146f565b95611684565b946117a5565b85601186634e487b7160e01b600052526000fd5b9450505050506127109192500460675481101560001461182c5790565b50600090565b90503d8086833e6118438183610fa4565b8101908281830312610ebf578051906001600160401b0382116108b357019080601f83011215610ebf57815161187881610fc5565b926118866040519485610fa4565b818452848085019260051b820101928311610ee25784809101915b8383106118b25750505050386117a2565b82518152918101918591016118a1565b6040513d87823e3d90fd5b8351861685528c9750889650938401939092019160010161175f565b156118f057565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b9190916000838201938412911290801582169115161761147c57565b906000805b83518210156119a9576119a39061199d906119976001600160a01b036119908689611693565b5116611f0f565b90611949565b91611684565b9061196a565b90506119b6919250612144565b5050565b606c549081151580611b73575b80611b4e575b15611a39576119db81611c7c565b90600019830192831161147c57611a30602092611a187f9324f7e5a7c0288808a634ccde44b8e979676474b22e29ee9dd569b55e791a4b95611346565b509063ffffffff82549181199060201b169116179055565b604051908152a1565b63ffffffff90814311611afa57611a4f81611c7c565b60405190611a5c82610f89565b43841682526001600160e01b039081166020830190815294600160401b811015610f6057806001611a909201606c55611346565b919091611ae4579151945163ffffffff95909416949094169216602090811b63ffffffff1916929092179092557f9324f7e5a7c0288808a634ccde44b8e979676474b22e29ee9dd569b55e791a4b91611a30565b634e487b7160e01b600052600060045260246000fd5b60405162461bcd60e51b815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203360448201526532206269747360d01b6064820152608490fd5b50600019820182811161147c57611b6963ffffffff91611346565b50541643146119cd565b600019830183811161147c57611b8890611346565b50506119c7565b9190918054611b9d82611431565b9181151580611c56575b15611bd357611bb585611c7c565b90600019830192831161147c57611bcf92611a18916113ca565b9190565b9063ffffffff90814311611afa57611bea86611c7c565b9060405193611bf885610f89565b43841685526001600160e01b039283166020860190815291600160401b811015610f6057611c2b916001820181556113ca565b939093611ae4579351905163ffffffff9190941616921660201b63ffffffff19169190911790559190565b50600019820182811161147c57611c7263ffffffff91836113ca565b5054164314611ba7565b6001600160e01b0390818111611c90571690565b60405162461bcd60e51b815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e20326044820152663234206269747360c81b6064820152608490fd5b611cee81612284565b15611e455760405190611d0082610f45565b611d086112c7565b825260669081549360009485845580611e16575b50845b82518051821015611dc05781611d3491611693565b51845490600160401b821015611dac5760018201808755821015611d9857858852805160209091015160a01b6001600160a01b0319166001600160a01b03919091161760008051602061255283398151915290910155611d9390611684565b611d1f565b634e487b7160e01b88526032600452602488fd5b634e487b7160e01b88526041600452602488fd5b50509350611e03915091611e117f23aad4e61744ece164130aa415c1616e80136b0f0770e56589438b90b269265e936040519384936040855260408501906110d5565b9083820360208501526110d5565b0390a1565b838652600080516020612552833981519152908101905b818110611e3a5750611d1c565b868155600101611e2d565b60405163d173577960e01b8152600490fd5b90602091611e70815180928185528580860191016112a4565b601f01601f1916010190565b9060018060a01b038092169182600052606a60205280611e9f6040600020611431565b16911691818314611ef15780600052606a602052611ec1836040600020611b8f565b50506040519182527fd061168252f441733658f09e4d8f5b2d998ed4ef24a2bbfd6ceca52ea131500260204393a4565b505050565b8181039291600013801582851316918412161761147c57565b6000809160018060a01b03811691828152602091606d8352604091611f35838220611431565b91858252606e855260ff8483205416156000146120e7575081611f5791611ef6565b9485156120df5784600052606d84528260002093845494611f7781611431565b50851515806120b9575b15611fd557600019860195861161147c577f88770dc862e47a7ed586907857eb1b75e4c5ffc8b707c7ee10eb74d6885fe59495611fbd916113ca565b5063ffffffff81541690555b8351928352820152a290565b63ffffffff9586431161206657855191611fee83610f89565b87431683528383019160008352600160401b811015610f6057612016916001820181556113ca565b919091611ae4579151915163ffffffff1960209190911b169690911663ffffffff16959095179094557f88770dc862e47a7ed586907857eb1b75e4c5ffc8b707c7ee10eb74d6885fe59493611fc9565b855162461bcd60e51b815260048101849052602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203360448201526532206269747360d01b6064820152608490fd5b50600019860186811161147c576120d563ffffffff91836113ca565b5054164314611f81565b505050505090565b90506120f49195506116a7565b936120ff8186611ef6565b9485156120df577f88770dc862e47a7ed586907857eb1b75e4c5ffc8b707c7ee10eb74d6885fe5949385600052606d815261213d8285600020611b8f565b5050611fc9565b906121576121506113e2565b9283611949565b90606b5480151580612268575b80612243575b156121c15761217883611c7c565b600019820191821161147c57611a1861219092611393565b7f86dcf86b12dfeedea74ae9300dbdaa193bcce5809369c8177ea2f4eaaa65729b60408051858152846020820152a1565b63ffffffff804311611afa576121d684611c7c565b604051926121e384610f89565b43831684526001600160e01b039182166020850190815290600160401b811015610f60578060016122179201606b55611393565b939093611ae4579351905163ffffffff9190941616921660201b63ffffffff1916919091179055612190565b50600019810181811161147c5761225e63ffffffff91611393565b505416431461216a565b600019820182811161147c5761227d90611393565b5050612164565b5190600080805b84518210156122f4576001600160a01b0390816122a88488611693565b5151169182911610156122e25761199d6122db91936001600160601b0360206122d1868a611693565b510151169061146f565b909161228b565b60405163ba50f91160e01b8152600490fd5b5091925061271014905061230757600090565b600190565b91612317818361242c565b600581101561241657159081612400575b506123f85760405161236c8161235e6020820194630b135d3f60e11b968787526024840152604060448401526064830190611e57565b03601f198101835282610fa4565b6000938492839251915afa913d156123f1573d61238881611073565b906123966040519283610fa4565b81523d82602083013e5b836123e5575b836123b2575b50505090565b9091925060208180518101031261020557602001516001600160e01b0319811691908290036103205750143880806123ac565b805160201493506123a6565b60606123a0565b505050600190565b6001600160a01b03858116911614905038612328565b634e487b7160e01b600052602160045260246000fd5b815160418103612459575090612455916020820151906060604084015193015160001a9061249c565b9091565b6040036124925760406020830151920151918260ff1c91601b830180931161147c57612455936001600160ff1b03169260ff169061249c565b5050600090600290565b9291907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083116125455760ff16601b8114158061253a575b61252e579160809493916020936040519384528484015260408301526060820152600093849182805260015afa156125215781516001600160a01b0381161561251b579190565b50600190565b50604051903d90823e3d90fd5b50505050600090600490565b50601c8114156124d4565b5050505060009060039056fe46501879b8ca8525e8c2fd519e2fbfcfa2ebea26501294aa02cbfcfb12e94354a264697066735822122094469d769ca0fc9272b48d5aa8be89698a211bb91dbc2c5eca9e2fbf1d61181b64736f6c63430008140033"]
    #[doc = r" ```"]
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(b"`@`\x80\x81R`\x04\x90\x816\x10\x15a\0\x15W`\0\x80\xfd[`\0\x91\x825`\xe0\x1c\x80b\xcf*\xb5\x14a\x0f\x12W\x80c\r\xba3\x94\x14a\x0e\xe6W\x80c\x16&\xba~\x14a\x0b\xddW\x80c\x17\x03\xa0\x18\x14a\x0b'W\x80c\x1eL\xd8^\x14a\n\xfbW\x80c1O:I\x14a\n\xdeW\x80c;$.J\x14a\n\xa5W\x80c=V\x11\xf6\x14a\t\x04W\x80c@\xbf/\xb7\x14a\x08\xe5W\x80cQ@\xa5H\x14a\x07\xeaW\x80c^\x10B\xe8\x14a\x07\xadW\x80c^\xf53)\x14a\x07\x88W\x80cibU\xbe\x14a\x07\x10W\x80cqP\x18\xa6\x14a\x06\xb2W\x80ct<1\xf4\x14a\x06kW\x80c\x85}\xc1\x90\x14a\x05_W\x80c\x8d\xa5\xcb[\x14a\x056W\x80c\x95_-\x90\x14a\x04\xe9W\x80c\x98\xec\x1a\xc9\x14a\x04\xbcW\x80c\xab\x11\x89\x95\x14a\x03#W\x80c\xb93\xfat\x14a\x02\xb1W\x80c\xcd\xcd5\x81\x14a\x02nW\x80c\xde\xc5\xd1\xf6\x14a\x02\tW\x80c\xec\x7f\xbb1\x14a\x01\xc7Wc\xf2\xfd\xe3\x8b\x14a\x013W`\0\x80\xfd[4a\x01\xc3W` 6`\x03\x19\x01\x12a\x01\xc3Wa\x01La\x0f\xdcV[\x91a\x01Ua\x12\x03V[`\x01`\x01`\xa0\x1b\x03\x83\x16\x15a\x01qW\x83a\x01n\x84a\x12[V[\x80\xf3[\x90` `\x84\x92Q\x91bF\x1b\xcd`\xe5\x1b\x83R\x82\x01R`&`$\x82\x01R\x7fOwnable: new owner is the zero a`D\x82\x01Reddress`\xd0\x1b`d\x82\x01R\xfd[\x82\x80\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x91`\xff\x90\x82\x90`\x01`\x01`\xa0\x1b\x03a\x01\xf2a\x0f\xdcV[\x16\x81R`n\x85R T\x16\x90Q\x90\x15\x15\x81R\xf3[P\x80\xfd[P\x904a\x01\xc3W6`\x03\x19\x01\x12a\x02\x05W`\x01`\x01`@\x1b\x03\x90\x805\x82\x81\x11a\x02jWa\x029\x906\x90\x83\x01a\x115V[\x90`$5\x92\x83\x11a\x02jWa\x02Wa\x02e\x91a\x01n\x946\x91\x01a\x0f\xf2V[\x91a\x02`a\x12\x03V[a\x1c\xe5V[a\x19eV[\x83\x80\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x91`\x01`\x01`\xa0\x1b\x03\x90a\x02\xa9\x90\x83\x90\x83a\x02\x9ca\x0f\xdcV[\x16\x81R`j\x86R a\x141V[\x16\x90Q\x90\x81R\xf3[P\x914a\x03 W\x80`\x03\x196\x01\x12a\x03 WP`lT\x91`\0\x90\x83a\x02\xeaWPP` \x91P`\0\x90[Q`\x01`\x01`\xe0\x1b\x03\x90\x91\x16\x81R\xf3[`\0\x19\x84\x01\x93\x84\x11a\x03\rWPPa\x03\x03` \x92a\x13FV[PT\x82\x1c\x90a\x02\xdaV[cNH{q`\xe0\x1b\x82R`\x11\x90R`$\x90\xfd[\x80\xfd[P4a\x01\xc3W``6`\x03\x19\x01\x12a\x01\xc3Wa\x03=a\x0f\xdcV[`D5`\x01`\x01`@\x1b\x03\x81\x11a\x04\xb8Wa\x03[\x906\x90\x84\x01a\x115V[\x90\x84T`\xff\x81`\x08\x1c\x16\x15\x93\x84\x80\x95a\x04\xabW[\x80\x15a\x04\x94W[\x15a\x04:WP`\xff\x19\x81\x16`\x01\x17\x86Ua\x03\xc9\x92\x91\x90\x84a\x04)W[Pa\x03\xa3`\xff\x87T`\x08\x1c\x16a\x18\xe9V[`\x01\x80`\xa0\x1b\x03\x16`\x01`\x01``\x1b\x03`\xa0\x1b`hT\x16\x17`hUa\x02``$5a\x19\xbaV[a\x03\xe2`\xff\x84T`\x08\x1c\x16a\x03\xdd\x81a\x18\xe9V[a\x18\xe9V[a\x03\xeb3a\x12[V[a\x03\xf3WP\x80\xf3[` \x7f\x7f&\xb8?\xf9n\x1f+jh/\x138R\xf6y\x8a\t\xc4e\xda\x95\x92\x14`\xce\xfb8G@$\x98\x91a\xff\0\x19\x84T\x16\x84UQ`\x01\x81R\xa1\x80\xf3[a\xff\xff\x19\x16a\x01\x01\x17\x86U8a\x03\x92V[`\x84\x90` \x87Q\x91bF\x1b\xcd`\xe5\x1b\x83R\x82\x01R`.`$\x82\x01R\x7fInitializable: contract is alrea`D\x82\x01Rm\x19\x1eH\x1a[\x9a]\x1aX[\x1a^\x99Y`\x92\x1b`d\x82\x01R\xfd[P0;\x15\x80\x15a\x03vWP`\x01`\xff\x83\x16\x14a\x03vV[P`\x01`\xff\x83\x16\x10a\x03oV[\x84\x80\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x90a\x04\xe2a\x04\xdda\x0f\xdcV[a\x16\xa7V[\x90Q\x90\x81R\xf3[PP4a\x02\x05W\x80`\x03\x196\x01\x12a\x02\x05Wa\x05\x03a\x0f\xdcV[\x91`$5c\xff\xff\xff\xff\x81\x16\x80\x91\x03a\x051W\x82a\x04\xe2\x92` \x95`\x01\x80`\xa0\x1b\x03\x16\x81R`m\x86R a\x15\xfaV[`\0\x80\xfd[PP4a\x02\x05W\x81`\x03\x196\x01\x12a\x02\x05W`3T\x90Q`\x01`\x01`\xa0\x1b\x03\x90\x91\x16\x81R` \x90\xf3[P4a\x01\xc3W\x82`\x03\x196\x01\x12a\x01\xc3W3\x83R`n` R`\xff\x82\x84 T\x16\x15a\x06]W`eT\x80\x15a\x06JW\x90\x83\x91`\0\x19\x01`eU3\x82R`n` R\x82\x82 `\xff\x19\x81T\x16\x90Ua\x05\xbba\x05\xb63a\x1f\x0fV[a!DV[PP`hT`\x01`\x01`\xa0\x1b\x03\x93\x90\x84\x16\x91\x82;\x15a\x02jW\x83\x92`$\x84\x92\x84Q\x95\x86\x93\x84\x92cQ\xb2zm`\xe1\x1b\x84R3\x90\x84\x01RZ\xf1\x90\x81\x15a\x06AWPa\x06-W[PP`hT\x163\x7f1\xe0\xad\xfe\xc7\x1b\xcc\xee7\xb6\xe8:\x90\xc2\xfe\xdb\x17\xd8\xf1i?\xee\x86<Gq\xe7\xbf\xe2\xae\xd5\x80\x83\x80\xa3\x80\xf3[a\x066\x90a\x0fvV[a\x02\x05W\x818a\x05\xffV[Q=\x84\x82>=\x90\xfd[cNH{q`\xe0\x1b\x84R`\x11\x82R`$\x84\xfd[\x90Qc%\xecl\x1f`\xe0\x1b\x81R\xfd[P4a\x01\xc3W` 6`\x03\x19\x01\x12a\x01\xc3Wa\x06\x85a\x0f\xdcV[\x913\x84R`n` R`\xff\x81\x85 T\x16\x15a\x06\xa5W\x83a\x01n\x843a\x1e|V[Qc%\xecl\x1f`\xe0\x1b\x81R\xfd[\x834a\x03 W\x80`\x03\x196\x01\x12a\x03 Wa\x06\xcba\x12\x03V[`3\x80T`\x01`\x01`\xa0\x1b\x03\x19\x81\x16\x90\x91U`\0\x90`\x01`\x01`\xa0\x1b\x03\x16\x7f\x8b\xe0\x07\x9cS\x16Y\x14\x13D\xcd\x1f\xd0\xa4\xf2\x84\x19I\x7f\x97\"\xa3\xda\xaf\xe3\xb4\x18okdW\xe0\x82\x80\xa3\x80\xf3[P4a\x01\xc3W\x81`\x03\x196\x01\x12a\x01\xc3W\x805\x90`$5\x92`\x01`\x01`@\x1b\x03\x84\x11a\x04\xb8Wa\x07g\x7fq<\xa5;\x88\xd6\xebc\xf5\xb1\x85L\xb8\xcb\xddsn\xc5\x1e\xda\"^Fy\x1a\xa9)\x8b\x01`d\x8f\x92a\x01n\x956\x91\x01a\x0f\xf2V[\x92a\x07pa\x12\x03V[`gT\x90\x80`gU\x82Q\x91\x82R` \x82\x01R\xa1a\x19eV[\x83\x824a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05Wa\x01n\x90a\x07\xa7a\x12\x03V[5a\x19\xbaV[PP4a\x02\x05W\x80`\x03\x196\x01\x12a\x02\x05W` \x91`\x01`\x01`\xa0\x1b\x03\x90a\x02\xa9\x90\x82a\x07\xd8a\x0f\xdcV[\x16\x81R`j\x85R\x83`$5\x91 a\x15\xfaV[P4a\x01\xc3W\x81`\x03\x196\x01\x12a\x01\xc3W\x805`\x01`\x01`@\x1b\x03\x80\x82\x11a\x04\xb8W6`#\x83\x01\x12\x15a\x04\xb8W\x81\x83\x015\x90a\x08%\x82a\x0f\xc5V[\x90a\x082\x86Q\x92\x83a\x0f\xa4V[\x82\x82R` \x80\x83\x01\x94\x85`$\x80\x96`\x05\x1b\x83\x01\x01\x916\x83\x11a\x08\xe1W\x86\x81\x01\x91[\x83\x83\x10a\x08\xb7WPPPPP\x825\x90\x81\x11a\x08\xb3Wa\x08u\x906\x90\x86\x01a\x10\x8eV[PQ\x15a\x08\xa0WPQ\x91\x82Q`eT\x03a\x08\x93W\x83a\x01n\x84a\x19eV[Qc\x16\x9e\xfb[`\xe1\x1b\x81R\xfd[cNH{q`\xe0\x1b`\0\x90\x81R`2\x84R\xfd[\x86\x80\xfd[\x825\x86\x81\x11a\x08\xddW\x85\x91a\x08\xd2\x83\x92\x8b6\x91\x87\x01\x01a\x0f\xf2V[\x81R\x01\x92\x01\x91a\x08SV[\x8c\x80\xfd[\x8a\x80\xfd[PP4a\x02\x05W\x81`\x03\x196\x01\x12a\x02\x05W` \x90`gT\x90Q\x90\x81R\xf3[P\x91\x904a\x02\x05W`\x03\x19\x90\x80\x826\x01\x12a\x01\xc3W\x835\x91`\x01`\x01`@\x1b\x03\x90\x81\x84\x11a\x04\xb8W``\x90\x846\x03\x01\x12a\x02jW\x81Q\x90``\x82\x01\x82\x81\x10\x82\x82\x11\x17a\n\x92W\x83R\x83\x86\x015\x90\x81\x11a\x04\xb8Wa\tf\x90\x866\x91\x86\x01\x01a\x10\x8eV[\x81R` \x81\x01\x90`$\x84\x015\x82R`D\x83\x82\x01\x94\x015\x84R`$5\x95`\x01\x80`\xa0\x1b\x03\x96\x87\x81\x16\x81\x03a\x08\xb3W3\x87R`n` R`\xff\x85\x88 T\x16a\n\x83Wa\t\xe2\x90a\t\xb5`eTa\x16\x84V[`eU3\x88R`n` R\x85\x88 `\x01`\xff\x19\x82T\x16\x17\x90Ua\t\xdaa\x05\xb63a\x1f\x0fV[PP3a\x1e|V[\x86`hT\x16\x92\x83;\x15a\x08\xb3W\x91\x86\x80\x94\x92a\n(\x94\x87Q\x98\x89\x96\x87\x95\x86\x94c\x99&\xee}`\xe0\x1b\x86R3\x90\x86\x01R\x8a`$\x86\x01RQ```D\x86\x01R`\xa4\x85\x01\x90a\x1eWV[\x91Q`d\x84\x01RQ`\x84\x83\x01R\x03\x92Z\xf1\x90\x81\x15a\x06AWPa\ntW[P\x90`hT\x163\x7f\xa4S\xdba*\xf5\x9eU!\xd6\xab\x92\x84\xdc>-\x06\xaf(n\xb1\xb1\xb7\xb7q\xfc\xe4ql\x19\xf2\xc1\x83\x80\xa3\x80\xf3[a\n}\x90a\x0fvV[8a\nFV[P\x83QcB\xeeh\xb5`\xe0\x1b\x81R\xfd[cNH{q`\xe0\x1b\x86R`A\x87R`$\x86\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x91a\x04\xe2\x90\x82\x90`\x01`\x01`\xa0\x1b\x03a\n\xd1a\x0f\xdcV[\x16\x81R`m\x85R a\x141V[PP4a\x02\x05W\x81`\x03\x196\x01\x12a\x02\x05W` \x90a\x04\xe2a\x13\xe2V[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x90a\x04\xe2c\xff\xff\xff\xffa\x0b!a\x10`V[\x16a\x15]V[\x82\x844a\x03 W\x80`\x03\x196\x01\x12a\x03 W``\x82Qa\x0bF\x81a\x0fEV[R\x81Q\x91a\x0bS\x83a\x0fEV[`fTa\x0b_\x81a\x0f\xc5V[\x90a\x0bl\x83Q\x92\x83a\x0f\xa4V[\x80\x82R`f\x84R` \x93`\0\x80Q` a%R\x839\x81Q\x91R\x85\x80\x85\x01[\x84\x84\x10a\x0b\xaaW\x85\x89R\x86Q\x82\x81R\x80a\x0b\xa6\x81\x85\x01\x8ca\x10\xd5V[\x03\x90\xf3[`\x01\x91\x82\x91\x88Qa\x0b\xba\x81a\x0f\x89V[\x85T\x84\x80`\xa0\x1b\x03\x81\x16\x82R`\xa0\x1c\x83\x82\x01R\x81R\x01\x92\x01\x92\x01\x91\x90\x86\x90a\x0b\x8aV[P4a\x01\xc3W\x81`\x03\x196\x01\x12a\x01\xc3W`\x01`\x01`@\x1b\x03\x92`$5\x84\x81\x11a\x02\x05Wa\x0c\x0e\x906\x90\x84\x01a\x10\x8eV[\x93\x84Q\x85\x01` \x95``\x81\x88\x84\x01\x93\x03\x12a\x02jW\x86\x81\x01Q\x83\x81\x11a\x04\xb8W\x81\x01\x91\x80`?\x84\x01\x12\x15a\x04\xb8W\x87\x83\x01Q\x92a\x0cJ\x84a\x0f\xc5V[\x93a\x0cW\x89Q\x95\x86a\x0f\xa4V[\x80\x85R\x88\x8a\x86\x01\x91`\x05\x1b\x83\x01\x01\x91\x83\x83\x11a\x0e\xe2W\x89\x01\x90[\x82\x82\x10a\x0e\xc3WPPP\x86\x82\x01Q\x84\x81\x11a\x0e\xbfW\x82\x01\x90\x80`?\x83\x01\x12\x15a\x0e\xbfW\x88\x82\x01Q\x90a\x0c\xa2\x82a\x0f\xc5V[\x95a\x0c\xaf\x8aQ\x97\x88a\x0f\xa4V[\x82\x87R\x89\x8b\x88\x01\x93`\x05\x1b\x85\x01\x01\x93\x82\x85\x11a\x0e\xbbW\x8a\x81\x01\x93[\x85\x85\x10a\x0eZWPPPPPP``\x01Q\x91c\xff\xff\xff\xff\x83\x16\x80\x93\x03a\x02jW\x81Q\x93\x80\x81\x95\x83Q\x81\x03a\x0eGW\x80\x15a\x0e7W\x91\x90\x81\x93C\x87\x10\x15\x95\x895\x92[\x85\x87\x10a\rvWPPPPPPPa\rfWa\r&\x81a\x14\x92V[\x82\x11a\rVWa\r5\x90a\x15]V[\x11a\rHWPQc\x0b\x13]?`\xe1\x1b\x81R\xf3[\x90Qc\xe1!c/`\xe0\x1b\x81R\xfd[\x83QcK\x05\xa0\xf7`\xe1\x1b\x81R\x83\x90\xfd[\x83Qc\xe6O\x18\x0f`\xe0\x1b\x81R\x83\x90\xfd[`\x01\x80`\xa0\x9b\x93\x94\x95\x96\x97\x98\x9b\x1b\x03\x80a\r\x90\x8c\x86a\x16\x93V[Q\x16\x98a\x0e'W\x80\x89\x91\x8f\x8f\x8d\x90`ja\r\xaf\x93\x87\x8eRR\x8b a\x15\xfaV[\x16\x92\x16\x10\x15a\x0e\x17Wa\r\xce\x90\x85a\r\xc7\x8c\x87a\x16\x93V[Q\x91a#\x0cV[\x15a\x0e\x07W\x90a\r\xffa\r\xf9\x8d\x95\x94\x93a\r\xf3\x8b\x8f`m\x8d\x9a\x8c\x9e\x8dRR\x8a a\x15\xfaV[\x90a\x14oV[\x99a\x16\x84V[\x95\x94\x93a\r\x0bV[\x8aQc\x8b\xaaW\x9f`\xe0\x1b\x81R\x8a\x90\xfd[\x8bQc\xbaP\xf9\x11`\xe0\x1b\x81R\x8b\x90\xfd[\x8cQc\xe6O\x18\x0f`\xe0\x1b\x81R\x8c\x90\xfd[\x88Qc%\x1fV\xa1`\xe2\x1b\x81R\x88\x90\xfd[\x88Q`\x01b\x13\x98\xb9`\xe3\x1b\x03\x19\x81R\x88\x90\xfd[\x84Q\x83\x81\x11a\x08\xe1W\x82\x01\x84`_\x82\x01\x12\x15a\x08\xe1W\x8c\x81\x01Q\x8d\x91a\x0e\x8ba\x0e\x82\x83a\x10sV[\x93Q\x93\x84a\x0f\xa4V[\x81\x83R\x86``\x83\x83\x01\x01\x11a\x08\xddW\x91\x8f\x93\x91a\x0e\xb0\x90\x85\x94``\x86\x85\x01\x91\x01a\x12\xa4V[\x81R\x01\x94\x01\x93a\x0c\xcaV[\x88\x80\xfd[\x85\x80\xfd[\x81Q`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x03a\x0e\xbbW\x81R\x90\x8a\x01\x90\x8a\x01a\x0cqV[\x87\x80\xfd[PP4a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W` \x90a\x04\xe2c\xff\xff\xff\xffa\x0f\x0ca\x10`V[\x16a\x14\x92V[\x83\x824a\x02\x05W` 6`\x03\x19\x01\x12a\x02\x05W\x805`\x01`\x01`@\x1b\x03\x81\x11a\x01\xc3Wa\x01n\x91a\x02e\x916\x91\x01a\x0f\xf2V[` \x81\x01\x90\x81\x10`\x01`\x01`@\x1b\x03\x82\x11\x17a\x0f`W`@RV[cNH{q`\xe0\x1b`\0R`A`\x04R`$`\0\xfd[`\x01`\x01`@\x1b\x03\x81\x11a\x0f`W`@RV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1b\x03\x82\x11\x17a\x0f`W`@RV[\x90`\x1f\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1b\x03\x82\x11\x17a\x0f`W`@RV[`\x01`\x01`@\x1b\x03\x81\x11a\x0f`W`\x05\x1b` \x01\x90V[`\x045\x90`\x01`\x01`\xa0\x1b\x03\x82\x16\x82\x03a\x051WV[\x81`\x1f\x82\x01\x12\x15a\x051W\x805\x91a\x10\t\x83a\x0f\xc5V[\x92a\x10\x17`@Q\x94\x85a\x0f\xa4V[\x80\x84R` \x92\x83\x80\x86\x01\x92`\x05\x1b\x82\x01\x01\x92\x83\x11a\x051W\x83\x01\x90[\x82\x82\x10a\x10AWPPPP\x90V[\x815`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x03a\x051W\x81R\x90\x83\x01\x90\x83\x01a\x103V[`\x045\x90c\xff\xff\xff\xff\x82\x16\x82\x03a\x051WV[`\x01`\x01`@\x1b\x03\x81\x11a\x0f`W`\x1f\x01`\x1f\x19\x16` \x01\x90V[\x81`\x1f\x82\x01\x12\x15a\x051W\x805\x90a\x10\xa5\x82a\x10sV[\x92a\x10\xb3`@Q\x94\x85a\x0f\xa4V[\x82\x84R` \x83\x83\x01\x01\x11a\x051W\x81`\0\x92` \x80\x93\x01\x83\x86\x017\x83\x01\x01R\x90V[\x90` \x91\x82\x82\x01\x90Q\x92\x80\x83R\x83Q\x80\x92R\x80`@\x80\x94\x01\x94\x01\x92`\0\x90[\x83\x82\x10a\x11\x03WPPPPP\x90V[\x84Q\x80Q`\x01`\x01`\xa0\x1b\x03\x16\x87R\x83\x01Q`\x01`\x01``\x1b\x03\x16\x86\x84\x01R\x94\x85\x01\x94\x93\x82\x01\x93`\x01\x90\x91\x01\x90a\x10\xf4V[\x91\x90` \x80\x84\x83\x03\x12a\x051W`@\x80Q\x91a\x11P\x83a\x0fEV[\x82\x95\x805\x90`\x01`\x01`@\x1b\x03\x82\x11a\x051W\x01\x90\x84`\x1f\x83\x01\x12\x15a\x051W\x815a\x11{\x81a\x0f\xc5V[\x95a\x11\x88\x85Q\x97\x88a\x0f\xa4V[\x81\x87R\x82\x80\x88\x01\x92`\x06\x1b\x85\x01\x01\x93\x81\x85\x11a\x051W\x83\x01\x91[\x84\x83\x10a\x11\xb2WPPPPPPRV[\x85\x83\x83\x03\x12a\x051W\x85Q\x90a\x11\xc7\x82a\x0f\x89V[\x835`\x01`\x01`\xa0\x1b\x03\x81\x16\x81\x03a\x051W\x82R\x84\x84\x015\x90`\x01`\x01``\x1b\x03\x82\x16\x82\x03a\x051W\x82\x86\x92\x83\x8a\x95\x01R\x81R\x01\x92\x01\x91a\x11\xa2V[`3T`\x01`\x01`\xa0\x1b\x03\x163\x03a\x12\x17WV[`d`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R` `$\x82\x01R\x7fOwnable: caller is not the owner`D\x82\x01R\xfd[`3\x80T`\x01`\x01`\xa0\x1b\x03\x92\x83\x16`\x01`\x01`\xa0\x1b\x03\x19\x82\x16\x81\x17\x90\x92U\x90\x91\x16\x7f\x8b\xe0\x07\x9cS\x16Y\x14\x13D\xcd\x1f\xd0\xa4\xf2\x84\x19I\x7f\x97\"\xa3\xda\xaf\xe3\xb4\x18okdW\xe0`\0\x80\xa3V[`\0[\x83\x81\x10a\x12\xb7WPP`\0\x91\x01RV[\x81\x81\x01Q\x83\x82\x01R` \x01a\x12\xa7V[`fT\x90a\x12\xd4\x82a\x0f\xc5V[\x91`@a\x12\xe3\x81Q\x94\x85a\x0f\xa4V[\x81\x84R\x83` \x80\x91\x01\x91`f`\0R`\0\x80Q` a%R\x839\x81Q\x91R\x90`\0\x93[\x85\x85\x10a\x13\x15WPPPPPPV[`\x01\x84\x81\x92\x84Qa\x13%\x81a\x0f\x89V[\x86T\x84\x80`\xa0\x1b\x03\x81\x16\x82R`\xa0\x1c\x83\x82\x01R\x81R\x01\x93\x01\x94\x01\x93\x91a\x13\x06V[`lT\x81\x10\x15a\x13}W`l`\0R\x7f+JQ\xabP_\xc9j\tR\xef\xda+\xa6\x1b\xcd0x\xd4\xc0,9\xa1\x86\xec\x16\xf2\x18\x83\xfb\xe0\x16\x01\x90`\0\x90V[cNH{q`\xe0\x1b`\0R`2`\x04R`$`\0\xfd[`kT\x81\x10\x15a\x13}W`k`\0R\x7f\xbdC\xcb\x8e\xce\x8c\xd1\x86;\xcd`\x82\xd6\\[\r%f[\x1c\xe1y\x80\xf0\xdaC\xc0\xedT_\x98\xb4\x01\x90`\0\x90V[\x80T\x82\x10\x15a\x13}W`\0R` `\0 \x01\x90`\0\x90V[`kT`\0\x81a\x13\xfdWPP`\0[`\x01`\x01`\xe0\x1b\x03\x16\x90V[`\0\x19\x82\x01\x91\x82\x11a\x14\x1dWPa\x14\x13\x90a\x13\x93V[PT` \x1ca\x13\xf1V[cNH{q`\xe0\x1b\x81R`\x11`\x04R`$\x90\xfd[\x80T`\0\x92\x91\x81a\x14DWP`\0\x92PPV[`\0\x19\x82\x01\x91\x82\x11a\x14[Wa\x14\x13\x92\x93Pa\x13\xcaV[cNH{q`\xe0\x1b\x84R`\x11`\x04R`$\x84\xfd[\x91\x90\x82\x01\x80\x92\x11a\x14|WV[cNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[C\x81\x10\x15a\x15\x19W`kT\x90`\0\x90[\x82\x82\x10a\x14\xbeWPP`\0\x81\x15`\0\x14a\x13\xfdWP`\0\x91\x90PV[\x90\x91`\x01\x90a\x14\xd3\x81\x85\x18\x83\x1c\x82\x86\x16a\x14oV[\x91\x83c\xff\xff\xff\xffa\x14\xe3\x85a\x13\x93V[PT\x16\x11\x15a\x14\xf6WPP\x91[\x90a\x14\xa2V[\x90\x93P\x81\x01\x80\x91\x11\x15a\x14\xf0WcNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[`d`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R` `$\x82\x01R\x7fCheckpoints: block not yet mined`D\x82\x01R\xfd[C\x81\x10\x15a\x15\x19W`lT\x90`\0\x90[\x82\x82\x10a\x15\x9fWPP`\0\x81\x15`\0\x14a\x15\x89WP`\0\x91\x90PV[`\0\x19\x82\x01\x91\x82\x11a\x14\x1dWPa\x14\x13\x90a\x13FV[\x90\x91`\x01\x90a\x15\xb4\x81\x85\x18\x83\x1c\x82\x86\x16a\x14oV[\x91\x83c\xff\xff\xff\xffa\x15\xc4\x85a\x13FV[PT\x16\x11\x15a\x15\xd7WPP\x91[\x90a\x15mV[\x90\x93P\x81\x01\x80\x91\x11\x15a\x15\xd1WcNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[\x91\x90C\x81\x10\x15a\x15\x19W\x82T\x90`\0\x90[\x82\x82\x10a\x16(WPP`\0\x92\x81\x15`\0\x14a\x14DWP`\0\x92PPV[\x90\x91`\x01\x90a\x16=\x81\x85\x18\x83\x1c\x82\x86\x16a\x14oV[\x91\x83c\xff\xff\xff\xffa\x16N\x85\x8aa\x13\xcaV[PT\x16\x11\x15a\x16aWPP\x91[\x90a\x16\x0bV[\x90\x93P\x81\x01\x80\x91\x11\x15a\x16[WcNH{q`\xe0\x1b`\0R`\x11`\x04R`$`\0\xfd[`\0\x19\x81\x14a\x14|W`\x01\x01\x90V[\x80Q\x82\x10\x15a\x13}W` \x91`\x05\x1b\x01\x01\x90V[a\x16\xafa\x12\xc7V[\x80Q\x90\x92`\0a\x16\xd7a\x16\xc1\x84a\x0f\xc5V[\x93a\x16\xcf`@Q\x95\x86a\x0f\xa4V[\x80\x85Ra\x0f\xc5V[` \x84\x81\x01\x95\x91`\x1f\x19\x016\x877\x82[\x87Q\x81\x10\x15a\x17\x1eWa\x17\x19\x90`\x01`\x01`\xa0\x1b\x03a\x17\x06\x82\x8ba\x16\x93V[QQ\x16a\x17\x13\x82\x89a\x16\x93V[Ra\x16\x84V[a\x16\xe7V[P\x90\x91\x93\x92\x94\x84`@Q\x80\x92c\x90\x04\x13G`\xe0\x1b\x82R`D\x82\x01\x90`\x01\x80`\xa0\x1b\x03\x91\x82`\x04\x98\x16\x88\x85\x01R`$\x98`@\x8a\x86\x01RQ\x80\x91R`d\x84\x01\x91\x90\x85[\x88\x82\x82\x10a\x18\xcdWPPPP\x82\x80\x91\x03\x91\x7f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x16Z\xfa\x90\x81\x15a\x18\xc2W\x85\x91a\x182W[P\x84[\x87Q\x86\x10\x15a\x18\x0fWa\x17\xb8\x86\x83a\x16\x93V[Q\x90`\x01`\x01``\x1b\x03\x84a\x17\xcd\x89\x8ca\x16\x93V[Q\x01Q\x16\x91\x82\x81\x02\x92\x81\x84\x04\x14\x90\x15\x17\x15a\x17\xfbWa\x17\xf5\x91a\x17\xef\x91a\x14oV[\x95a\x16\x84V[\x94a\x17\xa5V[\x85`\x11\x86cNH{q`\xe0\x1b`\0RR`\0\xfd[\x94PPPPPa'\x10\x91\x92P\x04`gT\x81\x10\x15`\0\x14a\x18,W\x90V[P`\0\x90V[\x90P=\x80\x86\x83>a\x18C\x81\x83a\x0f\xa4V[\x81\x01\x90\x82\x81\x83\x03\x12a\x0e\xbfW\x80Q\x90`\x01`\x01`@\x1b\x03\x82\x11a\x08\xb3W\x01\x90\x80`\x1f\x83\x01\x12\x15a\x0e\xbfW\x81Qa\x18x\x81a\x0f\xc5V[\x92a\x18\x86`@Q\x94\x85a\x0f\xa4V[\x81\x84R\x84\x80\x85\x01\x92`\x05\x1b\x82\x01\x01\x92\x83\x11a\x0e\xe2W\x84\x80\x91\x01\x91[\x83\x83\x10a\x18\xb2WPPPP8a\x17\xa2V[\x82Q\x81R\x91\x81\x01\x91\x85\x91\x01a\x18\xa1V[`@Q=\x87\x82>=\x90\xfd[\x83Q\x86\x16\x85R\x8c\x97P\x88\x96P\x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x17_V[\x15a\x18\xf0WV[`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`+`$\x82\x01R\x7fInitializable: contract is not i`D\x82\x01Rjnitializing`\xa8\x1b`d\x82\x01R`\x84\x90\xfd[\x91\x90\x91`\0\x83\x82\x01\x93\x84\x12\x91\x12\x90\x80\x15\x82\x16\x91\x15\x16\x17a\x14|WV[\x90`\0\x80[\x83Q\x82\x10\x15a\x19\xa9Wa\x19\xa3\x90a\x19\x9d\x90a\x19\x97`\x01`\x01`\xa0\x1b\x03a\x19\x90\x86\x89a\x16\x93V[Q\x16a\x1f\x0fV[\x90a\x19IV[\x91a\x16\x84V[\x90a\x19jV[\x90Pa\x19\xb6\x91\x92Pa!DV[PPV[`lT\x90\x81\x15\x15\x80a\x1bsW[\x80a\x1bNW[\x15a\x1a9Wa\x19\xdb\x81a\x1c|V[\x90`\0\x19\x83\x01\x92\x83\x11a\x14|Wa\x1a0` \x92a\x1a\x18\x7f\x93$\xf7\xe5\xa7\xc0(\x88\x08\xa64\xcc\xdeD\xb8\xe9ygdt\xb2.)\xee\x9d\xd5i\xb5^y\x1aK\x95a\x13FV[P\x90c\xff\xff\xff\xff\x82T\x91\x81\x19\x90` \x1b\x16\x91\x16\x17\x90UV[`@Q\x90\x81R\xa1V[c\xff\xff\xff\xff\x90\x81C\x11a\x1a\xfaWa\x1aO\x81a\x1c|V[`@Q\x90a\x1a\\\x82a\x0f\x89V[C\x84\x16\x82R`\x01`\x01`\xe0\x1b\x03\x90\x81\x16` \x83\x01\x90\x81R\x94`\x01`@\x1b\x81\x10\x15a\x0f`W\x80`\x01a\x1a\x90\x92\x01`lUa\x13FV[\x91\x90\x91a\x1a\xe4W\x91Q\x94Qc\xff\xff\xff\xff\x95\x90\x94\x16\x94\x90\x94\x16\x92\x16` \x90\x81\x1bc\xff\xff\xff\xff\x19\x16\x92\x90\x92\x17\x90\x92U\x7f\x93$\xf7\xe5\xa7\xc0(\x88\x08\xa64\xcc\xdeD\xb8\xe9ygdt\xb2.)\xee\x9d\xd5i\xb5^y\x1aK\x91a\x1a0V[cNH{q`\xe0\x1b`\0R`\0`\x04R`$`\0\xfd[`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`&`$\x82\x01R\x7fSafeCast: value doesn't fit in 3`D\x82\x01Re2 bits`\xd0\x1b`d\x82\x01R`\x84\x90\xfd[P`\0\x19\x82\x01\x82\x81\x11a\x14|Wa\x1bic\xff\xff\xff\xff\x91a\x13FV[PT\x16C\x14a\x19\xcdV[`\0\x19\x83\x01\x83\x81\x11a\x14|Wa\x1b\x88\x90a\x13FV[PPa\x19\xc7V[\x91\x90\x91\x80Ta\x1b\x9d\x82a\x141V[\x91\x81\x15\x15\x80a\x1cVW[\x15a\x1b\xd3Wa\x1b\xb5\x85a\x1c|V[\x90`\0\x19\x83\x01\x92\x83\x11a\x14|Wa\x1b\xcf\x92a\x1a\x18\x91a\x13\xcaV[\x91\x90V[\x90c\xff\xff\xff\xff\x90\x81C\x11a\x1a\xfaWa\x1b\xea\x86a\x1c|V[\x90`@Q\x93a\x1b\xf8\x85a\x0f\x89V[C\x84\x16\x85R`\x01`\x01`\xe0\x1b\x03\x92\x83\x16` \x86\x01\x90\x81R\x91`\x01`@\x1b\x81\x10\x15a\x0f`Wa\x1c+\x91`\x01\x82\x01\x81Ua\x13\xcaV[\x93\x90\x93a\x1a\xe4W\x93Q\x90Qc\xff\xff\xff\xff\x91\x90\x94\x16\x16\x92\x16` \x1bc\xff\xff\xff\xff\x19\x16\x91\x90\x91\x17\x90U\x91\x90V[P`\0\x19\x82\x01\x82\x81\x11a\x14|Wa\x1crc\xff\xff\xff\xff\x91\x83a\x13\xcaV[PT\x16C\x14a\x1b\xa7V[`\x01`\x01`\xe0\x1b\x03\x90\x81\x81\x11a\x1c\x90W\x16\x90V[`@QbF\x1b\xcd`\xe5\x1b\x81R` `\x04\x82\x01R`'`$\x82\x01R\x7fSafeCast: value doesn't fit in 2`D\x82\x01Rf24 bits`\xc8\x1b`d\x82\x01R`\x84\x90\xfd[a\x1c\xee\x81a\"\x84V[\x15a\x1eEW`@Q\x90a\x1d\0\x82a\x0fEV[a\x1d\x08a\x12\xc7V[\x82R`f\x90\x81T\x93`\0\x94\x85\x84U\x80a\x1e\x16W[P\x84[\x82Q\x80Q\x82\x10\x15a\x1d\xc0W\x81a\x1d4\x91a\x16\x93V[Q\x84T\x90`\x01`@\x1b\x82\x10\x15a\x1d\xacW`\x01\x82\x01\x80\x87U\x82\x10\x15a\x1d\x98W\x85\x88R\x80Q` \x90\x91\x01Q`\xa0\x1b`\x01`\x01`\xa0\x1b\x03\x19\x16`\x01`\x01`\xa0\x1b\x03\x91\x90\x91\x16\x17`\0\x80Q` a%R\x839\x81Q\x91R\x90\x91\x01Ua\x1d\x93\x90a\x16\x84V[a\x1d\x1fV[cNH{q`\xe0\x1b\x88R`2`\x04R`$\x88\xfd[cNH{q`\xe0\x1b\x88R`A`\x04R`$\x88\xfd[PP\x93Pa\x1e\x03\x91P\x91a\x1e\x11\x7f#\xaa\xd4\xe6\x17D\xec\xe1d\x13\n\xa4\x15\xc1an\x80\x13k\x0f\x07p\xe5e\x89C\x8b\x90\xb2i&^\x93`@Q\x93\x84\x93`@\x85R`@\x85\x01\x90a\x10\xd5V[\x90\x83\x82\x03` \x85\x01Ra\x10\xd5V[\x03\x90\xa1V[\x83\x86R`\0\x80Q` a%R\x839\x81Q\x91R\x90\x81\x01\x90[\x81\x81\x10a\x1e:WPa\x1d\x1cV[\x86\x81U`\x01\x01a\x1e-V[`@Qc\xd1sWy`\xe0\x1b\x81R`\x04\x90\xfd[\x90` \x91a\x1ep\x81Q\x80\x92\x81\x85R\x85\x80\x86\x01\x91\x01a\x12\xa4V[`\x1f\x01`\x1f\x19\x16\x01\x01\x90V[\x90`\x01\x80`\xa0\x1b\x03\x80\x92\x16\x91\x82`\0R`j` R\x80a\x1e\x9f`@`\0 a\x141V[\x16\x91\x16\x91\x81\x83\x14a\x1e\xf1W\x80`\0R`j` Ra\x1e\xc1\x83`@`\0 a\x1b\x8fV[PP`@Q\x91\x82R\x7f\xd0a\x16\x82R\xf4As6X\xf0\x9eM\x8f[-\x99\x8e\xd4\xef$\xa2\xbb\xfdl\xec\xa5.\xa11P\x02` C\x93\xa4V[PPPV[\x81\x81\x03\x92\x91`\0\x13\x80\x15\x82\x85\x13\x16\x91\x84\x12\x16\x17a\x14|WV[`\0\x80\x91`\x01\x80`\xa0\x1b\x03\x81\x16\x91\x82\x81R` \x91`m\x83R`@\x91a\x1f5\x83\x82 a\x141V[\x91\x85\x82R`n\x85R`\xff\x84\x83 T\x16\x15`\0\x14a \xe7WP\x81a\x1fW\x91a\x1e\xf6V[\x94\x85\x15a \xdfW\x84`\0R`m\x84R\x82`\0 \x93\x84T\x94a\x1fw\x81a\x141V[P\x85\x15\x15\x80a \xb9W[\x15a\x1f\xd5W`\0\x19\x86\x01\x95\x86\x11a\x14|W\x7f\x88w\r\xc8b\xe4z~\xd5\x86\x90xW\xeb\x1bu\xe4\xc5\xff\xc8\xb7\x07\xc7\xee\x10\xebt\xd6\x88_\xe5\x94\x95a\x1f\xbd\x91a\x13\xcaV[Pc\xff\xff\xff\xff\x81T\x16\x90U[\x83Q\x92\x83R\x82\x01R\xa2\x90V[c\xff\xff\xff\xff\x95\x86C\x11a fW\x85Q\x91a\x1f\xee\x83a\x0f\x89V[\x87C\x16\x83R\x83\x83\x01\x91`\0\x83R`\x01`@\x1b\x81\x10\x15a\x0f`Wa \x16\x91`\x01\x82\x01\x81Ua\x13\xcaV[\x91\x90\x91a\x1a\xe4W\x91Q\x91Qc\xff\xff\xff\xff\x19` \x91\x90\x91\x1b\x16\x96\x90\x91\x16c\xff\xff\xff\xff\x16\x95\x90\x95\x17\x90\x94U\x7f\x88w\r\xc8b\xe4z~\xd5\x86\x90xW\xeb\x1bu\xe4\xc5\xff\xc8\xb7\x07\xc7\xee\x10\xebt\xd6\x88_\xe5\x94\x93a\x1f\xc9V[\x85QbF\x1b\xcd`\xe5\x1b\x81R`\x04\x81\x01\x84\x90R`&`$\x82\x01R\x7fSafeCast: value doesn't fit in 3`D\x82\x01Re2 bits`\xd0\x1b`d\x82\x01R`\x84\x90\xfd[P`\0\x19\x86\x01\x86\x81\x11a\x14|Wa \xd5c\xff\xff\xff\xff\x91\x83a\x13\xcaV[PT\x16C\x14a\x1f\x81V[PPPPP\x90V[\x90Pa \xf4\x91\x95Pa\x16\xa7V[\x93a \xff\x81\x86a\x1e\xf6V[\x94\x85\x15a \xdfW\x7f\x88w\r\xc8b\xe4z~\xd5\x86\x90xW\xeb\x1bu\xe4\xc5\xff\xc8\xb7\x07\xc7\xee\x10\xebt\xd6\x88_\xe5\x94\x93\x85`\0R`m\x81Ra!=\x82\x85`\0 a\x1b\x8fV[PPa\x1f\xc9V[\x90a!Wa!Pa\x13\xe2V[\x92\x83a\x19IV[\x90`kT\x80\x15\x15\x80a\"hW[\x80a\"CW[\x15a!\xc1Wa!x\x83a\x1c|V[`\0\x19\x82\x01\x91\x82\x11a\x14|Wa\x1a\x18a!\x90\x92a\x13\x93V[\x7f\x86\xdc\xf8k\x12\xdf\xee\xde\xa7J\xe90\r\xbd\xaa\x19;\xcc\xe5\x80\x93i\xc8\x17~\xa2\xf4\xea\xaaer\x9b`@\x80Q\x85\x81R\x84` \x82\x01R\xa1V[c\xff\xff\xff\xff\x80C\x11a\x1a\xfaWa!\xd6\x84a\x1c|V[`@Q\x92a!\xe3\x84a\x0f\x89V[C\x83\x16\x84R`\x01`\x01`\xe0\x1b\x03\x91\x82\x16` \x85\x01\x90\x81R\x90`\x01`@\x1b\x81\x10\x15a\x0f`W\x80`\x01a\"\x17\x92\x01`kUa\x13\x93V[\x93\x90\x93a\x1a\xe4W\x93Q\x90Qc\xff\xff\xff\xff\x91\x90\x94\x16\x16\x92\x16` \x1bc\xff\xff\xff\xff\x19\x16\x91\x90\x91\x17\x90Ua!\x90V[P`\0\x19\x81\x01\x81\x81\x11a\x14|Wa\"^c\xff\xff\xff\xff\x91a\x13\x93V[PT\x16C\x14a!jV[`\0\x19\x82\x01\x82\x81\x11a\x14|Wa\"}\x90a\x13\x93V[PPa!dV[Q\x90`\0\x80\x80[\x84Q\x82\x10\x15a\"\xf4W`\x01`\x01`\xa0\x1b\x03\x90\x81a\"\xa8\x84\x88a\x16\x93V[QQ\x16\x91\x82\x91\x16\x10\x15a\"\xe2Wa\x19\x9da\"\xdb\x91\x93`\x01`\x01``\x1b\x03` a\"\xd1\x86\x8aa\x16\x93V[Q\x01Q\x16\x90a\x14oV[\x90\x91a\"\x8bV[`@Qc\xbaP\xf9\x11`\xe0\x1b\x81R`\x04\x90\xfd[P\x91\x92Pa'\x10\x14\x90Pa#\x07W`\0\x90V[`\x01\x90V[\x91a#\x17\x81\x83a$,V[`\x05\x81\x10\x15a$\x16W\x15\x90\x81a$\0W[Pa#\xf8W`@Qa#l\x81a#^` \x82\x01\x94c\x0b\x13]?`\xe1\x1b\x96\x87\x87R`$\x84\x01R`@`D\x84\x01R`d\x83\x01\x90a\x1eWV[\x03`\x1f\x19\x81\x01\x83R\x82a\x0f\xa4V[`\0\x93\x84\x92\x83\x92Q\x91Z\xfa\x91=\x15a#\xf1W=a#\x88\x81a\x10sV[\x90a#\x96`@Q\x92\x83a\x0f\xa4V[\x81R=\x82` \x83\x01>[\x83a#\xe5W[\x83a#\xb2W[PPP\x90V[\x90\x91\x92P` \x81\x80Q\x81\x01\x03\x12a\x02\x05W` \x01Q`\x01`\x01`\xe0\x1b\x03\x19\x81\x16\x91\x90\x82\x90\x03a\x03 WP\x148\x80\x80a#\xacV[\x80Q` \x14\x93Pa#\xa6V[``a#\xa0V[PPP`\x01\x90V[`\x01`\x01`\xa0\x1b\x03\x85\x81\x16\x91\x16\x14\x90P8a#(V[cNH{q`\xe0\x1b`\0R`!`\x04R`$`\0\xfd[\x81Q`A\x81\x03a$YWP\x90a$U\x91` \x82\x01Q\x90```@\x84\x01Q\x93\x01Q`\0\x1a\x90a$\x9cV[\x90\x91V[`@\x03a$\x92W`@` \x83\x01Q\x92\x01Q\x91\x82`\xff\x1c\x91`\x1b\x83\x01\x80\x93\x11a\x14|Wa$U\x93`\x01`\x01`\xff\x1b\x03\x16\x92`\xff\x16\x90a$\x9cV[PP`\0\x90`\x02\x90V[\x92\x91\x90\x7f\x7f\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]WnsW\xa4P\x1d\xdf\xe9/Fh\x1b \xa0\x83\x11a%EW`\xff\x16`\x1b\x81\x14\x15\x80a%:W[a%.W\x91`\x80\x94\x93\x91` \x93`@Q\x93\x84R\x84\x84\x01R`@\x83\x01R``\x82\x01R`\0\x93\x84\x91\x82\x80R`\x01Z\xfa\x15a%!W\x81Q`\x01`\x01`\xa0\x1b\x03\x81\x16\x15a%\x1bW\x91\x90V[P`\x01\x90V[P`@Q\x90=\x90\x82>=\x90\xfd[PPPP`\0\x90`\x04\x90V[P`\x1c\x81\x14\x15a$\xd4V[PPPP`\0\x90`\x03\x90V\xfeFP\x18y\xb8\xca\x85%\xe8\xc2\xfdQ\x9e/\xbf\xcf\xa2\xeb\xea&P\x12\x94\xaa\x02\xcb\xfc\xfb\x12\xe9CT\xa2dipfsX\"\x12 \x94F\x9dv\x9c\xa0\xfc\x92r\xb4\x8dZ\xa8\xbe\x89i\x8a!\x1b\xb9\x1d\xbc,^\xca\x9e/\xbf\x1da\x18\x1bdsolcC\0\x08\x14\03");
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "```solidity\nstruct Quorum { StrategyParams[] strategies; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct Quorum {
        pub strategies: ::alloy_sol_types::private::Vec<
            <StrategyParams as ::alloy_sol_types::SolType>::RustType,
        >,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Array<StrategyParams>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Vec<
                <StrategyParams as ::alloy_sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Quorum> for UnderlyingRustTuple<'_> {
            fn from(value: Quorum) -> Self {
                (value.strategies,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Quorum {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    strategies: tuple.0,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Quorum {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Quorum {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::Array<StrategyParams> as alloy_sol_types::SolType>::tokenize(&self.strategies),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Quorum {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Quorum {
            const NAME: &'static str = "Quorum";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed("Quorum(StrategyParams[] strategies)")
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components.push(<StrategyParams as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<StrategyParams as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                <::alloy_sol_types::sol_data::Array<StrategyParams> as alloy_sol_types::SolType>::eip712_data_word(&self.strategies).0.to_vec()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Quorum {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Array<StrategyParams> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.strategies)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Array<StrategyParams> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.strategies, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "```solidity\nstruct SignatureWithSaltAndExpiry { bytes signature; bytes32 salt; uint256 expiry; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct SignatureWithSaltAndExpiry {
        pub signature: ::alloy_sol_types::private::Bytes,
        pub salt: ::alloy_sol_types::private::FixedBytes<32>,
        pub expiry: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Bytes,
            ::alloy_sol_types::sol_data::FixedBytes<32>,
            ::alloy_sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Bytes,
            ::alloy_sol_types::private::FixedBytes<32>,
            ::alloy_sol_types::private::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SignatureWithSaltAndExpiry> for UnderlyingRustTuple<'_> {
            fn from(value: SignatureWithSaltAndExpiry) -> Self {
                (value.signature, value.salt, value.expiry)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SignatureWithSaltAndExpiry {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    signature: tuple.0,
                    salt: tuple.1,
                    expiry: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SignatureWithSaltAndExpiry {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SignatureWithSaltAndExpiry {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (<::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(&self.signature), <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self.salt), <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self.expiry),)
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SignatureWithSaltAndExpiry {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SignatureWithSaltAndExpiry {
            const NAME: &'static str = "SignatureWithSaltAndExpiry";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SignatureWithSaltAndExpiry(bytes signature,bytes32 salt,uint256 expiry)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(&self.signature).0, <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::eip712_data_word(&self.salt).0, <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::eip712_data_word(&self.expiry).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SignatureWithSaltAndExpiry {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.signature) + <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.salt) + <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.expiry)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.signature, out);
                <::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.salt, out);
                <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.expiry, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "```solidity\nstruct StrategyParams { address strategy; uint96 multiplier; }\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct StrategyParams {
        pub strategy: ::alloy_sol_types::private::Address,
        pub multiplier:
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            ::alloy_sol_types::sol_data::Address,
            ::alloy_sol_types::sol_data::Uint<96>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            ::alloy_sol_types::private::Address,
            <::alloy_sol_types::sol_data::Uint<96> as ::alloy_sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<StrategyParams> for UnderlyingRustTuple<'_> {
            fn from(value: StrategyParams) -> Self {
                (value.strategy, value.multiplier)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for StrategyParams {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    strategy: tuple.0,
                    multiplier: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for StrategyParams {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for StrategyParams {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.strategy,
                    ),
                    <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::SolType>::tokenize(
                        &self.multiplier,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_encode_packed_to(
                    &tuple, out,
                )
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple =
                    <UnderlyingRustTuple<'_> as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::abi_packed_encoded_size(
                    &tuple,
                )
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for StrategyParams {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> =
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for StrategyParams {
            const NAME: &'static str = "StrategyParams";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "StrategyParams(address strategy,uint96 multiplier)",
                )
            }
            #[inline]
            fn eip712_components(
            ) -> alloy_sol_types::private::Vec<alloy_sol_types::private::Cow<'static, str>>
            {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [<::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(&self.strategy).0, <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::SolType>::eip712_data_word(&self.multiplier).0, ].concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for StrategyParams {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize + <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.strategy) + <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.multiplier)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(<Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust));
                <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.strategy, out);
                <::alloy_sol_types::sol_data::Uint<96> as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.multiplier, out);
            }
            #[inline]
            fn encode_topic(rust: &Self::RustType) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, &mut out);
                alloy_sol_types::abi::token::WordToken(alloy_sol_types::private::keccak256(out))
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `InsufficientSignedStake()` and selector `0xe121632f`.\n```solidity\nerror InsufficientSignedStake();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InsufficientSignedStake {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientSignedStake> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientSignedStake) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientSignedStake {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientSignedStake {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientSignedStake()";
            const SELECTOR: [u8; 4] = [225u8, 33u8, 99u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `InsufficientWeight()` and selector `0xa8792fd1`.\n```solidity\nerror InsufficientWeight();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InsufficientWeight {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientWeight> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientWeight) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientWeight {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientWeight {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientWeight()";
            const SELECTOR: [u8; 4] = [168u8, 121u8, 47u8, 209u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `InvalidLength()` and selector `0x947d5a84`.\n```solidity\nerror InvalidLength();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidLength {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidLength> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidLength) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidLength()";
            const SELECTOR: [u8; 4] = [148u8, 125u8, 90u8, 132u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `InvalidQuorum()` and selector `0xd1735779`.\n```solidity\nerror InvalidQuorum();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidQuorum {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidQuorum> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidQuorum) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidQuorum {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidQuorum {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidQuorum()";
            const SELECTOR: [u8; 4] = [209u8, 115u8, 87u8, 121u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `InvalidReferenceBlock()` and selector `0xe64f180f`.\n```solidity\nerror InvalidReferenceBlock();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidReferenceBlock {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidReferenceBlock> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidReferenceBlock) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidReferenceBlock {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidReferenceBlock {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidReferenceBlock()";
            const SELECTOR: [u8; 4] = [230u8, 79u8, 24u8, 15u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `InvalidSignature()` and selector `0x8baa579f`.\n```solidity\nerror InvalidSignature();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidSignature {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSignature()";
            const SELECTOR: [u8; 4] = [139u8, 170u8, 87u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `InvalidSignedWeight()` and selector `0x960b41ee`.\n```solidity\nerror InvalidSignedWeight();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidSignedWeight {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSignedWeight> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSignedWeight) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSignedWeight {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSignedWeight {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSignedWeight()";
            const SELECTOR: [u8; 4] = [150u8, 11u8, 65u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `InvalidThreshold()` and selector `0xaabd5a09`.\n```solidity\nerror InvalidThreshold();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct InvalidThreshold {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidThreshold> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidThreshold) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidThreshold {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidThreshold {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidThreshold()";
            const SELECTOR: [u8; 4] = [170u8, 189u8, 90u8, 9u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `LengthMismatch()` and selector `0xff633a38`.\n```solidity\nerror LengthMismatch();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct LengthMismatch {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LengthMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: LengthMismatch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LengthMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LengthMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LengthMismatch()";
            const SELECTOR: [u8; 4] = [255u8, 99u8, 58u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `MustUpdateAllOperators()` and selector `0x2d3df6b6`.\n```solidity\nerror MustUpdateAllOperators();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct MustUpdateAllOperators {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MustUpdateAllOperators> for UnderlyingRustTuple<'_> {
            fn from(value: MustUpdateAllOperators) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MustUpdateAllOperators {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MustUpdateAllOperators {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MustUpdateAllOperators()";
            const SELECTOR: [u8; 4] = [45u8, 61u8, 246u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `NotSorted()` and selector `0xba50f911`.\n```solidity\nerror NotSorted();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct NotSorted {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotSorted> for UnderlyingRustTuple<'_> {
            fn from(value: NotSorted) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotSorted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotSorted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotSorted()";
            const SELECTOR: [u8; 4] = [186u8, 80u8, 249u8, 17u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `OperatorAlreadyRegistered()` and selector `0x42ee68b5`.\n```solidity\nerror OperatorAlreadyRegistered();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OperatorAlreadyRegistered {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorAlreadyRegistered> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorAlreadyRegistered) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorAlreadyRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorAlreadyRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorAlreadyRegistered()";
            const SELECTOR: [u8; 4] = [66u8, 238u8, 104u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Custom error with signature `OperatorNotRegistered()` and selector `0x25ec6c1f`.\n```solidity\nerror OperatorNotRegistered();\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct OperatorNotRegistered {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorNotRegistered> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorNotRegistered) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorNotRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorNotRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorNotRegistered()";
            const SELECTOR: [u8; 4] = [37u8, 236u8, 108u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `Initialized(uint8)` and selector `0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498`.\n```solidity\nevent Initialized(uint8 version);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u8,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<8>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint8)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    127u8, 38u8, 184u8, 63u8, 249u8, 110u8, 31u8, 43u8, 106u8, 104u8, 47u8, 19u8,
                    56u8, 82u8, 246u8, 121u8, 138u8, 9u8, 196u8, 101u8, 218u8, 149u8, 146u8, 20u8,
                    96u8, 206u8, 251u8, 56u8, 71u8, 64u8, 36u8, 152u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<8> as alloy_sol_types::SolType>::tokenize(
                        &self.version,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `MinimumWeightUpdated(uint256,uint256)` and selector `0x713ca53b88d6eb63f5b1854cb8cbdd736ec51eda225e46791aa9298b0160648f`.\n```solidity\nevent MinimumWeightUpdated(uint256 _old, uint256 _new);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct MinimumWeightUpdated {
        #[allow(missing_docs)]
        pub _old: ::alloy_sol_types::private::U256,
        #[allow(missing_docs)]
        pub _new: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for MinimumWeightUpdated {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "MinimumWeightUpdated(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    113u8, 60u8, 165u8, 59u8, 136u8, 214u8, 235u8, 99u8, 245u8, 177u8, 133u8, 76u8,
                    184u8, 203u8, 221u8, 115u8, 110u8, 197u8, 30u8, 218u8, 34u8, 94u8, 70u8, 121u8,
                    26u8, 169u8, 41u8, 139u8, 1u8, 96u8, 100u8, 143u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    _old: data.0,
                    _new: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._old,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._new,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for MinimumWeightUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&MinimumWeightUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &MinimumWeightUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `OperatorDeregistered(address,address)` and selector `0x31e0adfec71bccee37b6e83a90c2fedb17d8f1693fee863c4771e7bfe2aed580`.\n```solidity\nevent OperatorDeregistered(address indexed _operator, address indexed _avs);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorDeregistered {
        #[allow(missing_docs)]
        pub _operator: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub _avs: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorDeregistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorDeregistered(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    49u8, 224u8, 173u8, 254u8, 199u8, 27u8, 204u8, 238u8, 55u8, 182u8, 232u8, 58u8,
                    144u8, 194u8, 254u8, 219u8, 23u8, 216u8, 241u8, 105u8, 63u8, 238u8, 134u8,
                    60u8, 71u8, 113u8, 231u8, 191u8, 226u8, 174u8, 213u8, 128u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    _operator: topics.1,
                    _avs: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self._operator.clone(),
                    self._avs.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._operator);
                out[2usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._avs);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorDeregistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorDeregistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorDeregistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `OperatorRegistered(address,address)` and selector `0xa453db612af59e5521d6ab9284dc3e2d06af286eb1b1b7b771fce4716c19f2c1`.\n```solidity\nevent OperatorRegistered(address indexed _operator, address indexed _avs);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorRegistered {
        #[allow(missing_docs)]
        pub _operator: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub _avs: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorRegistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorRegistered(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    164u8, 83u8, 219u8, 97u8, 42u8, 245u8, 158u8, 85u8, 33u8, 214u8, 171u8, 146u8,
                    132u8, 220u8, 62u8, 45u8, 6u8, 175u8, 40u8, 110u8, 177u8, 177u8, 183u8, 183u8,
                    113u8, 252u8, 228u8, 113u8, 108u8, 25u8, 242u8, 193u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    _operator: topics.1,
                    _avs: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self._operator.clone(),
                    self._avs.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._operator);
                out[2usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._avs);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `OperatorWeightUpdated(address,uint256,uint256)` and selector `0x88770dc862e47a7ed586907857eb1b75e4c5ffc8b707c7ee10eb74d6885fe594`.\n```solidity\nevent OperatorWeightUpdated(address indexed _operator, uint256 oldWeight, uint256 newWeight);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OperatorWeightUpdated {
        #[allow(missing_docs)]
        pub _operator: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub oldWeight: ::alloy_sol_types::private::U256,
        #[allow(missing_docs)]
        pub newWeight: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorWeightUpdated {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorWeightUpdated(address,uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    136u8, 119u8, 13u8, 200u8, 98u8, 228u8, 122u8, 126u8, 213u8, 134u8, 144u8,
                    120u8, 87u8, 235u8, 27u8, 117u8, 228u8, 197u8, 255u8, 200u8, 183u8, 7u8, 199u8,
                    238u8, 16u8, 235u8, 116u8, 214u8, 136u8, 95u8, 229u8, 148u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    _operator: topics.1,
                    oldWeight: data.0,
                    newWeight: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.oldWeight,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newWeight,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self._operator.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self._operator);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorWeightUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorWeightUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorWeightUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `OwnershipTransferred(address,address)` and selector `0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0`.\n```solidity\nevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct OwnershipTransferred {
        #[allow(missing_docs)]
        pub previousOwner: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub newOwner: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OwnershipTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OwnershipTransferred(address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8, 31u8,
                    208u8, 164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8, 218u8,
                    175u8, 227u8, 180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    previousOwner: topics.1,
                    newOwner: topics.2,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.previousOwner.clone(),
                    self.newOwner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.previousOwner);
                out[2usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.newOwner);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OwnershipTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OwnershipTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OwnershipTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `QuorumUpdated(((address,uint96)[]),((address,uint96)[]))` and selector `0x23aad4e61744ece164130aa415c1616e80136b0f0770e56589438b90b269265e`.\n```solidity\nevent QuorumUpdated(Quorum _old, Quorum _new);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct QuorumUpdated {
        #[allow(missing_docs)]
        pub _old: <Quorum as ::alloy_sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub _new: <Quorum as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for QuorumUpdated {
            type DataTuple<'a> = (Quorum, Quorum);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str =
                "QuorumUpdated(((address,uint96)[]),((address,uint96)[]))";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    35u8, 170u8, 212u8, 230u8, 23u8, 68u8, 236u8, 225u8, 100u8, 19u8, 10u8, 164u8,
                    21u8, 193u8, 97u8, 110u8, 128u8, 19u8, 107u8, 15u8, 7u8, 112u8, 229u8, 101u8,
                    137u8, 67u8, 139u8, 144u8, 178u8, 105u8, 38u8, 94u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    _old: data.0,
                    _new: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <Quorum as alloy_sol_types::SolType>::tokenize(&self._old),
                    <Quorum as alloy_sol_types::SolType>::tokenize(&self._new),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for QuorumUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&QuorumUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &QuorumUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `SigningKeyUpdate(address,uint256,address,address)` and selector `0xd061168252f441733658f09e4d8f5b2d998ed4ef24a2bbfd6ceca52ea1315002`.\n```solidity\nevent SigningKeyUpdate(address indexed operator, uint256 indexed updateBlock, address indexed newSigningKey, address oldSigningKey);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct SigningKeyUpdate {
        #[allow(missing_docs)]
        pub operator: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub updateBlock: ::alloy_sol_types::private::U256,
        #[allow(missing_docs)]
        pub newSigningKey: ::alloy_sol_types::private::Address,
        #[allow(missing_docs)]
        pub oldSigningKey: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SigningKeyUpdate {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SigningKeyUpdate(address,uint256,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    208u8, 97u8, 22u8, 130u8, 82u8, 244u8, 65u8, 115u8, 54u8, 88u8, 240u8, 158u8,
                    77u8, 143u8, 91u8, 45u8, 153u8, 142u8, 212u8, 239u8, 36u8, 162u8, 187u8, 253u8,
                    108u8, 236u8, 165u8, 46u8, 161u8, 49u8, 80u8, 2u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    updateBlock: topics.2,
                    newSigningKey: topics.3,
                    oldSigningKey: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.oldSigningKey,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.updateBlock.clone(),
                    self.newSigningKey.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                out[1usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.operator);
                out[2usize] = <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::EventTopic>::encode_topic(&self.updateBlock);
                out[3usize] = <::alloy_sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(&self.newSigningKey);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SigningKeyUpdate {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SigningKeyUpdate> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SigningKeyUpdate) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `ThresholdWeightUpdated(uint256)` and selector `0x9324f7e5a7c0288808a634ccde44b8e979676474b22e29ee9dd569b55e791a4b`.\n```solidity\nevent ThresholdWeightUpdated(uint256 _thresholdWeight);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct ThresholdWeightUpdated {
        #[allow(missing_docs)]
        pub _thresholdWeight: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ThresholdWeightUpdated {
            type DataTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "ThresholdWeightUpdated(uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    147u8, 36u8, 247u8, 229u8, 167u8, 192u8, 40u8, 136u8, 8u8, 166u8, 52u8, 204u8,
                    222u8, 68u8, 184u8, 233u8, 121u8, 103u8, 100u8, 116u8, 178u8, 46u8, 41u8,
                    238u8, 157u8, 213u8, 105u8, 181u8, 94u8, 121u8, 26u8, 75u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    _thresholdWeight: data.0,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._thresholdWeight,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ThresholdWeightUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ThresholdWeightUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ThresholdWeightUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `TotalWeightUpdated(uint256,uint256)` and selector `0x86dcf86b12dfeedea74ae9300dbdaa193bcce5809369c8177ea2f4eaaa65729b`.\n```solidity\nevent TotalWeightUpdated(uint256 oldTotalWeight, uint256 newTotalWeight);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct TotalWeightUpdated {
        #[allow(missing_docs)]
        pub oldTotalWeight: ::alloy_sol_types::private::U256,
        #[allow(missing_docs)]
        pub newTotalWeight: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for TotalWeightUpdated {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "TotalWeightUpdated(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    134u8, 220u8, 248u8, 107u8, 18u8, 223u8, 238u8, 222u8, 167u8, 74u8, 233u8,
                    48u8, 13u8, 189u8, 170u8, 25u8, 59u8, 204u8, 229u8, 128u8, 147u8, 105u8, 200u8,
                    23u8, 126u8, 162u8, 244u8, 234u8, 170u8, 101u8, 114u8, 155u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldTotalWeight: data.0,
                    newTotalWeight: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.oldTotalWeight,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newTotalWeight,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for TotalWeightUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&TotalWeightUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &TotalWeightUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Event with signature `UpdateMinimumWeight(uint256,uint256)` and selector `0x1ea42186b305fa37310450d9fb87ea1e8f0c7f447e771479e3b27634bfe84dc1`.\n```solidity\nevent UpdateMinimumWeight(uint256 oldMinimumWeight, uint256 newMinimumWeight);\n```"]
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    #[derive(Clone)]
    pub struct UpdateMinimumWeight {
        #[allow(missing_docs)]
        pub oldMinimumWeight: ::alloy_sol_types::private::U256,
        #[allow(missing_docs)]
        pub newMinimumWeight: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for UpdateMinimumWeight {
            type DataTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type DataToken<'a> = <Self::DataTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "UpdateMinimumWeight(uint256,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 =
                alloy_sol_types::private::B256::new([
                    30u8, 164u8, 33u8, 134u8, 179u8, 5u8, 250u8, 55u8, 49u8, 4u8, 80u8, 217u8,
                    251u8, 135u8, 234u8, 30u8, 143u8, 12u8, 127u8, 68u8, 126u8, 119u8, 20u8, 121u8,
                    227u8, 178u8, 118u8, 52u8, 191u8, 232u8, 77u8, 193u8,
                ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    oldMinimumWeight: data.0,
                    newMinimumWeight: data.1,
                }
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.oldMinimumWeight,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self.newMinimumWeight,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(Self::SIGNATURE_HASH);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for UpdateMinimumWeight {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&UpdateMinimumWeight> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &UpdateMinimumWeight) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Constructor`.\n```solidity\nconstructor(address _delegationManager);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct constructorCall {
        pub _delegationManager: ::alloy_sol_types::private::Address,
    }
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<constructorCall> for UnderlyingRustTuple<'_> {
                fn from(value: constructorCall) -> Self {
                    (value._delegationManager,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for constructorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _delegationManager: tuple.0,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolConstructor for constructorCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._delegationManager,
                    ),
                )
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `deregisterOperator()` and selector `0x857dc190`.\n```solidity\nfunction deregisterOperator() external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct deregisterOperatorCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`deregisterOperator()`](deregisterOperatorCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct deregisterOperatorReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deregisterOperatorCall> for UnderlyingRustTuple<'_> {
                fn from(value: deregisterOperatorCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deregisterOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deregisterOperatorReturn> for UnderlyingRustTuple<'_> {
                fn from(value: deregisterOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for deregisterOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deregisterOperatorCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = deregisterOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deregisterOperator()";
            const SELECTOR: [u8; 4] = [133u8, 125u8, 193u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getLastCheckpointOperatorWeight(address)` and selector `0x3b242e4a`.\n```solidity\nfunction getLastCheckpointOperatorWeight(address _operator) external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointOperatorWeightCall {
        pub _operator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getLastCheckpointOperatorWeight(address)`](getLastCheckpointOperatorWeightCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointOperatorWeightReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointOperatorWeightCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLastCheckpointOperatorWeightCall) -> Self {
                    (value._operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastCheckpointOperatorWeightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointOperatorWeightReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLastCheckpointOperatorWeightReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastCheckpointOperatorWeightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastCheckpointOperatorWeightCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLastCheckpointOperatorWeightReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastCheckpointOperatorWeight(address)";
            const SELECTOR: [u8; 4] = [59u8, 36u8, 46u8, 74u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getLastCheckpointThresholdWeight()` and selector `0xb933fa74`.\n```solidity\nfunction getLastCheckpointThresholdWeight() external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointThresholdWeightCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getLastCheckpointThresholdWeight()`](getLastCheckpointThresholdWeightCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointThresholdWeightReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointThresholdWeightCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLastCheckpointThresholdWeightCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastCheckpointThresholdWeightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointThresholdWeightReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLastCheckpointThresholdWeightReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastCheckpointThresholdWeightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastCheckpointThresholdWeightCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLastCheckpointThresholdWeightReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastCheckpointThresholdWeight()";
            const SELECTOR: [u8; 4] = [185u8, 51u8, 250u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getLastCheckpointThresholdWeightAtBlock(uint32)` and selector `0x1e4cd85e`.\n```solidity\nfunction getLastCheckpointThresholdWeightAtBlock(uint32 _blockNumber) external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointThresholdWeightAtBlockCall {
        pub _blockNumber: u32,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getLastCheckpointThresholdWeightAtBlock(uint32)`](getLastCheckpointThresholdWeightAtBlockCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointThresholdWeightAtBlockReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointThresholdWeightAtBlockCall>
                for UnderlyingRustTuple<'_>
            {
                fn from(value: getLastCheckpointThresholdWeightAtBlockCall) -> Self {
                    (value._blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
                for getLastCheckpointThresholdWeightAtBlockCall
            {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _blockNumber: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointThresholdWeightAtBlockReturn>
                for UnderlyingRustTuple<'_>
            {
                fn from(value: getLastCheckpointThresholdWeightAtBlockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
                for getLastCheckpointThresholdWeightAtBlockReturn
            {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastCheckpointThresholdWeightAtBlockCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLastCheckpointThresholdWeightAtBlockReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastCheckpointThresholdWeightAtBlock(uint32)";
            const SELECTOR: [u8; 4] = [30u8, 76u8, 216u8, 94u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self._blockNumber,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getLastCheckpointTotalWeight()` and selector `0x314f3a49`.\n```solidity\nfunction getLastCheckpointTotalWeight() external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointTotalWeightCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getLastCheckpointTotalWeight()`](getLastCheckpointTotalWeightCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointTotalWeightReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointTotalWeightCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLastCheckpointTotalWeightCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastCheckpointTotalWeightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointTotalWeightReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLastCheckpointTotalWeightReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastCheckpointTotalWeightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastCheckpointTotalWeightCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLastCheckpointTotalWeightReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastCheckpointTotalWeight()";
            const SELECTOR: [u8; 4] = [49u8, 79u8, 58u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getLastCheckpointTotalWeightAtBlock(uint32)` and selector `0x0dba3394`.\n```solidity\nfunction getLastCheckpointTotalWeightAtBlock(uint32 _blockNumber) external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointTotalWeightAtBlockCall {
        pub _blockNumber: u32,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getLastCheckpointTotalWeightAtBlock(uint32)`](getLastCheckpointTotalWeightAtBlockCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastCheckpointTotalWeightAtBlockReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u32,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointTotalWeightAtBlockCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLastCheckpointTotalWeightAtBlockCall) -> Self {
                    (value._blockNumber,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastCheckpointTotalWeightAtBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _blockNumber: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastCheckpointTotalWeightAtBlockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLastCheckpointTotalWeightAtBlockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastCheckpointTotalWeightAtBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastCheckpointTotalWeightAtBlockCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<32>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLastCheckpointTotalWeightAtBlockReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastCheckpointTotalWeightAtBlock(uint32)";
            const SELECTOR: [u8; 4] = [13u8, 186u8, 51u8, 148u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self._blockNumber,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getLastestOperatorSigningKey(address)` and selector `0xcdcd3581`.\n```solidity\nfunction getLastestOperatorSigningKey(address _operator) external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastestOperatorSigningKeyCall {
        pub _operator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getLastestOperatorSigningKey(address)`](getLastestOperatorSigningKeyCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getLastestOperatorSigningKeyReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastestOperatorSigningKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: getLastestOperatorSigningKeyCall) -> Self {
                    (value._operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastestOperatorSigningKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getLastestOperatorSigningKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getLastestOperatorSigningKeyReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getLastestOperatorSigningKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getLastestOperatorSigningKeyCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getLastestOperatorSigningKeyReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getLastestOperatorSigningKey(address)";
            const SELECTOR: [u8; 4] = [205u8, 205u8, 53u8, 129u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getOperatorSigningKeyAtBlock(address,uint256)` and selector `0x5e1042e8`.\n```solidity\nfunction getOperatorSigningKeyAtBlock(address _operator, uint256 _blockNumber) external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorSigningKeyAtBlockCall {
        pub _operator: ::alloy_sol_types::private::Address,
        pub _blockNumber: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getOperatorSigningKeyAtBlock(address,uint256)`](getOperatorSigningKeyAtBlockCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorSigningKeyAtBlockReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorSigningKeyAtBlockCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorSigningKeyAtBlockCall) -> Self {
                    (value._operator, value._blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorSigningKeyAtBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _operator: tuple.0,
                        _blockNumber: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorSigningKeyAtBlockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorSigningKeyAtBlockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorSigningKeyAtBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorSigningKeyAtBlockCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorSigningKeyAtBlockReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorSigningKeyAtBlock(address,uint256)";
            const SELECTOR: [u8; 4] = [94u8, 16u8, 66u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._operator,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._blockNumber,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getOperatorWeight(address)` and selector `0x98ec1ac9`.\n```solidity\nfunction getOperatorWeight(address _operator) external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorWeightCall {
        pub _operator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getOperatorWeight(address)`](getOperatorWeightCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorWeightReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorWeightCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorWeightCall) -> Self {
                    (value._operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorWeightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorWeightReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorWeightReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorWeightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorWeightCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorWeightReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorWeight(address)";
            const SELECTOR: [u8; 4] = [152u8, 236u8, 26u8, 201u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `getOperatorWeightAtBlock(address,uint32)` and selector `0x955f2d90`.\n```solidity\nfunction getOperatorWeightAtBlock(address _operator, uint32 _blockNumber) external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorWeightAtBlockCall {
        pub _operator: ::alloy_sol_types::private::Address,
        pub _blockNumber: u32,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`getOperatorWeightAtBlock(address,uint32)`](getOperatorWeightAtBlockCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct getOperatorWeightAtBlockReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address, u32);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorWeightAtBlockCall> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorWeightAtBlockCall) -> Self {
                    (value._operator, value._blockNumber)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorWeightAtBlockCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _operator: tuple.0,
                        _blockNumber: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorWeightAtBlockReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorWeightAtBlockReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getOperatorWeightAtBlockReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorWeightAtBlockCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<32>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorWeightAtBlockReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorWeightAtBlock(address,uint32)";
            const SELECTOR: [u8; 4] = [149u8, 95u8, 45u8, 144u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._operator,
                    ),
                    <::alloy_sol_types::sol_data::Uint<32> as alloy_sol_types::SolType>::tokenize(
                        &self._blockNumber,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `initialize(address,uint256,((address,uint96)[]))` and selector `0xab118995`.\n```solidity\nfunction initialize(address _serviceManager, uint256 _thresholdWeight, Quorum memory _quorum) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeCall {
        pub _serviceManager: ::alloy_sol_types::private::Address,
        pub _thresholdWeight: ::alloy_sol_types::private::U256,
        pub _quorum: <Quorum as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`initialize(address,uint256,((address,uint96)[]))`](initializeCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
                Quorum,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Address,
                ::alloy_sol_types::private::U256,
                <Quorum as ::alloy_sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value._serviceManager, value._thresholdWeight, value._quorum)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _serviceManager: tuple.0,
                        _thresholdWeight: tuple.1,
                        _quorum: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Address,
                ::alloy_sol_types::sol_data::Uint<256>,
                Quorum,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,uint256,((address,uint96)[]))";
            const SELECTOR: [u8; 4] = [171u8, 17u8, 137u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._serviceManager,
                    ),
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._thresholdWeight,
                    ),
                    <Quorum as alloy_sol_types::SolType>::tokenize(&self._quorum),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `isValidSignature(bytes32,bytes)` and selector `0x1626ba7e`.\n```solidity\nfunction isValidSignature(bytes32 _dataHash, bytes memory _signatureData) external view returns (bytes4);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct isValidSignatureCall {
        pub _dataHash: ::alloy_sol_types::private::FixedBytes<32>,
        pub _signatureData: ::alloy_sol_types::private::Bytes,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`isValidSignature(bytes32,bytes)`](isValidSignatureCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct isValidSignatureReturn {
        pub _0: ::alloy_sol_types::private::FixedBytes<4>,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::FixedBytes<32>,
                ::alloy_sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isValidSignatureCall> for UnderlyingRustTuple<'_> {
                fn from(value: isValidSignatureCall) -> Self {
                    (value._dataHash, value._signatureData)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isValidSignatureCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _dataHash: tuple.0,
                        _signatureData: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isValidSignatureReturn> for UnderlyingRustTuple<'_> {
                fn from(value: isValidSignatureReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isValidSignatureReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isValidSignatureCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::FixedBytes<32>,
                ::alloy_sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = isValidSignatureReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::FixedBytes<4>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isValidSignature(bytes32,bytes)";
            const SELECTOR: [u8; 4] = [22u8, 38u8, 186u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::FixedBytes<32> as alloy_sol_types::SolType>::tokenize(&self._dataHash), <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(&self._signatureData),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `minimumWeight()` and selector `0x40bf2fb7`.\n```solidity\nfunction minimumWeight() external view returns (uint256);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct minimumWeightCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`minimumWeight()`](minimumWeightCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct minimumWeightReturn {
        pub _0: ::alloy_sol_types::private::U256,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<minimumWeightCall> for UnderlyingRustTuple<'_> {
                fn from(value: minimumWeightCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for minimumWeightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<minimumWeightReturn> for UnderlyingRustTuple<'_> {
                fn from(value: minimumWeightReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for minimumWeightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for minimumWeightCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = minimumWeightReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "minimumWeight()";
            const SELECTOR: [u8; 4] = [64u8, 191u8, 47u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `operatorRegistered(address)` and selector `0xec7fbb31`.\n```solidity\nfunction operatorRegistered(address _operator) external view returns (bool);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct operatorRegisteredCall {
        pub _operator: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`operatorRegistered(address)`](operatorRegisteredCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct operatorRegisteredReturn {
        pub _0: bool,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorRegisteredCall> for UnderlyingRustTuple<'_> {
                fn from(value: operatorRegisteredCall) -> Self {
                    (value._operator,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for operatorRegisteredCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _operator: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorRegisteredReturn> for UnderlyingRustTuple<'_> {
                fn from(value: operatorRegisteredReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for operatorRegisteredReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for operatorRegisteredCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = operatorRegisteredReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "operatorRegistered(address)";
            const SELECTOR: [u8; 4] = [236u8, 127u8, 187u8, 49u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._operator,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `owner()` and selector `0x8da5cb5b`.\n```solidity\nfunction owner() external view returns (address);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`owner()`](ownerCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct ownerReturn {
        pub _0: ::alloy_sol_types::private::Address,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerCall> for UnderlyingRustTuple<'_> {
                fn from(value: ownerCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ownerReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ownerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ownerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ownerCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = ownerReturn;
            type ReturnTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "owner()";
            const SELECTOR: [u8; 4] = [141u8, 165u8, 203u8, 91u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `quorum()` and selector `0x1703a018`.\n```solidity\nfunction quorum() external view returns (Quorum memory);\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct quorumCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`quorum()`](quorumCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct quorumReturn {
        pub _0: <Quorum as ::alloy_sol_types::SolType>::RustType,
    }
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<quorumCall> for UnderlyingRustTuple<'_> {
                fn from(value: quorumCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for quorumCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Quorum,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (<Quorum as ::alloy_sol_types::SolType>::RustType,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<quorumReturn> for UnderlyingRustTuple<'_> {
                fn from(value: quorumReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for quorumReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for quorumCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = quorumReturn;
            type ReturnTuple<'a> = (Quorum,);
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "quorum()";
            const SELECTOR: [u8; 4] = [23u8, 3u8, 160u8, 24u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `registerOperatorWithSignature((bytes,bytes32,uint256),address)` and selector `0x3d5611f6`.\n```solidity\nfunction registerOperatorWithSignature(SignatureWithSaltAndExpiry memory _operatorSignature, address _signingKey) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registerOperatorWithSignatureCall {
        pub _operatorSignature:
            <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
        pub _signingKey: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`registerOperatorWithSignature((bytes,bytes32,uint256),address)`](registerOperatorWithSignatureCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct registerOperatorWithSignatureReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                SignatureWithSaltAndExpiry,
                ::alloy_sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
                ::alloy_sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorWithSignatureCall> for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorWithSignatureCall) -> Self {
                    (value._operatorSignature, value._signingKey)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerOperatorWithSignatureCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _operatorSignature: tuple.0,
                        _signingKey: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorWithSignatureReturn> for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorWithSignatureReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for registerOperatorWithSignatureReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerOperatorWithSignatureCall {
            type Parameters<'a> = (
                SignatureWithSaltAndExpiry,
                ::alloy_sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerOperatorWithSignatureReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str =
                "registerOperatorWithSignature((bytes,bytes32,uint256),address)";
            const SELECTOR: [u8; 4] = [61u8, 86u8, 17u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <SignatureWithSaltAndExpiry as alloy_sol_types::SolType>::tokenize(
                        &self._operatorSignature,
                    ),
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._signingKey,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `renounceOwnership()` and selector `0x715018a6`.\n```solidity\nfunction renounceOwnership() external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct renounceOwnershipCall {}
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`renounceOwnership()`](renounceOwnershipCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct renounceOwnershipReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceOwnershipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceOwnershipCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceOwnership()";
            const SELECTOR: [u8; 4] = [113u8, 80u8, 24u8, 166u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `transferOwnership(address)` and selector `0xf2fde38b`.\n```solidity\nfunction transferOwnership(address newOwner) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipCall {
        pub newOwner: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`transferOwnership(address)`](transferOwnershipCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct transferOwnershipReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipCall> for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipCall) -> Self {
                    (value.newOwner,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferOwnershipCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { newOwner: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferOwnershipReturn> for UnderlyingRustTuple<'_> {
                fn from(value: transferOwnershipReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for transferOwnershipReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferOwnershipCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferOwnershipReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferOwnership(address)";
            const SELECTOR: [u8; 4] = [242u8, 253u8, 227u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `updateMinimumWeight(uint256,address[])` and selector `0x696255be`.\n```solidity\nfunction updateMinimumWeight(uint256 _newMinimumWeight, address[] memory _operators) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateMinimumWeightCall {
        pub _newMinimumWeight: ::alloy_sol_types::private::U256,
        pub _operators: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`updateMinimumWeight(uint256,address[])`](updateMinimumWeightCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateMinimumWeightReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::U256,
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateMinimumWeightCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateMinimumWeightCall) -> Self {
                    (value._newMinimumWeight, value._operators)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateMinimumWeightCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _newMinimumWeight: tuple.0,
                        _operators: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateMinimumWeightReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateMinimumWeightReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateMinimumWeightReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateMinimumWeightCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Uint<256>,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateMinimumWeightReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateMinimumWeight(uint256,address[])";
            const SELECTOR: [u8; 4] = [105u8, 98u8, 85u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(&self._newMinimumWeight), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address> as alloy_sol_types::SolType>::tokenize(&self._operators),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `updateOperatorSigningKey(address)` and selector `0x743c31f4`.\n```solidity\nfunction updateOperatorSigningKey(address _newSigningKey) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorSigningKeyCall {
        pub _newSigningKey: ::alloy_sol_types::private::Address,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`updateOperatorSigningKey(address)`](updateOperatorSigningKeyCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorSigningKeyReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorSigningKeyCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorSigningKeyCall) -> Self {
                    (value._newSigningKey,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorSigningKeyCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _newSigningKey: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorSigningKeyReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorSigningKeyReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorSigningKeyReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateOperatorSigningKeyCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateOperatorSigningKeyReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateOperatorSigningKey(address)";
            const SELECTOR: [u8; 4] = [116u8, 60u8, 49u8, 244u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self._newSigningKey,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `updateOperators(address[])` and selector `0x00cf2ab5`.\n```solidity\nfunction updateOperators(address[] memory _operators) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorsCall {
        pub _operators: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`updateOperators(address[])`](updateOperatorsCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorsReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> =
                (::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> =
                (::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorsCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorsCall) -> Self {
                    (value._operators,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _operators: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateOperatorsCall {
            type Parameters<'a> =
                (::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateOperatorsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateOperators(address[])";
            const SELECTOR: [u8; 4] = [0u8, 207u8, 42u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Address,
                > as alloy_sol_types::SolType>::tokenize(
                    &self._operators
                ),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `updateOperatorsForQuorum(address[][],bytes)` and selector `0x5140a548`.\n```solidity\nfunction updateOperatorsForQuorum(address[][] memory operatorsPerQuorum, bytes memory) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorsForQuorumCall {
        pub operatorsPerQuorum: ::alloy_sol_types::private::Vec<
            ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
        >,
        pub _1: ::alloy_sol_types::private::Bytes,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`updateOperatorsForQuorum(address[][],bytes)`](updateOperatorsForQuorumCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateOperatorsForQuorumReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                ::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
                >,
                ::alloy_sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                ::alloy_sol_types::private::Vec<
                    ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
                >,
                ::alloy_sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorsForQuorumCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorsForQuorumCall) -> Self {
                    (value.operatorsPerQuorum, value._1)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorsForQuorumCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        operatorsPerQuorum: tuple.0,
                        _1: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorsForQuorumReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorsForQuorumReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateOperatorsForQuorumReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateOperatorsForQuorumCall {
            type Parameters<'a> = (
                ::alloy_sol_types::sol_data::Array<
                    ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
                >,
                ::alloy_sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateOperatorsForQuorumReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateOperatorsForQuorum(address[][],bytes)";
            const SELECTOR: [u8; 4] = [81u8, 64u8, 165u8, 72u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Array<
                        ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
                    > as alloy_sol_types::SolType>::tokenize(
                        &self.operatorsPerQuorum
                    ),
                    <::alloy_sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self._1,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `updateQuorumConfig(((address,uint96)[]),address[])` and selector `0xdec5d1f6`.\n```solidity\nfunction updateQuorumConfig(Quorum memory _quorum, address[] memory _operators) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateQuorumConfigCall {
        pub _quorum: <Quorum as ::alloy_sol_types::SolType>::RustType,
        pub _operators: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`updateQuorumConfig(((address,uint96)[]),address[])`](updateQuorumConfigCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateQuorumConfigReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                Quorum,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Quorum as ::alloy_sol_types::SolType>::RustType,
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateQuorumConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateQuorumConfigCall) -> Self {
                    (value._quorum, value._operators)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateQuorumConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _quorum: tuple.0,
                        _operators: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateQuorumConfigReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateQuorumConfigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateQuorumConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateQuorumConfigCall {
            type Parameters<'a> = (
                Quorum,
                ::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address>,
            );
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateQuorumConfigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateQuorumConfig(((address,uint96)[]),address[])";
            const SELECTOR: [u8; 4] = [222u8, 197u8, 209u8, 246u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (<Quorum as alloy_sol_types::SolType>::tokenize(&self._quorum), <::alloy_sol_types::sol_data::Array<::alloy_sol_types::sol_data::Address> as alloy_sol_types::SolType>::tokenize(&self._operators),)
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Function with signature `updateStakeThreshold(uint256)` and selector `0x5ef53329`.\n```solidity\nfunction updateStakeThreshold(uint256 _thresholdWeight) external;\n```"]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateStakeThresholdCall {
        pub _thresholdWeight: ::alloy_sol_types::private::U256,
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container type for the return parameters of the [`updateStakeThreshold(uint256)`](updateStakeThresholdCall) function."]
    #[allow(non_camel_case_types, non_snake_case)]
    #[derive(Clone)]
    pub struct updateStakeThresholdReturn {}
    #[allow(non_camel_case_types, non_snake_case, clippy::style)]
    const _: () = {
        use ::alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (::alloy_sol_types::private::U256,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateStakeThresholdCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateStakeThresholdCall) -> Self {
                    (value._thresholdWeight,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateStakeThresholdCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _thresholdWeight: tuple.0,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(_t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateStakeThresholdReturn> for UnderlyingRustTuple<'_> {
                fn from(value: updateStakeThresholdReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateStakeThresholdReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateStakeThresholdCall {
            type Parameters<'a> = (::alloy_sol_types::sol_data::Uint<256>,);
            type Token<'a> = <Self::Parameters<'a> as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateStakeThresholdReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<'a> as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateStakeThreshold(uint256)";
            const SELECTOR: [u8; 4] = [94u8, 245u8, 51u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <::alloy_sol_types::sol_data::Uint<256> as alloy_sol_types::SolType>::tokenize(
                        &self._thresholdWeight,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<'_> as alloy_sol_types::SolType>::abi_decode_sequence(
                    data, validate,
                )
                .map(Into::into)
            }
        }
    };
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container for all the [`ECDSAStakeRegistry`](self) function calls."]
    pub enum ECDSAStakeRegistryCalls {
        deregisterOperator(deregisterOperatorCall),
        getLastCheckpointOperatorWeight(getLastCheckpointOperatorWeightCall),
        getLastCheckpointThresholdWeight(getLastCheckpointThresholdWeightCall),
        getLastCheckpointThresholdWeightAtBlock(getLastCheckpointThresholdWeightAtBlockCall),
        getLastCheckpointTotalWeight(getLastCheckpointTotalWeightCall),
        getLastCheckpointTotalWeightAtBlock(getLastCheckpointTotalWeightAtBlockCall),
        getLastestOperatorSigningKey(getLastestOperatorSigningKeyCall),
        getOperatorSigningKeyAtBlock(getOperatorSigningKeyAtBlockCall),
        getOperatorWeight(getOperatorWeightCall),
        getOperatorWeightAtBlock(getOperatorWeightAtBlockCall),
        initialize(initializeCall),
        isValidSignature(isValidSignatureCall),
        minimumWeight(minimumWeightCall),
        operatorRegistered(operatorRegisteredCall),
        owner(ownerCall),
        quorum(quorumCall),
        registerOperatorWithSignature(registerOperatorWithSignatureCall),
        renounceOwnership(renounceOwnershipCall),
        transferOwnership(transferOwnershipCall),
        updateMinimumWeight(updateMinimumWeightCall),
        updateOperatorSigningKey(updateOperatorSigningKeyCall),
        updateOperators(updateOperatorsCall),
        updateOperatorsForQuorum(updateOperatorsForQuorumCall),
        updateQuorumConfig(updateQuorumConfigCall),
        updateStakeThreshold(updateStakeThresholdCall),
    }
    #[automatically_derived]
    impl ECDSAStakeRegistryCalls {
        #[doc = r" All the selectors of this enum."]
        #[doc = r""]
        #[doc = r" Note that the selectors might not be in the same order as the variants."]
        #[doc = r" No guarantees are made about the order of the selectors."]
        #[doc = r""]
        #[doc = r" Prefer using `SolInterface` methods instead."]
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [0u8, 207u8, 42u8, 181u8],
            [13u8, 186u8, 51u8, 148u8],
            [22u8, 38u8, 186u8, 126u8],
            [23u8, 3u8, 160u8, 24u8],
            [30u8, 76u8, 216u8, 94u8],
            [49u8, 79u8, 58u8, 73u8],
            [59u8, 36u8, 46u8, 74u8],
            [61u8, 86u8, 17u8, 246u8],
            [64u8, 191u8, 47u8, 183u8],
            [81u8, 64u8, 165u8, 72u8],
            [94u8, 16u8, 66u8, 232u8],
            [94u8, 245u8, 51u8, 41u8],
            [105u8, 98u8, 85u8, 190u8],
            [113u8, 80u8, 24u8, 166u8],
            [116u8, 60u8, 49u8, 244u8],
            [133u8, 125u8, 193u8, 144u8],
            [141u8, 165u8, 203u8, 91u8],
            [149u8, 95u8, 45u8, 144u8],
            [152u8, 236u8, 26u8, 201u8],
            [171u8, 17u8, 137u8, 149u8],
            [185u8, 51u8, 250u8, 116u8],
            [205u8, 205u8, 53u8, 129u8],
            [222u8, 197u8, 209u8, 246u8],
            [236u8, 127u8, 187u8, 49u8],
            [242u8, 253u8, 227u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ECDSAStakeRegistryCalls {
        const NAME: &'static str = "ECDSAStakeRegistryCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 25usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::deregisterOperator(_) => <deregisterOperatorCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLastCheckpointOperatorWeight(_) => <getLastCheckpointOperatorWeightCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLastCheckpointThresholdWeight(_) => <getLastCheckpointThresholdWeightCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLastCheckpointThresholdWeightAtBlock(_) => <getLastCheckpointThresholdWeightAtBlockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLastCheckpointTotalWeight(_) => <getLastCheckpointTotalWeightCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLastCheckpointTotalWeightAtBlock(_) => <getLastCheckpointTotalWeightAtBlockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getLastestOperatorSigningKey(_) => <getLastestOperatorSigningKeyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperatorSigningKeyAtBlock(_) => <getOperatorSigningKeyAtBlockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperatorWeight(_) => <getOperatorWeightCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::getOperatorWeightAtBlock(_) => <getOperatorWeightAtBlockCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => <initializeCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::isValidSignature(_) => <isValidSignatureCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::minimumWeight(_) => <minimumWeightCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::operatorRegistered(_) => <operatorRegisteredCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::owner(_) => <ownerCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::quorum(_) => <quorumCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::registerOperatorWithSignature(_) => <registerOperatorWithSignatureCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::renounceOwnership(_) => <renounceOwnershipCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::transferOwnership(_) => <transferOwnershipCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateMinimumWeight(_) => <updateMinimumWeightCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateOperatorSigningKey(_) => <updateOperatorSigningKeyCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateOperators(_) => <updateOperatorsCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateOperatorsForQuorum(_) => <updateOperatorsForQuorumCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateQuorumConfig(_) => <updateQuorumConfigCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::updateStakeThreshold(_) => <updateStakeThresholdCall as alloy_sol_types::SolCall>::SELECTOR,
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            )
                -> alloy_sol_types::Result<ECDSAStakeRegistryCalls>] = &[
                {
                    fn updateOperators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <updateOperatorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::updateOperators)
                    }
                    updateOperators
                },
                {
                    fn getLastCheckpointTotalWeightAtBlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getLastCheckpointTotalWeightAtBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(ECDSAStakeRegistryCalls::getLastCheckpointTotalWeightAtBlock)
                    }
                    getLastCheckpointTotalWeightAtBlock
                },
                {
                    fn isValidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <isValidSignatureCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::isValidSignature)
                    }
                    isValidSignature
                },
                {
                    fn quorum(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <quorumCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(ECDSAStakeRegistryCalls::quorum)
                    }
                    quorum
                },
                {
                    fn getLastCheckpointThresholdWeightAtBlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getLastCheckpointThresholdWeightAtBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(ECDSAStakeRegistryCalls::getLastCheckpointThresholdWeightAtBlock)
                    }
                    getLastCheckpointThresholdWeightAtBlock
                },
                {
                    fn getLastCheckpointTotalWeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getLastCheckpointTotalWeightCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(ECDSAStakeRegistryCalls::getLastCheckpointTotalWeight)
                    }
                    getLastCheckpointTotalWeight
                },
                {
                    fn getLastCheckpointOperatorWeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getLastCheckpointOperatorWeightCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(ECDSAStakeRegistryCalls::getLastCheckpointOperatorWeight)
                    }
                    getLastCheckpointOperatorWeight
                },
                {
                    fn registerOperatorWithSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <registerOperatorWithSignatureCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(ECDSAStakeRegistryCalls::registerOperatorWithSignature)
                    }
                    registerOperatorWithSignature
                },
                {
                    fn minimumWeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <minimumWeightCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::minimumWeight)
                    }
                    minimumWeight
                },
                {
                    fn updateOperatorsForQuorum(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <updateOperatorsForQuorumCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::updateOperatorsForQuorum)
                    }
                    updateOperatorsForQuorum
                },
                {
                    fn getOperatorSigningKeyAtBlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getOperatorSigningKeyAtBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(ECDSAStakeRegistryCalls::getOperatorSigningKeyAtBlock)
                    }
                    getOperatorSigningKeyAtBlock
                },
                {
                    fn updateStakeThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <updateStakeThresholdCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::updateStakeThreshold)
                    }
                    updateStakeThreshold
                },
                {
                    fn updateMinimumWeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <updateMinimumWeightCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::updateMinimumWeight)
                    }
                    updateMinimumWeight
                },
                {
                    fn renounceOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::renounceOwnership)
                    }
                    renounceOwnership
                },
                {
                    fn updateOperatorSigningKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <updateOperatorSigningKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::updateOperatorSigningKey)
                    }
                    updateOperatorSigningKey
                },
                {
                    fn deregisterOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <deregisterOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::deregisterOperator)
                    }
                    deregisterOperator
                },
                {
                    fn owner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <ownerCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(ECDSAStakeRegistryCalls::owner)
                    }
                    owner
                },
                {
                    fn getOperatorWeightAtBlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getOperatorWeightAtBlockCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::getOperatorWeightAtBlock)
                    }
                    getOperatorWeightAtBlock
                },
                {
                    fn getOperatorWeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getOperatorWeightCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::getOperatorWeight)
                    }
                    getOperatorWeight
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate)
                            .map(ECDSAStakeRegistryCalls::initialize)
                    }
                    initialize
                },
                {
                    fn getLastCheckpointThresholdWeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getLastCheckpointThresholdWeightCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(ECDSAStakeRegistryCalls::getLastCheckpointThresholdWeight)
                    }
                    getLastCheckpointThresholdWeight
                },
                {
                    fn getLastestOperatorSigningKey(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <getLastestOperatorSigningKeyCall as alloy_sol_types::SolCall>::abi_decode_raw(data, validate).map(ECDSAStakeRegistryCalls::getLastestOperatorSigningKey)
                    }
                    getLastestOperatorSigningKey
                },
                {
                    fn updateQuorumConfig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <updateQuorumConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::updateQuorumConfig)
                    }
                    updateQuorumConfig
                },
                {
                    fn operatorRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <operatorRegisteredCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::operatorRegistered)
                    }
                    operatorRegistered
                },
                {
                    fn transferOwnership(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryCalls> {
                        <transferOwnershipCall as alloy_sol_types::SolCall>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryCalls::transferOwnership)
                    }
                    transferOwnership
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::deregisterOperator(inner) => <deregisterOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getLastCheckpointOperatorWeight(inner) => <getLastCheckpointOperatorWeightCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getLastCheckpointThresholdWeight(inner) => <getLastCheckpointThresholdWeightCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getLastCheckpointThresholdWeightAtBlock(inner) => <getLastCheckpointThresholdWeightAtBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getLastCheckpointTotalWeight(inner) => <getLastCheckpointTotalWeightCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getLastCheckpointTotalWeightAtBlock(inner) => <getLastCheckpointTotalWeightAtBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getLastestOperatorSigningKey(inner) => <getLastestOperatorSigningKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorSigningKeyAtBlock(inner) => <getOperatorSigningKeyAtBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorWeight(inner) => <getOperatorWeightCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::getOperatorWeightAtBlock(inner) => <getOperatorWeightAtBlockCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::isValidSignature(inner) => <isValidSignatureCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::minimumWeight(inner) => <minimumWeightCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::operatorRegistered(inner) => <operatorRegisteredCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::owner(inner) => <ownerCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::quorum(inner) => <quorumCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::registerOperatorWithSignature(inner) => <registerOperatorWithSignatureCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::renounceOwnership(inner) => <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::transferOwnership(inner) => <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateMinimumWeight(inner) => <updateMinimumWeightCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateOperatorSigningKey(inner) => <updateOperatorSigningKeyCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateOperators(inner) => <updateOperatorsCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateOperatorsForQuorum(inner) => <updateOperatorsForQuorumCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateQuorumConfig(inner) => <updateQuorumConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
                Self::updateStakeThreshold(inner) => <updateStakeThresholdCall as alloy_sol_types::SolCall>::abi_encoded_size(inner),
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::deregisterOperator(inner) => <deregisterOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getLastCheckpointOperatorWeight(inner) => <getLastCheckpointOperatorWeightCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getLastCheckpointThresholdWeight(inner) => <getLastCheckpointThresholdWeightCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getLastCheckpointThresholdWeightAtBlock(inner) => <getLastCheckpointThresholdWeightAtBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getLastCheckpointTotalWeight(inner) => <getLastCheckpointTotalWeightCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getLastCheckpointTotalWeightAtBlock(inner) => <getLastCheckpointTotalWeightAtBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getLastestOperatorSigningKey(inner) => <getLastestOperatorSigningKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getOperatorSigningKeyAtBlock(inner) => <getOperatorSigningKeyAtBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getOperatorWeight(inner) => <getOperatorWeightCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::getOperatorWeightAtBlock(inner) => <getOperatorWeightAtBlockCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::initialize(inner) => <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::isValidSignature(inner) => <isValidSignatureCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::minimumWeight(inner) => <minimumWeightCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::operatorRegistered(inner) => <operatorRegisteredCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::owner(inner) => <ownerCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::quorum(inner) => <quorumCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::registerOperatorWithSignature(inner) => <registerOperatorWithSignatureCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::renounceOwnership(inner) => <renounceOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::transferOwnership(inner) => <transferOwnershipCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateMinimumWeight(inner) => <updateMinimumWeightCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateOperatorSigningKey(inner) => <updateOperatorSigningKeyCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateOperators(inner) => <updateOperatorsCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateOperatorsForQuorum(inner) => <updateOperatorsForQuorumCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateQuorumConfig(inner) => <updateQuorumConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
                Self::updateStakeThreshold(inner) => <updateStakeThresholdCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out),
            }
        }
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container for all the [`ECDSAStakeRegistry`](self) custom errors."]
    pub enum ECDSAStakeRegistryErrors {
        InsufficientSignedStake(InsufficientSignedStake),
        InsufficientWeight(InsufficientWeight),
        InvalidLength(InvalidLength),
        InvalidQuorum(InvalidQuorum),
        InvalidReferenceBlock(InvalidReferenceBlock),
        InvalidSignature(InvalidSignature),
        InvalidSignedWeight(InvalidSignedWeight),
        InvalidThreshold(InvalidThreshold),
        LengthMismatch(LengthMismatch),
        MustUpdateAllOperators(MustUpdateAllOperators),
        NotSorted(NotSorted),
        OperatorAlreadyRegistered(OperatorAlreadyRegistered),
        OperatorNotRegistered(OperatorNotRegistered),
    }
    #[automatically_derived]
    impl ECDSAStakeRegistryErrors {
        #[doc = r" All the selectors of this enum."]
        #[doc = r""]
        #[doc = r" Note that the selectors might not be in the same order as the variants."]
        #[doc = r" No guarantees are made about the order of the selectors."]
        #[doc = r""]
        #[doc = r" Prefer using `SolInterface` methods instead."]
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [37u8, 236u8, 108u8, 31u8],
            [45u8, 61u8, 246u8, 182u8],
            [66u8, 238u8, 104u8, 181u8],
            [139u8, 170u8, 87u8, 159u8],
            [148u8, 125u8, 90u8, 132u8],
            [150u8, 11u8, 65u8, 238u8],
            [168u8, 121u8, 47u8, 209u8],
            [170u8, 189u8, 90u8, 9u8],
            [186u8, 80u8, 249u8, 17u8],
            [209u8, 115u8, 87u8, 121u8],
            [225u8, 33u8, 99u8, 47u8],
            [230u8, 79u8, 24u8, 15u8],
            [255u8, 99u8, 58u8, 56u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for ECDSAStakeRegistryErrors {
        const NAME: &'static str = "ECDSAStakeRegistryErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 13usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::InsufficientSignedStake(_) => {
                    <InsufficientSignedStake as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientWeight(_) => {
                    <InsufficientWeight as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidLength(_) => <InvalidLength as alloy_sol_types::SolError>::SELECTOR,
                Self::InvalidQuorum(_) => <InvalidQuorum as alloy_sol_types::SolError>::SELECTOR,
                Self::InvalidReferenceBlock(_) => {
                    <InvalidReferenceBlock as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSignature(_) => {
                    <InvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSignedWeight(_) => {
                    <InvalidSignedWeight as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidThreshold(_) => {
                    <InvalidThreshold as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LengthMismatch(_) => <LengthMismatch as alloy_sol_types::SolError>::SELECTOR,
                Self::MustUpdateAllOperators(_) => {
                    <MustUpdateAllOperators as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotSorted(_) => <NotSorted as alloy_sol_types::SolError>::SELECTOR,
                Self::OperatorAlreadyRegistered(_) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorNotRegistered(_) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(unsafe_code, non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            )
                -> alloy_sol_types::Result<ECDSAStakeRegistryErrors>] = &[
                {
                    fn OperatorNotRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <OperatorNotRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::OperatorNotRegistered)
                    }
                    OperatorNotRegistered
                },
                {
                    fn MustUpdateAllOperators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <MustUpdateAllOperators as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::MustUpdateAllOperators)
                    }
                    MustUpdateAllOperators
                },
                {
                    fn OperatorAlreadyRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::OperatorAlreadyRegistered)
                    }
                    OperatorAlreadyRegistered
                },
                {
                    fn InvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <InvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::InvalidSignature)
                    }
                    InvalidSignature
                },
                {
                    fn InvalidLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <InvalidLength as alloy_sol_types::SolError>::abi_decode_raw(data, validate)
                            .map(ECDSAStakeRegistryErrors::InvalidLength)
                    }
                    InvalidLength
                },
                {
                    fn InvalidSignedWeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <InvalidSignedWeight as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::InvalidSignedWeight)
                    }
                    InvalidSignedWeight
                },
                {
                    fn InsufficientWeight(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <InsufficientWeight as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::InsufficientWeight)
                    }
                    InsufficientWeight
                },
                {
                    fn InvalidThreshold(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <InvalidThreshold as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::InvalidThreshold)
                    }
                    InvalidThreshold
                },
                {
                    fn NotSorted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <NotSorted as alloy_sol_types::SolError>::abi_decode_raw(data, validate)
                            .map(ECDSAStakeRegistryErrors::NotSorted)
                    }
                    NotSorted
                },
                {
                    fn InvalidQuorum(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <InvalidQuorum as alloy_sol_types::SolError>::abi_decode_raw(data, validate)
                            .map(ECDSAStakeRegistryErrors::InvalidQuorum)
                    }
                    InvalidQuorum
                },
                {
                    fn InsufficientSignedStake(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <InsufficientSignedStake as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::InsufficientSignedStake)
                    }
                    InsufficientSignedStake
                },
                {
                    fn InvalidReferenceBlock(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <InvalidReferenceBlock as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::InvalidReferenceBlock)
                    }
                    InvalidReferenceBlock
                },
                {
                    fn LengthMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<ECDSAStakeRegistryErrors> {
                        <LengthMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                            data, validate,
                        )
                        .map(ECDSAStakeRegistryErrors::LengthMismatch)
                    }
                    LengthMismatch
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(alloy_sol_types::Error::unknown_selector(
                    <Self as alloy_sol_types::SolInterface>::NAME,
                    selector,
                ));
            };
            (unsafe { DECODE_SHIMS.get_unchecked(idx) })(data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::InsufficientSignedStake(inner) => {
                    <InsufficientSignedStake as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InsufficientWeight(inner) => {
                    <InsufficientWeight as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidLength(inner) => {
                    <InvalidLength as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidQuorum(inner) => {
                    <InvalidQuorum as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidReferenceBlock(inner) => {
                    <InvalidReferenceBlock as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidSignature(inner) => {
                    <InvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidSignedWeight(inner) => {
                    <InvalidSignedWeight as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::InvalidThreshold(inner) => {
                    <InvalidThreshold as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::LengthMismatch(inner) => {
                    <LengthMismatch as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::MustUpdateAllOperators(inner) => {
                    <MustUpdateAllOperators as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NotSorted(inner) => {
                    <NotSorted as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::OperatorAlreadyRegistered(inner) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorNotRegistered(inner) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::InsufficientSignedStake(inner) => {
                    <InsufficientSignedStake as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::InsufficientWeight(inner) => {
                    <InsufficientWeight as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidLength(inner) => {
                    <InvalidLength as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidQuorum(inner) => {
                    <InvalidQuorum as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidReferenceBlock(inner) => {
                    <InvalidReferenceBlock as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidSignature(inner) => {
                    <InvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidSignedWeight(inner) => {
                    <InvalidSignedWeight as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::InvalidThreshold(inner) => {
                    <InvalidThreshold as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::LengthMismatch(inner) => {
                    <LengthMismatch as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::MustUpdateAllOperators(inner) => {
                    <MustUpdateAllOperators as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::NotSorted(inner) => {
                    <NotSorted as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::OperatorAlreadyRegistered(inner) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner, out,
                    )
                }
                Self::OperatorNotRegistered(inner) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    #[allow(missing_docs, clippy::too_many_arguments)]
    #[doc = "Container for all the [`ECDSAStakeRegistry`](self) events."]
    pub enum ECDSAStakeRegistryEvents {
        Initialized(Initialized),
        MinimumWeightUpdated(MinimumWeightUpdated),
        OperatorDeregistered(OperatorDeregistered),
        OperatorRegistered(OperatorRegistered),
        OperatorWeightUpdated(OperatorWeightUpdated),
        OwnershipTransferred(OwnershipTransferred),
        QuorumUpdated(QuorumUpdated),
        SigningKeyUpdate(SigningKeyUpdate),
        ThresholdWeightUpdated(ThresholdWeightUpdated),
        TotalWeightUpdated(TotalWeightUpdated),
        UpdateMinimumWeight(UpdateMinimumWeight),
    }
    #[automatically_derived]
    impl ECDSAStakeRegistryEvents {
        #[doc = r" All the selectors of this enum."]
        #[doc = r""]
        #[doc = r" Note that the selectors might not be in the same order as the variants."]
        #[doc = r" No guarantees are made about the order of the selectors."]
        #[doc = r""]
        #[doc = r" Prefer using `SolInterface` methods instead."]
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                30u8, 164u8, 33u8, 134u8, 179u8, 5u8, 250u8, 55u8, 49u8, 4u8, 80u8, 217u8, 251u8,
                135u8, 234u8, 30u8, 143u8, 12u8, 127u8, 68u8, 126u8, 119u8, 20u8, 121u8, 227u8,
                178u8, 118u8, 52u8, 191u8, 232u8, 77u8, 193u8,
            ],
            [
                35u8, 170u8, 212u8, 230u8, 23u8, 68u8, 236u8, 225u8, 100u8, 19u8, 10u8, 164u8,
                21u8, 193u8, 97u8, 110u8, 128u8, 19u8, 107u8, 15u8, 7u8, 112u8, 229u8, 101u8,
                137u8, 67u8, 139u8, 144u8, 178u8, 105u8, 38u8, 94u8,
            ],
            [
                49u8, 224u8, 173u8, 254u8, 199u8, 27u8, 204u8, 238u8, 55u8, 182u8, 232u8, 58u8,
                144u8, 194u8, 254u8, 219u8, 23u8, 216u8, 241u8, 105u8, 63u8, 238u8, 134u8, 60u8,
                71u8, 113u8, 231u8, 191u8, 226u8, 174u8, 213u8, 128u8,
            ],
            [
                113u8, 60u8, 165u8, 59u8, 136u8, 214u8, 235u8, 99u8, 245u8, 177u8, 133u8, 76u8,
                184u8, 203u8, 221u8, 115u8, 110u8, 197u8, 30u8, 218u8, 34u8, 94u8, 70u8, 121u8,
                26u8, 169u8, 41u8, 139u8, 1u8, 96u8, 100u8, 143u8,
            ],
            [
                127u8, 38u8, 184u8, 63u8, 249u8, 110u8, 31u8, 43u8, 106u8, 104u8, 47u8, 19u8, 56u8,
                82u8, 246u8, 121u8, 138u8, 9u8, 196u8, 101u8, 218u8, 149u8, 146u8, 20u8, 96u8,
                206u8, 251u8, 56u8, 71u8, 64u8, 36u8, 152u8,
            ],
            [
                134u8, 220u8, 248u8, 107u8, 18u8, 223u8, 238u8, 222u8, 167u8, 74u8, 233u8, 48u8,
                13u8, 189u8, 170u8, 25u8, 59u8, 204u8, 229u8, 128u8, 147u8, 105u8, 200u8, 23u8,
                126u8, 162u8, 244u8, 234u8, 170u8, 101u8, 114u8, 155u8,
            ],
            [
                136u8, 119u8, 13u8, 200u8, 98u8, 228u8, 122u8, 126u8, 213u8, 134u8, 144u8, 120u8,
                87u8, 235u8, 27u8, 117u8, 228u8, 197u8, 255u8, 200u8, 183u8, 7u8, 199u8, 238u8,
                16u8, 235u8, 116u8, 214u8, 136u8, 95u8, 229u8, 148u8,
            ],
            [
                139u8, 224u8, 7u8, 156u8, 83u8, 22u8, 89u8, 20u8, 19u8, 68u8, 205u8, 31u8, 208u8,
                164u8, 242u8, 132u8, 25u8, 73u8, 127u8, 151u8, 34u8, 163u8, 218u8, 175u8, 227u8,
                180u8, 24u8, 111u8, 107u8, 100u8, 87u8, 224u8,
            ],
            [
                147u8, 36u8, 247u8, 229u8, 167u8, 192u8, 40u8, 136u8, 8u8, 166u8, 52u8, 204u8,
                222u8, 68u8, 184u8, 233u8, 121u8, 103u8, 100u8, 116u8, 178u8, 46u8, 41u8, 238u8,
                157u8, 213u8, 105u8, 181u8, 94u8, 121u8, 26u8, 75u8,
            ],
            [
                164u8, 83u8, 219u8, 97u8, 42u8, 245u8, 158u8, 85u8, 33u8, 214u8, 171u8, 146u8,
                132u8, 220u8, 62u8, 45u8, 6u8, 175u8, 40u8, 110u8, 177u8, 177u8, 183u8, 183u8,
                113u8, 252u8, 228u8, 113u8, 108u8, 25u8, 242u8, 193u8,
            ],
            [
                208u8, 97u8, 22u8, 130u8, 82u8, 244u8, 65u8, 115u8, 54u8, 88u8, 240u8, 158u8, 77u8,
                143u8, 91u8, 45u8, 153u8, 142u8, 212u8, 239u8, 36u8, 162u8, 187u8, 253u8, 108u8,
                236u8, 165u8, 46u8, 161u8, 49u8, 80u8, 2u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for ECDSAStakeRegistryEvents {
        const NAME: &'static str = "ECDSAStakeRegistryEvents";
        const COUNT: usize = 11usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::Initialized)
                }
                Some(<MinimumWeightUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <MinimumWeightUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::MinimumWeightUpdated)
                }
                Some(<OperatorDeregistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorDeregistered as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OperatorDeregistered)
                }
                Some(<OperatorRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OperatorRegistered)
                }
                Some(<OperatorWeightUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OperatorWeightUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OperatorWeightUpdated)
                }
                Some(<OwnershipTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <OwnershipTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::OwnershipTransferred)
                }
                Some(<QuorumUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <QuorumUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::QuorumUpdated)
                }
                Some(<SigningKeyUpdate as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SigningKeyUpdate as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::SigningKeyUpdate)
                }
                Some(<ThresholdWeightUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ThresholdWeightUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::ThresholdWeightUpdated)
                }
                Some(<TotalWeightUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <TotalWeightUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::TotalWeightUpdated)
                }
                Some(<UpdateMinimumWeight as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <UpdateMinimumWeight as alloy_sol_types::SolEvent>::decode_raw_log(
                        topics, data, validate,
                    )
                    .map(Self::UpdateMinimumWeight)
                }
                _ => alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                    name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                    log: alloy_sol_types::private::Box::new(
                        alloy_sol_types::private::LogData::new_unchecked(
                            topics.to_vec(),
                            data.to_vec().into(),
                        ),
                    ),
                }),
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for ECDSAStakeRegistryEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::MinimumWeightUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorDeregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorWeightUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::QuorumUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SigningKeyUpdate(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ThresholdWeightUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::TotalWeightUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::UpdateMinimumWeight(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::MinimumWeightUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorDeregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorWeightUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OwnershipTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::QuorumUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SigningKeyUpdate(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ThresholdWeightUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::TotalWeightUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::UpdateMinimumWeight(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use ::alloy_contract;
    #[doc = "Creates a new wrapper around an on-chain [`ECDSAStakeRegistry`](self) contract instance.\n\nSee the [wrapper's documentation](`ECDSAStakeRegistryInstance`) for more details."]
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> ECDSAStakeRegistryInstance<T, P, N> {
        ECDSAStakeRegistryInstance::<T, P, N>::new(address, provider)
    }
    #[doc = "Deploys this contract using the given `provider` and constructor arguments, if any.\n\nReturns a new instance of the contract, if the deployment was successful.\n\nFor more fine-grained control over the deployment process, use [`deploy_builder`] instead."]
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _delegationManager: ::alloy_sol_types::private::Address,
    ) -> impl ::core::future::Future<Output = alloy_contract::Result<ECDSAStakeRegistryInstance<T, P, N>>>
    {
        ECDSAStakeRegistryInstance::<T, P, N>::deploy(provider, _delegationManager)
    }
    #[doc = "Creates a `RawCallBuilder` for deploying this contract using the given `provider`\nand constructor arguments, if any.\n\nThis is a simple wrapper around creating a `RawCallBuilder` with the data set to\nthe bytecode concatenated with the constructor's ABI-encoded arguments."]
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
        _delegationManager: ::alloy_sol_types::private::Address,
    ) -> alloy_contract::RawCallBuilder<T, P, N> {
        ECDSAStakeRegistryInstance::<T, P, N>::deploy_builder(provider, _delegationManager)
    }
    #[doc = "A [`ECDSAStakeRegistry`](self) instance.\n\nContains type-safe methods for interacting with an on-chain instance of the\n[`ECDSAStakeRegistry`](self) contract located at a given `address`, using a given\nprovider `P`.\n\nIf the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)\ndocumentation on how to provide it), the `deploy` and `deploy_builder` methods can\nbe used to deploy a new instance of the contract.\n\nSee the [module-level documentation](self) for all the available methods."]
    #[derive(Clone)]
    pub struct ECDSAStakeRegistryInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for ECDSAStakeRegistryInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("ECDSAStakeRegistryInstance")
                .field(&self.address)
                .finish()
        }
    }
    #[doc = r" Instantiation and getters/setters."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > ECDSAStakeRegistryInstance<T, P, N>
    {
        #[doc = "Creates a new wrapper around an on-chain [`ECDSAStakeRegistry`](self) contract instance.\n\nSee the [wrapper's documentation](`ECDSAStakeRegistryInstance`) for more details."]
        #[inline]
        pub const fn new(address: alloy_sol_types::private::Address, provider: P) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        #[doc = "Deploys this contract using the given `provider` and constructor arguments, if any.\n\nReturns a new instance of the contract, if the deployment was successful.\n\nFor more fine-grained control over the deployment process, use [`deploy_builder`] instead."]
        #[inline]
        pub async fn deploy(
            provider: P,
            _delegationManager: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::Result<ECDSAStakeRegistryInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider, _delegationManager);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        #[doc = "Creates a `RawCallBuilder` for deploying this contract using the given `provider`\nand constructor arguments, if any.\n\nThis is a simple wrapper around creating a `RawCallBuilder` with the data set to\nthe bytecode concatenated with the constructor's ABI-encoded arguments."]
        #[inline]
        pub fn deploy_builder(
            provider: P,
            _delegationManager: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                [
                    &BYTECODE[..],
                    &alloy_sol_types::SolConstructor::abi_encode(&constructorCall {
                        _delegationManager,
                    })[..],
                ]
                .concat()
                .into(),
            )
        }
        #[doc = r" Returns a reference to the address."]
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        #[doc = r" Sets the address."]
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        #[doc = r" Sets the address and returns `self`."]
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        #[doc = r" Returns a reference to the provider."]
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> ECDSAStakeRegistryInstance<T, &P, N> {
        #[doc = r" Clones the provider and returns a new instance with the cloned provider."]
        #[inline]
        pub fn with_cloned_provider(self) -> ECDSAStakeRegistryInstance<T, P, N> {
            ECDSAStakeRegistryInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    #[doc = r" Function calls."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > ECDSAStakeRegistryInstance<T, P, N>
    {
        #[doc = r" Creates a new call builder using this contract instance's provider and address."]
        #[doc = r""]
        #[doc = r" Note that the call can be any function call, not just those defined in this"]
        #[doc = r" contract. Prefer using the other methods for building type-safe contract calls."]
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        #[doc = "Creates a new call builder for the [`deregisterOperator`] function."]
        pub fn deregisterOperator(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, deregisterOperatorCall, N> {
            self.call_builder(&deregisterOperatorCall {})
        }
        #[doc = "Creates a new call builder for the [`getLastCheckpointOperatorWeight`] function."]
        pub fn getLastCheckpointOperatorWeight(
            &self,
            _operator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLastCheckpointOperatorWeightCall, N> {
            self.call_builder(&getLastCheckpointOperatorWeightCall { _operator })
        }
        #[doc = "Creates a new call builder for the [`getLastCheckpointThresholdWeight`] function."]
        pub fn getLastCheckpointThresholdWeight(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLastCheckpointThresholdWeightCall, N>
        {
            self.call_builder(&getLastCheckpointThresholdWeightCall {})
        }
        #[doc = "Creates a new call builder for the [`getLastCheckpointThresholdWeightAtBlock`] function."]
        pub fn getLastCheckpointThresholdWeightAtBlock(
            &self,
            _blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLastCheckpointThresholdWeightAtBlockCall, N>
        {
            self.call_builder(&getLastCheckpointThresholdWeightAtBlockCall { _blockNumber })
        }
        #[doc = "Creates a new call builder for the [`getLastCheckpointTotalWeight`] function."]
        pub fn getLastCheckpointTotalWeight(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLastCheckpointTotalWeightCall, N> {
            self.call_builder(&getLastCheckpointTotalWeightCall {})
        }
        #[doc = "Creates a new call builder for the [`getLastCheckpointTotalWeightAtBlock`] function."]
        pub fn getLastCheckpointTotalWeightAtBlock(
            &self,
            _blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLastCheckpointTotalWeightAtBlockCall, N>
        {
            self.call_builder(&getLastCheckpointTotalWeightAtBlockCall { _blockNumber })
        }
        #[doc = "Creates a new call builder for the [`getLastestOperatorSigningKey`] function."]
        pub fn getLastestOperatorSigningKey(
            &self,
            _operator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getLastestOperatorSigningKeyCall, N> {
            self.call_builder(&getLastestOperatorSigningKeyCall { _operator })
        }
        #[doc = "Creates a new call builder for the [`getOperatorSigningKeyAtBlock`] function."]
        pub fn getOperatorSigningKeyAtBlock(
            &self,
            _operator: ::alloy_sol_types::private::Address,
            _blockNumber: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorSigningKeyAtBlockCall, N> {
            self.call_builder(&getOperatorSigningKeyAtBlockCall {
                _operator,
                _blockNumber,
            })
        }
        #[doc = "Creates a new call builder for the [`getOperatorWeight`] function."]
        pub fn getOperatorWeight(
            &self,
            _operator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorWeightCall, N> {
            self.call_builder(&getOperatorWeightCall { _operator })
        }
        #[doc = "Creates a new call builder for the [`getOperatorWeightAtBlock`] function."]
        pub fn getOperatorWeightAtBlock(
            &self,
            _operator: ::alloy_sol_types::private::Address,
            _blockNumber: u32,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorWeightAtBlockCall, N> {
            self.call_builder(&getOperatorWeightAtBlockCall {
                _operator,
                _blockNumber,
            })
        }
        #[doc = "Creates a new call builder for the [`initialize`] function."]
        pub fn initialize(
            &self,
            _serviceManager: ::alloy_sol_types::private::Address,
            _thresholdWeight: ::alloy_sol_types::private::U256,
            _quorum: <Quorum as ::alloy_sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(&initializeCall {
                _serviceManager,
                _thresholdWeight,
                _quorum,
            })
        }
        #[doc = "Creates a new call builder for the [`isValidSignature`] function."]
        pub fn isValidSignature(
            &self,
            _dataHash: ::alloy_sol_types::private::FixedBytes<32>,
            _signatureData: ::alloy_sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, isValidSignatureCall, N> {
            self.call_builder(&isValidSignatureCall {
                _dataHash,
                _signatureData,
            })
        }
        #[doc = "Creates a new call builder for the [`minimumWeight`] function."]
        pub fn minimumWeight(&self) -> alloy_contract::SolCallBuilder<T, &P, minimumWeightCall, N> {
            self.call_builder(&minimumWeightCall {})
        }
        #[doc = "Creates a new call builder for the [`operatorRegistered`] function."]
        pub fn operatorRegistered(
            &self,
            _operator: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, operatorRegisteredCall, N> {
            self.call_builder(&operatorRegisteredCall { _operator })
        }
        #[doc = "Creates a new call builder for the [`owner`] function."]
        pub fn owner(&self) -> alloy_contract::SolCallBuilder<T, &P, ownerCall, N> {
            self.call_builder(&ownerCall {})
        }
        #[doc = "Creates a new call builder for the [`quorum`] function."]
        pub fn quorum(&self) -> alloy_contract::SolCallBuilder<T, &P, quorumCall, N> {
            self.call_builder(&quorumCall {})
        }
        #[doc = "Creates a new call builder for the [`registerOperatorWithSignature`] function."]
        pub fn registerOperatorWithSignature(
            &self,
            _operatorSignature: <SignatureWithSaltAndExpiry as ::alloy_sol_types::SolType>::RustType,
            _signingKey: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, registerOperatorWithSignatureCall, N> {
            self.call_builder(&registerOperatorWithSignatureCall {
                _operatorSignature,
                _signingKey,
            })
        }
        #[doc = "Creates a new call builder for the [`renounceOwnership`] function."]
        pub fn renounceOwnership(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceOwnershipCall, N> {
            self.call_builder(&renounceOwnershipCall {})
        }
        #[doc = "Creates a new call builder for the [`transferOwnership`] function."]
        pub fn transferOwnership(
            &self,
            newOwner: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferOwnershipCall, N> {
            self.call_builder(&transferOwnershipCall { newOwner })
        }
        #[doc = "Creates a new call builder for the [`updateMinimumWeight`] function."]
        pub fn updateMinimumWeight(
            &self,
            _newMinimumWeight: ::alloy_sol_types::private::U256,
            _operators: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateMinimumWeightCall, N> {
            self.call_builder(&updateMinimumWeightCall {
                _newMinimumWeight,
                _operators,
            })
        }
        #[doc = "Creates a new call builder for the [`updateOperatorSigningKey`] function."]
        pub fn updateOperatorSigningKey(
            &self,
            _newSigningKey: ::alloy_sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateOperatorSigningKeyCall, N> {
            self.call_builder(&updateOperatorSigningKeyCall { _newSigningKey })
        }
        #[doc = "Creates a new call builder for the [`updateOperators`] function."]
        pub fn updateOperators(
            &self,
            _operators: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateOperatorsCall, N> {
            self.call_builder(&updateOperatorsCall { _operators })
        }
        #[doc = "Creates a new call builder for the [`updateOperatorsForQuorum`] function."]
        pub fn updateOperatorsForQuorum(
            &self,
            operatorsPerQuorum: ::alloy_sol_types::private::Vec<
                ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
            >,
            _1: ::alloy_sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateOperatorsForQuorumCall, N> {
            self.call_builder(&updateOperatorsForQuorumCall {
                operatorsPerQuorum,
                _1,
            })
        }
        #[doc = "Creates a new call builder for the [`updateQuorumConfig`] function."]
        pub fn updateQuorumConfig(
            &self,
            _quorum: <Quorum as ::alloy_sol_types::SolType>::RustType,
            _operators: ::alloy_sol_types::private::Vec<::alloy_sol_types::private::Address>,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateQuorumConfigCall, N> {
            self.call_builder(&updateQuorumConfigCall {
                _quorum,
                _operators,
            })
        }
        #[doc = "Creates a new call builder for the [`updateStakeThreshold`] function."]
        pub fn updateStakeThreshold(
            &self,
            _thresholdWeight: ::alloy_sol_types::private::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateStakeThresholdCall, N> {
            self.call_builder(&updateStakeThresholdCall { _thresholdWeight })
        }
    }
    #[doc = r" Event filters."]
    #[automatically_derived]
    impl<
            T: alloy_contract::private::Transport + ::core::clone::Clone,
            P: alloy_contract::private::Provider<T, N>,
            N: alloy_contract::private::Network,
        > ECDSAStakeRegistryInstance<T, P, N>
    {
        #[doc = r" Creates a new event filter using this contract instance's provider and address."]
        #[doc = r""]
        #[doc = r" Note that the type can be any event, not just those defined in this contract."]
        #[doc = r" Prefer using the other methods for building type-safe event filters."]
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        #[doc = "Creates a new event filter for the [`Initialized`] event."]
        pub fn Initialized_filter(&self) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        #[doc = "Creates a new event filter for the [`MinimumWeightUpdated`] event."]
        pub fn MinimumWeightUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, MinimumWeightUpdated, N> {
            self.event_filter::<MinimumWeightUpdated>()
        }
        #[doc = "Creates a new event filter for the [`OperatorDeregistered`] event."]
        pub fn OperatorDeregistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorDeregistered, N> {
            self.event_filter::<OperatorDeregistered>()
        }
        #[doc = "Creates a new event filter for the [`OperatorRegistered`] event."]
        pub fn OperatorRegistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorRegistered, N> {
            self.event_filter::<OperatorRegistered>()
        }
        #[doc = "Creates a new event filter for the [`OperatorWeightUpdated`] event."]
        pub fn OperatorWeightUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorWeightUpdated, N> {
            self.event_filter::<OperatorWeightUpdated>()
        }
        #[doc = "Creates a new event filter for the [`OwnershipTransferred`] event."]
        pub fn OwnershipTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OwnershipTransferred, N> {
            self.event_filter::<OwnershipTransferred>()
        }
        #[doc = "Creates a new event filter for the [`QuorumUpdated`] event."]
        pub fn QuorumUpdated_filter(&self) -> alloy_contract::Event<T, &P, QuorumUpdated, N> {
            self.event_filter::<QuorumUpdated>()
        }
        #[doc = "Creates a new event filter for the [`SigningKeyUpdate`] event."]
        pub fn SigningKeyUpdate_filter(&self) -> alloy_contract::Event<T, &P, SigningKeyUpdate, N> {
            self.event_filter::<SigningKeyUpdate>()
        }
        #[doc = "Creates a new event filter for the [`ThresholdWeightUpdated`] event."]
        pub fn ThresholdWeightUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ThresholdWeightUpdated, N> {
            self.event_filter::<ThresholdWeightUpdated>()
        }
        #[doc = "Creates a new event filter for the [`TotalWeightUpdated`] event."]
        pub fn TotalWeightUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, TotalWeightUpdated, N> {
            self.event_filter::<TotalWeightUpdated>()
        }
        #[doc = "Creates a new event filter for the [`UpdateMinimumWeight`] event."]
        pub fn UpdateMinimumWeight_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, UpdateMinimumWeight, N> {
            self.event_filter::<UpdateMinimumWeight>()
        }
    }
}
