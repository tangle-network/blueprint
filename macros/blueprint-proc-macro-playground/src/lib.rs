use gadget_blueprint_proc_macro::{job, registration_hook, request_hook};

#[derive(Debug, Clone, Copy)]
enum Error {
    InvalidKeygen,
    InvalidSignature,
    InvalidRefresh,
}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        let msg = match self {
            Error::InvalidKeygen => "Invalid Keygen",
            Error::InvalidSignature => "Invalid Signature",
            Error::InvalidRefresh => "Invalid Refresh",
        };
        write!(f, "{}", msg)
    }
}

impl std::error::Error for Error {}

struct MyContext;

/// Simple Threashold (t) Keygen Job for n parties.
#[job(id = 0, params(n, t), result(_), verifier(evm = "KeygenContract"))]
pub fn keygen(ctx: MyContext, n: u16, t: u8) -> Result<Vec<u8>, Error> {
    let _ = (n, t);
    Ok(vec![0; 33])
}

/// Sign a message using a key generated by the keygen job.
#[job(id = 1, params(keygen_id, data), result(_))]
pub async fn sign(keygen_id: u64, data: Vec<u8>) -> Result<Vec<u8>, Error> {
    let _ = (keygen_id, data);
    Ok(vec![0; 65])
}

#[job(id = 2, params(keygen_id, new_t), result(_))]
pub fn refresh(keygen_id: u64, new_t: Option<u8>) -> Result<Vec<u64>, Error> {
    let _ = (keygen_id, new_t);
    Ok(vec![0; 33])
}

#[registration_hook(evm = "RegistrationContract")]
pub fn on_register(pubkey: Vec<u8>);

#[request_hook(evm = "RequestContract")]
pub fn on_request(nft_id: u64);

#[cfg(test)]
mod tests {

    #[test]
    fn generated_blueprint() {
        eprintln!("{}", super::KEYGEN_JOB_DEF);
        assert_eq!(super::KEYGEN_JOB_ID, 0);
        eprintln!("{}", super::REGISTRATION_HOOK);
    }
}
