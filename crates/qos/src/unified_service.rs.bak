use blueprint_core::{error, info};
use std::sync::Arc;

use crate::QoSConfig;
use crate::error::Result;
use crate::heartbeat::{HeartbeatConsumer, HeartbeatService};
use crate::logging::grafana::{CreateDataSourceRequest, LokiJsonData, PrometheusJsonData};
use crate::logging::{GrafanaClient, init_loki_logging};
use crate::metrics::opentelemetry::OpenTelemetryConfig;
use crate::metrics::provider::EnhancedMetricsProvider;
use crate::metrics::service::MetricsService;
use crate::servers::{
    ServerManager, grafana::GrafanaServer, loki::LokiServer, prometheus::PrometheusServer,
    scraping_prometheus::{ScrapingPrometheusServer, ScrapingPrometheusServerConfig}, // Added
};

/// Unified `QoS` service that combines heartbeat, metrics, logging, and dashboard functionality
pub struct QoSService<C>
where
    C: HeartbeatConsumer + Send + Sync + 'static,
{
    /// Heartbeat service
    #[allow(dead_code)]
    heartbeat_service: Option<HeartbeatService<C>>,

    /// Metrics service
    metrics_service: Option<MetricsService>,

    /// Grafana client
    grafana_client: Option<Arc<GrafanaClient>>,

    /// Dashboard URL
    dashboard_url: Option<String>,

    /// Grafana server manager
    grafana_server: Option<Arc<GrafanaServer>>,

    /// Loki server manager
    loki_server: Option<Arc<LokiServer>>,

    /// Prometheus server manager
    prometheus_server: Option<Arc<PrometheusServer>>,

    /// Scraping Prometheus server manager
    scraping_prometheus_server: Option<Arc<ScrapingPrometheusServer>>,

    /// Oneshot sender to signal completion when this service is dropped.
    completion_tx: Option<tokio::sync::oneshot::Sender<Result<()>>>,
}

impl<C> QoSService<C>
where
    C: HeartbeatConsumer + Send + Sync + 'static,
{
    /// Create a new `QoS` service with heartbeat, metrics, and optional Loki/Grafana integration
    ///
    /// # Errors
    /// Returns an error if the metrics service initialization fails
    pub async fn new(config: QoSConfig, heartbeat_consumer: Arc<C>) -> Result<Self> {
        // Initialize heartbeat service if configured
        let heartbeat_service = config
            .heartbeat
            .clone()
            .map(|config| HeartbeatService::new(config, heartbeat_consumer));

        // Initialize metrics service if configured
        let metrics_service = if let Some(metrics_config) = config.metrics.clone() {
            Some(MetricsService::new(metrics_config)?)
        } else {
            None
        };

        // Initialize Loki logging if configured
        if let Some(loki_config) = &config.loki {
            if let Err(e) = init_loki_logging(loki_config.clone()) {
                error!("Failed to initialize Loki logging: {}", e);
            } else {
                info!("Initialized Loki logging");
            }
        }

                // (around line 88)
                let (grafana_server, loki_server, prometheus_server, scraping_prometheus_server_opt) = if config.manage_servers {
                    // Define instances with new names
                    let grafana_server_instance = config
                        .grafana_server
                        .as_ref()
                        .map(|cfg| Arc::new(GrafanaServer::new(cfg.clone())));
                    let loki_server_instance = config
                        .loki_server
                        .as_ref()
                        .map(|cfg| Arc::new(LokiServer::new(cfg.clone())));
                    let prometheus_server_instance = config
                        .prometheus_server
                        .as_ref()
                        .map(|cfg| Arc::new(PrometheusServer::new(cfg.clone())));
                    let scraping_prometheus_server_instance = config // This was the block you added
                        .scraping_prometheus_server
                        .as_ref()
                        .map(|cfg| {
                            match ScrapingPrometheusServer::new(cfg.clone()) {
                                Ok(server) => Arc::new(server),
                                Err(e) => {
                                    error!("Failed to create ScrapingPrometheusServer in new(): {}. It will not be started.", e);
                                    panic!("Critical: Failed to create ScrapingPrometheusServer in new(): {}", e);
                                }
                            }
                        });
        
                    // Start the servers using the *_instance variables (around line 118 onwards)
                    if let Some(server) = &grafana_server_instance { // Use grafana_server_instance
                        info!("Starting Grafana server...");
                        if let Err(e) = server.start().await {
                            error!("Failed to start Grafana server: {}", e); // Non-critical, just log
                        } else {
                            info!("Grafana server started successfully: {}", server.url());
                        }
                    }
        
                    if let Some(server) = &loki_server_instance { // Use loki_server_instance
                        info!("Starting Loki server...");
                        if let Err(e) = server.start().await {
                            error!("Failed to start Loki server: {}", e); // Non-critical, just log
                        } else {
                            info!("Loki server started successfully: {}", server.url());
                        }
                    }
        
                    if let Some(server) = &prometheus_server_instance { // Use prometheus_server_instance
                        info!("Starting Prometheus server (exposer)...");
                        if let Err(e) = server.start().await {
                            error!("Failed to start critical Prometheus server (exposer): {}", e); return Err(e); // This is critical
                        } else {
                            info!("Prometheus server (exposer) started successfully: {}", server.url());
                        }
                    }
        
                    if let Some(server) = &scraping_prometheus_server_instance { // Use scraping_prometheus_server_instance
                        info!("Starting scraping Prometheus server (new)... ");
                        if let Err(e) = server.start().await {
                            error!("Failed to start scraping Prometheus server (new): {}. Metrics might not be scraped.", e);
                        } else {
                            info!("Scraping Prometheus server (new) started successfully: {}", server.url());
                        }
                    }
        
                    // Return the instances (around line 145)
                    (grafana_server_instance, loki_server_instance, prometheus_server_instance, scraping_prometheus_server_instance)
                } else {
                    (None, None, None, None)
                };
                // Now, the variables from line 88 (grafana_server, loki_server, etc.) are correctly populated
                // and can be used for the struct initialization later.

        // Update Grafana client if we are managing servers
        let grafana_client = if let Some(server) = &grafana_server {
            Some(Arc::new(GrafanaClient::new(server.client_config())))
        } else {
            config
                .grafana
                .as_ref()
                .map(|grafana_config| Arc::new(GrafanaClient::new(grafana_config.clone())))
        };

        Ok(Self {
            heartbeat_service,
            metrics_service,
            grafana_client,
            dashboard_url: None,
            grafana_server,
            loki_server,
            prometheus_server,
            scraping_prometheus_server: scraping_prometheus_server_opt,
            completion_tx: None,
        })
    }

    /// Create a new `QoS` service with custom OpenTelemetry configuration
    ///
    /// # Errors
    /// Returns an error if the metrics service initialization fails
    pub async fn with_otel_config(
        config: QoSConfig,
        heartbeat_consumer: Arc<C>,
        otel_config: OpenTelemetryConfig,
    ) -> Result<Self> {
        // Initialize heartbeat service if configured
        let heartbeat_service = config
            .heartbeat
            .clone()
            .map(|config| HeartbeatService::new(config, heartbeat_consumer));

        // Initialize metrics service if configured
        let metrics_service = if let Some(metrics_config) = config.metrics.clone() {
            Some(MetricsService::with_otel_config(
                metrics_config,
                otel_config,
            )?)
        } else {
            None
        };

        // Initialize Loki logging if configured
        if let Some(loki_config) = &config.loki {
            if let Err(e) = init_loki_logging(loki_config.clone()) {
                error!("Failed to initialize Loki logging: {}", e);
            } else {
                info!("Initialized Loki logging");
            }
        }

        // Initialize server managers if configured
        let (grafana_server, loki_server, prometheus_server) = if config.manage_servers {
        let (grafana_server, loki_server, prometheus_server, scraping_prometheus_server) = if config.manage_servers {
            let (grafana_server, loki_server, prometheus_server, scraping_prometheus_server) = (
                config
                    .grafana_server
                    .as_ref()
                    .map(|cfg| Arc::new(GrafanaServer::new(cfg.clone()))),
                config
                    .loki_server
                    .as_ref()
                    .map(|cfg| Arc::new(LokiServer::new(cfg.clone()))),
                config
                    .prometheus_server
                    .as_ref()
                    .map(|cfg| Arc::new(PrometheusServer::new(cfg.clone()))),
                config
                    .scraping_prometheus_server
                    .as_ref()
                    .map(|cfg| Arc::new(ScrapingPrometheusServer::new(cfg.clone()))),
            );

            // Start the servers if configured
            if let Some(server) = &grafana_server {
                info!("Starting Grafana server...");
                if let Err(e) = server.start().await {
                    error!("Failed to start Grafana server: {}", e);
                } else {
                    info!("Grafana server started successfully");
                }
            }

            if let Some(server) = &loki_server {
                info!("Starting Loki server...");
                if let Err(e) = server.start().await {
                    error!("Failed to start Loki server: {}", e);
                } else {
                    info!("Loki server started successfully");
                }
            }

            if let Some(server) = &prometheus_server {
                info!("Starting Prometheus server...");
                if let Err(e) = server.start().await {
                    error!("Failed to start critical Prometheus server: {}", e); return Err(e);
                } else {
                    info!("Prometheus server started successfully");
                }
            }

            (grafana_server, loki_server, prometheus_server, scraping_prometheus_server)
        } else {
            (None, None, None, None)
        };

        // Update Grafana client if we are managing servers
        let grafana_client = if let Some(server) = &grafana_server {
            Some(Arc::new(GrafanaClient::new(server.client_config())))
        } else {
            // Otherwise use the provided config
            config
                .grafana
                .as_ref()
                .map(|grafana_config| Arc::new(GrafanaClient::new(grafana_config.clone())))
        };

        Ok(Self {
            heartbeat_service,
            metrics_service,
            grafana_client,
            dashboard_url: None,
            grafana_server,
            loki_server,
            prometheus_server,
            scraping_prometheus_server,
            completion_tx: None,
        })
    }

    /// Create a Grafana dashboard for the service
    ///
    /// # Errors
    /// Returns an error if the dashboard creation fails due to Grafana API issues
    pub async fn create_dashboard(
        &mut self,
        service_id: u64,
        blueprint_id: u64,
        prometheus_datasource_uid: &str, // Renamed for clarity to UID
        loki_datasource_uid: &str,       // Renamed for clarity to UID
    ) -> Result<Option<String>> {
        if let Some(client) = &self.grafana_client {

            let prometheus_ds_name = "Blueprint Prometheus";
            let prometheus_url = self.prometheus_server_url().unwrap_or_else(|| {
                blueprint_core::warn!("Prometheus server URL not available for Grafana data source creation, defaulting to http://localhost:9091");
                "http://localhost:9091".to_string()
            });

            let prometheus_json_data = PrometheusJsonData {
                http_method: "POST".to_string(),
                timeout: Some(30),
            };
            let prometheus_request_payload = CreateDataSourceRequest {
                name: prometheus_ds_name.to_string(),
                ds_type: "prometheus".to_string(),
                url: prometheus_url.clone(),
                access: "proxy".to_string(),
                uid: Some(prometheus_datasource_uid.to_string()),
                is_default: Some(true),
                json_data: Some(serde_json::to_value(prometheus_json_data).map_err(|e| crate::error::Error::Json(e.to_string()))?),
            };

            match client.create_or_update_datasource(prometheus_request_payload).await {
                Ok(response) => {
                    info!("Successfully created/updated Prometheus datasource '{}' in Grafana with UID: {}", response.name, response.datasource.uid);
                }
                Err(e) => {
                    error!("Failed to create/update Prometheus datasource '{}' in Grafana: {}. Halting dashboard creation.", prometheus_ds_name, e);
                    return Err(e);
                }
            }

            if !loki_datasource_uid.is_empty() {
                let loki_ds_name = "Blueprint Loki";
                let loki_url = self.loki_server_url().unwrap_or_else(|| {
                    blueprint_core::warn!("Loki server URL not available for Grafana data source creation, defaulting to http://localhost:3100");
                    "http://localhost:3100".to_string()
                });

                let loki_json_data = LokiJsonData {
                    max_lines: Some(1000),
                };
                let loki_request_payload = CreateDataSourceRequest {
                    name: loki_ds_name.to_string(),
                    ds_type: "loki".to_string(),
                    url: loki_url.clone(),
                    access: "proxy".to_string(),
                    uid: Some(loki_datasource_uid.to_string()),
                    is_default: Some(false),
                    json_data: Some(serde_json::to_value(loki_json_data).map_err(|e| crate::error::Error::Json(e.to_string()))?),
                };

                match client.create_or_update_datasource(loki_request_payload).await {
                    Ok(response) => {
                        info!("Successfully created/updated Loki datasource '{}' in Grafana with UID: {}", response.name, response.datasource.uid);
                    }
                    Err(e) => {
                        error!("Failed to create/update Loki datasource in Grafana: {}. Proceeding with dashboard creation attempt.", e);
                    }
                }
            }

            // Now, create the dashboard using the provided datasource UIDs
            match client.create_blueprint_dashboard(
                service_id, // Now passed as a parameter
                blueprint_id, // Now passed as a parameter
                prometheus_datasource_uid,
                loki_datasource_uid,
            ).await {
                Ok(url) => {
                    self.dashboard_url = Some(url.clone());
                    info!("Successfully created/updated Grafana dashboard: {}", url);
                    Ok(Some(url))
                }
                Err(e) => {
                    error!("Failed to create Grafana dashboard: {}", e);
                    Err(e)
                }
            }
        } else {
            Ok(None)
        }
    }

    /// Get the metrics provider if available
    #[must_use]
    pub fn metrics_provider(&self) -> Option<Arc<EnhancedMetricsProvider>> {
        self.metrics_service
            .as_ref()
            .map(super::metrics::service::MetricsService::provider)
    }

    /// Record job execution if metrics service is available
    pub fn record_job_execution(&self, job_id: u64, execution_time: f64) {
        if let Some(service) = &self.metrics_service {
            service.record_job_execution(job_id, execution_time);
        }
    }

    /// Record job error if metrics service is available
    pub fn record_job_error(&self, job_id: u64, error_type: &str) {
        if let Some(service) = &self.metrics_service {
            service.record_job_error(job_id, error_type);
        }
    }

    /// Get the Grafana server URL if available
    #[must_use]
    pub fn grafana_server_url(&self) -> Option<String> {
        self.grafana_server.as_ref().map(|server| server.url())
    }

    /// Get the Loki server URL if available
    #[must_use]
    pub fn loki_server_url(&self) -> Option<String> {
        self.loki_server.as_ref().map(|server| server.url())
    }

    /// Get the Grafana client if available
    #[must_use]
    pub fn grafana_client(&self) -> Option<&Arc<GrafanaClient>> {
        self.grafana_client.as_ref()
    }

    /// Get the Prometheus server URL if available
    #[must_use]
    pub fn prometheus_server_url(&self) -> Option<String> {
        self.prometheus_server.as_ref().map(|server| server.url())
    }

    /// Get the Scraping Prometheus server URL if available
    #[must_use]
    pub fn scraping_prometheus_server_url(&self) -> Option<String> {
        self.scraping_prometheus_server.as_ref().map(|server| server.url())
    }

    /// Get the Prometheus registry if available
    #[must_use]
    pub fn prometheus_registry(&self) -> Option<Arc<prometheus::Registry>> {
        self.metrics_provider().map(|provider| {
            let collector = provider.prometheus_collector();
            Arc::new(collector.registry().clone())
        })
    }

    /// Get the heartbeat service if available
    #[must_use]
    pub fn heartbeat_service(&self) -> Option<&HeartbeatService<C>> {
        self.heartbeat_service.as_ref()
    }

    /// Debug method to check if servers are initialized
    pub fn debug_server_status(&self) {
        info!("Server status:");
        info!("Grafana server: {}", self.grafana_server.is_some());
        info!("Loki server: {}", self.loki_server.is_some());
        info!("Prometheus server (exposer): {}", self.prometheus_server.is_some());
        info!("Scraping Prometheus server: {}", self.scraping_prometheus_server.is_some()); // Added to debug_server_status

        if let Some(server) = &self.grafana_server {
            info!("Grafana URL: {}", server.url());
        }
        if let Some(server) = &self.loki_server {
            info!("Loki URL: {}", server.url());
        }
        if let Some(server) = &self.prometheus_server {
            info!("Prometheus (exposer) URL: {}", server.url());
        }
        if let Some(server) = &self.scraping_prometheus_server { // Added to debug_server_status
            info!("Scraping Prometheus URL: {}", server.url());
        }
    }

    /// Sets the oneshot sender that will be used to signal completion when this QoSService is dropped.
    /// This is typically called by an adapter (e.g., QoSServiceAdapter) when integrating QoSService
    /// into a runner framework that expects a completion signal.
    pub fn set_completion_sender(&mut self, tx: tokio::sync::oneshot::Sender<Result<()>>) {
        if self.completion_tx.is_some() {
            blueprint_core::warn!("[QoSService::set_completion_sender] Completion sender was already set. Overwriting.");
        }
        self.completion_tx = Some(tx);
    }
} // Closing brace for impl<C> QoSService<C>

impl<C> Drop for QoSService<C>
where
    C: HeartbeatConsumer + Send + Sync + 'static,
{
    fn drop(&mut self) {
        use std::backtrace::Backtrace;
        let bt = Backtrace::force_capture();
        info!("[QoSService::Drop] Dropping QoSService<C>. Backtrace:\n{:?}", bt);
        // Stop the server managers
        if let Some(server) = &self.grafana_server {
            info!("Stopping Grafana server...");
            let _ = futures::executor::block_on(server.stop());
        }

        if let Some(server) = &self.loki_server {
            info!("Stopping Loki server...");
            let _ = futures::executor::block_on(server.stop());
        }

        if let Some(server) = &self.prometheus_server {
            info!("Stopping Prometheus server (exposer)...");
            let _ = futures::executor::block_on(server.stop());
        }

        if let Some(server) = &self.scraping_prometheus_server { // Added to drop
            info!("Stopping scraping Prometheus server...");
            let _ = futures::executor::block_on(server.stop());
        }

        // Signal completion if a sender was provided
        if let Some(tx) = self.completion_tx.take() {
            if tx.send(Ok(())).is_err() {
                info!("[QoSService::Drop] Completion signal receiver was already dropped while sending Ok.");
            } else {
                info!("[QoSService::Drop] Sent Ok(()) completion signal.");
            }
        } else {
            info!("[QoSService::Drop] No completion sender was set, so no explicit signal sent.");
        }
        info!("[QoSService::Drop] Finished dropping QoSService<C>.");
    }
}
