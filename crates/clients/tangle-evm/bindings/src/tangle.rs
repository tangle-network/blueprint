///Module containing a contract's types and functions.
/**

```solidity
library PaymentLib {
    struct ServiceEscrow { address token; uint256 balance; uint256 totalDeposited; uint256 totalReleased; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod PaymentLib {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /**```solidity
struct ServiceEscrow { address token; uint256 balance; uint256 totalDeposited; uint256 totalReleased; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceEscrow {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub balance: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub totalDeposited: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub totalReleased: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ServiceEscrow> for UnderlyingRustTuple<'_> {
            fn from(value: ServiceEscrow) -> Self {
                (value.token, value.balance, value.totalDeposited, value.totalReleased)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ServiceEscrow {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    token: tuple.0,
                    balance: tuple.1,
                    totalDeposited: tuple.2,
                    totalReleased: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ServiceEscrow {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ServiceEscrow {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.balance),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalDeposited),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalReleased),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ServiceEscrow {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ServiceEscrow {
            const NAME: &'static str = "ServiceEscrow";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ServiceEscrow(address token,uint256 balance,uint256 totalDeposited,uint256 totalReleased)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.token,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.balance)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.totalDeposited,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.totalReleased)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ServiceEscrow {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.token,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.balance,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalDeposited,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalReleased,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.token,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.balance,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalDeposited,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalReleased,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`PaymentLib`](self) contract instance.

See the [wrapper's documentation](`PaymentLibInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> PaymentLibInstance<T, P, N> {
        PaymentLibInstance::<T, P, N>::new(address, provider)
    }
    /**A [`PaymentLib`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`PaymentLib`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct PaymentLibInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for PaymentLibInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("PaymentLibInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PaymentLibInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`PaymentLib`](self) contract instance.

See the [wrapper's documentation](`PaymentLibInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> PaymentLibInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> PaymentLibInstance<T, P, N> {
            PaymentLibInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PaymentLibInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > PaymentLibInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
///Module containing a contract's types and functions.
/**

```solidity
library SlashingLib {
    type SlashStatus is uint8;
    struct SlashProposal { uint64 serviceId; address operator; address proposer; uint256 amount; uint256 effectiveAmount; bytes32 evidence; uint64 proposedAt; uint64 executeAfter; SlashStatus status; string disputeReason; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod SlashingLib {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SlashStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<SlashStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl SlashStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SlashStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SlashStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct SlashProposal { uint64 serviceId; address operator; address proposer; uint256 amount; uint256 effectiveAmount; bytes32 evidence; uint64 proposedAt; uint64 executeAfter; SlashStatus status; string disputeReason; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SlashProposal {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub proposer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub effectiveAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub proposedAt: u64,
        #[allow(missing_docs)]
        pub executeAfter: u64,
        #[allow(missing_docs)]
        pub status: <SlashStatus as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub disputeReason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::FixedBytes<32>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            SlashStatus,
            alloy::sol_types::sol_data::String,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::FixedBytes<32>,
            u64,
            u64,
            <SlashStatus as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::String,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SlashProposal> for UnderlyingRustTuple<'_> {
            fn from(value: SlashProposal) -> Self {
                (
                    value.serviceId,
                    value.operator,
                    value.proposer,
                    value.amount,
                    value.effectiveAmount,
                    value.evidence,
                    value.proposedAt,
                    value.executeAfter,
                    value.status,
                    value.disputeReason,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SlashProposal {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    operator: tuple.1,
                    proposer: tuple.2,
                    amount: tuple.3,
                    effectiveAmount: tuple.4,
                    evidence: tuple.5,
                    proposedAt: tuple.6,
                    executeAfter: tuple.7,
                    status: tuple.8,
                    disputeReason: tuple.9,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SlashProposal {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SlashProposal {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.proposer,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.effectiveAmount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.proposedAt),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.executeAfter),
                    <SlashStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.disputeReason,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SlashProposal {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SlashProposal {
            const NAME: &'static str = "SlashProposal";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SlashProposal(uint64 serviceId,address operator,address proposer,uint256 amount,uint256 effectiveAmount,bytes32 evidence,uint64 proposedAt,uint64 executeAfter,uint8 status,string disputeReason)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.serviceId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.operator,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.proposer,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.amount)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.effectiveAmount,
                        )
                        .0,
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.evidence)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.proposedAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.executeAfter)
                        .0,
                    <SlashStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.status,
                        )
                        .0,
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::eip712_data_word(
                            &self.disputeReason,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SlashProposal {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.serviceId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operator,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.proposer,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.amount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.effectiveAmount,
                    )
                    + <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.evidence,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.proposedAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.executeAfter,
                    )
                    + <SlashStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.status,
                    )
                    + <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.disputeReason,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.serviceId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operator,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.proposer,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.amount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.effectiveAmount,
                    out,
                );
                <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.evidence,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.proposedAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.executeAfter,
                    out,
                );
                <SlashStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.status,
                    out,
                );
                <alloy::sol_types::sol_data::String as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.disputeReason,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`SlashingLib`](self) contract instance.

See the [wrapper's documentation](`SlashingLibInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> SlashingLibInstance<T, P, N> {
        SlashingLibInstance::<T, P, N>::new(address, provider)
    }
    /**A [`SlashingLib`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`SlashingLib`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct SlashingLibInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for SlashingLibInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("SlashingLibInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SlashingLibInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`SlashingLib`](self) contract instance.

See the [wrapper's documentation](`SlashingLibInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> SlashingLibInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> SlashingLibInstance<T, P, N> {
            SlashingLibInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SlashingLibInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > SlashingLibInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
///Module containing a contract's types and functions.
/**

```solidity
library Types {
    type AssetKind is uint8;
    type MembershipModel is uint8;
    type PricingModel is uint8;
    type ServiceStatus is uint8;
    struct Asset { AssetKind kind; address token; }
    struct AssetSecurityCommitment { Asset asset; uint16 exposureBps; }
    struct AssetSecurityRequirement { Asset asset; uint16 minExposureBps; uint16 maxExposureBps; }
    struct Blueprint { address owner; address manager; uint64 createdAt; uint32 operatorCount; MembershipModel membership; PricingModel pricing; bool active; }
    struct BlueprintConfig { MembershipModel membership; PricingModel pricing; uint32 minOperators; uint32 maxOperators; uint256 subscriptionRate; uint64 subscriptionInterval; uint256 eventRate; }
    struct JobCall { uint8 jobIndex; address caller; uint64 createdAt; uint32 resultCount; uint256 payment; bool completed; }
    struct OperatorRegistration { uint64 registeredAt; uint64 updatedAt; bool active; bool online; }
    struct PaymentSplit { uint16 developerBps; uint16 protocolBps; uint16 operatorBps; uint16 restakerBps; }
    struct QuoteDetails { uint64 blueprintId; uint64 ttlBlocks; uint256 totalCost; uint64 timestamp; uint64 expiry; AssetSecurityCommitment[] securityCommitments; }
    struct Service { uint64 blueprintId; address owner; uint64 createdAt; uint64 ttl; uint64 terminatedAt; uint64 lastPaymentAt; uint32 operatorCount; uint32 minOperators; uint32 maxOperators; MembershipModel membership; PricingModel pricing; ServiceStatus status; }
    struct ServiceOperator { uint16 exposureBps; uint64 joinedAt; uint64 leftAt; bool active; }
    struct ServiceRequest { uint64 blueprintId; address requester; uint64 createdAt; uint64 ttl; uint32 operatorCount; uint32 approvalCount; address paymentToken; uint256 paymentAmount; MembershipModel membership; uint32 minOperators; uint32 maxOperators; bool rejected; }
    struct SignedQuote { QuoteDetails details; bytes signature; address operator; }
}
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Types {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssetKind(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<AssetKind> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl AssetKind {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssetKind {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssetKind {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MembershipModel(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<MembershipModel> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl MembershipModel {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for MembershipModel {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for MembershipModel {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PricingModel(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<PricingModel> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl PricingModel {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PricingModel {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PricingModel {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceStatus(u8);
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<ServiceStatus> for u8 {
            #[inline]
            fn stv_to_tokens(
                &self,
            ) -> <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'_> {
                alloy_sol_types::private::SolTypeValue::<
                    alloy::sol_types::sol_data::Uint<8>,
                >::stv_to_tokens(self)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::tokenize(self)
                    .0
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(self, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::abi_encoded_size(self)
            }
        }
        #[automatically_derived]
        impl ServiceStatus {
            /// The Solidity type name.
            pub const NAME: &'static str = stringify!(@ name);
            /// Convert from the underlying value type.
            #[inline]
            pub const fn from(value: u8) -> Self {
                Self(value)
            }
            /// Return the underlying value.
            #[inline]
            pub const fn into(self) -> u8 {
                self.0
            }
            /// Return the single encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode(&self.0)
            }
            /// Return the packed encoding of this value, delegating to the
            /// underlying type.
            #[inline]
            pub fn abi_encode_packed(&self) -> alloy_sol_types::private::Vec<u8> {
                <Self as alloy_sol_types::SolType>::abi_encode_packed(&self.0)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ServiceStatus {
            type RustType = u8;
            type Token<'a> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = Self::NAME;
            const ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <alloy::sol_types::sol_data::Uint<
                8,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                Self::type_check(token).is_ok()
            }
            #[inline]
            fn type_check(token: &Self::Token<'_>) -> alloy_sol_types::Result<()> {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::type_check(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::SolType>::detokenize(token)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ServiceStatus {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::topic_preimage_length(rust)
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(rust, out)
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic(rust)
            }
        }
    };
    /**```solidity
struct Asset { AssetKind kind; address token; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Asset {
        #[allow(missing_docs)]
        pub kind: <AssetKind as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (AssetKind, alloy::sol_types::sol_data::Address);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <AssetKind as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Asset> for UnderlyingRustTuple<'_> {
            fn from(value: Asset) -> Self {
                (value.kind, value.token)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Asset {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    kind: tuple.0,
                    token: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Asset {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Asset {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <AssetKind as alloy_sol_types::SolType>::tokenize(&self.kind),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Asset {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Asset {
            const NAME: &'static str = "Asset";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Asset(uint8 kind,address token)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <AssetKind as alloy_sol_types::SolType>::eip712_data_word(&self.kind)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.token,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Asset {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <AssetKind as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.kind,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.token,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <AssetKind as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.kind,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.token,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct AssetSecurityCommitment { Asset asset; uint16 exposureBps; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssetSecurityCommitment {
        #[allow(missing_docs)]
        pub asset: <Asset as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub exposureBps: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (Asset, alloy::sol_types::sol_data::Uint<16>);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <Asset as alloy::sol_types::SolType>::RustType,
            u16,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssetSecurityCommitment> for UnderlyingRustTuple<'_> {
            fn from(value: AssetSecurityCommitment) -> Self {
                (value.asset, value.exposureBps)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AssetSecurityCommitment {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    asset: tuple.0,
                    exposureBps: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssetSecurityCommitment {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssetSecurityCommitment {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <Asset as alloy_sol_types::SolType>::tokenize(&self.asset),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.exposureBps),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssetSecurityCommitment {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssetSecurityCommitment {
            const NAME: &'static str = "AssetSecurityCommitment";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssetSecurityCommitment(Asset asset,uint16 exposureBps)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Asset as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Asset as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <Asset as alloy_sol_types::SolType>::eip712_data_word(&self.asset).0,
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.exposureBps)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssetSecurityCommitment {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <Asset as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.asset,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.exposureBps,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <Asset as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.asset,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.exposureBps,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct AssetSecurityRequirement { Asset asset; uint16 minExposureBps; uint16 maxExposureBps; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AssetSecurityRequirement {
        #[allow(missing_docs)]
        pub asset: <Asset as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub minExposureBps: u16,
        #[allow(missing_docs)]
        pub maxExposureBps: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            Asset,
            alloy::sol_types::sol_data::Uint<16>,
            alloy::sol_types::sol_data::Uint<16>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <Asset as alloy::sol_types::SolType>::RustType,
            u16,
            u16,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AssetSecurityRequirement>
        for UnderlyingRustTuple<'_> {
            fn from(value: AssetSecurityRequirement) -> Self {
                (value.asset, value.minExposureBps, value.maxExposureBps)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AssetSecurityRequirement {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    asset: tuple.0,
                    minExposureBps: tuple.1,
                    maxExposureBps: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for AssetSecurityRequirement {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for AssetSecurityRequirement {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <Asset as alloy_sol_types::SolType>::tokenize(&self.asset),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.minExposureBps),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxExposureBps),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for AssetSecurityRequirement {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for AssetSecurityRequirement {
            const NAME: &'static str = "AssetSecurityRequirement";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "AssetSecurityRequirement(Asset asset,uint16 minExposureBps,uint16 maxExposureBps)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(<Asset as alloy_sol_types::SolStruct>::eip712_root_type());
                components
                    .extend(<Asset as alloy_sol_types::SolStruct>::eip712_components());
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <Asset as alloy_sol_types::SolType>::eip712_data_word(&self.asset).0,
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.minExposureBps,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.maxExposureBps,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for AssetSecurityRequirement {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <Asset as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.asset,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minExposureBps,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.maxExposureBps,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <Asset as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.asset,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minExposureBps,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.maxExposureBps,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Blueprint { address owner; address manager; uint64 createdAt; uint32 operatorCount; MembershipModel membership; PricingModel pricing; bool active; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Blueprint {
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub manager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub createdAt: u64,
        #[allow(missing_docs)]
        pub operatorCount: u32,
        #[allow(missing_docs)]
        pub membership: <MembershipModel as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub pricing: <PricingModel as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub active: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<32>,
            MembershipModel,
            PricingModel,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Address,
            u64,
            u32,
            <MembershipModel as alloy::sol_types::SolType>::RustType,
            <PricingModel as alloy::sol_types::SolType>::RustType,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Blueprint> for UnderlyingRustTuple<'_> {
            fn from(value: Blueprint) -> Self {
                (
                    value.owner,
                    value.manager,
                    value.createdAt,
                    value.operatorCount,
                    value.membership,
                    value.pricing,
                    value.active,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Blueprint {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    owner: tuple.0,
                    manager: tuple.1,
                    createdAt: tuple.2,
                    operatorCount: tuple.3,
                    membership: tuple.4,
                    pricing: tuple.5,
                    active: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Blueprint {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Blueprint {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.manager,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.createdAt),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorCount),
                    <MembershipModel as alloy_sol_types::SolType>::tokenize(
                        &self.membership,
                    ),
                    <PricingModel as alloy_sol_types::SolType>::tokenize(&self.pricing),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.active,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Blueprint {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Blueprint {
            const NAME: &'static str = "Blueprint";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Blueprint(address owner,address manager,uint64 createdAt,uint32 operatorCount,uint8 membership,uint8 pricing,bool active)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.owner,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.manager,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.createdAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.operatorCount)
                        .0,
                    <MembershipModel as alloy_sol_types::SolType>::eip712_data_word(
                            &self.membership,
                        )
                        .0,
                    <PricingModel as alloy_sol_types::SolType>::eip712_data_word(
                            &self.pricing,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.active,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Blueprint {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.owner,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.manager,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.createdAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operatorCount,
                    )
                    + <MembershipModel as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.membership,
                    )
                    + <PricingModel as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.pricing,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.active,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.owner,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.manager,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.createdAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operatorCount,
                    out,
                );
                <MembershipModel as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.membership,
                    out,
                );
                <PricingModel as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.pricing,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.active,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct BlueprintConfig { MembershipModel membership; PricingModel pricing; uint32 minOperators; uint32 maxOperators; uint256 subscriptionRate; uint64 subscriptionInterval; uint256 eventRate; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlueprintConfig {
        #[allow(missing_docs)]
        pub membership: <MembershipModel as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub pricing: <PricingModel as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub minOperators: u32,
        #[allow(missing_docs)]
        pub maxOperators: u32,
        #[allow(missing_docs)]
        pub subscriptionRate: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub subscriptionInterval: u64,
        #[allow(missing_docs)]
        pub eventRate: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            MembershipModel,
            PricingModel,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <MembershipModel as alloy::sol_types::SolType>::RustType,
            <PricingModel as alloy::sol_types::SolType>::RustType,
            u32,
            u32,
            alloy::sol_types::private::primitives::aliases::U256,
            u64,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlueprintConfig> for UnderlyingRustTuple<'_> {
            fn from(value: BlueprintConfig) -> Self {
                (
                    value.membership,
                    value.pricing,
                    value.minOperators,
                    value.maxOperators,
                    value.subscriptionRate,
                    value.subscriptionInterval,
                    value.eventRate,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlueprintConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    membership: tuple.0,
                    pricing: tuple.1,
                    minOperators: tuple.2,
                    maxOperators: tuple.3,
                    subscriptionRate: tuple.4,
                    subscriptionInterval: tuple.5,
                    eventRate: tuple.6,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for BlueprintConfig {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for BlueprintConfig {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <MembershipModel as alloy_sol_types::SolType>::tokenize(
                        &self.membership,
                    ),
                    <PricingModel as alloy_sol_types::SolType>::tokenize(&self.pricing),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.minOperators),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxOperators),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.subscriptionRate),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.subscriptionInterval),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.eventRate),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for BlueprintConfig {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for BlueprintConfig {
            const NAME: &'static str = "BlueprintConfig";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "BlueprintConfig(uint8 membership,uint8 pricing,uint32 minOperators,uint32 maxOperators,uint256 subscriptionRate,uint64 subscriptionInterval,uint256 eventRate)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <MembershipModel as alloy_sol_types::SolType>::eip712_data_word(
                            &self.membership,
                        )
                        .0,
                    <PricingModel as alloy_sol_types::SolType>::eip712_data_word(
                            &self.pricing,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.minOperators)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.maxOperators)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.subscriptionRate,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.subscriptionInterval,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.eventRate)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for BlueprintConfig {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <MembershipModel as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.membership,
                    )
                    + <PricingModel as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.pricing,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minOperators,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.maxOperators,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.subscriptionRate,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.subscriptionInterval,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.eventRate,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <MembershipModel as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.membership,
                    out,
                );
                <PricingModel as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.pricing,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minOperators,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.maxOperators,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.subscriptionRate,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.subscriptionInterval,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.eventRate,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct JobCall { uint8 jobIndex; address caller; uint64 createdAt; uint32 resultCount; uint256 payment; bool completed; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct JobCall {
        #[allow(missing_docs)]
        pub jobIndex: u8,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub createdAt: u64,
        #[allow(missing_docs)]
        pub resultCount: u32,
        #[allow(missing_docs)]
        pub payment: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub completed: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<8>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u8,
            alloy::sol_types::private::Address,
            u64,
            u32,
            alloy::sol_types::private::primitives::aliases::U256,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<JobCall> for UnderlyingRustTuple<'_> {
            fn from(value: JobCall) -> Self {
                (
                    value.jobIndex,
                    value.caller,
                    value.createdAt,
                    value.resultCount,
                    value.payment,
                    value.completed,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for JobCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    jobIndex: tuple.0,
                    caller: tuple.1,
                    createdAt: tuple.2,
                    resultCount: tuple.3,
                    payment: tuple.4,
                    completed: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for JobCall {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for JobCall {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.jobIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.createdAt),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.resultCount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.payment),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.completed,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for JobCall {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for JobCall {
            const NAME: &'static str = "JobCall";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "JobCall(uint8 jobIndex,address caller,uint64 createdAt,uint32 resultCount,uint256 payment,bool completed)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.jobIndex)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.caller,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.createdAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.resultCount)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.payment)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.completed,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for JobCall {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.jobIndex,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.caller,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.createdAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.resultCount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.payment,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.completed,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    8,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.jobIndex,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.caller,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.createdAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.resultCount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.payment,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.completed,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct OperatorRegistration { uint64 registeredAt; uint64 updatedAt; bool active; bool online; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorRegistration {
        #[allow(missing_docs)]
        pub registeredAt: u64,
        #[allow(missing_docs)]
        pub updatedAt: u64,
        #[allow(missing_docs)]
        pub active: bool,
        #[allow(missing_docs)]
        pub online: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64, bool, bool);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorRegistration> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorRegistration) -> Self {
                (value.registeredAt, value.updatedAt, value.active, value.online)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorRegistration {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    registeredAt: tuple.0,
                    updatedAt: tuple.1,
                    active: tuple.2,
                    online: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for OperatorRegistration {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for OperatorRegistration {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.registeredAt),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.updatedAt),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.active,
                    ),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.online,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for OperatorRegistration {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for OperatorRegistration {
            const NAME: &'static str = "OperatorRegistration";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "OperatorRegistration(uint64 registeredAt,uint64 updatedAt,bool active,bool online)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.registeredAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.updatedAt)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.active,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.online,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for OperatorRegistration {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.registeredAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.updatedAt,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.active,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.online,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.registeredAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.updatedAt,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.active,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.online,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct PaymentSplit { uint16 developerBps; uint16 protocolBps; uint16 operatorBps; uint16 restakerBps; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PaymentSplit {
        #[allow(missing_docs)]
        pub developerBps: u16,
        #[allow(missing_docs)]
        pub protocolBps: u16,
        #[allow(missing_docs)]
        pub operatorBps: u16,
        #[allow(missing_docs)]
        pub restakerBps: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<16>,
            alloy::sol_types::sol_data::Uint<16>,
            alloy::sol_types::sol_data::Uint<16>,
            alloy::sol_types::sol_data::Uint<16>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u16, u16, u16, u16);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PaymentSplit> for UnderlyingRustTuple<'_> {
            fn from(value: PaymentSplit) -> Self {
                (
                    value.developerBps,
                    value.protocolBps,
                    value.operatorBps,
                    value.restakerBps,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PaymentSplit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    developerBps: tuple.0,
                    protocolBps: tuple.1,
                    operatorBps: tuple.2,
                    restakerBps: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for PaymentSplit {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for PaymentSplit {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.developerBps),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.protocolBps),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorBps),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.restakerBps),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for PaymentSplit {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for PaymentSplit {
            const NAME: &'static str = "PaymentSplit";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "PaymentSplit(uint16 developerBps,uint16 protocolBps,uint16 operatorBps,uint16 restakerBps)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.developerBps)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.protocolBps)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.operatorBps)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.restakerBps)
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for PaymentSplit {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.developerBps,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.protocolBps,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operatorBps,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.restakerBps,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.developerBps,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.protocolBps,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operatorBps,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.restakerBps,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct QuoteDetails { uint64 blueprintId; uint64 ttlBlocks; uint256 totalCost; uint64 timestamp; uint64 expiry; AssetSecurityCommitment[] securityCommitments; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QuoteDetails {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub ttlBlocks: u64,
        #[allow(missing_docs)]
        pub totalCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub timestamp: u64,
        #[allow(missing_docs)]
        pub expiry: u64,
        #[allow(missing_docs)]
        pub securityCommitments: alloy::sol_types::private::Vec<
            <AssetSecurityCommitment as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Array<AssetSecurityCommitment>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            u64,
            alloy::sol_types::private::primitives::aliases::U256,
            u64,
            u64,
            alloy::sol_types::private::Vec<
                <AssetSecurityCommitment as alloy::sol_types::SolType>::RustType,
            >,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QuoteDetails> for UnderlyingRustTuple<'_> {
            fn from(value: QuoteDetails) -> Self {
                (
                    value.blueprintId,
                    value.ttlBlocks,
                    value.totalCost,
                    value.timestamp,
                    value.expiry,
                    value.securityCommitments,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QuoteDetails {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blueprintId: tuple.0,
                    ttlBlocks: tuple.1,
                    totalCost: tuple.2,
                    timestamp: tuple.3,
                    expiry: tuple.4,
                    securityCommitments: tuple.5,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for QuoteDetails {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for QuoteDetails {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.ttlBlocks),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalCost),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.timestamp),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                    <alloy::sol_types::sol_data::Array<
                        AssetSecurityCommitment,
                    > as alloy_sol_types::SolType>::tokenize(&self.securityCommitments),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for QuoteDetails {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for QuoteDetails {
            const NAME: &'static str = "QuoteDetails";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "QuoteDetails(uint64 blueprintId,uint64 ttlBlocks,uint256 totalCost,uint64 timestamp,uint64 expiry,AssetSecurityCommitment[] securityCommitments)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <AssetSecurityCommitment as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <AssetSecurityCommitment as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blueprintId)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.ttlBlocks)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.totalCost)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.timestamp)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.expiry)
                        .0,
                    <alloy::sol_types::sol_data::Array<
                        AssetSecurityCommitment,
                    > as alloy_sol_types::SolType>::eip712_data_word(
                            &self.securityCommitments,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for QuoteDetails {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blueprintId,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.ttlBlocks,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.totalCost,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.timestamp,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.expiry,
                    )
                    + <alloy::sol_types::sol_data::Array<
                        AssetSecurityCommitment,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.securityCommitments,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blueprintId,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.ttlBlocks,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.totalCost,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.timestamp,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.expiry,
                    out,
                );
                <alloy::sol_types::sol_data::Array<
                    AssetSecurityCommitment,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.securityCommitments,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct Service { uint64 blueprintId; address owner; uint64 createdAt; uint64 ttl; uint64 terminatedAt; uint64 lastPaymentAt; uint32 operatorCount; uint32 minOperators; uint32 maxOperators; MembershipModel membership; PricingModel pricing; ServiceStatus status; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Service {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub createdAt: u64,
        #[allow(missing_docs)]
        pub ttl: u64,
        #[allow(missing_docs)]
        pub terminatedAt: u64,
        #[allow(missing_docs)]
        pub lastPaymentAt: u64,
        #[allow(missing_docs)]
        pub operatorCount: u32,
        #[allow(missing_docs)]
        pub minOperators: u32,
        #[allow(missing_docs)]
        pub maxOperators: u32,
        #[allow(missing_docs)]
        pub membership: <MembershipModel as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub pricing: <PricingModel as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub status: <ServiceStatus as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<32>,
            MembershipModel,
            PricingModel,
            ServiceStatus,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            alloy::sol_types::private::Address,
            u64,
            u64,
            u64,
            u64,
            u32,
            u32,
            u32,
            <MembershipModel as alloy::sol_types::SolType>::RustType,
            <PricingModel as alloy::sol_types::SolType>::RustType,
            <ServiceStatus as alloy::sol_types::SolType>::RustType,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Service> for UnderlyingRustTuple<'_> {
            fn from(value: Service) -> Self {
                (
                    value.blueprintId,
                    value.owner,
                    value.createdAt,
                    value.ttl,
                    value.terminatedAt,
                    value.lastPaymentAt,
                    value.operatorCount,
                    value.minOperators,
                    value.maxOperators,
                    value.membership,
                    value.pricing,
                    value.status,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Service {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blueprintId: tuple.0,
                    owner: tuple.1,
                    createdAt: tuple.2,
                    ttl: tuple.3,
                    terminatedAt: tuple.4,
                    lastPaymentAt: tuple.5,
                    operatorCount: tuple.6,
                    minOperators: tuple.7,
                    maxOperators: tuple.8,
                    membership: tuple.9,
                    pricing: tuple.10,
                    status: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for Service {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for Service {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.owner,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.createdAt),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.ttl),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.terminatedAt),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.lastPaymentAt),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorCount),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.minOperators),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxOperators),
                    <MembershipModel as alloy_sol_types::SolType>::tokenize(
                        &self.membership,
                    ),
                    <PricingModel as alloy_sol_types::SolType>::tokenize(&self.pricing),
                    <ServiceStatus as alloy_sol_types::SolType>::tokenize(&self.status),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for Service {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for Service {
            const NAME: &'static str = "Service";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "Service(uint64 blueprintId,address owner,uint64 createdAt,uint64 ttl,uint64 terminatedAt,uint64 lastPaymentAt,uint32 operatorCount,uint32 minOperators,uint32 maxOperators,uint8 membership,uint8 pricing,uint8 status)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blueprintId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.owner,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.createdAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.ttl)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.terminatedAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.lastPaymentAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.operatorCount)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.minOperators)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.maxOperators)
                        .0,
                    <MembershipModel as alloy_sol_types::SolType>::eip712_data_word(
                            &self.membership,
                        )
                        .0,
                    <PricingModel as alloy_sol_types::SolType>::eip712_data_word(
                            &self.pricing,
                        )
                        .0,
                    <ServiceStatus as alloy_sol_types::SolType>::eip712_data_word(
                            &self.status,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for Service {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blueprintId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.owner,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.createdAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.ttl)
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.terminatedAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.lastPaymentAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operatorCount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minOperators,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.maxOperators,
                    )
                    + <MembershipModel as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.membership,
                    )
                    + <PricingModel as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.pricing,
                    )
                    + <ServiceStatus as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.status,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blueprintId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.owner,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.createdAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.ttl, out);
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.terminatedAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.lastPaymentAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operatorCount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minOperators,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.maxOperators,
                    out,
                );
                <MembershipModel as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.membership,
                    out,
                );
                <PricingModel as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.pricing,
                    out,
                );
                <ServiceStatus as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.status,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ServiceOperator { uint16 exposureBps; uint64 joinedAt; uint64 leftAt; bool active; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceOperator {
        #[allow(missing_docs)]
        pub exposureBps: u16,
        #[allow(missing_docs)]
        pub joinedAt: u64,
        #[allow(missing_docs)]
        pub leftAt: u64,
        #[allow(missing_docs)]
        pub active: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<16>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u16, u64, u64, bool);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ServiceOperator> for UnderlyingRustTuple<'_> {
            fn from(value: ServiceOperator) -> Self {
                (value.exposureBps, value.joinedAt, value.leftAt, value.active)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ServiceOperator {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    exposureBps: tuple.0,
                    joinedAt: tuple.1,
                    leftAt: tuple.2,
                    active: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ServiceOperator {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ServiceOperator {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.exposureBps),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.joinedAt),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.leftAt),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.active,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ServiceOperator {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ServiceOperator {
            const NAME: &'static str = "ServiceOperator";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ServiceOperator(uint16 exposureBps,uint64 joinedAt,uint64 leftAt,bool active)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.exposureBps)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.joinedAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.leftAt)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.active,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ServiceOperator {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.exposureBps,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.joinedAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.leftAt,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.active,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    16,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.exposureBps,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.joinedAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.leftAt,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.active,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct ServiceRequest { uint64 blueprintId; address requester; uint64 createdAt; uint64 ttl; uint32 operatorCount; uint32 approvalCount; address paymentToken; uint256 paymentAmount; MembershipModel membership; uint32 minOperators; uint32 maxOperators; bool rejected; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceRequest {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub requester: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub createdAt: u64,
        #[allow(missing_docs)]
        pub ttl: u64,
        #[allow(missing_docs)]
        pub operatorCount: u32,
        #[allow(missing_docs)]
        pub approvalCount: u32,
        #[allow(missing_docs)]
        pub paymentToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub paymentAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub membership: <MembershipModel as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub minOperators: u32,
        #[allow(missing_docs)]
        pub maxOperators: u32,
        #[allow(missing_docs)]
        pub rejected: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            MembershipModel,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Bool,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            alloy::sol_types::private::Address,
            u64,
            u64,
            u32,
            u32,
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            <MembershipModel as alloy::sol_types::SolType>::RustType,
            u32,
            u32,
            bool,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ServiceRequest> for UnderlyingRustTuple<'_> {
            fn from(value: ServiceRequest) -> Self {
                (
                    value.blueprintId,
                    value.requester,
                    value.createdAt,
                    value.ttl,
                    value.operatorCount,
                    value.approvalCount,
                    value.paymentToken,
                    value.paymentAmount,
                    value.membership,
                    value.minOperators,
                    value.maxOperators,
                    value.rejected,
                )
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ServiceRequest {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blueprintId: tuple.0,
                    requester: tuple.1,
                    createdAt: tuple.2,
                    ttl: tuple.3,
                    operatorCount: tuple.4,
                    approvalCount: tuple.5,
                    paymentToken: tuple.6,
                    paymentAmount: tuple.7,
                    membership: tuple.8,
                    minOperators: tuple.9,
                    maxOperators: tuple.10,
                    rejected: tuple.11,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for ServiceRequest {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for ServiceRequest {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.requester,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.createdAt),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.ttl),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.operatorCount),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.approvalCount),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.paymentToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.paymentAmount),
                    <MembershipModel as alloy_sol_types::SolType>::tokenize(
                        &self.membership,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.minOperators),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxOperators),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.rejected,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for ServiceRequest {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for ServiceRequest {
            const NAME: &'static str = "ServiceRequest";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "ServiceRequest(uint64 blueprintId,address requester,uint64 createdAt,uint64 ttl,uint32 operatorCount,uint32 approvalCount,address paymentToken,uint256 paymentAmount,uint8 membership,uint32 minOperators,uint32 maxOperators,bool rejected)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                alloy_sol_types::private::Vec::new()
            }
            #[inline]
            fn eip712_encode_type() -> alloy_sol_types::private::Cow<'static, str> {
                <Self as alloy_sol_types::SolStruct>::eip712_root_type()
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.blueprintId)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.requester,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.createdAt)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.ttl)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.operatorCount)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.approvalCount)
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.paymentToken,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.paymentAmount)
                        .0,
                    <MembershipModel as alloy_sol_types::SolType>::eip712_data_word(
                            &self.membership,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.minOperators)
                        .0,
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::eip712_data_word(&self.maxOperators)
                        .0,
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::eip712_data_word(
                            &self.rejected,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for ServiceRequest {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.blueprintId,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.requester,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.createdAt,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(&rust.ttl)
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operatorCount,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.approvalCount,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.paymentToken,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.paymentAmount,
                    )
                    + <MembershipModel as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.membership,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.minOperators,
                    )
                    + <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.maxOperators,
                    )
                    + <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.rejected,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.blueprintId,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.requester,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.createdAt,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(&rust.ttl, out);
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operatorCount,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.approvalCount,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.paymentToken,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    256,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.paymentAmount,
                    out,
                );
                <MembershipModel as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.membership,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.minOperators,
                    out,
                );
                <alloy::sol_types::sol_data::Uint<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.maxOperators,
                    out,
                );
                <alloy::sol_types::sol_data::Bool as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.rejected,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    /**```solidity
struct SignedQuote { QuoteDetails details; bytes signature; address operator; }
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SignedQuote {
        #[allow(missing_docs)]
        pub details: <QuoteDetails as alloy::sol_types::SolType>::RustType,
        #[allow(missing_docs)]
        pub signature: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            QuoteDetails,
            alloy::sol_types::sol_data::Bytes,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            <QuoteDetails as alloy::sol_types::SolType>::RustType,
            alloy::sol_types::private::Bytes,
            alloy::sol_types::private::Address,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SignedQuote> for UnderlyingRustTuple<'_> {
            fn from(value: SignedQuote) -> Self {
                (value.details, value.signature, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SignedQuote {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    details: tuple.0,
                    signature: tuple.1,
                    operator: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolValue for SignedQuote {
            type SolType = Self;
        }
        #[automatically_derived]
        impl alloy_sol_types::private::SolTypeValue<Self> for SignedQuote {
            #[inline]
            fn stv_to_tokens(&self) -> <Self as alloy_sol_types::SolType>::Token<'_> {
                (
                    <QuoteDetails as alloy_sol_types::SolType>::tokenize(&self.details),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.signature,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
            #[inline]
            fn stv_abi_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encoded_size(&tuple)
            }
            #[inline]
            fn stv_eip712_data_word(&self) -> alloy_sol_types::Word {
                <Self as alloy_sol_types::SolStruct>::eip712_hash_struct(self)
            }
            #[inline]
            fn stv_abi_encode_packed_to(
                &self,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_encode_packed_to(&tuple, out)
            }
            #[inline]
            fn stv_abi_packed_encoded_size(&self) -> usize {
                if let Some(size) = <Self as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE {
                    return size;
                }
                let tuple = <UnderlyingRustTuple<
                    '_,
                > as ::core::convert::From<Self>>::from(self.clone());
                <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_packed_encoded_size(&tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolType for SignedQuote {
            type RustType = Self;
            type Token<'a> = <UnderlyingSolTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SOL_NAME: &'static str = <Self as alloy_sol_types::SolStruct>::NAME;
            const ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::ENCODED_SIZE;
            const PACKED_ENCODED_SIZE: Option<usize> = <UnderlyingSolTuple<
                '_,
            > as alloy_sol_types::SolType>::PACKED_ENCODED_SIZE;
            #[inline]
            fn valid_token(token: &Self::Token<'_>) -> bool {
                <UnderlyingSolTuple<'_> as alloy_sol_types::SolType>::valid_token(token)
            }
            #[inline]
            fn detokenize(token: Self::Token<'_>) -> Self::RustType {
                let tuple = <UnderlyingSolTuple<
                    '_,
                > as alloy_sol_types::SolType>::detokenize(token);
                <Self as ::core::convert::From<UnderlyingRustTuple<'_>>>::from(tuple)
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolStruct for SignedQuote {
            const NAME: &'static str = "SignedQuote";
            #[inline]
            fn eip712_root_type() -> alloy_sol_types::private::Cow<'static, str> {
                alloy_sol_types::private::Cow::Borrowed(
                    "SignedQuote(QuoteDetails details,bytes signature,address operator)",
                )
            }
            #[inline]
            fn eip712_components() -> alloy_sol_types::private::Vec<
                alloy_sol_types::private::Cow<'static, str>,
            > {
                let mut components = alloy_sol_types::private::Vec::with_capacity(1);
                components
                    .push(
                        <QuoteDetails as alloy_sol_types::SolStruct>::eip712_root_type(),
                    );
                components
                    .extend(
                        <QuoteDetails as alloy_sol_types::SolStruct>::eip712_components(),
                    );
                components
            }
            #[inline]
            fn eip712_encode_data(&self) -> alloy_sol_types::private::Vec<u8> {
                [
                    <QuoteDetails as alloy_sol_types::SolType>::eip712_data_word(
                            &self.details,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::eip712_data_word(
                            &self.signature,
                        )
                        .0,
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::eip712_data_word(
                            &self.operator,
                        )
                        .0,
                ]
                    .concat()
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::EventTopic for SignedQuote {
            #[inline]
            fn topic_preimage_length(rust: &Self::RustType) -> usize {
                0usize
                    + <QuoteDetails as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.details,
                    )
                    + <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.signature,
                    )
                    + <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::topic_preimage_length(
                        &rust.operator,
                    )
            }
            #[inline]
            fn encode_topic_preimage(
                rust: &Self::RustType,
                out: &mut alloy_sol_types::private::Vec<u8>,
            ) {
                out.reserve(
                    <Self as alloy_sol_types::EventTopic>::topic_preimage_length(rust),
                );
                <QuoteDetails as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.details,
                    out,
                );
                <alloy::sol_types::sol_data::Bytes as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.signature,
                    out,
                );
                <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    &rust.operator,
                    out,
                );
            }
            #[inline]
            fn encode_topic(
                rust: &Self::RustType,
            ) -> alloy_sol_types::abi::token::WordToken {
                let mut out = alloy_sol_types::private::Vec::new();
                <Self as alloy_sol_types::EventTopic>::encode_topic_preimage(
                    rust,
                    &mut out,
                );
                alloy_sol_types::abi::token::WordToken(
                    alloy_sol_types::private::keccak256(out),
                )
            }
        }
    };
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Types`](self) contract instance.

See the [wrapper's documentation](`TypesInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TypesInstance<T, P, N> {
        TypesInstance::<T, P, N>::new(address, provider)
    }
    /**A [`Types`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Types`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TypesInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TypesInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TypesInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TypesInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Types`](self) contract instance.

See the [wrapper's documentation](`TypesInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TypesInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TypesInstance<T, P, N> {
            TypesInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TypesInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TypesInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
    }
}
/**

Generated by the following Solidity interface...
```solidity
library PaymentLib {
    struct ServiceEscrow {
        address token;
        uint256 balance;
        uint256 totalDeposited;
        uint256 totalReleased;
    }
}

library SlashingLib {
    type SlashStatus is uint8;
    struct SlashProposal {
        uint64 serviceId;
        address operator;
        address proposer;
        uint256 amount;
        uint256 effectiveAmount;
        bytes32 evidence;
        uint64 proposedAt;
        uint64 executeAfter;
        SlashStatus status;
        string disputeReason;
    }
}

library Types {
    type AssetKind is uint8;
    type MembershipModel is uint8;
    type PricingModel is uint8;
    type ServiceStatus is uint8;
    struct Asset {
        AssetKind kind;
        address token;
    }
    struct AssetSecurityCommitment {
        Asset asset;
        uint16 exposureBps;
    }
    struct AssetSecurityRequirement {
        Asset asset;
        uint16 minExposureBps;
        uint16 maxExposureBps;
    }
    struct Blueprint {
        address owner;
        address manager;
        uint64 createdAt;
        uint32 operatorCount;
        MembershipModel membership;
        PricingModel pricing;
        bool active;
    }
    struct BlueprintConfig {
        MembershipModel membership;
        PricingModel pricing;
        uint32 minOperators;
        uint32 maxOperators;
        uint256 subscriptionRate;
        uint64 subscriptionInterval;
        uint256 eventRate;
    }
    struct JobCall {
        uint8 jobIndex;
        address caller;
        uint64 createdAt;
        uint32 resultCount;
        uint256 payment;
        bool completed;
    }
    struct OperatorRegistration {
        uint64 registeredAt;
        uint64 updatedAt;
        bool active;
        bool online;
    }
    struct PaymentSplit {
        uint16 developerBps;
        uint16 protocolBps;
        uint16 operatorBps;
        uint16 restakerBps;
    }
    struct QuoteDetails {
        uint64 blueprintId;
        uint64 ttlBlocks;
        uint256 totalCost;
        uint64 timestamp;
        uint64 expiry;
        AssetSecurityCommitment[] securityCommitments;
    }
    struct Service {
        uint64 blueprintId;
        address owner;
        uint64 createdAt;
        uint64 ttl;
        uint64 terminatedAt;
        uint64 lastPaymentAt;
        uint32 operatorCount;
        uint32 minOperators;
        uint32 maxOperators;
        MembershipModel membership;
        PricingModel pricing;
        ServiceStatus status;
    }
    struct ServiceOperator {
        uint16 exposureBps;
        uint64 joinedAt;
        uint64 leftAt;
        bool active;
    }
    struct ServiceRequest {
        uint64 blueprintId;
        address requester;
        uint64 createdAt;
        uint64 ttl;
        uint32 operatorCount;
        uint32 approvalCount;
        address paymentToken;
        uint256 paymentAmount;
        MembershipModel membership;
        uint32 minOperators;
        uint32 maxOperators;
        bool rejected;
    }
    struct SignedQuote {
        QuoteDetails details;
        bytes signature;
        address operator;
    }
}

interface Tangle {
    error AccessControlBadConfirmation();
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
    error AddressEmptyCode(address target);
    error AggregationNotRequired(uint64 serviceId, uint8 jobIndex);
    error AggregationRequired(uint64 serviceId, uint8 jobIndex);
    error AggregationThresholdNotMet(uint64 serviceId, uint64 callId, uint256 achieved, uint256 required);
    error AlreadyApproved(uint64 requestId, address operator);
    error BlueprintNotActive(uint64 blueprintId);
    error BlueprintNotFound(uint64 blueprintId);
    error CommitmentAboveMaximum(address asset, uint16 committed, uint16 maximum);
    error CommitmentBelowMinimum(address asset, uint16 committed, uint16 minimum);
    error DeadlineExpired();
    error DisputeWindowPassed(uint64 slashId);
    error DuplicateOperatorQuote(address operator);
    error ECDSAInvalidSignature();
    error ECDSAInvalidSignatureLength(uint256 length);
    error ECDSAInvalidSignatureS(bytes32 s);
    error ERC1967InvalidImplementation(address implementation);
    error ERC1967NonPayable();
    error EnforcedPause();
    error ExpectedPause();
    error FailedCall();
    error HashToPointFailed();
    error InstantSlashNotEnabled();
    error InsufficientEscrowBalance(uint256 required, uint256 available);
    error InsufficientOperators(uint32 required, uint32 provided);
    error InsufficientPayment(uint256 required, uint256 sent);
    error InsufficientPaymentForQuotes(uint256 totalCost, uint256 payment);
    error InsufficientStake(address operator, uint256 required, uint256 actual);
    error InvalidBLSSignature();
    error InvalidInitialization();
    error InvalidPaymentSplit();
    error InvalidPaymentToken();
    error InvalidQuoteSignature(address operator);
    error InvalidSecurityRequirement();
    error InvalidSlashAmount();
    error InvalidSlashConfig();
    error InvalidState();
    error JobAlreadyCompleted(uint64 serviceId, uint64 callId);
    error JobCallNotFound(uint64 serviceId, uint64 callId);
    error LengthMismatch();
    error ManagerRejected(address manager);
    error ManagerReverted(address manager, bytes reason);
    error MissingAssetCommitment(address asset);
    error NoOperators();
    error NoQuotes();
    error NoSecurityRequirements();
    error NotBlueprintOwner(uint64 blueprintId, address caller);
    error NotInitializing();
    error NotPermittedCaller(uint64 serviceId, address caller);
    error NotServiceOwner(uint64 serviceId, address caller);
    error NotSlashCanceller(uint64 slashId, address caller);
    error NotSlashDisputer(uint64 slashId, address caller);
    error OperatorAlreadyRegistered(uint64 blueprintId, address operator);
    error OperatorNotActive(address operator);
    error OperatorNotInService(uint64 serviceId, address operator);
    error OperatorNotRegistered(uint64 blueprintId, address operator);
    error PairingFailed();
    error PaymentFailed();
    error QuoteAlreadyUsed(address operator);
    error QuoteBlueprintMismatch(address operator, uint64 expectedBlueprint, uint64 quotedBlueprint);
    error QuoteExpired(address operator, uint64 expiry);
    error QuoteTTLMismatch(address operator, uint64 expectedTTL, uint64 quotedTTL);
    error ReentrancyGuardReentrantCall();
    error ResultAlreadySubmitted(uint64 serviceId, uint64 callId, address operator);
    error SafeERC20FailedOperation(address token);
    error ServiceExpired(uint64 serviceId);
    error ServiceNotActive(uint64 serviceId);
    error ServiceNotFound(uint64 serviceId);
    error ServiceRequestAlreadyProcessed(uint64 requestId);
    error ServiceRequestNotFound(uint64 requestId);
    error SlashAlreadyCancelled(uint64 slashId);
    error SlashAlreadyExecuted(uint64 slashId);
    error SlashNotExecutable(uint64 slashId);
    error SlashNotFound(uint64 slashId);
    error SlashNotPending(uint64 slashId);
    error TokenNotAllowed(address token);
    error TooManyOperators(uint32 maximum, uint32 provided);
    error UUPSUnauthorizedCallContext();
    error UUPSUnsupportedProxiableUUID(bytes32 slot);
    error Unauthorized();
    error ZeroAddress();
    error ZeroAmount();

    event AggregatedResultSubmitted(uint64 indexed serviceId, uint64 indexed callId, uint256 signerBitmap, bytes output);
    event BlueprintCreated(uint64 indexed blueprintId, address indexed owner, address manager);
    event BlueprintDeactivated(uint64 indexed blueprintId);
    event BlueprintTransferred(uint64 indexed blueprintId, address indexed from, address indexed to);
    event BlueprintUpdated(uint64 indexed blueprintId, string metadataUri);
    event EscrowFunded(uint64 indexed serviceId, address indexed token, uint256 amount);
    event Initialized(uint64 version);
    event JobCompleted(uint64 indexed serviceId, uint64 indexed callId);
    event JobResultSubmitted(uint64 indexed serviceId, uint64 indexed callId, address indexed operator, bytes output);
    event JobSubmitted(uint64 indexed serviceId, uint64 indexed callId, uint8 jobIndex, address caller, bytes inputs);
    event OperatorJoinedService(uint64 indexed serviceId, address indexed operator, uint16 exposureBps);
    event OperatorLeftService(uint64 indexed serviceId, address indexed operator);
    event OperatorPreRegistered(uint64 indexed blueprintId, address indexed operator);
    event OperatorPreferencesUpdated(uint64 indexed blueprintId, address indexed operator, bytes preferences);
    event OperatorRegistered(uint64 indexed blueprintId, address indexed operator, bytes preferences);
    event OperatorRpcAddressUpdated(uint64 indexed blueprintId, address indexed operator, string rpcAddress);
    event OperatorUnregistered(uint64 indexed blueprintId, address indexed operator);
    event Paused(address account);
    event QuoteUsed(address indexed operator, bytes32 indexed quoteHash);
    event RewardsClaimed(address indexed account, address indexed token, uint256 amount);
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
    event ServiceActivated(uint64 indexed serviceId, uint64 indexed requestId, uint64 indexed blueprintId);
    event ServiceApproved(uint64 indexed requestId, address indexed operator);
    event ServiceRejected(uint64 indexed requestId, address indexed operator);
    event ServiceRequested(uint64 indexed requestId, uint64 indexed blueprintId, address indexed requester);
    event ServiceRequestedWithSecurity(uint64 indexed requestId, uint64 indexed blueprintId, address indexed requester, address[] operators, Types.AssetSecurityRequirement[] securityRequirements);
    event ServiceTerminated(uint64 indexed serviceId);
    event SlashCancelled(uint64 indexed slashId, address indexed canceller, string reason);
    event SlashConfigUpdated(uint64 disputeWindow, bool instantSlashEnabled, uint16 maxSlashBps);
    event SlashDisputed(uint64 indexed slashId, address indexed disputer, string reason);
    event SlashExecuted(uint64 indexed slashId, uint64 indexed serviceId, address indexed operator, uint256 actualSlashed);
    event SlashProposed(uint64 indexed slashId, uint64 indexed serviceId, address indexed operator, address proposer, uint256 amount, uint256 effectiveAmount, bytes32 evidence, uint64 executeAfter);
    event SubscriptionBilled(uint64 indexed serviceId, uint256 amount, uint64 period);
    event Unpaused(address account);
    event Upgraded(address indexed implementation);

    receive() external payable;

    function ADMIN_ROLE() external view returns (bytes32);
    function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
    function PAUSER_ROLE() external view returns (bytes32);
    function SLASH_ADMIN_ROLE() external view returns (bytes32);
    function UPGRADER_ROLE() external view returns (bytes32);
    function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
    function addPermittedCaller(uint64 serviceId, address caller) external;
    function approveService(uint64 requestId, uint8 restakingPercent) external;
    function approveServiceWithCommitments(uint64 requestId, Types.AssetSecurityCommitment[] memory commitments) external;
    function billSubscription(uint64 serviceId) external;
    function billSubscriptionBatch(uint64[] memory serviceIds) external returns (uint256 totalBilled, uint256 billedCount);
    function blueprintCount() external view returns (uint64);
    function blueprintOperatorCount(uint64 blueprintId) external view returns (uint256);
    function cancelSlash(uint64 slashId, string memory reason) external;
    function claimRewards() external;
    function claimRewards(address token) external;
    function createBlueprint(string memory metadataUri, address manager) external returns (uint64 blueprintId);
    function createBlueprintWithConfig(string memory metadataUri, address manager, Types.BlueprintConfig memory config) external returns (uint64 blueprintId);
    function createServiceFromQuotes(uint64 blueprintId, Types.SignedQuote[] memory quotes, bytes memory config, address[] memory permittedCallers, uint64 ttl) external payable returns (uint64 serviceId);
    function deactivateBlueprint(uint64 blueprintId) external;
    function disputeSlash(uint64 slashId, string memory reason) external;
    function executeSlash(uint64 slashId) external returns (uint256 actualSlashed);
    function executeSlashBatch(uint64[] memory slashIds) external returns (uint256 totalSlashed, uint256 executedCount);
    function fundService(uint64 serviceId, uint256 amount) external payable;
    function getBillableServices(uint64[] memory serviceIds) external view returns (uint64[] memory billable);
    function getBlueprint(uint64 id) external view returns (Types.Blueprint memory);
    function getBlueprintConfig(uint64 id) external view returns (Types.BlueprintConfig memory);
    function getExecutableSlashes(uint64 fromId, uint64 toId) external view returns (uint64[] memory ids);
    function getJobCall(uint64 serviceId, uint64 callId) external view returns (Types.JobCall memory);
    function getOperatorRegistration(uint64 blueprintId, address op) external view returns (Types.OperatorRegistration memory);
    function getRoleAdmin(bytes32 role) external view returns (bytes32);
    function getService(uint64 id) external view returns (Types.Service memory);
    function getServiceEscrow(uint64 serviceId) external view returns (PaymentLib.ServiceEscrow memory);
    function getServiceOperator(uint64 serviceId, address op) external view returns (Types.ServiceOperator memory);
    function getServiceOperators(uint64 serviceId) external view returns (address[] memory);
    function getServiceRequest(uint64 id) external view returns (Types.ServiceRequest memory);
    function getSlashProposal(uint64 slashId) external view returns (SlashingLib.SlashProposal memory);
    function grantRole(bytes32 role, address account) external;
    function hasRole(bytes32 role, address account) external view returns (bool);
    function initialize(address admin, address restaking_, address payable treasury_) external;
    function isOperatorRegistered(uint64 blueprintId, address op) external view returns (bool);
    function isPermittedCaller(uint64 serviceId, address caller) external view returns (bool);
    function isServiceActive(uint64 serviceId) external view returns (bool);
    function isServiceOperator(uint64 serviceId, address op) external view returns (bool);
    function joinService(uint64 serviceId, uint16 exposureBps) external;
    function leaveService(uint64 serviceId) external;
    function metricsRecorder() external view returns (address);
    function operatorStatusRegistry() external view returns (address);
    function pause() external;
    function paused() external view returns (bool);
    function paymentSplit() external view returns (uint16, uint16, uint16, uint16);
    function pendingRewards(address account) external view returns (uint256);
    function pendingRewards(address account, address token) external view returns (uint256);
    function preRegister(uint64 blueprintId) external;
    function proposeSlash(uint64 serviceId, address operator, uint256 amount, bytes32 evidence) external returns (uint64 slashId);
    function proxiableUUID() external view returns (bytes32);
    function registerOperator(uint64 blueprintId, bytes memory preferences) external;
    function rejectService(uint64 requestId) external;
    function removePermittedCaller(uint64 serviceId, address caller) external;
    function renounceRole(bytes32 role, address callerConfirmation) external;
    function requestService(uint64 blueprintId, address[] memory operators, bytes memory config, address[] memory permittedCallers, uint64 ttl, address paymentToken, uint256 paymentAmount) external payable returns (uint64 requestId);
    function requestServiceWithExposure(uint64 blueprintId, address[] memory operators, uint16[] memory exposures, bytes memory config, address[] memory permittedCallers, uint64 ttl, address paymentToken, uint256 paymentAmount) external payable returns (uint64 requestId);
    function requestServiceWithSecurity(uint64 blueprintId, address[] memory operators, Types.AssetSecurityRequirement[] memory securityRequirements, bytes memory config, address[] memory permittedCallers, uint64 ttl, address paymentToken, uint256 paymentAmount) external payable returns (uint64 requestId);
    function revokeRole(bytes32 role, address account) external;
    function serviceCount() external view returns (uint64);
    function serviceRequestCount() external view returns (uint64);
    function setMetricsRecorder(address recorder) external;
    function setOperatorStatusRegistry(address registry) external;
    function setPaymentSplit(Types.PaymentSplit memory split) external;
    function setSlashConfig(uint64 disputeWindow, bool instantSlashEnabled, uint16 maxSlashBps) external;
    function setTreasury(address payable treasury_) external;
    function submitAggregatedResult(uint64 serviceId, uint64 callId, bytes memory output, uint256 signerBitmap, uint256[2] memory aggregatedSignature, uint256[4] memory aggregatedPubkey) external;
    function submitJob(uint64 serviceId, uint8 jobIndex, bytes memory inputs) external payable returns (uint64 callId);
    function submitResult(uint64 serviceId, uint64 callId, bytes memory output) external;
    function submitResults(uint64 serviceId, uint64[] memory callIds, bytes[] memory outputs) external;
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
    function terminateService(uint64 serviceId) external;
    function transferBlueprint(uint64 blueprintId, address newOwner) external;
    function unpause() external;
    function unregisterOperator(uint64 blueprintId) external;
    function updateBlueprint(uint64 blueprintId, string memory metadataUri) external;
    function updateOperatorPreferences(uint64 blueprintId, bytes memory preferences) external;
    function updateRpcAddress(uint64 blueprintId, string memory rpcAddress) external;
    function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
}
```

...which was generated by the following JSON ABI:
```json
[
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DEFAULT_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "PAUSER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SLASH_ADMIN_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "UPGRADER_ROLE",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "UPGRADE_INTERFACE_VERSION",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "addPermittedCaller",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "approveService",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "restakingPercent",
        "type": "uint8",
        "internalType": "uint8"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "approveServiceWithCommitments",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "commitments",
        "type": "tuple[]",
        "internalType": "struct Types.AssetSecurityCommitment[]",
        "components": [
          {
            "name": "asset",
            "type": "tuple",
            "internalType": "struct Types.Asset",
            "components": [
              {
                "name": "kind",
                "type": "uint8",
                "internalType": "enum Types.AssetKind"
              },
              {
                "name": "token",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "exposureBps",
            "type": "uint16",
            "internalType": "uint16"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "billSubscription",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "billSubscriptionBatch",
    "inputs": [
      {
        "name": "serviceIds",
        "type": "uint64[]",
        "internalType": "uint64[]"
      }
    ],
    "outputs": [
      {
        "name": "totalBilled",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "billedCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "blueprintCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "blueprintOperatorCount",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "cancelSlash",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "reason",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimRewards",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "claimRewards",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createBlueprint",
    "inputs": [
      {
        "name": "metadataUri",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "manager",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createBlueprintWithConfig",
    "inputs": [
      {
        "name": "metadataUri",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "manager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "config",
        "type": "tuple",
        "internalType": "struct Types.BlueprintConfig",
        "components": [
          {
            "name": "membership",
            "type": "uint8",
            "internalType": "enum Types.MembershipModel"
          },
          {
            "name": "pricing",
            "type": "uint8",
            "internalType": "enum Types.PricingModel"
          },
          {
            "name": "minOperators",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "maxOperators",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "subscriptionRate",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "subscriptionInterval",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "eventRate",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "createServiceFromQuotes",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "quotes",
        "type": "tuple[]",
        "internalType": "struct Types.SignedQuote[]",
        "components": [
          {
            "name": "details",
            "type": "tuple",
            "internalType": "struct Types.QuoteDetails",
            "components": [
              {
                "name": "blueprintId",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "ttlBlocks",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "totalCost",
                "type": "uint256",
                "internalType": "uint256"
              },
              {
                "name": "timestamp",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "expiry",
                "type": "uint64",
                "internalType": "uint64"
              },
              {
                "name": "securityCommitments",
                "type": "tuple[]",
                "internalType": "struct Types.AssetSecurityCommitment[]",
                "components": [
                  {
                    "name": "asset",
                    "type": "tuple",
                    "internalType": "struct Types.Asset",
                    "components": [
                      {
                        "name": "kind",
                        "type": "uint8",
                        "internalType": "enum Types.AssetKind"
                      },
                      {
                        "name": "token",
                        "type": "address",
                        "internalType": "address"
                      }
                    ]
                  },
                  {
                    "name": "exposureBps",
                    "type": "uint16",
                    "internalType": "uint16"
                  }
                ]
              }
            ]
          },
          {
            "name": "signature",
            "type": "bytes",
            "internalType": "bytes"
          },
          {
            "name": "operator",
            "type": "address",
            "internalType": "address"
          }
        ]
      },
      {
        "name": "config",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "permittedCallers",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "ttl",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "deactivateBlueprint",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "disputeSlash",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "reason",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "executeSlash",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "actualSlashed",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "executeSlashBatch",
    "inputs": [
      {
        "name": "slashIds",
        "type": "uint64[]",
        "internalType": "uint64[]"
      }
    ],
    "outputs": [
      {
        "name": "totalSlashed",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "executedCount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "fundService",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "getBillableServices",
    "inputs": [
      {
        "name": "serviceIds",
        "type": "uint64[]",
        "internalType": "uint64[]"
      }
    ],
    "outputs": [
      {
        "name": "billable",
        "type": "uint64[]",
        "internalType": "uint64[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlueprint",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.Blueprint",
        "components": [
          {
            "name": "owner",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "manager",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "operatorCount",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "membership",
            "type": "uint8",
            "internalType": "enum Types.MembershipModel"
          },
          {
            "name": "pricing",
            "type": "uint8",
            "internalType": "enum Types.PricingModel"
          },
          {
            "name": "active",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getBlueprintConfig",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.BlueprintConfig",
        "components": [
          {
            "name": "membership",
            "type": "uint8",
            "internalType": "enum Types.MembershipModel"
          },
          {
            "name": "pricing",
            "type": "uint8",
            "internalType": "enum Types.PricingModel"
          },
          {
            "name": "minOperators",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "maxOperators",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "subscriptionRate",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "subscriptionInterval",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "eventRate",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getExecutableSlashes",
    "inputs": [
      {
        "name": "fromId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "toId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "ids",
        "type": "uint64[]",
        "internalType": "uint64[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getJobCall",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.JobCall",
        "components": [
          {
            "name": "jobIndex",
            "type": "uint8",
            "internalType": "uint8"
          },
          {
            "name": "caller",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "resultCount",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "payment",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "completed",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getOperatorRegistration",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "op",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.OperatorRegistration",
        "components": [
          {
            "name": "registeredAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "updatedAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "active",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "online",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getRoleAdmin",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getService",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.Service",
        "components": [
          {
            "name": "blueprintId",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "owner",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "ttl",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "terminatedAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "lastPaymentAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "operatorCount",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "minOperators",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "maxOperators",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "membership",
            "type": "uint8",
            "internalType": "enum Types.MembershipModel"
          },
          {
            "name": "pricing",
            "type": "uint8",
            "internalType": "enum Types.PricingModel"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum Types.ServiceStatus"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getServiceEscrow",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct PaymentLib.ServiceEscrow",
        "components": [
          {
            "name": "token",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "balance",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "totalDeposited",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "totalReleased",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getServiceOperator",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "op",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.ServiceOperator",
        "components": [
          {
            "name": "exposureBps",
            "type": "uint16",
            "internalType": "uint16"
          },
          {
            "name": "joinedAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "leftAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "active",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getServiceOperators",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getServiceRequest",
    "inputs": [
      {
        "name": "id",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct Types.ServiceRequest",
        "components": [
          {
            "name": "blueprintId",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "requester",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "createdAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "ttl",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "operatorCount",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "approvalCount",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "paymentToken",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "paymentAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "membership",
            "type": "uint8",
            "internalType": "enum Types.MembershipModel"
          },
          {
            "name": "minOperators",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "maxOperators",
            "type": "uint32",
            "internalType": "uint32"
          },
          {
            "name": "rejected",
            "type": "bool",
            "internalType": "bool"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getSlashProposal",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct SlashingLib.SlashProposal",
        "components": [
          {
            "name": "serviceId",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "operator",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "proposer",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "amount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "effectiveAmount",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "evidence",
            "type": "bytes32",
            "internalType": "bytes32"
          },
          {
            "name": "proposedAt",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "executeAfter",
            "type": "uint64",
            "internalType": "uint64"
          },
          {
            "name": "status",
            "type": "uint8",
            "internalType": "enum SlashingLib.SlashStatus"
          },
          {
            "name": "disputeReason",
            "type": "string",
            "internalType": "string"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "grantRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "hasRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "initialize",
    "inputs": [
      {
        "name": "admin",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "restaking_",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "treasury_",
        "type": "address",
        "internalType": "address payable"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isOperatorRegistered",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "op",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isPermittedCaller",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isServiceActive",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "isServiceOperator",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "op",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "joinService",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "exposureBps",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "leaveService",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "metricsRecorder",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "operatorStatusRegistry",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "paused",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "paymentSplit",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      },
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      },
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      },
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingRewards",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pendingRewards",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "preRegister",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "proposeSlash",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "evidence",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "proxiableUUID",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "registerOperator",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "preferences",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "rejectService",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removePermittedCaller",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "renounceRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "callerConfirmation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "requestService",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operators",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "config",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "permittedCallers",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "ttl",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "paymentToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "paymentAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "requestServiceWithExposure",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operators",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "exposures",
        "type": "uint16[]",
        "internalType": "uint16[]"
      },
      {
        "name": "config",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "permittedCallers",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "ttl",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "paymentToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "paymentAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "requestServiceWithSecurity",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operators",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "securityRequirements",
        "type": "tuple[]",
        "internalType": "struct Types.AssetSecurityRequirement[]",
        "components": [
          {
            "name": "asset",
            "type": "tuple",
            "internalType": "struct Types.Asset",
            "components": [
              {
                "name": "kind",
                "type": "uint8",
                "internalType": "enum Types.AssetKind"
              },
              {
                "name": "token",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "minExposureBps",
            "type": "uint16",
            "internalType": "uint16"
          },
          {
            "name": "maxExposureBps",
            "type": "uint16",
            "internalType": "uint16"
          }
        ]
      },
      {
        "name": "config",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "permittedCallers",
        "type": "address[]",
        "internalType": "address[]"
      },
      {
        "name": "ttl",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "paymentToken",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "paymentAmount",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "revokeRole",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "serviceCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "serviceRequestCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "setMetricsRecorder",
    "inputs": [
      {
        "name": "recorder",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setOperatorStatusRegistry",
    "inputs": [
      {
        "name": "registry",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setPaymentSplit",
    "inputs": [
      {
        "name": "split",
        "type": "tuple",
        "internalType": "struct Types.PaymentSplit",
        "components": [
          {
            "name": "developerBps",
            "type": "uint16",
            "internalType": "uint16"
          },
          {
            "name": "protocolBps",
            "type": "uint16",
            "internalType": "uint16"
          },
          {
            "name": "operatorBps",
            "type": "uint16",
            "internalType": "uint16"
          },
          {
            "name": "restakerBps",
            "type": "uint16",
            "internalType": "uint16"
          }
        ]
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSlashConfig",
    "inputs": [
      {
        "name": "disputeWindow",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "instantSlashEnabled",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "maxSlashBps",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setTreasury",
    "inputs": [
      {
        "name": "treasury_",
        "type": "address",
        "internalType": "address payable"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitAggregatedResult",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "output",
        "type": "bytes",
        "internalType": "bytes"
      },
      {
        "name": "signerBitmap",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "aggregatedSignature",
        "type": "uint256[2]",
        "internalType": "uint256[2]"
      },
      {
        "name": "aggregatedPubkey",
        "type": "uint256[4]",
        "internalType": "uint256[4]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitJob",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "jobIndex",
        "type": "uint8",
        "internalType": "uint8"
      },
      {
        "name": "inputs",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "callId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "submitResult",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "output",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "submitResults",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "callIds",
        "type": "uint64[]",
        "internalType": "uint64[]"
      },
      {
        "name": "outputs",
        "type": "bytes[]",
        "internalType": "bytes[]"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "supportsInterface",
    "inputs": [
      {
        "name": "interfaceId",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "terminateService",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "transferBlueprint",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "newOwner",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unpause",
    "inputs": [],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "unregisterOperator",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateBlueprint",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "metadataUri",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateOperatorPreferences",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "preferences",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "updateRpcAddress",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "rpcAddress",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeToAndCall",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "event",
    "name": "AggregatedResultSubmitted",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "signerBitmap",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "output",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlueprintCreated",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "owner",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "manager",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlueprintDeactivated",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlueprintTransferred",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "from",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "to",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "BlueprintUpdated",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "metadataUri",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "EscrowFunded",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Initialized",
    "inputs": [
      {
        "name": "version",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "JobCompleted",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "JobResultSubmitted",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "output",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "JobSubmitted",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "jobIndex",
        "type": "uint8",
        "indexed": false,
        "internalType": "uint8"
      },
      {
        "name": "caller",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "inputs",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorJoinedService",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "exposureBps",
        "type": "uint16",
        "indexed": false,
        "internalType": "uint16"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorLeftService",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorPreRegistered",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorPreferencesUpdated",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "preferences",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorRegistered",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "preferences",
        "type": "bytes",
        "indexed": false,
        "internalType": "bytes"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorRpcAddressUpdated",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "rpcAddress",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "OperatorUnregistered",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Paused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "QuoteUsed",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "quoteHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RewardsClaimed",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleAdminChanged",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "previousAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "newAdminRole",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleGranted",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "RoleRevoked",
    "inputs": [
      {
        "name": "role",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "account",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "sender",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ServiceActivated",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "requestId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ServiceApproved",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ServiceRejected",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ServiceRequested",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "requester",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ServiceRequestedWithSecurity",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "blueprintId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "requester",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "operators",
        "type": "address[]",
        "indexed": false,
        "internalType": "address[]"
      },
      {
        "name": "securityRequirements",
        "type": "tuple[]",
        "indexed": false,
        "internalType": "struct Types.AssetSecurityRequirement[]",
        "components": [
          {
            "name": "asset",
            "type": "tuple",
            "internalType": "struct Types.Asset",
            "components": [
              {
                "name": "kind",
                "type": "uint8",
                "internalType": "enum Types.AssetKind"
              },
              {
                "name": "token",
                "type": "address",
                "internalType": "address"
              }
            ]
          },
          {
            "name": "minExposureBps",
            "type": "uint16",
            "internalType": "uint16"
          },
          {
            "name": "maxExposureBps",
            "type": "uint16",
            "internalType": "uint16"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ServiceTerminated",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashCancelled",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "canceller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "reason",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashConfigUpdated",
    "inputs": [
      {
        "name": "disputeWindow",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      },
      {
        "name": "instantSlashEnabled",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      },
      {
        "name": "maxSlashBps",
        "type": "uint16",
        "indexed": false,
        "internalType": "uint16"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashDisputed",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "disputer",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "reason",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashExecuted",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "actualSlashed",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SlashProposed",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "proposer",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "effectiveAmount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "evidence",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "executeAfter",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SubscriptionBilled",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "indexed": true,
        "internalType": "uint64"
      },
      {
        "name": "amount",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      },
      {
        "name": "period",
        "type": "uint64",
        "indexed": false,
        "internalType": "uint64"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Unpaused",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Upgraded",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "AccessControlBadConfirmation",
    "inputs": []
  },
  {
    "type": "error",
    "name": "AccessControlUnauthorizedAccount",
    "inputs": [
      {
        "name": "account",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "neededRole",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "AddressEmptyCode",
    "inputs": [
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "AggregationNotRequired",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "jobIndex",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "AggregationRequired",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "jobIndex",
        "type": "uint8",
        "internalType": "uint8"
      }
    ]
  },
  {
    "type": "error",
    "name": "AggregationThresholdNotMet",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "achieved",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "required",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "AlreadyApproved",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "BlueprintNotActive",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "BlueprintNotFound",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "CommitmentAboveMaximum",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "committed",
        "type": "uint16",
        "internalType": "uint16"
      },
      {
        "name": "maximum",
        "type": "uint16",
        "internalType": "uint16"
      }
    ]
  },
  {
    "type": "error",
    "name": "CommitmentBelowMinimum",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "committed",
        "type": "uint16",
        "internalType": "uint16"
      },
      {
        "name": "minimum",
        "type": "uint16",
        "internalType": "uint16"
      }
    ]
  },
  {
    "type": "error",
    "name": "DeadlineExpired",
    "inputs": []
  },
  {
    "type": "error",
    "name": "DisputeWindowPassed",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "DuplicateOperatorQuote",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureLength",
    "inputs": [
      {
        "name": "length",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "ECDSAInvalidSignatureS",
    "inputs": [
      {
        "name": "s",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967InvalidImplementation",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ERC1967NonPayable",
    "inputs": []
  },
  {
    "type": "error",
    "name": "EnforcedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExpectedPause",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FailedCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "HashToPointFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InstantSlashNotEnabled",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InsufficientEscrowBalance",
    "inputs": [
      {
        "name": "required",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "available",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientOperators",
    "inputs": [
      {
        "name": "required",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "provided",
        "type": "uint32",
        "internalType": "uint32"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientPayment",
    "inputs": [
      {
        "name": "required",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "sent",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientPaymentForQuotes",
    "inputs": [
      {
        "name": "totalCost",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "payment",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InsufficientStake",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "required",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "actual",
        "type": "uint256",
        "internalType": "uint256"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidBLSSignature",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidInitialization",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidPaymentSplit",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidPaymentToken",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidQuoteSignature",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "InvalidSecurityRequirement",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSlashAmount",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidSlashConfig",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidState",
    "inputs": []
  },
  {
    "type": "error",
    "name": "JobAlreadyCompleted",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "JobCallNotFound",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "LengthMismatch",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ManagerRejected",
    "inputs": [
      {
        "name": "manager",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ManagerReverted",
    "inputs": [
      {
        "name": "manager",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "reason",
        "type": "bytes",
        "internalType": "bytes"
      }
    ]
  },
  {
    "type": "error",
    "name": "MissingAssetCommitment",
    "inputs": [
      {
        "name": "asset",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NoOperators",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoQuotes",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoSecurityRequirements",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotBlueprintOwner",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotInitializing",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NotPermittedCaller",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotServiceOwner",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotSlashCanceller",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "NotSlashDisputer",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "caller",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OperatorAlreadyRegistered",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OperatorNotActive",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OperatorNotInService",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "OperatorNotRegistered",
    "inputs": [
      {
        "name": "blueprintId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "PairingFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PaymentFailed",
    "inputs": []
  },
  {
    "type": "error",
    "name": "QuoteAlreadyUsed",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "QuoteBlueprintMismatch",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "expectedBlueprint",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "quotedBlueprint",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "QuoteExpired",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "expiry",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "QuoteTTLMismatch",
    "inputs": [
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "expectedTTL",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "quotedTTL",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "ReentrancyGuardReentrantCall",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ResultAlreadySubmitted",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "callId",
        "type": "uint64",
        "internalType": "uint64"
      },
      {
        "name": "operator",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "SafeERC20FailedOperation",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ServiceExpired",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "ServiceNotActive",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "ServiceNotFound",
    "inputs": [
      {
        "name": "serviceId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "ServiceRequestAlreadyProcessed",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "ServiceRequestNotFound",
    "inputs": [
      {
        "name": "requestId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "SlashAlreadyCancelled",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "SlashAlreadyExecuted",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "SlashNotExecutable",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "SlashNotFound",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "SlashNotPending",
    "inputs": [
      {
        "name": "slashId",
        "type": "uint64",
        "internalType": "uint64"
      }
    ]
  },
  {
    "type": "error",
    "name": "TokenNotAllowed",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "TooManyOperators",
    "inputs": [
      {
        "name": "maximum",
        "type": "uint32",
        "internalType": "uint32"
      },
      {
        "name": "provided",
        "type": "uint32",
        "internalType": "uint32"
      }
    ]
  },
  {
    "type": "error",
    "name": "UUPSUnauthorizedCallContext",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UUPSUnsupportedProxiableUUID",
    "inputs": [
      {
        "name": "slot",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ]
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAddress",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ZeroAmount",
    "inputs": []
  }
]
```*/
#[allow(
    non_camel_case_types,
    non_snake_case,
    clippy::pub_underscore_fields,
    clippy::style,
    clippy::empty_structs_with_brackets
)]
pub mod Tangle {
    use super::*;
    use alloy::sol_types as alloy_sol_types;
    /// The creation / init bytecode of the contract.
    ///
    /// ```text
    ///0x60a080604052346100e857306080527ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005460ff8160401c166100d9576002600160401b03196001600160401b03821601610073575b60405161c99390816100ed823960805181818161287e01526129960152f35b6001600160401b0319166001600160401b039081177ff0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a005581527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d290602090a15f80610054565b63f92ee8a960e01b5f5260045ffd5b5f80fdfe6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c806301ffc9a71461055957806306079dc514610554578063062375261461054f57806307e601291461054a5780630afd3738146105455780630f33e8e114610540578063108a7d631461053b578063110f829b1461053657806318c6801714610531578063208129561461052c57806323d7b3e114610527578063248a9ca3146105225780632b9da71a1461051d5780632d07e655146105185780632dae1885146105135780632ec2bd031461050e5780632f2ff15d146105095780632f46279f1461050457806330ae289c146104ff57806331d7a262146104fa5780633413e8ee146104f557806336568abe146104f0578063372500ab146104eb5780633dc0d5fe146104e65780633f4ba83a146104e1578063449bb849146104dc5780634f1ef286146104d757806352d1902d146104d2578063563a89f9146104cd5780635b71c934146104c85780635c975abb146104c35780635f359924146104be5780635f9b4dfa146104b9578063614823b2146104b457806364462595146104af5780636778afbc146104aa5780636a64a27e146104a55780636bda42f3146104a05780636d8b88c31461049b57806375b238fc1461049657806377380c7414610491578063784486371461048c57806378867a161461048757806380ac822814610482578063815d6a261461047d578063842524bb146104785780638456cb59146104735780638a4cf7631461046e5780638c9a281d146104695780638d3f65be1461046457806391d148541461045f57806393f3ddaf1461045a578063970e08fe14610455578063a217fddf14610450578063a37b92861461044b578063a595b21e14610446578063a5bfbae414610441578063a672bc0a1461043c578063aac7416b14610437578063aacdba9f14610432578063ad3cb1cc1461042d578063b055449b14610428578063b7696dbb14610423578063b81741ac1461041e578063bb207f1f14610419578063c0c53b8b14610414578063c325ae121461040f578063c602d4fa1461040a578063cc3d19c314610405578063cf3806c614610400578063d390bbbb146103fb578063d547741f146103f6578063da232ded146103f1578063dfe62aba146103ec578063e538da66146103e7578063e63ab1e9146103e2578063e72146a9146103dd578063eb8c3bcd146103d8578063ec9f0fdd146103d3578063ef1b42a2146103ce578063ef5cfb8c146103c9578063f0411af3146103c4578063f0f44260146103bf5763f72c0d8b0361000e57616736565b6166eb565b616654565b6165cd565b616470565b6162e5565b61620e565b616161565b616127565b616096565b615f7d565b615eb1565b615e7d565b615e57565b615b88565b61581a565b6157f4565b615334565b6151ac565b61512a565b61500f565b614f39565b614be7565b614ba0565b61465d565b61461b565b6144c3565b6141c8565b61417b565b6140dc565b6140c2565b613f9e565b613ec3565b613e3b565b613dff565b613dc5565b613d0c565b613c9b565b613bc4565b613b73565b613b14565b6139c1565b6137d7565b61373d565b613703565b61356b565b613496565b61344f565b6131f5565b6131ac565b612f2a565b612de8565b612c9d565b612c6f565b612b2e565b612a4a565b612984565b61283c565b6125ef565b612571565b6123dd565b612245565b6121fd565b611e69565b611e19565b611ac6565b611a75565b611a3c565b6119ec565b61199f565b6114b4565b610ec2565b610e90565b610e26565b610ddf565b610d5d565b610c2b565b610ae5565b6109c5565b61081c565b6107f3565b6107ca565b610661565b346105af5760203660031901126105af5760043563ffffffff60e01b81168091036105af57602090637965db0b60e01b811490811561059e575b506040519015158152f35b6301ffc9a760e01b1490505f610593565b5f80fd5b6001600160401b038116036105af57565b600435906105d1826105b3565b565b60a435906105d1826105b3565b608435906105d1826105b3565b35906105d1826105b3565b9181601f840112156105af578235916001600160401b0383116105af57602083818601950101116105af57565b9060406003198301126105af5760043561063e816105b3565b91602435906001600160401b0382116105af5761065d916004016105f8565b9091565b346105af5761066f36610625565b335f9081525f8051602061c947833981519152602052604090205460ff16156107a0579061069e9136916127eb565b6106b9826001600160401b03165f52601d60205260405f2090565b805460401c6001600160a01b03161561078457600501805460801c60ff166106e0816163a3565b6002811461076857806106f46003926163a3565b1461074957805460ff60801b1916600360801b1790557fe80d1a183af30916f79b15a6c85e82470d0b88065dfdd2505d106adf0e8b7796604051806107446001600160401b033396169482614b8f565b0390a3005b6307705ccd60e41b5f526001600160401b03831660045260245ffd5b5ffd5b63532af36960e01b5f526001600160401b03841660045260245ffd5b63162e3fab60e21b5f526001600160401b03831660045260245ffd5b6001600160401b0383630393979d60e31b5f52166004523360245260445ffd5b5f9103126105af57565b346105af575f3660031901126105af5760206001600160401b0360045460801c16604051908152f35b346105af575f3660031901126105af5760206001600160401b0360045460401c16604051908152f35b346105af5760203660031901126105af57600435610839816105b3565b6108428161867c565b6001600160401b0361088a61087d61086b856001600160401b03165f52600760205260405f2090565b335f9081526020919091526040902090565b546001600160401b031690565b16156109a557600101805461093891906001600160a01b031680610969575b505f6108df336108ca866001600160401b03165f52600760205260405f2090565b9060018060a01b03165f5260205260405f2090565b55610904336108ff856001600160401b03165f52600860205260405f2090565b6186fc565b50610918610913825460e01c90565b616797565b81546001600160e01b031660e09190911b6001600160e01b031916179055565b6001600160401b033391167f88e46e95bcdf1020c0caf9f3dd5fde69c41d2151dbbca0a77c03c4e28b4d3ec15f80a3005b604051630a8d22bb60e11b602082015233602482015261099f9161099a82604481015b03601f198101845283612736565b6186e2565b5f6108a9565b639bcccbfd60e01b5f526001600160401b0382166004523360245260445ffd5b346105af576001600160401b036109db36610625565b9290911690815f526007602052610a0460405f203360018060a01b03165f5260205260405f2090565b6001600160401b0381541615610a68577f2d0e8c75ccfc606463bd5f7556ccf358b1c409ec6059cee6e51935a29bd0fdc191610a4d610a5f926001600160401b034216906167a9565b604051946020865260208601916167d1565b928033940390a3005b82639bcccbfd60e01b5f526004523360245260445ffd5b9181601f840112156105af578235916001600160401b0383116105af576020808501948460051b0101116105af57565b6001600160a01b038116036105af57565b60c435906105d182610aaf565b60a435906105d182610aaf565b35906105d182610aaf565b6101003660031901126105af57610afa6105c4565b6024356001600160401b0381116105af57610b19903690600401610a7f565b916044356001600160401b0381116105af57610b39903690600401610a7f565b9290936064356001600160401b0381116105af57610b5b9036906004016105f8565b949095608435956001600160401b0387116105af57610bbd97610b85610ba3983690600401610a7f565b949093610b906105d3565b96610b99610ac0565b9860e4359a616802565b6040516001600160401b0390911681529081906020820190565b0390f35b60409060031901126105af57600435610bd9816105b3565b90602435610be6816105b3565b90565b60206040818301928281528451809452019201905f5b818110610c0c5750505090565b82516001600160401b0316845260209384019390920191600101610bff565b346105af57610c3936610bc1565b6001600160401b03165f825b826001600160401b03821610610d0c57506001600160401b031691610c69836168ca565b925f915b836001600160401b0382161080610cfa575b15610cec5780610cab610ca6610cb4936001600160401b03165f52601d60205260405f2090565b618e9b565b610cb9576168ad565b610c6d565b610ce781610cd96001600160401b03610cd1886168ad565b971689616932565b906001600160401b03169052565b6168ad565b60405180610bbd8782610be9565b50816001600160401b03841610610c7f565b610d2a610ca6826001600160401b03165f52601d60205260405f2090565b610d40575b6001016001600160401b0316610c45565b906001610d546001600160401b03926168ad565b92915050610d2f565b346105af5760203660031901126105af57600435610d7a816105b3565b60ff6002610d878361867c565b015460101c1615610dc3576001600160401b033391167fd39ff75a15c31a272891c52e42995acfa27459ba1c12239cbac23cdb76f530845f80a3005b6001600160401b039063210eb4ed60e11b5f521660045260245ffd5b346105af5760203660031901126105af57600435610dfc81610aaf565b610e04618ee5565b601f80546001600160a01b0319166001600160a01b0392909216919091179055005b346105af5760403660031901126105af57600435610e43816105b3565b602435906001600160401b0382116105af57366023830112156105af578160040135906001600160401b0382116105af5736602460608402850101116105af576024610018930190616946565b346105af5760203660031901126105af576020610eae600435616d69565b604051908152f35b61ffff8116036105af57565b346105af5760403660031901126105af57600435610edf816105b3565b602435610eeb81610eb6565b610ef361870f565b610efb618736565b610f04826198dc565b600281019081546001610f1b8260ff9060701c1690565b610f24816122e3565b03611498576001606082901c60ff16610f3c816122c7565b0361143d5763ffffffff604082901c16801515918261146b575b505061143d57546001600160401b03166001600160401b03610f8f61087d61086b846001600160401b03165f52600760205260405f2090565b161561144c57610fc1610fb7336108ca876001600160401b03165f52601160205260405f2090565b5460901c60ff1690565b61143d57610fe0906001600160401b03165f52600560205260405f2090565b5f54610ffc906001600160a01b03165b6001600160a01b031690565b9060405163d775cb6160e01b8152602081600481865afa8015611363576001915f9161141e575b509101805490926001600160a01b039091169182611387575b60405163f46913bb60e01b815233600482015260248101829052602081604481865afa908115611363575f91611368575b50156112e65750506001600160a01b031680611256575b506111aa6111f49261115b611097612757565b61ffff87168152426001600160401b031660208201525f6040820152600160608201526110d9336108ca8a6001600160401b03165f52601160205260405f2090565b8151815461ffff191661ffff919091161781559060609060208101518354604083015171ffffffffffffffffffffffffffffffff00001990911660109290921b69ffffffffffffffff0000169190911760509190911b67ffffffffffffffff60501b161783550151815460ff60901b191690151560901b60ff60901b16179055565b61117f3361117a886001600160401b03165f52601260205260405f2090565b619916565b50611196611191825463ffffffff1690565b616d3e565b63ffffffff1663ffffffff19825416179055565b60405161ffff8416815233906001600160401b038616907f2457918796078440068385e73e422539c84f2f9045dd442e123d4284258ae24a90602090a3546001600160a01b031690565b6001600160a01b03811661120b575b61001861876e565b604051634d51354960e11b60208201526001600160401b03909316602484015233604484015261ffff909116606483015261124e919061099a826084810161098c565b5f8080611203565b60405163168e485d60e31b81526001600160401b038616600482015233602482015290602090829060449082906001600160a01b03165afa5f91816112b5575b501561108457156112a7575f611084565b6282b42960e81b5f5260045ffd5b6112d891925060203d6020116112df575b6112d08183612736565b810190616dc0565b905f611296565b503d6112c6565b604051631c9d11bd60e31b815233600482015291602090839060249082905afa90811561136357610765925f92611332575b5063936d426d60e01b5f5233600452602452604452606490565b61135591925060203d60201161135c575b61134d8183612736565b810190616d87565b9083611318565b503d611343565b616d96565b611381915060203d6020116112df576112d08183612736565b5f61106d565b6004604061139d6001600160a01b038616610ff0565b8151632a6e736160e11b815292839182905afa90815f915f936113eb575b506113c8575b505061103c565b15806113e2575b6113da575b806113c1565b90505f6113d4565b508015156113cf565b909250611410915060403d604011611417575b6114088183612736565b810190616da1565b915f6113bb565b503d6113fe565b611437915060203d60201161135c5761134d8183612736565b5f611023565b63baf3f0f760e01b5f5260045ffd5b639bcccbfd60e01b5f526001600160401b03166004523360245260445ffd5b63ffffffff91925061148361148d9163ffffffff1690565b9263ffffffff1690565b911610155f80610f56565b63098bfc5b60e31b5f526001600160401b03851660045260245ffd5b346105af5760603660031901126105af576004356114d1816105b3565b602435906114de826105b3565b6044356001600160401b0381116105af576114fd9036906004016105f8565b9061150661870f565b61150e618736565b611517836198dc565b906115228585619929565b94600161155061153985546001600160401b031690565b6001600160401b03165f52600560205260405f2090565b0180549092906001600160a01b0316806118e1575b5061158e61158a610fb761086b896001600160401b03165f52601160205260405f2090565b1590565b6118c15760038701946115a2865460ff1690565b61189f576115e96115e2336108ca866115cc8c6001600160401b03165f52601760205260405f2090565b906001600160401b03165f5260205260405f2090565b5460ff1690565b61187957916116c69593916001600160401b0395936116326116258a6108ca866115cc33936001600160401b03165f52601760205260405f2090565b805460ff19166001179055565b60018a019261166161164b611191865463ffffffff1690565b855463ffffffff191663ffffffff909116178555565b81818c858d6116768a5460018060a01b031690565b926001600160a01b03841661181f575b509150507f8a04f99fe23284e874e8dd017345248279cc59701695e73bcdbeb6241bcd2ac692508a91501698899216998a936040519182913397836167f1565b0390a49054600191906116e1906001600160a01b0316610ff0565b80611796575b5063ffffffff6116fc81925463ffffffff1690565b92169116101561170e5761001861876e565b600293611756936117278694600160ff19825416179055565b7f60a7649f6e93e7a3ce1dc9729c20e3d95dce28c6a6bd957cde09d8a1cb37c19f5f80a3015460681c60ff1690565b61175f816122e3565b1480611789575b611774575b80808080611203565b60026117829201549061998e565b5f8061176b565b5060028201541515611766565b88546040516313110f8160e21b81526001600160401b038a16600482015260ff909116602482015290602090829060449082906001600160a01b03165afa5f91816117ee575b50156116e757915063ffffffff6116e7565b61181191925060203d602011611818575b6118098183612736565b810190616ef9565b905f6117dc565b503d6117ff565b5461186e9561099a9361098c9260ff169361184f886115cc836001600160401b03165f52601860205260405f2090565b9060405198899663c40c80d160e01b6020890152339260248901616e0d565b81815f858d8f611686565b635bf3fe7760e11b5f526001600160401b0380881660045283166024523360445260645ffd5b630a55512f60e01b5f526001600160401b03808816600452831660245260445ffd5b63783482e960e01b5f526001600160401b0386166004523360245260445ffd5b6118f3906001600160a01b0316610ff0565b61193a60206119038a5460ff1690565b604051630cf6add960e11b81526001600160401b038b16600482015260ff8216602482015290939092839190829081906044820190565b03915afa5f918161197e575b50611952575b50611565565b61195c578061194c565b631dc5933760e21b5f526001600160401b03871660045260ff1660245260445ffd5b61199891925060203d6020116112df576112d08183612736565b905f611946565b346105af575f3660031901126105af57601f546040516001600160a01b039091168152602090f35b60409060031901126105af576004356119df816105b3565b90602435610be681610aaf565b346105af576020611a326001600160401b03611a07366119c7565b91165f9081526013845260408082206001600160a01b03909316825260019092016020522054151590565b6040519015158152f35b346105af5760403660031901126105af57610018602435600435611a5f82610aaf565b611a70611a6b82616d69565b619032565b619ddf565b346105af5760203660031901126105af576001600160401b03600435611a9a816105b3565b165f526010602052602060ff600260405f20015460701c16611abb816122e3565b600160405191148152f35b346105af5760803660031901126105af57600435611ae3816105b3565b60243590611af082610aaf565b6044359160643591611b01816198dc565b5492611b2b610ff0611b1b6001600160401b038716611539565b9560401c6001600160a01b031690565b33148015611dfd575b801580611de7575b611d4d575b156112a757611b65836108ca846001600160401b03165f52601160205260405f2090565b5460ff609082901c161580611d38575b611d0f57611b96611ba592611b8d60019361ffff1690565b8833888861a016565b9401546001600160a01b031690565b6001600160a01b038116611bc8575b6040516001600160401b0385168152602090f35b5f54611bdc906001600160a01b0316610ff0565b604051631c9d11bd60e31b81526001600160a01b03851660048201529590602090879060249082905afa9283156113635761098c611ccc95611ca29561099a94610bbd9a5f92611cee575b508115611ce657611c4a91611c3e611c4392616f23565b616f64565b61ffff1690565b61271061ffff821611611cdd575b611c6a611c709161ffff606491160490565b60ff1690565b90606460ff831611611cd4575b611cb090604051978891602083016014916001600160601b03199060601b1681520190565b03601f198101885287612736565b604051630881898f60e01b602082015295869360248501616f73565b5f8080611bb4565b60649150611c7d565b50612710611c58565b50505f611c4a565b611d0891925060203d60201161135c5761134d8183612736565b905f611c27565b63783482e960e01b5f526001600160401b0383166004526001600160a01b03841660245260445ffd5b50601081901c6001600160401b031615611b75565b6001850154611d6690610ff0906001600160a01b031681565b6040516374ceeb5560e01b81526001600160401b038516600482015290602090829060249082905afa5f9181611db6575b50611da3575b50611b41565b6001600160a01b0316331490505f611d9d565b611dd991925060203d602011611de0575b611dd18183612736565b810190616f0e565b905f611d97565b503d611dc7565b5060018501546001600160a01b03161515611b3c565b508354611e12906001600160a01b0316610ff0565b3314611b34565b346105af5760203660031901126105af57600435611e3681610aaf565b60018060a01b03165f52601960205260405f205f8052602052602060405f2054604051908152f35b60ff8116036105af57565b60603660031901126105af57600435611e81816105b3565b60243590611e8e82611e5e565b6044356001600160401b0381116105af57611ead9036906004016105f8565b919092611eb861870f565b611ec0618736565b611ec9826198dc565b600281015493906001607086901c60ff16611ee3816122e3565b036121e15760018101546001600160401b03604082901c1680151591826121af575b505061219357611f4961158a611f2c866001600160401b03165f52601360205260405f2090565b611f3533610ff0565b906001915f520160205260405f2054151590565b612173575f9460029060681c60ff16611f61816122e3565b1461212d575b908291611f85856001600160401b03165f52601560205260405f2090565b958654611f98906001600160401b031690565b96611fa2886168ad565b815467ffffffffffffffff19166001600160401b03909116179055611fc5612766565b60ff85168152903360208301526001600160401b0342166040830152606082015f9052608082015260a081015f905286612010876001600160401b03165f52601660205260405f2090565b9061202b91906001600160401b03165f5260205260405f2090565b9061203591616fc3565b868287612053886001600160401b03165f52601860205260405f2090565b9061206e91906001600160401b03165f5260205260405f2090565b91612078926170e2565b546001600160401b03165f90815260056020526040902060010154610bbd967fde37cc48d21778e1c9a075c4e41c5aff6918c3ea6151221f0af3ce8121a29db59390916001600160a01b031690816120f7575b50506120ec6040519283926001600160401b03808a169816963390856171d7565b0390a3610ba361876e565b612126916121218861098c87878d604051978895639838caa360e01b6020880152602487016171a6565b61a253565b5f846120cb565b93508190600361215e61214787546001600160401b031690565b6001600160401b03165f52600660205260405f2090565b01549461216b348761a1c9565b909150611f67565b63357756d160e21b5f526001600160401b0384166004523360245260445ffd5b637c3e621b60e01b5f526001600160401b03841660045260245ffd5b6121d892506121cc91906001600160401b0316616fa3565b616fa3565b6001600160401b031690565b42115f80611f05565b63098bfc5b60e31b5f526001600160401b03841660045260245ffd5b346105af5760403660031901126105af5760043560243561221d81610aaf565b336001600160a01b03821603612236576100189161a2cd565b63334bd91960e11b5f5260045ffd5b346105af575f3660031901126105af5761225d618736565b6122663361a36d565b8061227f575b60015f8051602061c92783398151915255005b5f906040519081527f9310ccfcb8de723f578a9e4282ea9f521f05ae40dc08f3068dfad528a65ee3c760203392a35f61226c565b634e487b7160e01b5f52602160045260245ffd5b600211156122d157565b6122b3565b906122e0826122c7565b52565b600311156122d157565b906122e0826122e3565b6105d1909291926101608061018083019561231b8482516001600160401b03169052565b6020818101516001600160a01b0316908501526040818101516001600160401b0316908501526060818101516001600160401b0316908501526080818101516001600160401b03169085015260a0818101516001600160401b03169085015260c08181015163ffffffff169085015260e08181015163ffffffff16908501526101008181015163ffffffff16908501526123bf6101208201516101208601906122d6565b6123d36101408201516101408601906122ed565b01519101906122ed565b346105af5760203660031901126105af576001600160401b03600435612402816105b3565b61240a6171fe565b50165f526010602052610bbd60405f2061256561255b600261242a612775565b936124726124628254612453612446826001600160401b031690565b6001600160401b03168952565b60401c6001600160a01b031690565b6001600160a01b03166020870152565b6124f96124e960018301546124a0612490826001600160401b031690565b6001600160401b031660408a0152565b6124c2604082901c6001600160401b03165b6001600160401b031660608a0152565b6124e3608082901c6001600160401b03166001600160401b031660808a0152565b60c01c90565b6001600160401b031660a0870152565b015463ffffffff811660c085015263ffffffff602082901c1660e085015263ffffffff604082901c1661010085015261253d606082901c60ff166101208601617267565b612552606882901c60ff166101408601617270565b60701c60ff1690565b6101608301617270565b604051918291826122f7565b346105af575f3660031901126105af57612589618f54565b5f8051602061c9078339815191525460ff8116156125e05760ff19165f8051602061c907833981519152557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b638dfc202b60e01b5f5260045ffd5b346105af5760203660031901126105af576001600160401b03600435612614816105b3565b61261d8161867c565b80546001600160a01b0316330361266257600201805462ff000019169055167fe14286f3ad49ada6d0911adda8ef90616999045bde2a33e391a7b5ae6589e7895f80a2005b5063234e071d60e01b5f52166004523360245260445ffd5b634e487b7160e01b5f52604160045260245ffd5b60e081019081106001600160401b038211176126a957604052565b61267a565b608081019081106001600160401b038211176126a957604052565b60c081019081106001600160401b038211176126a957604052565b61014081019081106001600160401b038211176126a957604052565b604081019081106001600160401b038211176126a957604052565b606081019081106001600160401b038211176126a957604052565b90601f801991011681019081106001600160401b038211176126a957604052565b604051906105d1608083612736565b604051906105d160c083612736565b604051906105d161018083612736565b604051906105d160e083612736565b604051906105d1606083612736565b604051906105d161014083612736565b604051906105d1604083612736565b906105d16040519283612736565b6001600160401b0381116126a957601f01601f191660200190565b9291926127f7826127d0565b916128056040519384612736565b8294818452818301116105af578281602093845f960137010152565b9080601f830112156105af57816020610be6933591016127eb565b60403660031901126105af5760043561285481610aaf565b6024356001600160401b0381116105af57612873903690600401612821565b906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016308114908115612962575b50612953576128b6618fc3565b6040516352d1902d60e01b8152916020836004816001600160a01b0386165afa5f9381612932575b506128ff57634c9c8ce360e01b5f526001600160a01b03821660045260245ffd5b905f8051602061c8c7833981519152830361291e57610018925061ba94565b632a87526960e21b5f52600483905260245ffd5b61294c91945060203d60201161135c5761134d8183612736565b925f6128de565b63703e46dd60e11b5f5260045ffd5b5f8051602061c8c7833981519152546001600160a01b0316141590505f6128a9565b346105af575f3660031901126105af577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036129535760206040515f8051602061c8c78339815191528152f35b91909160c08060e083019480516129f1816122c7565b84526020810151612a01816122e3565b602085015263ffffffff604082015116604085015263ffffffff6060820151166060850152608081015160808501526001600160401b0360a08201511660a08501520151910152565b346105af5760203660031901126105af576001600160401b03600435612a6f816105b3565b612a77617279565b50165f526006602052610bbd60405f20600360405191612a968361268e565b612aea612add825460ff8116612aab816122c7565b8652612ac060ff8260081c1660208801617270565b63ffffffff601082901c1660408701525b60301c63ffffffff1690565b63ffffffff166060850152565b60018101546080840152612b1b612b0b60028301546001600160401b031690565b6001600160401b031660a0850152565b015460c0820152604051918291826129db565b346105af5760203660031901126105af57600435612b4b816105b3565b612b54816198dc565b805460401c6001600160a01b0316336001600160a01b0390911603612c4f5760028101805460ff60701b1916600160711b179055612c0790600190612bf99061153990808401805467ffffffffffffffff60801b19164260801b67ffffffffffffffff60801b161790556001600160401b0386167f3fd558a59bbce1d996d17eab7fde314bcd201ec3f17375a7f873b3162927e8815f80a2546001600160401b031690565b01546001600160a01b031690565b906001600160a01b038216612c1857005b604051630a24e8a960e41b60208201526001600160401b0390911660248201523360448201526100189161099a826064810161098c565b630cd567cf60e11b5f526001600160401b0382166004523360245260445ffd5b346105af575f3660031901126105af57602060ff5f8051602061c90783398151915254166040519015158152f35b346105af57612cab366119c7565b6001600160a01b03612cbc836198dc565b5460401c163303612cee576001600160401b0361001892165f52601360205260405f209060018060a01b03169061b3dc565b6001600160401b0382630cd567cf60e11b5f52166004523360245260445ffd5b6105d19092919261016080610180830195612d328482516001600160401b03169052565b6020818101516001600160a01b0316908501526040818101516001600160401b0316908501526060818101516001600160401b03169085015260808181015163ffffffff169085015260a08181015163ffffffff169085015260c0818101516001600160a01b03169085015260e081015160e0850152612dbc6101008201516101008601906122d6565b6101208181015163ffffffff16908501526101408181015163ffffffff16908501525b01511515910152565b346105af5760203660031901126105af576001600160401b03600435612e0d816105b3565b612e156171fe565b50165f526009602052610bbd60405f20612f1e612f146004612e35612775565b93612e516124628254612453612446826001600160401b031690565b612eb9612eac6001830154612e6f612490826001600160401b031690565b612e85604082901c6001600160401b03166124b2565b612ea0608082901c63ffffffff1663ffffffff1660808a0152565b60a01c63ffffffff1690565b63ffffffff1660a0870152565b60028101546001600160a01b031660c0860152600381015460e08601520154612ee960ff82166101008601617267565b63ffffffff600882901c1661012085015263ffffffff602882901c1661014085015260481c60ff1690565b1515610160830152565b60405191829182612d0e565b346105af5760403660031901126105af57600435612f47816105b3565b602435612f5381611e5e565b612f5b61870f565b612f63618736565b612f6c82619078565b600481015460481c60ff16613190575f915f5b612f9a856001600160401b03165f52600a60205260405f2090565b5481101561318857610ff0612fe3612fcc83612fc7896001600160401b03165f52600a60205260405f2090565b616c24565b9054339360039290921b1c6001600160a01b031690565b14612ff057600101612f7f565b5090915060015b156112a75761301e6115e2336108ca866001600160401b03165f52600c60205260405f2090565b61316857613044611625336108ca866001600160401b03165f52600c60205260405f2090565b6130c76001612bf96115398286019561308b61306b611191895463ffffffff9060a01c1690565b885463ffffffff60a01b191660a09190911b63ffffffff60a01b16178855565b336001600160401b0389167fceda1a44ead4da3d3abaaa941afa6d9530fd84dd8e99385c9183d986dcab980f5f80a3546001600160401b031690565b906001600160a01b038216613121575b50505463ffffffff6131036130fa60a084901c83165b9360801c63ffffffff1690565b63ffffffff1690565b9116146131125761001861876e565b61311b906192f7565b5f611203565b604051632c567acd60e21b60208201523360248201526001600160401b038516604482015260ff90911660648201526131619161099a826084810161098c565b5f806130d7565b630f2bb0f160e41b5f526001600160401b0383166004523360245260445ffd5b509091612ff7565b63252048a360e21b5f526001600160401b03831660045260245ffd5b346105af5760206001600160401b036131e9816131c8366119c7565b91165f526007845260405f209060018060a01b03165f5260205260405f2090565b54161515604051908152f35b346105af5760203660031901126105af57600435613212816105b3565b61321a618736565b613223816198dc565b60028101908154600161323a8260ff9060601c1690565b613243816122c7565b0361143d5763ffffffff6132636130fa8383169360201c63ffffffff1690565b9116111561143d5761328961086b846001600160401b03165f52601160205260405f2090565b9061329c61158a835460ff9060901c1690565b61342f576132b6611539600192546001600160401b031690565b0180549092906001600160a01b0316806133b4575b50815468ffffffffffffffffff60501b19164260501b67ffffffffffffffff60501b161790915561332790613315336108ff866001600160401b03165f52601260205260405f2090565b50611196610913825463ffffffff1690565b61336a60405191336001600160401b0385167f8ce53e4b6002ff090e641ddecdaf7edd2813a98e19139fa7d1c79fccc3c4dead5f80a3546001600160a01b031690565b6001600160a01b0381166133805761001861876e565b63965d231b60e01b60208301526001600160401b03909216602482015233604482015261124e9161099a826064810161098c565b6133c6906001600160a01b0316610ff0565b60405163728c6f3b60e11b81526001600160401b038616600482015233602482015290602090829060449082905afa5f918161340e575b50156132cb57156112a7575f6132cb565b61342891925060203d6020116112df576112d08183612736565b905f6133fd565b63783482e960e01b5f526001600160401b0384166004523360245260445ffd5b346105af5760203660031901126105af5760043561346c81610aaf565b613474618ee5565b602080546001600160a01b0319166001600160a01b0392909216919091179055005b346105af57610bbd6134de6001600160401b036134b2366119c7565b91906134bc6172d3565b50165f52600760205260405f209060018060a01b03165f5260205260405f2090565b60ff604051916134ed836126ae565b546001600160401b03811683526001600160401b038160401c166020840152818160801c161515604084015260881c16151560608201526040519182918291909160608060808301946001600160401b0381511684526001600160401b03602082015116602085015260408101511515604085015201511515910152565b346105af5760203660031901126105af57600435613588816105b3565b613590618736565b61359981619078565b60048101906135ad825460ff9060481c1690565b613190575f915f5b6135d0856001600160401b03165f52600a60205260405f2090565b548110156136fb57610ff06135fd612fcc83612fc7896001600160401b03165f52600a60205260405f2090565b1461360a576001016135b5565b5090915060015b156112a757612bf96115396136a69361363f600194690100000000000000000060ff60481b19825416179055565b805461366a9060401c6001600160a01b031660028301546001600160a01b031660038401549161a42c565b336001600160401b0387167fc63050b963ec6e2cf36df90ecacaa43212c0e74b8c3a58a0f8cce3bd5a2a76755f80a3546001600160401b031690565b906001600160a01b0382166136bd5761001861876e565b604051631939a94360e31b60208201523360248201526001600160401b0390911660448201526136f49161099a826064810161098c565b5f80611203565b509091613611565b346105af575f3660031901126105af5760206040517fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c217758152f35b346105af5761374b36610625565b6001600160401b03839293165f52601d60205260018060a01b0360405f205460401c16331415806137b2575b613792576100189261378a9136916127eb565b90339061a455565b63dd2c7fb760e01b5f526001600160401b0382166004523360245260445ffd5b50335f9081525f8051602061c947833981519152602052604090205460ff1615613777565b346105af576101203660031901126105af576004356001600160401b0381116105af576138089036906004016105f8565b505060243561381681610aaf565b60e03660431901126105af57610bbd9061382e61870f565b6004546001600160401b031690613863613847836168ad565b6001600160401b03166001600160401b03196004541617600455565b6138e661386e616c75565b6138be6138796172f7565b6138b5613884612785565b338152936001600160a01b0387166020860152426001600160401b031660408601525f606086015260808501617267565b60a08301617270565b600160c08201525b6138e1846001600160401b03165f52600560205260405f2090565b61733d565b613909613904836001600160401b03165f52600660205260405f2090565b617428565b6040516001600160a01b038216815233906001600160401b038416907f2b0f6a7b1f5afd7832e49972f40b9fcd16998930b24f36469c91003502d0d99890602090a36001600160a01b038116613975575b506040516001600160401b0390911681529081906020820190565b604051630b6535d760e01b60208201526001600160401b03831660248201523360448201523060648201526139b191612121826084810161098c565b5f61395a565b801515036105af57565b346105af5760603660031901126105af576004356139de816105b3565b6024356139ea816139b7565b604435916139f783610eb6565b6139ff618ee5565b6001600160401b038116610e108110908115613b07575b50613aec5761ffff83168015908115613afb575b50613aec57613ae77f33e0411431005a063470b554094e62f6973aa35fce230eaf5d5a0079be4e339c93613ab9613a5f612794565b6001600160401b0385168082528615156020830181905261ffff8516604093840152601c80546affffffffffffffffffffff1916909217921b60ff60401b1691909117604884901b6affff00000000000000000016179055565b6040519384938491604091949361ffff916001600160401b0360608601971685521515602085015216910152565b0390a1005b63d8f2727d60e01b5f5260045ffd5b6127109150115f613a2a565b62278d009150115f613a16565b346105af5760403660031901126105af576020613b6a600435613b3681610aaf565b60243590613b4382610aaf565b60018060a01b03165f526019835260405f209060018060a01b03165f5260205260405f2090565b54604051908152f35b346105af57613b81366119c7565b6001600160a01b03613b92836198dc565b5460401c163303612cee576001600160401b0361001892165f52601360205260405f209060018060a01b03169061ba1b565b346105af57610bbd613c0c6001600160401b03613be0366119c7565b9190613bea6172d3565b50165f52601160205260405f209060018060a01b03165f5260205260405f2090565b60ff60405191613c1b836126ae565b5461ffff811683526001600160401b038160101c1660208401526001600160401b038160501c16604084015260901c161515606082015260405191829182919091606080608083019461ffff81511684526001600160401b0360208201511660208501526001600160401b03604082015116604085015201511515910152565b346105af575f3660031901126105af57613cb3618f54565b613cbb61870f565b600160ff195f8051602061c9078339815191525416175f8051602061c907833981519152557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b346105af57613d1a366119c7565b6001600160a01b03811691908215613db657613d358261867c565b8054909190336001600160a01b03821603613d965782546001600160a01b0319166001600160a01b039283161790925516906001600160401b03167fd2b958a1b0b978ceded4986b4f49c8b25fbd6e812cb8925e13efc731ea4aa24d5f80a4005b6001600160401b038463234e071d60e01b5f52166004523360245260445ffd5b63d92e233d60e01b5f5260045ffd5b346105af575f3660031901126105af5760206040517f4c7070c6c19cc9b427b94fe5979ee0c573f8edd00d25591afe4c9510de9479ba8152f35b346105af5760203660031901126105af576001600160401b03600435613e24816105b3565b165f526008602052602060405f2054604051908152f35b346105af5760403660031901126105af57602060ff613e8d602435600435613e6282610aaf565b5f525f8051602061c8e7833981519152845260405f209060018060a01b03165f5260205260405f2090565b54166040519015158152f35b60206003198201126105af57600435906001600160401b0382116105af5761065d91600401610a7f565b346105af57613ed136613e99565b613eda816168ca565b915f915f5b818110613f3a57505050613ef2816168ca565b915f5b828110613f0a5760405180610bbd8682610be9565b80613f34613f2a613f1d60019486616932565b516001600160401b031690565b610cd98388616932565b01613ef5565b80613f5a613f4b60019385876174ee565b35613f55816105b3565b61a57a565b613f65575b01613edf565b613f708184866174ee565b35613f7a816105b3565b6001600160401b03613f95613f8e886174fe565b9789616932565b91169052613f5f565b60403660031901126105af57600435613fb6816105b3565b602435613fc1618736565b6002613fcc836198dc565b01546001607082901c60ff16613fe1816122e3565b036140a65760019060681c60ff16613ff8816122e3565b0361143d577fd28de7c518c312fa388e03f8d1203d8f4c75161e358ffb0827b6caa2e9ac8a316001600160401b03614041846001600160401b03165f52601460205260405f2090565b805461405a906001600160a01b0316918583349261a65a565b6001600160a01b03169384158061409d575b614085575b6040519384521691602090a361001861876e565b614098614092853461751a565b3361a6ec565b614071565b5083341161406c565b63098bfc5b60e31b5f526001600160401b03831660045260245ffd5b346105af575f3660031901126105af5760206040515f8152f35b60e03660031901126105af576004356140f4816105b3565b6024356001600160401b0381116105af57614113903690600401610a7f565b916044356001600160401b0381116105af576141339036906004016105f8565b929093606435936001600160401b0385116105af57610bbd9561415d610ba3963690600401610a7f565b9290916141686105e0565b94614171610acd565b9660c43598617527565b346105af57602060ff6141b96001600160401b03614198366119c7565b91165f526011845260405f209060018060a01b03165f5260205260405f2090565b5460901c166040519015158152f35b346105af5760203660031901126105af576004356141e5816105b3565b6141ed618736565b614208816001600160401b03165f52601d60205260405f2090565b9061421561158a83618e9b565b6144a8578154906001600160401b038216906020614244836001600160401b03165f52601060205260405f2090565b5f5490939061425f90611b1b906001600160a01b0316610ff0565b9461427185546001600160401b031690565b60038801546004808a01546040516308d795d560e41b81526001600160a01b039a909a16918a01919091526001600160401b0392831660248a015293909116604488015260648701526084860191909152849060a49082905f905af1928315611363575f93614472575b50612bf9611539614300936142f28660019561a7be565b50546001600160401b031690565b916001600160a01b03831661432c575b610bbd8261431c61876e565b6040519081529081906020820190565b5f54614340906001600160a01b0316610ff0565b905460408051631c9d11bd60e31b81529082901c6001600160a01b031660048201819052949092602090849060249082905afa801561136357610bbd9561098c611ca29461099a93614432975f91614453575b50801561444a57611c436143ba916143b48b6143ae81616f23565b926175c0565b90616f64565b61271061ffff821611614441575b611c6a6143da9161ffff606491160490565b90606460ff831611614438575b614416906001600160401b031693604051978891602083016014916001600160601b03199060601b1681520190565b604051637e14b91960e01b602082015295869360248501616f73565b5f614310565b606491506143e7565b506127106143c8565b506127106143ba565b61446c915060203d60201161135c5761134d8183612736565b5f614393565b6001919350611539614300936142f261449c612bf99460203d60201161135c5761134d8183612736565b969450509350506142db565b63b48b095960e01b5f526001600160401b031660045260245ffd5b346105af57610bbd61452f6001600160401b036144df36610bc1565b91905f60a06040516144f0816126c9565b8281528260208201528260408201528260608201528260808201520152165f52601660205260405f20906001600160401b03165f5260205260405f2090565b6145bb6145b2600360405193614544856126c9565b805460ff81168652600881901c6001600160a01b0316602087015261457f9060a81c6001600160401b03166001600160401b03166040870152565b6145a0614593600183015463ffffffff1690565b63ffffffff166060870152565b60028101546080860152015460ff1690565b151560a0830152565b6040519182918291909160a08060c083019460ff8151168452600180831b0360208201511660208501526001600160401b03604082015116604085015263ffffffff60608201511660608501526080810151608085015201511515910152565b346105af575f3660031901126105af57608060025461ffff604051918181168352818160101c166020840152818160201c16604084015260301c166060820152f35b346105af5760603660031901126105af576146796004356105b3565b6024356001600160401b0381116105af57614698903690600401610a7f565b906044356001600160401b0381116105af576146b8903690600401610a7f565b90916146c261870f565b6146ca618736565b818403614b48576146ee6004356001600160401b03165f52601060205260405f2090565b61470261153982546001600160401b031690565b5f5b8681106147135761001861876e565b61475b6147336004356001600160401b03165f52601660205260405f2090565b614746614741848b896174ee565b61741e565b6001600160401b03165f5260205260405f2090565b61478261158a610fb7336108ca6004356001600160401b03165f52601160205260405f2090565b614b2457600381015460ff16614af0576147c86115e2896108ca6147b96004356001600160401b03165f52601760205260405f2090565b6147466147418833958d6174ee565b614ab85790600191614807611625876108ca8c614746614741886147ff6004356001600160401b03165f52601760205260405f2090565b9333966174ee565b61483561481d6111918584015463ffffffff1690565b8483019063ffffffff1663ffffffff19825416179055565b82840154889087906001600160a01b0316898c8683614a2e575b925090506148619350614741926174ee565b61486c83898b6175cd565b907f8a04f99fe23284e874e8dd017345248279cc59701695e73bcdbeb6241bcd2ac6604051806148b46001600160401b03339716956001600160401b036004351695836167f1565b0390a48383015483906148cf906001600160a01b0316610ff0565b806149b5575b5063ffffffff806148ec8685015463ffffffff1690565b9216911610158061499e575b614904575b5001614704565b60038101805460ff191660011790556001600160401b03614929614741848c8a6174ee565b166001600160401b03600435167f60a7649f6e93e7a3ce1dc9729c20e3d95dce28c6a6bd957cde09d8a1cb37c19f5f80a360028581015460681c60ff1661496f816122e3565b1480614991575b156148fd57600261498b91015460043561998e565b5f6148fd565b5060028101541515614976565b506149b061158a600383015460ff1690565b6148f8565b82546040516313110f8160e21b8152600480356001600160401b03169082015260ff90911660248201529060209082906001600160a01b031681806044810103915afa5f9181614a0e575b50156148d55790505f6148d5565b614a2791925060203d8111611818576118098183612736565b905f614a00565b614aad95614a8b61098c9261099a95614a85614a4b8c5460ff1690565b9961474661474185614a61614741828d876174ee565b9a614a7f6004356001600160401b03165f52601860205260405f2090565b946174ee565b936175cd565b9160405197889563c40c80d160e01b6020880152339160043560248901616e0d565b87865f898c8661484f565b610765614ac9614741848b896174ee565b635bf3fe7760e11b5f526001600160401b0360048035821690521660245233604452606490565b610765614b01614741848b896174ee565b630a55512f60e01b5f526001600160401b03600480358216905216602452604490565b63783482e960e01b5f908152600480356001600160401b0316905233602452604490fd5b631fec674760e31b5f5260045ffd5b60405190614b66602083612736565b5f8252565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b906020610be6928181520190614b6b565b346105af575f3660031901126105af57610bbd604051614bc1604082612736565b60058152640352e302e360dc1b6020820152604051918291602083526020830190614b6b565b346105af57614bf536613e99565b90614bfe618736565b5f915f915f5b828110614c26578385614c1561876e565b604080519182526020820192909252f35b614c4e614c376147418386866174ee565b6001600160401b03165f52601d60205260405f2090565b90614c5b61158a83618e9b565b614eb95781546001600160401b038116966020614c89896001600160401b03165f52601060205260405f2090565b5f54909990614cb490614ca4906001600160a01b0316610ff0565b9460401c6001600160a01b031690565b93614cc68b546001600160401b031690565b60038801546004808a01546040516308d795d560e41b81526001600160a01b0399909916918901919091526001600160401b03928316602489015293909116604487015260648601526084850191909152839060a49082905f905af191821561136357868685925f95614e70575b50614d6b614d6586614d7996614d5f82614d5a61474160019a612bf99a6115399a6174ee565b61a7be565b506175c0565b9a6174fe565b9a546001600160401b031690565b906001600160a01b038216614d99575b5050600191505b01939293614c04565b5f54614dad906001600160a01b0316610ff0565b935491604083901c6001600160a01b0316604051631c9d11bd60e31b81526001600160a01b038216600482015295909290602090879081806024810103915afa9283156113635761098c614e3995611ca29561099a9460019a5f92614e50575b508115614e4057614e2e611c436143da936143b4846143ae611c6a96616f23565b61ffff606491160490565b5f80614d89565b50506143da611c6a612710614e2e565b614e6991925060203d811161135c5761134d8183612736565b905f614e0d565b6001939550614d65612bf993614d7996614d5f61153995614d5a614741614ea7614d6b9860203d811161135c5761134d8183612736565b9c9a5050509550509650935050614d34565b60019150949394614d90565b81516001600160a01b039081168252602080840151909116908201526040808301516001600160401b03169082015260608083015163ffffffff1690820152608082015160e0820193926105d1929160c0918291614f22816122c7565b6080850152612ddf60a082015160a08601906122ed565b346105af5760203660031901126105af576001600160401b03600435614f5e816105b3565b614f66617279565b50165f526005602052610bbd60405f20615003614ffa600260405193614f8b8561268e565b80546001600160a01b03908116865260018201549081166020870152614fcb9061459390614fc560a082901c6001600160401b0316612490565b60e01c90565b0154614fdd60ff821660808601617267565b614ff1600882901c60ff1660a08601617270565b60101c60ff1690565b151560c0830152565b60405191829182614ec5565b346105af5760803660031901126105af57615028618ee5565b604051615034816126ae565b6004359061504182610eb6565b8181526024359061505182610eb6565b81602082015261ffff806044359461506886610eb6565b6040840195865260606064359461507e86610eb6565b0193845216921682018092116150d8576150ad611c436150b36150bc946150ad611c43612710985161ffff1690565b906175c0565b925161ffff1690565b036150c95761001861760e565b6343744f7160e01b5f5260045ffd5b616783565b90602080835192838152019201905f5b8181106150fa5750505090565b82516001600160a01b03168452602093840193909201916001016150ed565b906020610be69281815201906150dd565b346105af5760203660031901126105af576001600160401b0360043561514f816105b3565b165f52601260205260405f206040519081602082549182815201915f5260205f20905f5b81811061519657610bbd8561518a81870382612736565b60405191829182615119565b8254845260209093019260019283019201615173565b346105af5760603660031901126105af576004356151c981610aaf565b602435906151d682610aaf565b6044356151e281610aaf565b5f8051602061c96783398151915254926001600160401b0361521360ff604087901c1615956001600160401b031690565b168015908161532c575b6001149081615322575b159081615319575b5061530a57615272928461526960016001600160401b03195f8051602061c9678339815191525416175f8051602061c96783398151915255565b6152d55761a89b565b61527857005b6152a260ff60401b195f8051602061c96783398151915254165f8051602061c96783398151915255565b604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2908060208101613ae7565b615305600160401b60ff60401b195f8051602061c9678339815191525416175f8051602061c96783398151915255565b61a89b565b63f92ee8a960e01b5f5260045ffd5b9050155f61522f565b303b159150615227565b85915061521d565b346105af576101403660031901126105af57600435615352816105b3565b61535d6024356105b3565b6044356001600160401b0381116105af5761537c9036906004016105f8565b9190606435903660c4116105af5736610144116105af5761539b61870f565b6153a3618736565b6153ac836198dc565b936153b960243585619929565b946153ce61153982546001600160401b031690565b9160038701936153df855460ff1690565b6157cd5760018401546001600160a01b03165f8161573e575b1561570c57615421905f90611a2c908b906001600160a01b031680615661575b5050888a61aa34565b8082106156235750506084359560a4356154396127b3565b97885260208801526040906154e861158a615453846127c2565b60c4803582529a60e435602083015261546b866127c2565b60408d0135815260608d013560208201526154846127b3565b92835260208301528c6154e361549b368b8b6127eb565b805160209182012089516001600160c01b031960c095861b81169382019390935260243590941b9091166028840152603083015281605081015b03601f198101835282612736565b61bc9c565b615614576002978961550b60018b99612bf961559a9c600160ff19825416179055565b8c6001600160a01b0382166155d1575b50507fe6fcb3342abe43c21acc6a04e3d7912476836976e07ed47d0b15a374e200e2f091506001600160401b03169384926155686001600160401b03602435169788965193849384617719565b0390a37f60a7649f6e93e7a3ce1dc9729c20e3d95dce28c6a6bd957cde09d8a1cb37c19f5f80a3015460681c60ff1690565b6155a3816122e3565b14806155c4575b6155b65761001861876e565b60026136f49201549061998e565b50600282015415156155aa565b61560b9361098c6155e661099a935460ff1690565b916084888c8c8c51998a9763158bb2eb60e01b60208a01526024359160248a016176cc565b5f89818c61551b565b63ab1b236b60e01b5f5260045ffd5b604051630ae5923560e11b81526001600160401b038a81166004830152602480359091169082015260448101929092526064820152608490fd5b0390fd5b6156b19160409161567d906001600160a01b0316915460ff1690565b82516312fe632760e11b81526001600160401b038f16600482015260ff909116602482015292839190829081906044820190565b03915afa90815f915f936156d9575b506156ce575b8c9150615418565b915091505f806156c6565b9092506156fe915060403d604011615705575b6156f68183612736565b8101906176a7565b915f6156c0565b503d6156ec565b6107658861571b8b5460ff1690565b63279db37560e11b5f526001600160401b0390911660045260ff16602452604490565b61578c60206157556001600160a01b038516610ff0565b8c54604051630cf6add960e11b81526001600160401b038e16600482015260ff909116602482015292839190829081906044820190565b03915afa5f91816157ac575b506157a4575b506153f8565b90505f61579e565b6157c691925060203d6020116112df576112d08183612736565b905f615798565b630a55512f60e01b5f526001600160401b038088166004526024803591909116905260445ffd5b346105af575f3660031901126105af5760206001600160401b0360045416604051908152f35b346105af5761582836610625565b61583061870f565b6158398361867c565b600281015461584c9060101c60ff161590565b615b6c575f54615864906001600160a01b0316610ff0565b60405163eb47353360e01b8152336004820152909190602081602481865afa908115611363575f91615b4d575b5015615b3a576001600160401b036158c161087d336108ca896001600160401b03165f52600760205260405f2090565b16615b1a5760405163d775cb6160e01b8152602081600481865afa8015611363576001915f91615afb575b509101805490926001600160a01b039091169182615a74575b60405163f46913bb60e01b815233600482015260248101829052602081604481865afa908115611363575f91615a55575b50156112e657507fa9cf99c4c75bf0874576e6ee70b00b920e9c36551e4d6c17694ecaa684624d2b93610744939092615a1092506001600160a01b038116615a28575b506159e26001600160401b0342166159b0615992612757565b6001600160401b0383168152915b6001600160401b03166020830152565b60016040820152600160608201526159dd336108ca8b6001600160401b03165f52600760205260405f2090565b617752565b615a013361117a896001600160401b03165f52600860205260405f2090565b50610918611191825460e01c90565b6040519182916001600160401b0333971695836167f1565b6040516333bc9e6360e11b6020820152615a4f916121218261098c888c3360248501617730565b5f615979565b615a6e915060203d6020116112df576112d08183612736565b5f615936565b60046040615a8a6001600160a01b038616610ff0565b8151632a6e736160e11b815292839182905afa90815f915f93615ad8575b50615ab5575b5050615905565b1580615acf575b615ac7575b80615aae565b90505f615ac1565b50801515615abc565b909250615af4915060403d604011611417576114088183612736565b915f615aa8565b615b14915060203d60201161135c5761134d8183612736565b5f6158ec565b639ec4e30d60e01b5f526001600160401b0385166004523360245260445ffd5b6371ab6ad560e11b5f523360045260245ffd5b615b66915060203d6020116112df576112d08183612736565b5f615891565b63210eb4ed60e11b5f526001600160401b03841660045260245ffd5b346105af5760203660031901126105af57600435615ba5816105b3565b615bad618736565b615bb6816198dc565b60028101546001607082901c60ff16615bce816122e3565b036140a65760019060681c60ff16615be5816122e3565b0361143d5760018101805490926001600160401b03604083901c168015159081615e37575b50615e1c5790600191615c506121cc615c2d61214787546001600160401b031690565b6121c7615c4460028301546001600160401b031690565b96879201549560c01c90565b4210615e0d57615c71816001600160401b03165f52601460205260405f2090565b6001810154838110615df65750615c8b83615caa9261be0a565b86546001600160c01b03164260c01b6001600160c01b03191617909655565b615ccd615cc8826001600160401b03165f52601260205260405f2090565b61bb33565b91615cd883516168ca565b935f965f975b8551891015615d7c57615d74600191615d5c615d49615d418a615d2d8f615d2090615d1a8e6001600160401b03165f52601160205260405f2090565b93616932565b516001600160a01b031690565b60018060a01b03165f5260205260405f2090565b5461ffff1690565b615d538d8c616932565b9061ffff169052565b6150ad611c43615d6c8d8c616932565b5161ffff1690565b980197615cde565b7f24dc485bef04b4d790d97ac10381d8d9e66c56dd6fba9931b703ca169511778a966001600160401b039685615dc794615dc1615deb989c546001600160401b031690565b8961b7c8565b6040519384931695839092916001600160401b036020916040840195845216910152565b0390a261001861876e565b63039ff3b160e41b5f52600484905260245260445ffd5b631ab7da6b60e01b5f5260045ffd5b637c3e621b60e01b5f526001600160401b031660045260245ffd5b615e4f91506121cc906001600160401b038516616fa3565b42115f615c0a565b346105af575f3660031901126105af57602080546040516001600160a01b039091168152f35b346105af5760403660031901126105af57610018602435600435615ea082610aaf565b615eac611a6b82616d69565b61a2cd565b346105af57615ebf36613e99565b615ec7618736565b5f905f928115615f6e575f5b828110615ee557505050614c1561876e565b615f02615ef38285856174ee565b35615efd816105b3565b61abaa565b615f0f575b600101615ed3565b9392615f66615f606001926001600160401b03615f2d8988886174ee565b35615f37816105b3565b165f52601060205283615f5861214760405f206001600160401b0390541690565b0154906175c0565b946174fe565b949050615f07565b631f2a200560e01b5f5260045ffd5b346105af57615f8b36610625565b615fa961086b846001600160401b03165f52600760205260405f2090565b6001600160401b03615fc282546001600160401b031690565b1615616076577f8547e94bd95ca7d3c7a3be9b66a29e6f36151be54a2563e35098438861a4c87191616001610744926001600160401b034216906167a9565b6160216001612bf9876001600160401b03165f52600560205260405f2090565b6001600160a01b038116616049575b506040519182916001600160401b0333971695836167f1565b604051637ac7103360e11b60208201526160709161099a8261098c868a3360248501617730565b5f616030565b639bcccbfd60e01b5f526001600160401b0384166004523360245260445ffd5b346105af576160a436610625565b6001600160a01b036160b58461867c565b5416330361610757907f30fc45e05a33fd9068cf6ae1a8f3db2b9d15372dd6494eccc8cd5d305fdf38b3916001600160401b036160ff6040519384936020855260208501916167d1565b9416930390a2005b6001600160401b038363234e071d60e01b5f52166004523360245260445ffd5b346105af575f3660031901126105af5760206040517f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a8152f35b346105af5760403660031901126105af576004356001600160401b0381116105af576161919036906004016105f8565b5050610bbd6024356161a281610aaf565b6161aa61870f565b6004546001600160401b0316906161c3613847836168ad565b6139096161ce612785565b3381526001600160a01b0383166020820152426001600160401b031660408201525f60608201525f60808201525f60a08201526138c660c0820160019052565b346105af5760203660031901126105af576001600160401b03600435616233816105b3565b61623b6172d3565b50165f526014602052610bbd60405f2060036040519161625a836126ae565b80546001600160a01b0316808452600182015460208086019182526002840154604080880191825295909401546060968701908152855193845291519083015291519281019290925251918101919091529081906080820190565b9181601f840112156105af578235916001600160401b0383116105af576020808501948460071b0101116105af57565b6101003660031901126105af576162fa6105c4565b6024356001600160401b0381116105af57616319903690600401610a7f565b916044356001600160401b0381116105af576163399036906004016162b5565b9290936064356001600160401b0381116105af5761635b9036906004016105f8565b949095608435956001600160401b0387116105af57610bbd97616385610ba3983690600401610a7f565b9490936163906105d3565b96616399610ac0565b9860e4359a6177c3565b600411156122d157565b906122e0826163a3565b610160610120610be693602084526163db6020850182516001600160401b03169052565b60208101516001600160a01b0316604085015260408101516001600160a01b0316606085015260608101516080850152608081015160a085015260a081015160c085015261643960c082015160e08601906001600160401b03169052565b60e08101516001600160401b031661010085015261645f610100820151838601906163ad565b015191610140808201520190614b6b565b346105af5760203660031901126105af576001600160401b03600435616495816105b3565b60606101206040516164a6816126e4565b5f81525f60208201525f60408201525f838201525f60808201525f60a08201525f60c08201525f60e08201525f6101008201520152165f52601d602052610bbd60405f206165bb60066164f76127a3565b926165306165208254612453616513826001600160401b031690565b6001600160401b03168852565b6001600160a01b03166020860152565b60018101546001600160a01b031660408501526002810154606085015260038101546080850152600481015460a08501526165b56165ab600583015461658f61657f826001600160401b031690565b6001600160401b031660c0890152565b6001600160401b03604082901c1660e088015260801c60ff1690565b6101008601617b14565b01617b1d565b610120820152604051918291826163b7565b346105af5760203660031901126105af576004356165ea81610aaf565b6165f2618736565b6165fc813361a3c0565b90816166155760015f8051602061c92783398151915255005b6040519182526001600160a01b03169033907f9310ccfcb8de723f578a9e4282ea9f521f05ae40dc08f3068dfad528a65ee3c790602090a35f8061226c565b60a03660031901126105af5760043561666c816105b3565b6024356001600160401b0381116105af5761668b903690600401610a7f565b90916044356001600160401b0381116105af576166ac9036906004016105f8565b929093606435936001600160401b0385116105af57610bbd956166d6610ba3963690600401610a7f565b949093608435966166e6886105b3565b617bbb565b346105af5760203660031901126105af5760043561670881610aaf565b616710618ee5565b6001600160a01b03168015613db6576001600160601b0360a01b60015416176001555f80f35b346105af575f3660031901126105af5760206040517f189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e38152f35b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b63ffffffff1680156150d8575f190190565b9067ffffffffffffffff60401b82549160401b169067ffffffffffffffff60401b1916179055565b908060209392818452848401375f828201840152601f01601f1916010190565b916020610be69381815201916167d1565b9b9a999897969594939b61681461870f565b61681c618736565b8c8303614b485761682c8d616896565b9361683a6040519586612736565b8d8552602085019d60051b8101903682116105af579d818f5b106168795750506168659b9c506189c0565b60015f8051602061c9278339815191525590565b60208f9181923561688981610eb6565b8152019e019d818f616853565b6001600160401b0381116126a95760051b60200190565b6001600160401b03166001600160401b0381146150d85760010190565b906168d482616896565b6168e16040519182612736565b82815280926168f2601f1991616896565b0190602036910137565b634e487b7160e01b5f52603260045260245ffd5b80511561691d5760200190565b6168fc565b80516001101561691d5760400190565b805182101561691d5760209160051b010190565b909161695061870f565b616958618736565b61696182619078565b90616974600483015460ff9060481c1690565b613190575f935f5b616997856001600160401b03165f52600a60205260405f2090565b54811015616c1a57610ff06169c4612fcc83612fc7896001600160401b03165f52600a60205260405f2090565b146169d15760010161697c565b50909192935060015b156112a757616a016115e2336108ca876001600160401b03165f52600c60205260405f2090565b616bfa57616a20846001600160401b03165f52600e60205260405f2090565b82828254616be9575b5050505f5b828110616bad5750616a58611625336108ca876001600160401b03165f52600c60205260405f2090565b616ad76115396001850194616a9b616a7b611191885463ffffffff9060a01c1690565b875463ffffffff60a01b191660a09190911b63ffffffff60a01b16178755565b336001600160401b0388167fceda1a44ead4da3d3abaaa941afa6d9530fd84dd8e99385c9183d986dcab980f5f80a3546001600160401b031690565b918015616b9e57616afe611c6a614e2e6040616af8600195616b0d97616c39565b01616c95565b9201546001600160a01b031690565b906001600160a01b038216616b57575b50505463ffffffff616b376130fa60a084901c83166130ed565b911614616b48575b506105d161876e565b616b51906192f7565b5f616b3f565b604051632c567acd60e21b60208201523360248201526001600160401b038516604482015260ff9091166064820152616b979161099a826084810161098c565b5f80616b1d565b5050616b0d6001606492612bf9565b600190616be3616bd2336108ca896001600160401b03165f52600f60205260405f2090565b616bdd838787616c42565b90616c9f565b01616a2e565b616bf2926190b2565b5f8282616a29565b630f2bb0f160e41b5f526001600160401b0384166004523360245260445ffd5b50909192936169da565b805482101561691d575f5260205f2001905f90565b901561691d5790565b919081101561691d576060020190565b805482101561691d575f5260205f209060011b01905f90565b600211156105af57565b604435610be681616c6b565b35610be681616c6b565b35610be681610aaf565b35610be681610eb6565b8054600160401b8110156126a957616cbc91600182018155616c52565b616d395760016040836105d19435616cd381616c6b565b616cdc816122c7565b60ff80198654169116178455616d1b6020820135616cf981610aaf565b8554610100600160a81b03191660089190911b610100600160a81b0316178555565b013591616d2783610eb6565b019061ffff1661ffff19825416179055565b616770565b63ffffffff1663ffffffff81146150d85760010190565b634e487b7160e01b5f52601260045260245ffd5b5f525f8051602061c8e7833981519152602052600160405f20015490565b908160209103126105af575190565b6040513d5f823e3d90fd5b91908260409103126105af5760208251616dba816139b7565b92015190565b908160209103126105af5751610be6816139b7565b90600182811c92168015616e03575b6020831014616def57565b634e487b7160e01b5f52602260045260245ffd5b91607f1691616de4565b6001600160401b03918216815260ff909216602083015290911660408201526001600160a01b03909116606082015260c06080820152815494935f939092909190616e5787616dd5565b968760c08401526001811690815f14616ec55750600114616e87575b50610be694955060a08185039101526167d1565b9093505f5260205f205f905b868210616eae57509394508493830160e00192610be6616e73565b6001816020925460e0858901015201910190616e93565b905060e0929550610be69697915060ff191682860152151560051b840101928594616e73565b63ffffffff8116036105af57565b908160209103126105af5751610be681616eeb565b908160209103126105af5751610be681610aaf565b9061271082029180830461271014901517156150d857565b906006820291808304600614901517156150d857565b818102929181159184041417156150d857565b8115616f6e570490565b616d55565b91616f9c60ff916001600160401b03604094979697168552606060208601526060850190614b6b565b9416910152565b906001600160401b03809116911601906001600160401b0382116150d857565b815181546020840151610100600160a81b0360089190911b1660ff9092166001600160a81b0319909116171781556105d1916003906170639060a0906040810151855467ffffffffffffffff60a81b191660a89190911b67ffffffffffffffff60a81b1617855560608101516170529063ffffffff16600187019063ffffffff1663ffffffff19825416179055565b608081015160028601550151151590565b91019060ff801983541691151516179055565b9161708f9183549060031b91821b915f19901b19161790565b9055565b601f82116170a057505050565b5f5260205f20906020601f840160051c830193106170d8575b601f0160051c01905b8181106170cd575050565b5f81556001016170c2565b90915081906170b9565b9092916001600160401b0381116126a957617107816171018454616dd5565b84617093565b5f601f821160011461714157819061708f9394955f92617136575b50508160011b915f199060031b1c19161790565b013590505f80617122565b601f19821694617154845f5260205f2090565b915f5b87811061718e575083600195969710617175575b505050811b019055565b01355f19600384901b60f8161c191690555f808061716b565b90926020600181928686013581550194019101617157565b90610be6959360ff6080946001600160401b03809416855216602084015216604082015281606082015201916167d1565b610be6949260ff60609316825260018060a01b0316602082015281604082015201916167d1565b6040519061018082018281106001600160401b038211176126a9576040525f610160838281528260208201528260408201528260608201528260808201528260a08201528260c08201528260e08201528261010082015282610120820152826101408201520152565b6122e0826122c7565b6122e0826122e3565b604051906172868261268e565b5f60c0838281528260208201528260408201528260608201528260808201528260a08201520152565b906172b9816122e3565b815460ff60701b191660709190911b60ff60701b16179055565b604051906172e0826126ae565b5f6060838281528260208201528260408201520152565b60643560038110156105af5790565b90617310816122c7565b60ff80198354169116179055565b90617328816122e3565b61ff0082549160081b169061ff001916179055565b815181546001600160a01b0319166001600160a01b03919091161781556105d191906174069060c09060029060208501516001820180546001600160a01b0319166001600160a01b03929092169190911781556173cf906040870151815467ffffffffffffffff60a01b191660a09190911b67ffffffffffffffff60a01b16178155606087015163ffffffff16610918565b01926173e860808201516173e2816122c7565b85617306565b6173ff60a08201516173f9816122e3565b8561731e565b0151151590565b815462ff0000191690151560101b62ff000016179055565b35610be6816105b3565b61743d60443561743781616c6b565b82617306565b60643560038110156105af57617453908261731e565b60843561745f81616eeb565b65ffffffff000082549160101b169065ffffffff000019161781556174af60a43561748981616eeb565b825469ffffffff000000000000191660309190911b69ffffffff00000000000016178255565b60c43560018201556174e36174c460e461741e565b60028301906001600160401b03166001600160401b0319825416179055565b600361010435910155565b919081101561691d5760051b0190565b5f1981146150d85760010190565b5f198101919082116150d857565b919082039182116150d857565b9998979695949392919061753961870f565b617541618736565b61754a826168ca565b9a5f5b8381106175625750906168659a9b92916189c0565b806127106175738f93600194616932565b520161754d565b90600182018092116150d857565b90600282018092116150d857565b90600382018092116150d857565b90600482018092116150d857565b90600582018092116150d857565b919082018092116150d857565b919081101561691d5760051b81013590601e19813603018212156105af5701908135916001600160401b0383116105af5760200182360381136105af579190565b61ffff60043561761d81610eb6565b1661ffff19600254161760025560243561763681610eb6565b63ffff00006002549160101b169063ffff000019161760025560443561765b81610eb6565b65ffff000000006002549160201b169065ffff0000000019161760025560643561768481610eb6565b67ffff0000000000006002549160301b169067ffff000000000000191617600255565b91908260409103126105af57602082516176c081610eb6565b920151610be681611e5e565b9360e0956001600160401b0360409560ff60809b96839b9e9d9b61770b97168a52166020890152168587015261016060608701526101608601916167d1565b978684015260a08301370137565b604090610be69492815281602082015201916167d1565b6001600160a01b039091168152604060208201819052610be6939101916167d1565b8151815467ffffffffffffffff19166001600160401b0391909116178155906177886001600160401b03602083015116836167a9565b6040810151825460ff60801b191690151560801b60ff60801b161760609091015160ff60881b1990911690151560881b60ff60881b16179055565b98929993959b9a949b9791979690966177da61870f565b6177e2618736565b8615617940575f5b878c8183106178d1575050506177ff896168ca565b9c5f5b8a81106178b357508a9b9c9d8a8a61781c9a9b9c9d6189c0565b945f5b82811061787b5750907fe9b9d941d31762ebeb7a00008b4cf95e9a19255cb6695c9d35215c914a7e8486916178706040519283926001600160401b03339916976001600160401b038b169785617a6c565b0390a4610be661876e565b6001906178ad61789c896001600160401b03165f52600e60205260405f2090565b6178a783878761794f565b9061795f565b0161781f565b808f6178c46001936178cb92616932565b6127109052565b01617802565b6178dc91839161794f565b604081016178ec611c4382616c95565b15617931576178fc606091616c95565b91019061ffff61790e611c4384616c95565b91161161793157617924611c4361271092616c95565b11617931576001016177ea565b636923afcf60e01b5f5260045ffd5b6340eb7eb560e11b5f5260045ffd5b919081101561691d5760071b0190565b8054600160401b8110156126a95761797c91600182018155616c52565b919091616d3957606060016105d193833561799681616c6b565b61799f816122c7565b60ff801983541691161781556179de60208501356179bc81610aaf565b8254610100600160a81b03191660089190911b610100600160a81b0316178255565b0191617a0360408201356179f181610eb6565b845461ffff191661ffff909116178455565b013590617a0f82610eb6565b9063ffff000082549160101b169063ffff00001916179055565b916020908281520191905f5b818110617a425750505090565b9091926020806001928635617a5681610aaf565b848060a01b031681520194019101919091617a35565b90617a8590602093959495604084526040840191617a29565b90828183039101528281520191905f5b818110617aa25750505090565b9091926080806001928635617ab681616c6b565b617abf816122c7565b81526020870135617acf81610aaf565b848060a01b0316602082015261ffff6040880135617aec81610eb6565b16604082015261ffff6060880135617b0381610eb6565b166060820152019401929101617a95565b6122e0826163a3565b9060405191825f825492617b3084616dd5565b8084529360018116908115617b995750600114617b55575b506105d192500383612736565b90505f9291925260205f20905f915b818310617b7d5750509060206105d1928201015f617b48565b6020919350806001915483858901015201910190918492617b64565b9050602092506105d194915060ff191682840152151560051b8201015f617b48565b969095979392949197617bcc61870f565b617bd4618736565b617bdd8861867c565b9860028a0197617bf561158a8a5460ff9060101c1690565b61814157617c12848b600354617c0c368787618219565b9061ad40565b9990985f5b8b51811015617c9557617c4e6121cc61087d8f8f90615d2086615d1a615d2d936001600160401b03165f52600760205260405f2090565b15617c5b57600101617c17565b8c617c6c615d20610765938f616932565b639bcccbfd60e01b5f526001600160401b039091166004526001600160a01b0316602452604490565b5090919293949596989b6001909b9a989b0198617cb88a5460018060a01b031690565b6001600160a01b038116151580618138575b6180b1575b508c3410618099578694928d8a99979593617d3a9e9f99938e948c8f617d0490863411618087575b546001600160a01b031690565b926001600160a01b038416618053575b505050505050617d67617d336004546001600160401b039060801c1690565b9d8e6168ad565b6004805467ffffffffffffffff60801b191660809290921b67ffffffffffffffff60801b16919091179055565b617d82826001600160401b03165f52600660205260405f2090565b6001600160401b03421691617d9b8b5163ffffffff1690565b915463ffffffff601082901c168015618047579060301c63ffffffff165b91549260ff84169360081c60ff1694617dd0612775565b6001600160401b0390971687523360208801526001600160401b03811660408801526001600160401b038b1660608801525f60808801526001600160401b031660a087015263ffffffff1660c086015263ffffffff1660e085015263ffffffff16610100840152617e45906101208401617267565b617e53906101408301617270565b6001610160820152617e768c6001600160401b03165f52601060205260405f2090565b90617e8091618435565b8651617e8b906168ca565b97617e989289928d61af6d565b9633617eb58b6001600160401b03165f52601360205260405f2090565b90617ebf91619916565b505f5b82811061800b5750617f1e906001600160401b038a165f6001600160401b038d167f741e97ee1ff887c4d882f4c49ad280ea7d61d035e4e8a471e5319515502750238280a48054617cf79033906001600160a01b03168d61b0d9565b926001600160a01b038416617f59575b5050505080617f45575b5050505050610be661876e565b617f4f948661b556565b5f80808080617f38565b91818993617f6f617f6a8d9561757a565b6168ca565b91617f8c33617f7d85616910565b6001600160a01b039091169052565b5f5b818110617fcc575050509161098c61099a92617fc396946040519687946320a87b3960e21b6020870152339160248701618613565b5f808080617f2e565b9092945081939550617ffe617fec617fe783866001966174ee565b616c8b565b617f7d617ff88461757a565b88616932565b01918b93918b9593617f8e565b60019061804061802c8d6001600160401b03165f52601360205260405f2090565b61803a617fe784888b6174ee565b90619916565b5001617ec2565b50617db9600191612ad1565b61807c956121219361098c926040519788956361466c0960e11b60208801523360248801618362565b875f80888c82617d14565b618094614092883461751a565b617cf7565b639a6ae60d60e01b5f5260048d90523460245260445ffd5b6180c3906001600160a01b0316610ff0565b60405163e390fcdb60e01b81525f60048201819052602482015290602090829060449082905afa5f9181618117575b5015617ccf5715618103575f617ccf565b63094403b760e41b5f90815260045260245ffd5b61813191925060203d6020116112df576112d08183612736565b905f6180f2565b508d1515617cca565b63210eb4ed60e11b5f526001600160401b038a1660045260245ffd5b81601f820112156105af5780359061817482616896565b926181826040519485612736565b828452602060608186019402830101918183116105af57602001925b8284106181ac575050505090565b838203606081126105af5760408051916181c583612700565b126105af576060916020916040516181dc81612700565b87356181e781616c6b565b8152838801356181f681610aaf565b848201528152604087013561820a81610eb6565b8382015281520193019261819e565b9291909261822684616896565b936182346040519586612736565b602085828152019060051b8201918383116105af5780915b83831061825a575050505050565b82356001600160401b0381116105af578201906060828703126105af57604051906182848261271b565b82356001600160401b0381116105af57830160c0818903126105af57604051906182ad826126c9565b80356182b8816105b3565b82526182c6602082016105ed565b6020830152604081013560408301526182e1606082016105ed565b60608301526182f2608082016105ed565b608083015260a0810135906001600160401b0382116105af57618317918a910161815d565b60a082015282526020830135916001600160401b0383116105af576183526040856183488b60209897899801612821565b8685015201610ada565b604082015281520192019161824c565b9260c09461839b6001600160401b03946183a9949a99989a5f885260018060a01b0316602088015260e0604088015260e08701906150dd565b9185830360608701526167d1565b951660808201525f60a08201520152565b805468010000000000000000600160e01b03191660409290921b68010000000000000000600160e01b0316919091179055565b906183f7816122c7565b815460ff60601b191660609190911b60ff60601b16179055565b9061841b816122e3565b815460ff60681b191660689190911b60ff60681b16179055565b9061016060026105d19361847061845385516001600160401b031690565b825467ffffffffffffffff19166001600160401b03909116178255565b6020840151618489906001600160a01b03165b826183ba565b618531600182016184a761845360408801516001600160401b031690565b6184c46184be60608801516001600160401b031690565b826167a9565b6185036184db60808801516001600160401b031690565b825467ffffffffffffffff60801b191660809190911b67ffffffffffffffff60801b16178255565b60a08601516001600160401b031681546001600160c01b031660c09190911b6001600160c01b031916179055565b019161855d61854760c083015163ffffffff1690565b845463ffffffff191663ffffffff909116178455565b61859361857160e083015163ffffffff1690565b845467ffffffff00000000191660209190911b67ffffffff0000000016178455565b6185d26185a861010083015163ffffffff1690565b84546bffffffff0000000000000000191660409190911b6bffffffff000000000000000016178455565b6185ea6101208201516185e4816122c7565b846183ed565b6186026101408201516185fc816122e3565b84618411565b01519061860e826122e3565b6172af565b9360a0936001600160401b03809481616f9c959a999a1688525f6020890152166040870152600180861b0316606086015260c0608086015260c08501906150dd565b9061708f90618663816163a3565b825460ff60801b191660809190911b60ff60801b161790565b6001600160401b0380600454169116908110156186a1575f52600560205260405f2090565b6317f4923b60e21b5f5260045260245ffd5b3d156186dd573d906186c4826127d0565b916186d26040519384612736565b82523d5f602084013e565b606090565b5f91829182602083519301915af1506186f96186b3565b50565b610be6916001600160a01b03169061b3dc565b60ff5f8051602061c907833981519152541661872757565b63d93c066560e01b5f5260045ffd5b60025f8051602061c927833981519152541461875f5760025f8051602061c92783398151915255565b633ee5aeb560e01b5f5260045ffd5b60015f8051602061c92783398151915255565b906188fb61016060046105d1946187a261845386516001600160401b031690565b60208501516187b9906001600160a01b0316618483565b61884d600182016187d761845360408901516001600160401b031690565b6187ee6184be60608901516001600160401b031690565b618822618802608089015163ffffffff1690565b825463ffffffff60801b191660809190911b63ffffffff60801b16178255565b60a087015163ffffffff16815463ffffffff60a01b191660a09190911b63ffffffff60a01b16179055565b60c08501516002820180546001600160a01b0319166001600160a01b0390921691909117905560e0850151600382015501926188916101008201516173e2816122c7565b6188c26188a661012083015163ffffffff1690565b855464ffffffff00191660089190911b64ffffffff0016178555565b6173ff6188d761014083015163ffffffff1690565b855468ffffffff0000000000191660289190911b68ffffffff000000000016178555565b815469ff000000000000000000191690151560481b60ff60481b16179055565b8054600160401b8110156126a95761893891600182018155616c24565b81546001600160a01b0393841660039290921b91821b9390911b1916919091179055565b95906189a7936001600160401b039560c0999c9b9a97948761899994168a5260018060a01b031660208a015260e060408a015260e0890191617a29565b9186830360608801526167d1565b961660808301526001600160a01b031660a08201520152565b979094969a9992939891958615618e8c5761158a9b6189de8a61867c565b6189f2600282019e8f5460ff9060101c1690565b618e705760010180549092906001600160a01b031680151580618e67575b618dd0575b505f5b888c8b808410618d6c5750505050618a3134878761a1f3565b60045460401c6001600160401b031696618a76618a4d896168ad565b67ffffffffffffffff60401b6004549160401b169067ffffffffffffffff60401b191617600455565b879e618a938d6001600160401b03165f52600660205260405f2090565b5463ffffffff601082901c16908115618d6557815b8d63ffffffff821611618d46575060301c63ffffffff169163ffffffff83168015159081618d3c575b50618d1d57548e92919060ff169063ffffffff811615618d1457905b618af5612775565b6001600160401b0390941684523360208501526001600160401b03421660408501526001600160401b03891660608501528d63ffffffff1660808501525f60a08501526001600160a01b038a1660c08501528a60e0850152610100840190618b5c91617267565b63ffffffff1661012083015263ffffffff1661014082015261016081015f9052618b97896001600160401b03165f52600960205260405f2090565b90618ba191618781565b895f5b8a8a838310618c985750505050505f5b828110618c5d57505050618c0c90604051996001600160401b033391166001600160401b0388167fbd1fdda393b679e6c4f873e233b34e2c4ea8283a3f76345dbc143b86ea0476795f80a4546001600160a01b031690565b966001600160a01b038816618c28575b50505050505050505050565b6361466c0960e11b60208a0152618c4e99612121978a9761098c97339060248b0161895c565b5f808080808080808080618c1c565b600190618c92618c7e8a6001600160401b03165f52600d60205260405f2090565b618c8c617fe78488886174ee565b9061891b565b01618bb4565b618cfb82615d2d617fe78688614a7f618ce3615d6c848e618cde60019f9d618c8c618d0c9f8f617fe791614a7f88926001600160401b03165f52600a60205260405f2090565b616932565b976001600160401b03165f52600b60205260405f2090565b9061ffff1661ffff19825416179055565b018a90618ba4565b50600190618aed565b631f8cfa3960e21b5f5263ffffffff8084166004528d1660245260445ffd5b90508d115f618ad1565b63eb8e175d60e01b5f5263ffffffff9081166004528d1660245260445ffd5b6001618aa8565b618d9992615d2d617fe78661087d94614a7f6121cc976001600160401b03165f52600760205260405f2090565b15618dbe57612710618db1611c43615d6c848c616932565b1161143d57600101618a18565b8b617c6c617fe7610765938d8d6174ee565b618de2906001600160a01b0316610ff0565b60405163e390fcdb60e01b81525f60048201526001600160a01b038716602482015290602090829060449082905afa5f9181618e46575b5015618a155715618e2a575f618a15565b63094403b760e41b5f526001600160a01b03851660045260245ffd5b618e6091925060203d6020116112df576112d08183612736565b905f618e19565b50861515618a10565b63210eb4ed60e11b5f526001600160401b038b1660045260245ffd5b63ddf9d24560e01b5f5260045ffd5b6005015460ff8160801c16618eaf816163a3565b60018114618edf57618ec0816163a3565b159081618ecb575090565b6001600160401b03915060401c1642101590565b50505f90565b335f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c602052604090205460ff1615618f1d57565b63e2517d3f60e01b5f52336004527fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c2177560245260445ffd5b335f9081527f75442b0a96088b5456bc4ed01394c96a4feec0f883c9494257d76b96ab1c9b6b602052604090205460ff1615618f8c57565b63e2517d3f60e01b5f52336004527f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a60245260445ffd5b335f9081527fab71e3f32666744d246edff3f96e4bdafee2e9867098cdd118a979a7464786a8602052604090205460ff1615618ffb57565b63e2517d3f60e01b5f52336004527f189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e360245260445ffd5b5f8181525f8051602061c8e78339815191526020908152604080832033845290915290205460ff16156190625750565b63e2517d3f60e01b5f523360045260245260445ffd5b6001600160401b038060045460401c169116908110156190a0575f52600960205260405f2090565b63123616b360e11b5f5260045260245ffd5b9190915f5b815481101561925b576190ca8183616c52565b5080546001600160a01b03600882901c16915f91839190835b888a81831061911c575b5050505050501561910157506001016190b7565b6310c8eb2160e31b5f526001600160a01b031660045260245ffd5b610ff0602061913085899561913695616c42565b01616c8b565b148061922a575b619149576001016190e3565b925050915060016191606040616af8848a8c616c42565b9201549161ffff808416911681116191ec57506191916191866040616af8848a8c616c42565b9260101c61ffff1690565b9161ffff8084169116116191ae57505060015f808080888a6190ed565b916191c26040616af861076595898b616c42565b636d1000b760e01b5f526001600160a01b0390911660045261ffff90811660245216604452606490565b836192006040616af8610765958b8d616c42565b6394f47ccb60e01b5f526001600160a01b0390911660045261ffff90811660245216604452606490565b5061923e619239828b8d616c42565b616c81565b60ff83169061924c826122c7565b619255816122c7565b1461913d565b50505050565b90604051918281549182825260208201905f5260205f20925f5b8181106192905750506105d192500383612736565b84546001600160a01b031683526001948501948794506020909301920161927b565b9490936001600160401b03809481616f9c958160a0999c9b9c168a52166020890152166040870152600180861b0316606086015260c0608086015260c08501906150dd565b619312816001600160401b03165f52600960205260405f2090565b60045490919060801c6001600160401b03169061932e826168ad565b6004805467ffffffffffffffff60801b191660809290921b67ffffffffffffffff60801b169190911790558254906001600160401b03821690619382826001600160401b03165f52600560205260405f2090565b9261939e836001600160401b03165f52600660205260405f2090565b5060401c6001600160a01b031694426001600160401b03169360018201938454976193d3896001600160401b039060401c1690565b9860801c63ffffffff166004850154600881901c63ffffffff16602882901c63ffffffff169160ff1692600287019c8d546194129060ff9060081c1690565b9561941b612775565b6001600160401b0390981688526001600160a01b031660208801526001600160401b038c1660408801526001600160401b031660608701525f60808701526001600160401b038b1660a087015263ffffffff1660c086015263ffffffff1660e085015263ffffffff16610100840152619498906101208401617267565b6194a6906101408301617270565b60016101608201526194c9876001600160401b03165f52601060205260405f2090565b906194d391618435565b5f976194f0846001600160401b03165f52600a60205260405f2090565b6194f990619261565b928351619505906168ca565b955f9a5b85518c10156195d7576195cf60019161ffff8e6195c76108ca8f8f908f8f928f6195b092615d53619564615d4161117a9861954a615d208e61956c98616932565b9a8b916001600160401b03165f52600b60205260405f2090565b998a92616932565b619584619577612757565b61ffff89168152916159a0565b5f6040820152600160608201526110d9856108ca856001600160401b03165f52601160205260405f2090565b6001600160401b03165f52601260205260405f2090565b5016906175c0565b9b019a619509565b939991969297509499506196126195ff896001600160401b03165f52601360205260405f2090565b875460401c6001600160a01b031661803a565b505f5b6196308b6001600160401b03165f52600d60205260405f2090565b5481101561969957806196928c61803a61967d600195612fc78f619665906001600160401b03165f52601360205260405f2090565b946001600160401b03165f52600d60205260405f2090565b905460039190911b1c6001600160a01b031690565b5001619615565b509061972a6196cd9493926197206001899c8e9b9e8d6001600160401b03808061976b9e9f549d8e6001600160401b031690565b16931691167f741e97ee1ff887c4d882f4c49ad280ea7d61d035e4e8a471e5319515502750235f80a4018054909790619719906001600160a01b03169160401c6001600160a01b031690565b908c61b0d9565b5460081c60ff1690565b92619734846122e3565b8315806198cf575b1561988a578954617cf794506001600160401b031660028b01546001600160a01b031660038c0154918b61b7c8565b906001600160a01b038216619782575b5050505050565b6197ad617f6a6197a785969798956001600160401b03165f52600d60205260405f2090565b5461757a565b955494604086901c6001600160a01b03166197cb81617f7d8a616910565b5f5b6197e8876001600160401b03165f52600d60205260405f2090565b54811015619830578061982a61981861967d600194612fc78c6001600160401b03165f52600d60205260405f2090565b617f7d6198248461757a565b8d616932565b016197cd565b509061099a93949761098c926198636198526198809a6001600160401b031690565b955460401c6001600160401b031690565b926040519889966320a87b3960e21b6020890152602488016192b2565b5f8080808061977b565b505050806198996001926122e3565b14806198c2575b15617cf75760028601546003870154618094916001600160a01b03168761b48c565b50600386015415156198a0565b5060038a0154151561973c565b6001600160401b038060045460801c16911690811015619904575f52601060205260405f2090565b63645145db60e11b5f5260045260245ffd5b610be6916001600160a01b03169061ba1b565b6001600160401b039081165f818152601560205260409020548383169493921684101561997757610be69293505f52601660205260405f20906001600160401b03165f5260205260405f2090565b83906325b1baff60e21b5f5260045260245260445ffd5b91906001600160401b03831691825f52601060205260405f20925f5260126020526199bb60405f2061bb33565b6199c581516168ca565b915f935f945b8351861015619a4757619a3f600191619a2f619a25615d416199fe8d6001600160401b03165f52601160205260405f2090565b619a088c8b616932565b878060a01b0390511660018060a01b03165f5260205260405f2090565b615d538a8a616932565b6150ad611c43615d6c8a8a616932565b9501946199cb565b94509095619a5f6105d196546001600160401b031690565b9061b556565b6001600160a01b0381165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff16619afc576001600160a01b03165f8181527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260408120805460ff191660011790553391905f8051602061c8878339815191528180a4600190565b505f90565b6001600160a01b0381165f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c602052604090205460ff16619afc576001600160a01b0381165f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c60205260409020805460ff1916600117905533906001600160a01b03167fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c217755f8051602061c8878339815191525f80a4600190565b6001600160a01b0381165f9081527f75442b0a96088b5456bc4ed01394c96a4feec0f883c9494257d76b96ab1c9b6b602052604090205460ff16619afc576001600160a01b0381165f9081527f75442b0a96088b5456bc4ed01394c96a4feec0f883c9494257d76b96ab1c9b6b60205260409020805460ff1916600117905533906001600160a01b03167f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a5f8051602061c8878339815191525f80a4600190565b6001600160a01b0381165f9081527fab71e3f32666744d246edff3f96e4bdafee2e9867098cdd118a979a7464786a8602052604090205460ff16619afc576001600160a01b0381165f9081527fab71e3f32666744d246edff3f96e4bdafee2e9867098cdd118a979a7464786a860205260409020805460ff1916600117905533906001600160a01b03167f189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e35f8051602061c8878339815191525f80a4600190565b6001600160a01b0381165f9081525f8051602061c947833981519152602052604090205460ff16619afc576001600160a01b0381165f9081525f8051602061c94783398151915260205260409020805460ff1916600117905533906001600160a01b03167f4c7070c6c19cc9b427b94fe5979ee0c573f8edd00d25591afe4c9510de9479ba5f8051602061c8878339815191525f80a4600190565b5f8181525f8051602061c8e7833981519152602090815260408083206001600160a01b038616845290915290205460ff16618edf575f8181525f8051602061c8e7833981519152602090815260408083206001600160a01b03861684529091529020805460ff1916600117905533916001600160a01b0316905f8051602061c8878339815191525f80a4600190565b91909182516001600160401b0381116126a957619e8f816171018454616dd5565b6020601f8211600114619ec957819061708f9394955f92619ebe5750508160011b915f199060031b1c19161790565b015190505f80617122565b601f19821690619edc845f5260205f2090565b915f5b818110619f1557509583600195969710619efd57505050811b019055565b01515f1960f88460031b161c191690555f808061716b565b9192602060018192868b015181550194019201619edf565b60066101206105d193619f67619f4a82516001600160401b031690565b855467ffffffffffffffff19166001600160401b03909116178555565b6020810151619f7f906001600160a01b0316856183ba565b60408101516001850180546001600160a01b0319166001600160a01b03909216919091179055606081015160028501556080810151600385015560a0810151600485015561a00d60058501619fe161845360c08501516001600160401b031690565b619ff86184be60e08501516001600160401b031690565b6101008301519061a008826163a3565b618655565b01519101619e6e565b95949092801561a1ba576001600160a01b038416948515613db65761a03b908261ba7e565b96871561a1ba5761a1b56001600160401b03927f29615b457f22e163cc4540327d70f35c1990a8ef0003e915ad170acb817ace3d948442169a61a08f61a089601c546001600160401b031690565b8d616fa3565b9261a17461a0a5601b546001600160401b031690565b9a61a0cf61a0b28d6168ad565b601b906001600160401b03166001600160401b0319825416179055565b61a12f8c9f61a0fc61a0df6127a3565b6001600160401b038c168152936001600160a01b03166020850152565b6001600160a01b038d1660408401528460608401528560808401528660a084015260c08301906001600160401b03169052565b6001600160401b03861660e08201525f61010082015261a14d614b57565b61012082015261a16f8c601d906001600160401b03165f5260205260405f2090565b619f2d565b604080516001600160a01b03909a168a5260208a019190915288015260608701526001600160401b03166080860152908216949091169290819060a0820190565b0390a4565b63c58d593560e01b5f5260045ffd5b801561a1ef5780821061a1da575050565b63b99e2ab760e01b5f5260045260245260445ffd5b5050565b811561a24e576001600160a01b03168061a213575080821061a1da575050565b6105d19250604051916323b872dd60e01b602084015233602484015230604484015260648301526064825261a249608483612736565b61c28f565b505050565b905f809160208151910182855af161a2696186b3565b901561a273575050565b805161a29a57506338e6074d60e11b5f9081526001600160a01b0391909116600452602490fd5b604080516303d4276160e11b81526001600160a01b0390931660048401526024830152819061565d906044830190614b6b565b5f8181525f8051602061c8e7833981519152602090815260408083206001600160a01b038616845290915290205460ff1615618edf575f8181525f8051602061c8e7833981519152602090815260408083206001600160a01b03861684529091529020805460ff1916905533916001600160a01b0316907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b9060018060a01b03821691825f52601960205260405f205f805260205260405f205492831561a3b9575f6105d1928592825260196020526040822082805260205281604081205561a73c565b505f925050565b6001600160a01b038181165f8181526019602090815260408083209487168352939052919091205493929190841561a424579184916105d1935f5260196020525f61a41e83604083209060018060a01b03165f5260205260405f2090565b5561a73c565b505f93505050565b91908115801561a444575b61a24e576105d19261a73c565b506001600160a01b0383161561a437565b919061a47383601d906001600160401b03165f5260205260405f2090565b805460401c6001600160a01b03161561a55e57600581018054608081901c60ff1661a49d816163a3565b61a5425761a4b69060401c6001600160401b03166121cc565b42101561a52657805460ff60801b1916600160801b1790557f0d4418cc07b1c81f56e2d1277f5d11c1b27ebac6cdacafccecd4add6742b4b0f916001600160401b039161a507908590600601619e6e565b61a52160405192839260018060a01b031696169482614b8f565b0390a3565b63337c2c0160e01b5f526001600160401b03851660045260245ffd5b63079769ad60e11b5f526001600160401b03861660045260245ffd5b63162e3fab60e21b5f526001600160401b03841660045260245ffd5b61a595906001600160401b03165f52601060205260405f2090565b60028101546001607082901c60ff1661a5ad816122e3565b03618edf5760019060681c60ff1661a5c4816122e3565b03619afc576001810154906001600160401b03604083901c16801515908161a63a575b50618edf5761a62b9161a625600261a61661a60f6121476121cc96546001600160401b031690565b9360c01c90565b9201546001600160401b031690565b90616fa3565b421061a63657600190565b5f90565b61a65291506121cc906001600160401b038516616fa3565b42115f61a5e7565b92909192831561925b578360028201938454155f1461a6b85782546001600160a01b0319166001600160a01b03821617835560019361a69a92909161a1f3565b018054908382018092116150d8575580549182018092116150d85755565b82549091506001600160a01b039081169082160361a6dd576001928561a69a9261a1f3565b6356e7ec5f60e01b5f5260045ffd5b8115801561a72b575b61a1ef575f918291829182916001600160a01b03165af161a7146186b3565b501561a71c57565b6307a4ced160e51b5f5260045ffd5b506001600160a01b0381161561a6f5565b908215801561a7ad575b61a24e576001600160a01b03168061a77457505f918291829182916001600160a01b03165af161a7146186b3565b60405163a9059cbb60e01b60208201526001600160a01b03909216602483015260448201929092526105d19161a249826064810161098c565b506001600160a01b0382161561a746565b91906001600160401b0383165f52601d60205260405f20928360018060a01b03815460401c161561a87f5761a7f561158a82618e9b565b61a8635760058101805460ff60801b1916600160811b17905554917f4a816e132712dbdfe6a363965e5bc68f8e283b999ae11afe294a3162973c38556001600160401b0361a844818616611b1b565b6040519384526001600160a01b0316948116931691806020810161a1b5565b63b48b095960e01b5f526001600160401b03821660045260245ffd5b63162e3fab60e21b5f526001600160401b03821660045260245ffd5b91909161a8a661bb7b565b6001600160a01b03811615801561a9db575b801561a9ca575b613db65761a95a9261a91b61a93d9261a8d661bb7b565b61a8de61bba6565b61a8e661bbda565b61a8ee61bb7b565b61a8f781619a65565b5061a90181619b01565b5061a90b81619bc2565b5061a91581619c83565b50619d44565b505f80546001600160a01b0319166001600160a01b0392909216919091179055565b60018060a01b03166001600160601b0360a01b6001541617600155565b61a99f61a965612757565b61138881526103e860208201526107d0604082018190526060909101526002805467ffffffffffffffff19166707d007d003e81388179055565b61a9c261a9bd61a9ad61a9ec565b309061a9b761aa15565b9061bbea565b600355565b6105d161bc5b565b506001600160a01b0382161561a8bf565b506001600160a01b0383161561a8b8565b6040519061a9fb604083612736565b600b82526a54616e676c6551756f746560a81b6020830152565b6040519061aa24604083612736565b60018252603160f81b6020830152565b93929161aa62600261aa57876001600160401b03165f52601060205260405f2090565b015463ffffffff1690565b9161aa81615cc8876001600160401b03165f52601260205260405f2090565b935f945f945f945f5b835181101561ab3c5761aabe61aaa3615d208387616932565b6108ca8d6001600160401b03165f52601160205260405f2090565b5460ff609082901c161561ab335760ff861660010361ab265761aae8611c4361aaef9261ffff1690565b80996175c0565b9760018088841c161461ab08575b506001905b0161aa8a565b61ab1f9061ab19600193999b6174fe565b9a6175c0565b969061aafd565b5061aaef600180996175c0565b5060019061ab02565b5097969594935097505060ff16155f1461ab9457505061ab6b61ffff63ffffffff61ab73939616941684616f51565b612710900490565b918215908161ab8a575b5061ab8457565b60019150565b905015155f61ab7d565b94509261ab73915061ab6b9061ffff1684616f51565b61abb661158a8261a57a565b619afc5761abd5816001600160401b03165f52601060205260405f2090565b9061abea61214783546001600160401b031690565b9061ac06816001600160401b03165f52601460205260405f2090565b906001830154918260018201541061ad37578261ac229161be0a565b6001850180546001600160c01b03164260c01b6001600160c01b0319161790559461ac61615cc8836001600160401b03165f52601260205260405f2090565b9261ac6c84516168ca565b945f975f985b86518a101561accc5761acc46001916150ad611c43615d6c8e6198248e615d538f8f615d418692615d2d615d2085615d1a61acbe966001600160401b03165f52601160205260405f2090565b92616932565b99019861ac72565b61ad2f94995061ad21907f24dc485bef04b4d790d97ac10381d8d9e66c56dd6fba9931b703ca169511778a986001600160401b0398866002969561ad1b615dc7999e546001600160401b031690565b8b61b7c8565b01546001600160401b031690565b0390a2600190565b50505050505f90565b939290919382511561aef25761ad5683516168ca565b905f935f945b815186101561aee85761ad6f8683616932565b51604081015f5b88811061aea257508151516001600160401b03166001600160401b038b166001600160401b0382160361ae7357508151602001516001600160401b03166001600160401b0388166001600160401b0382160361ae4457508151608001516001600160401b031642811061ae1b57509160408261ae0a61ae00600196615d2061ae13978b601e61be59565b617f7d8c8b616932565b510151906175c0565b95019461ad5c565b9051637bbe57e960e01b5f526001600160a01b03166004526001600160401b031660245260445ffd5b905163ad21cd6560e01b5f526001600160a01b03166004526001600160401b038088166024521660445260645ffd5b90516356fe61a360e11b5f526001600160a01b03166004526001600160401b03808b166024521660445260645ffd5b61aeaf615d208289616932565b82516001600160a01b039081169116811461aecd575060010161ad76565b630278791760e11b5f526001600160a01b031660045260245ffd5b9650505092915050565b633f6c27f960e01b5f5260045ffd5b919081101561691d5760051b81013590605e19813603018212156105af570190565b90359060be19813603018212156105af570190565b903590601e19813603018212156105af57018035906001600160401b0382116105af576020019160608202360383136105af57565b90929194935f905f966001600160401b034216925b855189101561b0915761b03a60019161ffff8b8a8a8a8a8a8a6127109561afc061afb661afb08a858561af01565b8061af23565b60a081019061af38565b905061b042575b505094615d1a61803a936195b0615d209461afea89615d53876195c79c9d616932565b61b00261aff5612757565b61ffff8c168152916159a0565b5f6040820152600160608201526110d961b02d846001600160401b03165f52601160205260405f2090565b615d2d615d20888c616932565b98019761af82565b6195c79650936195b0615d209461afea8a95615d5361b07d6040616af861b07761afb661afb061803a9f615d1a9d8f9161af01565b90616c39565b9b50509550509450509350508f8b9061afc7565b9750505050505050565b91908260409103126105af576020825161b0b4816139b7565b920151610be6816105b3565b91908260409103126105af57602082516176c0816139b7565b6020546001600160a01b031692909190831561925b575f9384926001600160a01b03168061b239575b5061b115906001600160a01b0316610ff0565b803b156105af576040516257785560e41b81526001600160401b03851660048201526001600160a01b039290921660248301525f908290604490829084905af161b225575b506001600160401b0383161580158161b219575b61b1785750505050565b61b20f575b60ff81161561b207575b60205461b19e90610ff0906001600160a01b031681565b803b156105af5760405163b99f675960e01b81526001600160401b03938416600482015293909216602484015260ff1660448301525f908290606490829084905af161b1ed575b80808061925b565b8061b1fb5f61b20193612736565b806107c0565b5f61b1e5565b50600361b187565b61012c925061b17d565b5060ff8216151561b16e565b8061b1fb5f61b23393612736565b5f61b15a565b604080516268080b60e01b81526001600160401b03871660048201529081602481855afa90815f915f9361b36e575b5061b342575b505060408051634965dbc760e11b81526001600160401b038716600482015291829060249082905afa90815f915f9361b30f575b5061b2ae575b5061b102565b158061b303575b61b2c0575b8061b2a8565b90925060ff16605081111561b2e1575061b115610ff060015b93915061b2ba565b6032101561b2f65761b115610ff0600261b2d9565b61b115610ff0600361b2d9565b5060ff8116151561b2b5565b90925061b334915060403d60401161b33b575b61b32c8183612736565b81019061b0c0565b915f61b2a2565b503d61b322565b158061b35c575b61b354575b8061b26e565b95505f61b34e565b506001600160401b038116151561b349565b90925061b393915060403d60401161b39a575b61b38b8183612736565b81019061b09b565b915f61b268565b503d61b381565b8054801561b3c8575f19019061b3b78282616c24565b8154905f199060031b1b1916905555565b634e487b7160e01b5f52603160045260245ffd5b6001810191805f528260205260405f2054928315155f1461b484575f1984018481116150d85783545f198101949085116150d8575f95858361b4379761b42a950361b43d575b50505061b3a1565b905f5260205260405f2090565b55600190565b61b46d61b4679161b45e61b45461b47b9588616c24565b90549060031b1c90565b92839187616c24565b90617076565b85905f5260205260405f2090565b555f808061b422565b505050505f90565b6001600160401b03165f81815260146020526040902080546001600160a01b0319166001600160a01b038416178155909190600181019081548581018091116150d85760029255018054918483018093116150d8579190556040519283526001600160a01b0316917fd28de7c518c312fa388e03f8d1203d8f4c75161e358ffb0827b6caa2e9ac8a3190602090a3565b6040519061b529826126ae565b81606061ffff6002548181168452818160101c166020850152818160201c16604085015260301c16910152565b939195949290861561b7bf5761b59261b58361b5c5926001600160401b03165f52600560205260405f2090565b9761b58c61b51c565b9061bfe0565b875490979061b5ac906001906001600160a01b0316616afe565b6001600160a01b03811661b73e575b505f88519161a73c565b600154602087015161b5e1915f906001600160a01b031661a73c565b8261b5ef575b505050509050565b856060604061b604969801519101519061c10f565b5f5b815181101561b7305761b64361b62d61b61f8385616932565b51516001600160a01b031690565b5f602061b63a8587616932565b5101519161c253565b604061b64f8284616932565b51015161b65f575b60010161b606565b5f5461b68d9061b677906001600160a01b0316610ff0565b5f604061b6848587616932565b5101519161a73c565b5f5461b6a1906001600160a01b0316610ff0565b9061b6af61b61f8285616932565b604061b6bb8386616932565b510151833b156105af576040516351dce2e160e11b81526001600160a01b039290921660048301526001600160401b03871660248301526044820152915f908390606490829084905af19182156113635760019261b71c575b50905061b657565b8061b1fb5f61b72a93612736565b5f61b714565b50509050805f80808061b5e7565b61b750906001600160a01b0316610ff0565b6040516308179f3560e01b81526001600160401b038816600482015290602090829060249082905afa5f918161b79e575b501561b5bb576001600160a01b0316801561b5bb5790505f61b5bb565b61b7b891925060203d602011611de057611dd18183612736565b905f61b781565b50505050509050565b9491939096959296871561ba115761b80061b7f761b833926001600160401b03165f52600560205260405f2090565b9861b58c61b51c565b885490989061b81a906001906001600160a01b0316616afe565b6001600160a01b03811661b990575b508589519161a73c565b600154602088015161b84f9186906001600160a01b031661a73c565b8261b85d5750505050509050565b866060604061b87396979901519101519061c10f565b905f5b825181101561b9805761b89c61b88f61b61f8386616932565b83602061b63a8588616932565b604061b8a88285616932565b51015161b8b8575b60010161b876565b5f5461b8dd9061b8d0906001600160a01b0316610ff0565b83604061b6848588616932565b5f5461b8f1906001600160a01b0316610ff0565b9061b8ff61b61f8286616932565b604061b90b8387616932565b510151833b156105af576040516351dce2e160e11b81526001600160a01b039290921660048301526001600160401b03881660248301526044820152915f908390606490829084905af19182156113635760019261b96c575b50905061b8b0565b8061b1fb5f61b97a93612736565b5f61b964565b5050509050805f8080808061b7bf565b61b9a2906001600160a01b0316610ff0565b6040516308179f3560e01b81526001600160401b038916600482015290602090829060249082905afa5f918161b9f0575b501561b829576001600160a01b0316801561b8295790505f61b829565b61ba0a91925060203d602011611de057611dd18183612736565b905f61b9d3565b5050505050509050565b5f828152600182016020526040902054618edf57805490600160401b8210156126a9578261ba6961ba53846001809601855584616c24565b819391549060031b91821b915f19901b19161790565b90558054925f520160205260405f2055600190565b61ba909061ffff612710931690616f51565b0490565b90813b1561bb12575f8051602061c8c783398151915280546001600160a01b0319166001600160a01b0384169081179091557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a280511561bafa576186f99161c2e7565b50503461bb0357565b63b398979f60e01b5f5260045ffd5b50634c9c8ce360e01b5f9081526001600160a01b0391909116600452602490fd5b90604051918281549182825260208201905f5260205f20925f5b81811061bb625750506105d192500383612736565b845483526001948501948794506020909301920161bb4d565b60ff5f8051602061c9678339815191525460401c161561bb9757565b631afcd79f60e31b5f5260045ffd5b61bbae61bb7b565b61bbb661bb7b565b60ff195f8051602061c90783398151915254165f8051602061c90783398151915255565b61bbe261bb7b565b61876e61bb7b565b919091602081519101209160208151910120906040519160208301937f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f85526040840152606083015246608083015260018060a01b031660a082015260a0815261bc5560c082612736565b51902090565b6127106040805161bc6b8161271b565b62093a8081525f60208201520152601c80546affffffffffffffffffffff19166a2710000000000000093a80179055565b61bca89093929361c31c565b926040519061bcb682612700565b7f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c282527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed602083015260405161bd0b81612700565b7f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa60208201526040519261bd6184612700565b835260208301526040519161bd77606084612736565b6002835260405f5b81811061bdf357505061bdb2610be6959661bd9861c3e7565b9561bda286616910565b5261bdac85616910565b5061c536565b61bdbb84616922565b5261bdc583616922565b5061bdcf84616910565b5261bdd983616910565b5061bde383616922565b5261bded82616922565b5061c5f9565b60209061bdfe61c304565b8282880101520161bd7f565b906001820180549082821061be42578282039182116150d857556003820180549182018092116150d85755546001600160a01b031690565b509063039ff3b160e41b5f5260045260245260445ffd5b91906154d561bf1883516001600160401b03815116906001600160401b03602082015116906040810151906001600160401b0360808160608401511692015116916040519360208501957f23db36a658fd8dd61c928c7cbec6a1840e339e363efd875cdaf83a1d60c84a43875260408601526060850152608084015260a083015260c082015260c0815261beee60e082612736565b519020604051928391602083019586909160429261190160f01b8352600283015260228201520190565b5190209161bf316115e28483905f5260205260405f2090565b61bfc057604061bf4560208401518561c45c565b9201805190926001600160a01b03918216911681900361bfa557506116258361bf7592905f5260205260405f2090565b516001600160a01b03167f89a9fcf52fcdc48f0e669fb3b7125291da850132592f5dd580ffb58166c8e9e85f80a3565b6308b1c54760e11b5f526001600160a01b031660045260245ffd5b60408201516308d1827160e01b5f526001600160a01b031660045260245ffd5b91909161bfeb6172d3565b9261271061bffe61ffff83511684616f51565b04845261271061c03161ffff8060408461c01e8360208901511689616f51565b049560208a019687520151161684616f51565b049060408501918252845183039283116150d85761c05c9261c05491519061751a565b90519061751a565b6060830152565b6040519061c072602083612736565b5f80835282815b82811061c08557505050565b60209060405161c0948161271b565b5f81525f838201525f60408201528282850101520161c079565b9061c0b882616896565b61c0c56040519182612736565b828152809261c0d6601f1991616896565b01905f5b82811061c0e657505050565b60209060405161c0f58161271b565b5f81525f838201525f60408201528282850101520161c0da565b919493801561c2455761c122865161c0ae565b955f915f955f5b835181101561c23b578961c143611c43615d6c8486616932565b61c14d865161750c565b830361c1bb5750508061c165615d2060019387616932565b61c16f878a61751a565b61c1798b8a61751a565b9061c19461c185612794565b6001600160a01b039094168452565b6020830152604082015261c1a8828d616932565b5261c1b3818c616932565b505b0161c129565b61c22f88849b98614d5f8661c2359661c1f98f60019a61c1f38f9a8f908061c1ed83611c3e611c3e94615d2099616f51565b9b616f51565b99616932565b61c21361c204612794565b6001600160a01b039092168252565b85602082015287604082015261c2298383616932565b52616932565b966175c0565b9761c1b5565b5050505050505050565b505050509050610be661c063565b90821561a24e576001600160a01b039182165f908152601960209081526040808320939094168252919091522080549182018092116150d85755565b905f602091828151910182855af115616d96575f513d61c2de57506001600160a01b0381163b155b61c2be5750565b635274afe760e01b5f9081526001600160a01b0391909116600452602490fd5b6001141561c2b7565b5f80610be693602081519101845af461c2fe6186b3565b9161c472565b6040519061c31182612700565b5f6020838281520152565b61c3439061c32861c304565b50602081519101205f8051602061c8a7833981519152900690565b905f905f5b610100831061c3605763db4a5cd960e01b5f5260045ffd5b616f6e575f8051602061c8a78339815191526003818581818009090861c3858161c4d0565b905f8051602061c8a78339815191528280091461c3ba575060015f8051602061c8a7833981519152815f95089201919261c348565b9092915061c3c66127b3565b918252602082015290565b6040519061c3e0602083612736565b6020368337565b6040519061c3f6606083612736565b6002825281601f1961c4086002616896565b01906040905f5b83811061c41c5750505050565b602090835161c42a81612700565b845161c4368682612736565b853682378152845161c4488682612736565b85368237838201528282850101520161c40f565b610be69161c4699161c74e565b9092919261c788565b9061c496575080511561c48757805190602001fd5b63d6bda27560e01b5f5260045ffd5b8151158061c4c7575b61c4a7575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561c49f565b5f8051602061c8a783398151915290818060019206905b61c4f15750905090565b60018084161461c51d575b5f8051602061c8a7833981519152919260011c91818392099192919061c4e7565b5f8051602061c8a783398151915281819309915061c4fc565b61c53e61c304565b5080519081158061c5a1575b61c59c5760205f8051602061c8a7833981519152910151065f8051602061c8a7833981519152035f8051602061c8a783398151915281116150d8576040519161c59283612700565b8252602082015290565b905090565b5060208101511561c54a565b1561c5b457565b60405162461bcd60e51b815260206004820152601e60248201527f424e3235343a2070616972696e67206c656e677468206d69736d6174636800006044820152606490fd5b61c606815183511461c5ad565b805161c61181616f3b565b9261c61b846168ca565b925f5b83811061c66857505050506020809261c64e9261c63961c3d1565b94859260051b910160086107cf195a01fa1590565b61c659575160011490565b634df45e2f60e01b5f5260045ffd5b8061c67560019284616932565b515161c683617ff883616f3b565b52602061c6908285616932565b51015161c6a7617ff861c6a284616f3b565b61757a565b5261c6bd61c6b58286616932565b515160200190565b5161c6d2617ff861c6cd84616f3b565b617588565b5261c6dd8185616932565b51515161c6f4617ff861c6ef84616f3b565b617596565b5261c70d602061c7048387616932565b51015160200190565b5161c722617ff861c71d84616f3b565b6175a4565b52602061c72f8286616932565b5101515161c747617ff861c74284616f3b565b6175b2565b520161c61e565b815191906041830361c77e5761c7779250602082015190606060408401519301515f1a9061c804565b9192909190565b50505f9160029190565b61c791816163a3565b8061c79a575050565b61c7a3816163a3565b6001810361c7ba5763f645eedf60e01b5f5260045ffd5b61c7c3816163a3565b6002810361c7de575063fce698f760e01b5f5260045260245ffd5b8061c7ea6003926163a3565b1461c7f25750565b6335e2f38360e21b5f5260045260245ffd5b91907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0841161c87b579160209360809260ff5f9560405194855216868401526040830152606082015282805260015afa15611363575f516001600160a01b0381161561c87157905f905f90565b505f906001905f90565b5050505f916003919056fe2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800cd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033009b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f006f24b3acd9144fe986c6fc468ff993840c1793f585f39e15b5d20728bd2dda41f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00a164736f6c634300081a000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\xA0\x80`@R4a\0\xE8W0`\x80R\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0T`\xFF\x81`@\x1C\x16a\0\xD9W`\x02`\x01`@\x1B\x03\x19`\x01`\x01`@\x1B\x03\x82\x16\x01a\0sW[`@Qa\xC9\x93\x90\x81a\0\xED\x829`\x80Q\x81\x81\x81a(~\x01Ra)\x96\x01R\xF3[`\x01`\x01`@\x1B\x03\x19\x16`\x01`\x01`@\x1B\x03\x90\x81\x17\x7F\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0U\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90` \x90\xA1_\x80a\0TV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[_\x80\xFD\xFE`\x80`@R`\x046\x10\x15a\0\x1AW[6\x15a\0\x18W_\x80\xFD[\0[_5`\xE0\x1C\x80c\x01\xFF\xC9\xA7\x14a\x05YW\x80c\x06\x07\x9D\xC5\x14a\x05TW\x80c\x06#u&\x14a\x05OW\x80c\x07\xE6\x01)\x14a\x05JW\x80c\n\xFD78\x14a\x05EW\x80c\x0F3\xE8\xE1\x14a\x05@W\x80c\x10\x8A}c\x14a\x05;W\x80c\x11\x0F\x82\x9B\x14a\x056W\x80c\x18\xC6\x80\x17\x14a\x051W\x80c \x81)V\x14a\x05,W\x80c#\xD7\xB3\xE1\x14a\x05'W\x80c$\x8A\x9C\xA3\x14a\x05\"W\x80c+\x9D\xA7\x1A\x14a\x05\x1DW\x80c-\x07\xE6U\x14a\x05\x18W\x80c-\xAE\x18\x85\x14a\x05\x13W\x80c.\xC2\xBD\x03\x14a\x05\x0EW\x80c//\xF1]\x14a\x05\tW\x80c/F'\x9F\x14a\x05\x04W\x80c0\xAE(\x9C\x14a\x04\xFFW\x80c1\xD7\xA2b\x14a\x04\xFAW\x80c4\x13\xE8\xEE\x14a\x04\xF5W\x80c6V\x8A\xBE\x14a\x04\xF0W\x80c7%\0\xAB\x14a\x04\xEBW\x80c=\xC0\xD5\xFE\x14a\x04\xE6W\x80c?K\xA8:\x14a\x04\xE1W\x80cD\x9B\xB8I\x14a\x04\xDCW\x80cO\x1E\xF2\x86\x14a\x04\xD7W\x80cR\xD1\x90-\x14a\x04\xD2W\x80cV:\x89\xF9\x14a\x04\xCDW\x80c[q\xC94\x14a\x04\xC8W\x80c\\\x97Z\xBB\x14a\x04\xC3W\x80c_5\x99$\x14a\x04\xBEW\x80c_\x9BM\xFA\x14a\x04\xB9W\x80caH#\xB2\x14a\x04\xB4W\x80cdF%\x95\x14a\x04\xAFW\x80cgx\xAF\xBC\x14a\x04\xAAW\x80cjd\xA2~\x14a\x04\xA5W\x80ck\xDAB\xF3\x14a\x04\xA0W\x80cm\x8B\x88\xC3\x14a\x04\x9BW\x80cu\xB28\xFC\x14a\x04\x96W\x80cw8\x0Ct\x14a\x04\x91W\x80cxD\x867\x14a\x04\x8CW\x80cx\x86z\x16\x14a\x04\x87W\x80c\x80\xAC\x82(\x14a\x04\x82W\x80c\x81]j&\x14a\x04}W\x80c\x84%$\xBB\x14a\x04xW\x80c\x84V\xCBY\x14a\x04sW\x80c\x8AL\xF7c\x14a\x04nW\x80c\x8C\x9A(\x1D\x14a\x04iW\x80c\x8D?e\xBE\x14a\x04dW\x80c\x91\xD1HT\x14a\x04_W\x80c\x93\xF3\xDD\xAF\x14a\x04ZW\x80c\x97\x0E\x08\xFE\x14a\x04UW\x80c\xA2\x17\xFD\xDF\x14a\x04PW\x80c\xA3{\x92\x86\x14a\x04KW\x80c\xA5\x95\xB2\x1E\x14a\x04FW\x80c\xA5\xBF\xBA\xE4\x14a\x04AW\x80c\xA6r\xBC\n\x14a\x04<W\x80c\xAA\xC7Ak\x14a\x047W\x80c\xAA\xCD\xBA\x9F\x14a\x042W\x80c\xAD<\xB1\xCC\x14a\x04-W\x80c\xB0UD\x9B\x14a\x04(W\x80c\xB7im\xBB\x14a\x04#W\x80c\xB8\x17A\xAC\x14a\x04\x1EW\x80c\xBB \x7F\x1F\x14a\x04\x19W\x80c\xC0\xC5;\x8B\x14a\x04\x14W\x80c\xC3%\xAE\x12\x14a\x04\x0FW\x80c\xC6\x02\xD4\xFA\x14a\x04\nW\x80c\xCC=\x19\xC3\x14a\x04\x05W\x80c\xCF8\x06\xC6\x14a\x04\0W\x80c\xD3\x90\xBB\xBB\x14a\x03\xFBW\x80c\xD5Gt\x1F\x14a\x03\xF6W\x80c\xDA#-\xED\x14a\x03\xF1W\x80c\xDF\xE6*\xBA\x14a\x03\xECW\x80c\xE58\xDAf\x14a\x03\xE7W\x80c\xE6:\xB1\xE9\x14a\x03\xE2W\x80c\xE7!F\xA9\x14a\x03\xDDW\x80c\xEB\x8C;\xCD\x14a\x03\xD8W\x80c\xEC\x9F\x0F\xDD\x14a\x03\xD3W\x80c\xEF\x1BB\xA2\x14a\x03\xCEW\x80c\xEF\\\xFB\x8C\x14a\x03\xC9W\x80c\xF0A\x1A\xF3\x14a\x03\xC4W\x80c\xF0\xF4B`\x14a\x03\xBFWc\xF7,\r\x8B\x03a\0\x0EWag6V[af\xEBV[afTV[ae\xCDV[adpV[ab\xE5V[ab\x0EV[aaaV[aa'V[a`\x96V[a_}V[a^\xB1V[a^}V[a^WV[a[\x88V[aX\x1AV[aW\xF4V[aS4V[aQ\xACV[aQ*V[aP\x0FV[aO9V[aK\xE7V[aK\xA0V[aF]V[aF\x1BV[aD\xC3V[aA\xC8V[aA{V[a@\xDCV[a@\xC2V[a?\x9EV[a>\xC3V[a>;V[a=\xFFV[a=\xC5V[a=\x0CV[a<\x9BV[a;\xC4V[a;sV[a;\x14V[a9\xC1V[a7\xD7V[a7=V[a7\x03V[a5kV[a4\x96V[a4OV[a1\xF5V[a1\xACV[a/*V[a-\xE8V[a,\x9DV[a,oV[a+.V[a*JV[a)\x84V[a(<V[a%\xEFV[a%qV[a#\xDDV[a\"EV[a!\xFDV[a\x1EiV[a\x1E\x19V[a\x1A\xC6V[a\x1AuV[a\x1A<V[a\x19\xECV[a\x19\x9FV[a\x14\xB4V[a\x0E\xC2V[a\x0E\x90V[a\x0E&V[a\r\xDFV[a\r]V[a\x0C+V[a\n\xE5V[a\t\xC5V[a\x08\x1CV[a\x07\xF3V[a\x07\xCAV[a\x06aV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045c\xFF\xFF\xFF\xFF`\xE0\x1B\x81\x16\x80\x91\x03a\x05\xAFW` \x90cye\xDB\x0B`\xE0\x1B\x81\x14\x90\x81\x15a\x05\x9EW[P`@Q\x90\x15\x15\x81R\xF3[c\x01\xFF\xC9\xA7`\xE0\x1B\x14\x90P_a\x05\x93V[_\x80\xFD[`\x01`\x01`@\x1B\x03\x81\x16\x03a\x05\xAFWV[`\x045\x90a\x05\xD1\x82a\x05\xB3V[V[`\xA45\x90a\x05\xD1\x82a\x05\xB3V[`\x845\x90a\x05\xD1\x82a\x05\xB3V[5\x90a\x05\xD1\x82a\x05\xB3V[\x91\x81`\x1F\x84\x01\x12\x15a\x05\xAFW\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFW` \x83\x81\x86\x01\x95\x01\x01\x11a\x05\xAFWV[\x90`@`\x03\x19\x83\x01\x12a\x05\xAFW`\x045a\x06>\x81a\x05\xB3V[\x91`$5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFWa\x06]\x91`\x04\x01a\x05\xF8V[\x90\x91V[4a\x05\xAFWa\x06o6a\x06%V[3_\x90\x81R_\x80Q` a\xC9G\x839\x81Q\x91R` R`@\x90 T`\xFF\x16\x15a\x07\xA0W\x90a\x06\x9E\x916\x91a'\xEBV[a\x06\xB9\x82`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[\x80T`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x15a\x07\x84W`\x05\x01\x80T`\x80\x1C`\xFF\x16a\x06\xE0\x81ac\xA3V[`\x02\x81\x14a\x07hW\x80a\x06\xF4`\x03\x92ac\xA3V[\x14a\x07IW\x80T`\xFF`\x80\x1B\x19\x16`\x03`\x80\x1B\x17\x90U\x7F\xE8\r\x1A\x18:\xF3\t\x16\xF7\x9B\x15\xA6\xC8^\x82G\r\x0B\x88\x06]\xFD\xD2P]\x10j\xDF\x0E\x8Bw\x96`@Q\x80a\x07D`\x01`\x01`@\x1B\x033\x96\x16\x94\x82aK\x8FV[\x03\x90\xA3\0[c\x07p\\\xCD`\xE4\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`$_\xFD[_\xFD[cS*\xF3i`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[c\x16.?\xAB`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`$_\xFD[`\x01`\x01`@\x1B\x03\x83c\x03\x93\x97\x9D`\xE3\x1B_R\x16`\x04R3`$R`D_\xFD[_\x91\x03\x12a\x05\xAFWV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `\x01`\x01`@\x1B\x03`\x04T`\x80\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `\x01`\x01`@\x1B\x03`\x04T`@\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x089\x81a\x05\xB3V[a\x08B\x81a\x86|V[`\x01`\x01`@\x1B\x03a\x08\x8Aa\x08}a\x08k\x85`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[3_\x90\x81R` \x91\x90\x91R`@\x90 \x90V[T`\x01`\x01`@\x1B\x03\x16\x90V[\x16\x15a\t\xA5W`\x01\x01\x80Ta\t8\x91\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a\tiW[P_a\x08\xDF3a\x08\xCA\x86`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[Ua\t\x043a\x08\xFF\x85`\x01`\x01`@\x1B\x03\x16_R`\x08` R`@_ \x90V[a\x86\xFCV[Pa\t\x18a\t\x13\x82T`\xE0\x1C\x90V[ag\x97V[\x81T`\x01`\x01`\xE0\x1B\x03\x16`\xE0\x91\x90\x91\x1B`\x01`\x01`\xE0\x1B\x03\x19\x16\x17\x90UV[`\x01`\x01`@\x1B\x033\x91\x16\x7F\x88\xE4n\x95\xBC\xDF\x10 \xC0\xCA\xF9\xF3\xDD_\xDEi\xC4\x1D!Q\xDB\xBC\xA0\xA7|\x03\xC4\xE2\x8BM>\xC1_\x80\xA3\0[`@Qc\n\x8D\"\xBB`\xE1\x1B` \x82\x01R3`$\x82\x01Ra\t\x9F\x91a\t\x9A\x82`D\x81\x01[\x03`\x1F\x19\x81\x01\x84R\x83a'6V[a\x86\xE2V[_a\x08\xA9V[c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R3`$R`D_\xFD[4a\x05\xAFW`\x01`\x01`@\x1B\x03a\t\xDB6a\x06%V[\x92\x90\x91\x16\x90\x81_R`\x07` Ra\n\x04`@_ 3`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[`\x01`\x01`@\x1B\x03\x81T\x16\x15a\nhW\x7F-\x0E\x8Cu\xCC\xFC`dc\xBD_uV\xCC\xF3X\xB1\xC4\t\xEC`Y\xCE\xE6\xE5\x195\xA2\x9B\xD0\xFD\xC1\x91a\nMa\n_\x92`\x01`\x01`@\x1B\x03B\x16\x90ag\xA9V[`@Q\x94` \x86R` \x86\x01\x91ag\xD1V[\x92\x803\x94\x03\x90\xA3\0[\x82c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x04R3`$R`D_\xFD[\x91\x81`\x1F\x84\x01\x12\x15a\x05\xAFW\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFW` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x05\xAFWV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x03a\x05\xAFWV[`\xC45\x90a\x05\xD1\x82a\n\xAFV[`\xA45\x90a\x05\xD1\x82a\n\xAFV[5\x90a\x05\xD1\x82a\n\xAFV[a\x01\x006`\x03\x19\x01\x12a\x05\xAFWa\n\xFAa\x05\xC4V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x0B\x19\x906\x90`\x04\x01a\n\x7FV[\x91`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x0B9\x906\x90`\x04\x01a\n\x7FV[\x92\x90\x93`d5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x0B[\x906\x90`\x04\x01a\x05\xF8V[\x94\x90\x95`\x845\x95`\x01`\x01`@\x1B\x03\x87\x11a\x05\xAFWa\x0B\xBD\x97a\x0B\x85a\x0B\xA3\x986\x90`\x04\x01a\n\x7FV[\x94\x90\x93a\x0B\x90a\x05\xD3V[\x96a\x0B\x99a\n\xC0V[\x98`\xE45\x9Aah\x02V[`@Q`\x01`\x01`@\x1B\x03\x90\x91\x16\x81R\x90\x81\x90` \x82\x01\x90V[\x03\x90\xF3[`@\x90`\x03\x19\x01\x12a\x05\xAFW`\x045a\x0B\xD9\x81a\x05\xB3V[\x90`$5a\x0B\xE6\x81a\x05\xB3V[\x90V[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90_[\x81\x81\x10a\x0C\x0CWPPP\x90V[\x82Q`\x01`\x01`@\x1B\x03\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x0B\xFFV[4a\x05\xAFWa\x0C96a\x0B\xC1V[`\x01`\x01`@\x1B\x03\x16_\x82[\x82`\x01`\x01`@\x1B\x03\x82\x16\x10a\r\x0CWP`\x01`\x01`@\x1B\x03\x16\x91a\x0Ci\x83ah\xCAV[\x92_\x91[\x83`\x01`\x01`@\x1B\x03\x82\x16\x10\x80a\x0C\xFAW[\x15a\x0C\xECW\x80a\x0C\xABa\x0C\xA6a\x0C\xB4\x93`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[a\x8E\x9BV[a\x0C\xB9Wah\xADV[a\x0CmV[a\x0C\xE7\x81a\x0C\xD9`\x01`\x01`@\x1B\x03a\x0C\xD1\x88ah\xADV[\x97\x16\x89ai2V[\x90`\x01`\x01`@\x1B\x03\x16\x90RV[ah\xADV[`@Q\x80a\x0B\xBD\x87\x82a\x0B\xE9V[P\x81`\x01`\x01`@\x1B\x03\x84\x16\x10a\x0C\x7FV[a\r*a\x0C\xA6\x82`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[a\r@W[`\x01\x01`\x01`\x01`@\x1B\x03\x16a\x0CEV[\x90`\x01a\rT`\x01`\x01`@\x1B\x03\x92ah\xADV[\x92\x91PPa\r/V[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a\rz\x81a\x05\xB3V[`\xFF`\x02a\r\x87\x83a\x86|V[\x01T`\x10\x1C\x16\x15a\r\xC3W`\x01`\x01`@\x1B\x033\x91\x16\x7F\xD3\x9F\xF7Z\x15\xC3\x1A'(\x91\xC5.B\x99Z\xCF\xA2tY\xBA\x1C\x12#\x9C\xBA\xC2<\xDBv\xF50\x84_\x80\xA3\0[`\x01`\x01`@\x1B\x03\x90c!\x0E\xB4\xED`\xE1\x1B_R\x16`\x04R`$_\xFD[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a\r\xFC\x81a\n\xAFV[a\x0E\x04a\x8E\xE5V[`\x1F\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\0[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x0EC\x81a\x05\xB3V[`$5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFW6`#\x83\x01\x12\x15a\x05\xAFW\x81`\x04\x015\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFW6`$``\x84\x02\x85\x01\x01\x11a\x05\xAFW`$a\0\x18\x93\x01\x90aiFV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW` a\x0E\xAE`\x045amiV[`@Q\x90\x81R\xF3[a\xFF\xFF\x81\x16\x03a\x05\xAFWV[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x0E\xDF\x81a\x05\xB3V[`$5a\x0E\xEB\x81a\x0E\xB6V[a\x0E\xF3a\x87\x0FV[a\x0E\xFBa\x876V[a\x0F\x04\x82a\x98\xDCV[`\x02\x81\x01\x90\x81T`\x01a\x0F\x1B\x82`\xFF\x90`p\x1C\x16\x90V[a\x0F$\x81a\"\xE3V[\x03a\x14\x98W`\x01``\x82\x90\x1C`\xFF\x16a\x0F<\x81a\"\xC7V[\x03a\x14=Wc\xFF\xFF\xFF\xFF`@\x82\x90\x1C\x16\x80\x15\x15\x91\x82a\x14kW[PPa\x14=WT`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03a\x0F\x8Fa\x08}a\x08k\x84`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x16\x15a\x14LWa\x0F\xC1a\x0F\xB73a\x08\xCA\x87`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[T`\x90\x1C`\xFF\x16\x90V[a\x14=Wa\x0F\xE0\x90`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[_Ta\x0F\xFC\x90`\x01`\x01`\xA0\x1B\x03\x16[`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90`@Qc\xD7u\xCBa`\xE0\x1B\x81R` \x81`\x04\x81\x86Z\xFA\x80\x15a\x13cW`\x01\x91_\x91a\x14\x1EW[P\x91\x01\x80T\x90\x92`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x91\x82a\x13\x87W[`@Qc\xF4i\x13\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x82\x90R` \x81`D\x81\x86Z\xFA\x90\x81\x15a\x13cW_\x91a\x13hW[P\x15a\x12\xE6WPP`\x01`\x01`\xA0\x1B\x03\x16\x80a\x12VW[Pa\x11\xAAa\x11\xF4\x92a\x11[a\x10\x97a'WV[a\xFF\xFF\x87\x16\x81RB`\x01`\x01`@\x1B\x03\x16` \x82\x01R_`@\x82\x01R`\x01``\x82\x01Ra\x10\xD93a\x08\xCA\x8A`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x81Q\x81Ta\xFF\xFF\x19\x16a\xFF\xFF\x91\x90\x91\x16\x17\x81U\x90``\x90` \x81\x01Q\x83T`@\x83\x01Qq\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\x19\x90\x91\x16`\x10\x92\x90\x92\x1Bi\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\x16\x91\x90\x91\x17`P\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`P\x1B\x16\x17\x83U\x01Q\x81T`\xFF`\x90\x1B\x19\x16\x90\x15\x15`\x90\x1B`\xFF`\x90\x1B\x16\x17\x90UV[a\x11\x7F3a\x11z\x88`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[a\x99\x16V[Pa\x11\x96a\x11\x91\x82Tc\xFF\xFF\xFF\xFF\x16\x90V[am>V[c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90UV[`@Qa\xFF\xFF\x84\x16\x81R3\x90`\x01`\x01`@\x1B\x03\x86\x16\x90\x7F$W\x91\x87\x96\x07\x84@\x06\x83\x85\xE7>B%9\xC8O/\x90E\xDDD.\x12=B\x84%\x8A\xE2J\x90` \x90\xA3T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x12\x0BW[a\0\x18a\x87nV[`@QcMQ5I`\xE1\x1B` \x82\x01R`\x01`\x01`@\x1B\x03\x90\x93\x16`$\x84\x01R3`D\x84\x01Ra\xFF\xFF\x90\x91\x16`d\x83\x01Ra\x12N\x91\x90a\t\x9A\x82`\x84\x81\x01a\t\x8CV[_\x80\x80a\x12\x03V[`@Qc\x16\x8EH]`\xE3\x1B\x81R`\x01`\x01`@\x1B\x03\x86\x16`\x04\x82\x01R3`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xFA_\x91\x81a\x12\xB5W[P\x15a\x10\x84W\x15a\x12\xA7W_a\x10\x84V[b\x82\xB4)`\xE8\x1B_R`\x04_\xFD[a\x12\xD8\x91\x92P` =` \x11a\x12\xDFW[a\x12\xD0\x81\x83a'6V[\x81\x01\x90am\xC0V[\x90_a\x12\x96V[P=a\x12\xC6V[`@Qc\x1C\x9D\x11\xBD`\xE3\x1B\x81R3`\x04\x82\x01R\x91` \x90\x83\x90`$\x90\x82\x90Z\xFA\x90\x81\x15a\x13cWa\x07e\x92_\x92a\x132W[Pc\x93mBm`\xE0\x1B_R3`\x04R`$R`DR`d\x90V[a\x13U\x91\x92P` =` \x11a\x13\\W[a\x13M\x81\x83a'6V[\x81\x01\x90am\x87V[\x90\x83a\x13\x18V[P=a\x13CV[am\x96V[a\x13\x81\x91P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[_a\x10mV[`\x04`@a\x13\x9D`\x01`\x01`\xA0\x1B\x03\x86\x16a\x0F\xF0V[\x81Qc*nsa`\xE1\x1B\x81R\x92\x83\x91\x82\x90Z\xFA\x90\x81_\x91_\x93a\x13\xEBW[Pa\x13\xC8W[PPa\x10<V[\x15\x80a\x13\xE2W[a\x13\xDAW[\x80a\x13\xC1V[\x90P_a\x13\xD4V[P\x80\x15\x15a\x13\xCFV[\x90\x92Pa\x14\x10\x91P`@=`@\x11a\x14\x17W[a\x14\x08\x81\x83a'6V[\x81\x01\x90am\xA1V[\x91_a\x13\xBBV[P=a\x13\xFEV[a\x147\x91P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[_a\x10#V[c\xBA\xF3\xF0\xF7`\xE0\x1B_R`\x04_\xFD[c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x16`\x04R3`$R`D_\xFD[c\xFF\xFF\xFF\xFF\x91\x92Pa\x14\x83a\x14\x8D\x91c\xFF\xFF\xFF\xFF\x16\x90V[\x92c\xFF\xFF\xFF\xFF\x16\x90V[\x91\x16\x10\x15_\x80a\x0FVV[c\t\x8B\xFC[`\xE3\x1B_R`\x01`\x01`@\x1B\x03\x85\x16`\x04R`$_\xFD[4a\x05\xAFW``6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x14\xD1\x81a\x05\xB3V[`$5\x90a\x14\xDE\x82a\x05\xB3V[`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x14\xFD\x906\x90`\x04\x01a\x05\xF8V[\x90a\x15\x06a\x87\x0FV[a\x15\x0Ea\x876V[a\x15\x17\x83a\x98\xDCV[\x90a\x15\"\x85\x85a\x99)V[\x94`\x01a\x15Pa\x159\x85T`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[\x01\x80T\x90\x92\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a\x18\xE1W[Pa\x15\x8Ea\x15\x8Aa\x0F\xB7a\x08k\x89`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x15\x90V[a\x18\xC1W`\x03\x87\x01\x94a\x15\xA2\x86T`\xFF\x16\x90V[a\x18\x9FWa\x15\xE9a\x15\xE23a\x08\xCA\x86a\x15\xCC\x8C`\x01`\x01`@\x1B\x03\x16_R`\x17` R`@_ \x90V[\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[T`\xFF\x16\x90V[a\x18yW\x91a\x16\xC6\x95\x93\x91`\x01`\x01`@\x1B\x03\x95\x93a\x162a\x16%\x8Aa\x08\xCA\x86a\x15\xCC3\x93`\x01`\x01`@\x1B\x03\x16_R`\x17` R`@_ \x90V[\x80T`\xFF\x19\x16`\x01\x17\x90UV[`\x01\x8A\x01\x92a\x16aa\x16Ka\x11\x91\x86Tc\xFF\xFF\xFF\xFF\x16\x90V[\x85Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x85UV[\x81\x81\x8C\x85\x8Da\x16v\x8AT`\x01\x80`\xA0\x1B\x03\x16\x90V[\x92`\x01`\x01`\xA0\x1B\x03\x84\x16a\x18\x1FW[P\x91PP\x7F\x8A\x04\xF9\x9F\xE22\x84\xE8t\xE8\xDD\x01sE$\x82y\xCCYp\x16\x95\xE7;\xCD\xBE\xB6$\x1B\xCD*\xC6\x92P\x8A\x91P\x16\x98\x89\x92\x16\x99\x8A\x93`@Q\x91\x82\x913\x97\x83ag\xF1V[\x03\x90\xA4\x90T`\x01\x91\x90a\x16\xE1\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x80a\x17\x96W[Pc\xFF\xFF\xFF\xFFa\x16\xFC\x81\x92Tc\xFF\xFF\xFF\xFF\x16\x90V[\x92\x16\x91\x16\x10\x15a\x17\x0EWa\0\x18a\x87nV[`\x02\x93a\x17V\x93a\x17'\x86\x94`\x01`\xFF\x19\x82T\x16\x17\x90UV[\x7F`\xA7d\x9Fn\x93\xE7\xA3\xCE\x1D\xC9r\x9C \xE3\xD9]\xCE(\xC6\xA6\xBD\x95|\xDE\t\xD8\xA1\xCB7\xC1\x9F_\x80\xA3\x01T`h\x1C`\xFF\x16\x90V[a\x17_\x81a\"\xE3V[\x14\x80a\x17\x89W[a\x17tW[\x80\x80\x80\x80a\x12\x03V[`\x02a\x17\x82\x92\x01T\x90a\x99\x8EV[_\x80a\x17kV[P`\x02\x82\x01T\x15\x15a\x17fV[\x88T`@Qc\x13\x11\x0F\x81`\xE2\x1B\x81R`\x01`\x01`@\x1B\x03\x8A\x16`\x04\x82\x01R`\xFF\x90\x91\x16`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xFA_\x91\x81a\x17\xEEW[P\x15a\x16\xE7W\x91Pc\xFF\xFF\xFF\xFFa\x16\xE7V[a\x18\x11\x91\x92P` =` \x11a\x18\x18W[a\x18\t\x81\x83a'6V[\x81\x01\x90an\xF9V[\x90_a\x17\xDCV[P=a\x17\xFFV[Ta\x18n\x95a\t\x9A\x93a\t\x8C\x92`\xFF\x16\x93a\x18O\x88a\x15\xCC\x83`\x01`\x01`@\x1B\x03\x16_R`\x18` R`@_ \x90V[\x90`@Q\x98\x89\x96c\xC4\x0C\x80\xD1`\xE0\x1B` \x89\x01R3\x92`$\x89\x01an\rV[\x81\x81_\x85\x8D\x8Fa\x16\x86V[c[\xF3\xFEw`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x80\x88\x16`\x04R\x83\x16`$R3`DR`d_\xFD[c\nUQ/`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x80\x88\x16`\x04R\x83\x16`$R`D_\xFD[cx4\x82\xE9`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x86\x16`\x04R3`$R`D_\xFD[a\x18\xF3\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[a\x19:` a\x19\x03\x8AT`\xFF\x16\x90V[`@Qc\x0C\xF6\xAD\xD9`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x8B\x16`\x04\x82\x01R`\xFF\x82\x16`$\x82\x01R\x90\x93\x90\x92\x83\x91\x90\x82\x90\x81\x90`D\x82\x01\x90V[\x03\x91Z\xFA_\x91\x81a\x19~W[Pa\x19RW[Pa\x15eV[a\x19\\W\x80a\x19LV[c\x1D\xC5\x937`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x87\x16`\x04R`\xFF\x16`$R`D_\xFD[a\x19\x98\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_a\x19FV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW`\x1FT`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[`@\x90`\x03\x19\x01\x12a\x05\xAFW`\x045a\x19\xDF\x81a\x05\xB3V[\x90`$5a\x0B\xE6\x81a\n\xAFV[4a\x05\xAFW` a\x1A2`\x01`\x01`@\x1B\x03a\x1A\x076a\x19\xC7V[\x91\x16_\x90\x81R`\x13\x84R`@\x80\x82 `\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x82R`\x01\x90\x92\x01` R T\x15\x15\x90V[`@Q\x90\x15\x15\x81R\xF3[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFWa\0\x18`$5`\x045a\x1A_\x82a\n\xAFV[a\x1Apa\x1Ak\x82amiV[a\x902V[a\x9D\xDFV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a\x1A\x9A\x81a\x05\xB3V[\x16_R`\x10` R` `\xFF`\x02`@_ \x01T`p\x1C\x16a\x1A\xBB\x81a\"\xE3V[`\x01`@Q\x91\x14\x81R\xF3[4a\x05\xAFW`\x806`\x03\x19\x01\x12a\x05\xAFW`\x045a\x1A\xE3\x81a\x05\xB3V[`$5\x90a\x1A\xF0\x82a\n\xAFV[`D5\x91`d5\x91a\x1B\x01\x81a\x98\xDCV[T\x92a\x1B+a\x0F\xF0a\x1B\x1B`\x01`\x01`@\x1B\x03\x87\x16a\x159V[\x95`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[3\x14\x80\x15a\x1D\xFDW[\x80\x15\x80a\x1D\xE7W[a\x1DMW[\x15a\x12\xA7Wa\x1Be\x83a\x08\xCA\x84`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[T`\xFF`\x90\x82\x90\x1C\x16\x15\x80a\x1D8W[a\x1D\x0FWa\x1B\x96a\x1B\xA5\x92a\x1B\x8D`\x01\x93a\xFF\xFF\x16\x90V[\x883\x88\x88a\xA0\x16V[\x94\x01T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x1B\xC8W[`@Q`\x01`\x01`@\x1B\x03\x85\x16\x81R` \x90\xF3[_Ta\x1B\xDC\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\x1C\x9D\x11\xBD`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R\x95\x90` \x90\x87\x90`$\x90\x82\x90Z\xFA\x92\x83\x15a\x13cWa\t\x8Ca\x1C\xCC\x95a\x1C\xA2\x95a\t\x9A\x94a\x0B\xBD\x9A_\x92a\x1C\xEEW[P\x81\x15a\x1C\xE6Wa\x1CJ\x91a\x1C>a\x1CC\x92ao#V[aodV[a\xFF\xFF\x16\x90V[a'\x10a\xFF\xFF\x82\x16\x11a\x1C\xDDW[a\x1Cja\x1Cp\x91a\xFF\xFF`d\x91\x16\x04\x90V[`\xFF\x16\x90V[\x90`d`\xFF\x83\x16\x11a\x1C\xD4W[a\x1C\xB0\x90`@Q\x97\x88\x91` \x83\x01`\x14\x91`\x01`\x01``\x1B\x03\x19\x90``\x1B\x16\x81R\x01\x90V[\x03`\x1F\x19\x81\x01\x88R\x87a'6V[`@Qc\x08\x81\x89\x8F`\xE0\x1B` \x82\x01R\x95\x86\x93`$\x85\x01aosV[_\x80\x80a\x1B\xB4V[`d\x91Pa\x1C}V[Pa'\x10a\x1CXV[PP_a\x1CJV[a\x1D\x08\x91\x92P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[\x90_a\x1C'V[cx4\x82\xE9`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`\x01`\x01`\xA0\x1B\x03\x84\x16`$R`D_\xFD[P`\x10\x81\x90\x1C`\x01`\x01`@\x1B\x03\x16\x15a\x1BuV[`\x01\x85\x01Ta\x1Df\x90a\x0F\xF0\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Qct\xCE\xEBU`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x85\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA_\x91\x81a\x1D\xB6W[Pa\x1D\xA3W[Pa\x1BAV[`\x01`\x01`\xA0\x1B\x03\x163\x14\x90P_a\x1D\x9DV[a\x1D\xD9\x91\x92P` =` \x11a\x1D\xE0W[a\x1D\xD1\x81\x83a'6V[\x81\x01\x90ao\x0EV[\x90_a\x1D\x97V[P=a\x1D\xC7V[P`\x01\x85\x01T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15a\x1B<V[P\x83Ta\x1E\x12\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[3\x14a\x1B4V[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x1E6\x81a\n\xAFV[`\x01\x80`\xA0\x1B\x03\x16_R`\x19` R`@_ _\x80R` R` `@_ T`@Q\x90\x81R\xF3[`\xFF\x81\x16\x03a\x05\xAFWV[``6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x1E\x81\x81a\x05\xB3V[`$5\x90a\x1E\x8E\x82a\x1E^V[`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x1E\xAD\x906\x90`\x04\x01a\x05\xF8V[\x91\x90\x92a\x1E\xB8a\x87\x0FV[a\x1E\xC0a\x876V[a\x1E\xC9\x82a\x98\xDCV[`\x02\x81\x01T\x93\x90`\x01`p\x86\x90\x1C`\xFF\x16a\x1E\xE3\x81a\"\xE3V[\x03a!\xE1W`\x01\x81\x01T`\x01`\x01`@\x1B\x03`@\x82\x90\x1C\x16\x80\x15\x15\x91\x82a!\xAFW[PPa!\x93Wa\x1FIa\x15\x8Aa\x1F,\x86`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[a\x1F53a\x0F\xF0V[\x90`\x01\x91_R\x01` R`@_ T\x15\x15\x90V[a!sW_\x94`\x02\x90`h\x1C`\xFF\x16a\x1Fa\x81a\"\xE3V[\x14a!-W[\x90\x82\x91a\x1F\x85\x85`\x01`\x01`@\x1B\x03\x16_R`\x15` R`@_ \x90V[\x95\x86Ta\x1F\x98\x90`\x01`\x01`@\x1B\x03\x16\x90V[\x96a\x1F\xA2\x88ah\xADV[\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x90\x91\x16\x17\x90Ua\x1F\xC5a'fV[`\xFF\x85\x16\x81R\x903` \x83\x01R`\x01`\x01`@\x1B\x03B\x16`@\x83\x01R``\x82\x01_\x90R`\x80\x82\x01R`\xA0\x81\x01_\x90R\x86a \x10\x87`\x01`\x01`@\x1B\x03\x16_R`\x16` R`@_ \x90V[\x90a +\x91\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[\x90a 5\x91ao\xC3V[\x86\x82\x87a S\x88`\x01`\x01`@\x1B\x03\x16_R`\x18` R`@_ \x90V[\x90a n\x91\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[\x91a x\x92ap\xE2V[T`\x01`\x01`@\x1B\x03\x16_\x90\x81R`\x05` R`@\x90 `\x01\x01Ta\x0B\xBD\x96\x7F\xDE7\xCCH\xD2\x17x\xE1\xC9\xA0u\xC4\xE4\x1CZ\xFFi\x18\xC3\xEAaQ\"\x1F\n\xF3\xCE\x81!\xA2\x9D\xB5\x93\x90\x91`\x01`\x01`\xA0\x1B\x03\x16\x90\x81a \xF7W[PPa \xEC`@Q\x92\x83\x92`\x01`\x01`@\x1B\x03\x80\x8A\x16\x98\x16\x963\x90\x85aq\xD7V[\x03\x90\xA3a\x0B\xA3a\x87nV[a!&\x91a!!\x88a\t\x8C\x87\x87\x8D`@Q\x97\x88\x95c\x988\xCA\xA3`\xE0\x1B` \x88\x01R`$\x87\x01aq\xA6V[a\xA2SV[_\x84a \xCBV[\x93P\x81\x90`\x03a!^a!G\x87T`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[\x01T\x94a!k4\x87a\xA1\xC9V[\x90\x91Pa\x1FgV[c5wV\xD1`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R3`$R`D_\xFD[c|>b\x1B`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[a!\xD8\x92Pa!\xCC\x91\x90`\x01`\x01`@\x1B\x03\x16ao\xA3V[ao\xA3V[`\x01`\x01`@\x1B\x03\x16\x90V[B\x11_\x80a\x1F\x05V[c\t\x8B\xFC[`\xE3\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045`$5a\"\x1D\x81a\n\xAFV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a\"6Wa\0\x18\x91a\xA2\xCDV[c3K\xD9\x19`\xE1\x1B_R`\x04_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFWa\"]a\x876V[a\"f3a\xA3mV[\x80a\"\x7FW[`\x01_\x80Q` a\xC9'\x839\x81Q\x91RU\0[_\x90`@Q\x90\x81R\x7F\x93\x10\xCC\xFC\xB8\xDEr?W\x8A\x9EB\x82\xEA\x9FR\x1F\x05\xAE@\xDC\x08\xF3\x06\x8D\xFA\xD5(\xA6^\xE3\xC7` 3\x92\xA3_a\"lV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x02\x11\x15a\"\xD1WV[a\"\xB3V[\x90a\"\xE0\x82a\"\xC7V[RV[`\x03\x11\x15a\"\xD1WV[\x90a\"\xE0\x82a\"\xE3V[a\x05\xD1\x90\x92\x91\x92a\x01`\x80a\x01\x80\x83\x01\x95a#\x1B\x84\x82Q`\x01`\x01`@\x1B\x03\x16\x90RV[` \x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x85\x01R`@\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R``\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R`\x80\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R`\xA0\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R`\xC0\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01R`\xE0\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01Ra\x01\0\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01Ra#\xBFa\x01 \x82\x01Qa\x01 \x86\x01\x90a\"\xD6V[a#\xD3a\x01@\x82\x01Qa\x01@\x86\x01\x90a\"\xEDV[\x01Q\x91\x01\x90a\"\xEDV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a$\x02\x81a\x05\xB3V[a$\naq\xFEV[P\x16_R`\x10` Ra\x0B\xBD`@_ a%ea%[`\x02a$*a'uV[\x93a$ra$b\x82Ta$Sa$F\x82`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16\x89RV[`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x16` \x87\x01RV[a$\xF9a$\xE9`\x01\x83\x01Ta$\xA0a$\x90\x82`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16`@\x8A\x01RV[a$\xC2`@\x82\x90\x1C`\x01`\x01`@\x1B\x03\x16[`\x01`\x01`@\x1B\x03\x16``\x8A\x01RV[a$\xE3`\x80\x82\x90\x1C`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`\x80\x8A\x01RV[`\xC0\x1C\x90V[`\x01`\x01`@\x1B\x03\x16`\xA0\x87\x01RV[\x01Tc\xFF\xFF\xFF\xFF\x81\x16`\xC0\x85\x01Rc\xFF\xFF\xFF\xFF` \x82\x90\x1C\x16`\xE0\x85\x01Rc\xFF\xFF\xFF\xFF`@\x82\x90\x1C\x16a\x01\0\x85\x01Ra%=``\x82\x90\x1C`\xFF\x16a\x01 \x86\x01argV[a%R`h\x82\x90\x1C`\xFF\x16a\x01@\x86\x01arpV[`p\x1C`\xFF\x16\x90V[a\x01`\x83\x01arpV[`@Q\x91\x82\x91\x82a\"\xF7V[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFWa%\x89a\x8FTV[_\x80Q` a\xC9\x07\x839\x81Q\x91RT`\xFF\x81\x16\x15a%\xE0W`\xFF\x19\x16_\x80Q` a\xC9\x07\x839\x81Q\x91RU\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[c\x8D\xFC +`\xE0\x1B_R`\x04_\xFD[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a&\x14\x81a\x05\xB3V[a&\x1D\x81a\x86|V[\x80T`\x01`\x01`\xA0\x1B\x03\x163\x03a&bW`\x02\x01\x80Tb\xFF\0\0\x19\x16\x90U\x16\x7F\xE1B\x86\xF3\xADI\xAD\xA6\xD0\x91\x1A\xDD\xA8\xEF\x90ai\x99\x04[\xDE*3\xE3\x91\xA7\xB5\xAEe\x89\xE7\x89_\x80\xA2\0[Pc#N\x07\x1D`\xE0\x1B_R\x16`\x04R3`$R`D_\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`\xE0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[a&zV[`\x80\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[`\xC0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[a\x01@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[``\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[`@Q\x90a\x05\xD1`\x80\x83a'6V[`@Q\x90a\x05\xD1`\xC0\x83a'6V[`@Q\x90a\x05\xD1a\x01\x80\x83a'6V[`@Q\x90a\x05\xD1`\xE0\x83a'6V[`@Q\x90a\x05\xD1``\x83a'6V[`@Q\x90a\x05\xD1a\x01@\x83a'6V[`@Q\x90a\x05\xD1`@\x83a'6V[\x90a\x05\xD1`@Q\x92\x83a'6V[`\x01`\x01`@\x1B\x03\x81\x11a&\xA9W`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x92\x91\x92a'\xF7\x82a'\xD0V[\x91a(\x05`@Q\x93\x84a'6V[\x82\x94\x81\x84R\x81\x83\x01\x11a\x05\xAFW\x82\x81` \x93\x84_\x96\x017\x01\x01RV[\x90\x80`\x1F\x83\x01\x12\x15a\x05\xAFW\x81` a\x0B\xE6\x935\x91\x01a'\xEBV[`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a(T\x81a\n\xAFV[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa(s\x906\x90`\x04\x01a(!V[\x90`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x81\x14\x90\x81\x15a)bW[Pa)SWa(\xB6a\x8F\xC3V[`@QcR\xD1\x90-`\xE0\x1B\x81R\x91` \x83`\x04\x81`\x01`\x01`\xA0\x1B\x03\x86\x16Z\xFA_\x93\x81a)2W[Pa(\xFFWcL\x9C\x8C\xE3`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04R`$_\xFD[\x90_\x80Q` a\xC8\xC7\x839\x81Q\x91R\x83\x03a)\x1EWa\0\x18\x92Pa\xBA\x94V[c*\x87Ri`\xE2\x1B_R`\x04\x83\x90R`$_\xFD[a)L\x91\x94P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[\x92_a(\xDEV[cp>F\xDD`\xE1\x1B_R`\x04_\xFD[_\x80Q` a\xC8\xC7\x839\x81Q\x91RT`\x01`\x01`\xA0\x1B\x03\x16\x14\x15\x90P_a(\xA9V[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x160\x03a)SW` `@Q_\x80Q` a\xC8\xC7\x839\x81Q\x91R\x81R\xF3[\x91\x90\x91`\xC0\x80`\xE0\x83\x01\x94\x80Qa)\xF1\x81a\"\xC7V[\x84R` \x81\x01Qa*\x01\x81a\"\xE3V[` \x85\x01Rc\xFF\xFF\xFF\xFF`@\x82\x01Q\x16`@\x85\x01Rc\xFF\xFF\xFF\xFF``\x82\x01Q\x16``\x85\x01R`\x80\x81\x01Q`\x80\x85\x01R`\x01`\x01`@\x1B\x03`\xA0\x82\x01Q\x16`\xA0\x85\x01R\x01Q\x91\x01RV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a*o\x81a\x05\xB3V[a*waryV[P\x16_R`\x06` Ra\x0B\xBD`@_ `\x03`@Q\x91a*\x96\x83a&\x8EV[a*\xEAa*\xDD\x82T`\xFF\x81\x16a*\xAB\x81a\"\xC7V[\x86Ra*\xC0`\xFF\x82`\x08\x1C\x16` \x88\x01arpV[c\xFF\xFF\xFF\xFF`\x10\x82\x90\x1C\x16`@\x87\x01R[`0\x1Cc\xFF\xFF\xFF\xFF\x16\x90V[c\xFF\xFF\xFF\xFF\x16``\x85\x01RV[`\x01\x81\x01T`\x80\x84\x01Ra+\x1Ba+\x0B`\x02\x83\x01T`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16`\xA0\x85\x01RV[\x01T`\xC0\x82\x01R`@Q\x91\x82\x91\x82a)\xDBV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a+K\x81a\x05\xB3V[a+T\x81a\x98\xDCV[\x80T`@\x1C`\x01`\x01`\xA0\x1B\x03\x163`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x03a,OW`\x02\x81\x01\x80T`\xFF`p\x1B\x19\x16`\x01`q\x1B\x17\x90Ua,\x07\x90`\x01\x90a+\xF9\x90a\x159\x90\x80\x84\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16B`\x80\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x90U`\x01`\x01`@\x1B\x03\x86\x16\x7F?\xD5X\xA5\x9B\xBC\xE1\xD9\x96\xD1~\xAB\x7F\xDE1K\xCD \x1E\xC3\xF1su\xA7\xF8s\xB3\x16)'\xE8\x81_\x80\xA2T`\x01`\x01`@\x1B\x03\x16\x90V[\x01T`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16a,\x18W\0[`@Qc\n$\xE8\xA9`\xE4\x1B` \x82\x01R`\x01`\x01`@\x1B\x03\x90\x91\x16`$\x82\x01R3`D\x82\x01Ra\0\x18\x91a\t\x9A\x82`d\x81\x01a\t\x8CV[c\x0C\xD5g\xCF`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R3`$R`D_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `\xFF_\x80Q` a\xC9\x07\x839\x81Q\x91RT\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xAFWa,\xAB6a\x19\xC7V[`\x01`\x01`\xA0\x1B\x03a,\xBC\x83a\x98\xDCV[T`@\x1C\x163\x03a,\xEEW`\x01`\x01`@\x1B\x03a\0\x18\x92\x16_R`\x13` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16\x90a\xB3\xDCV[`\x01`\x01`@\x1B\x03\x82c\x0C\xD5g\xCF`\xE1\x1B_R\x16`\x04R3`$R`D_\xFD[a\x05\xD1\x90\x92\x91\x92a\x01`\x80a\x01\x80\x83\x01\x95a-2\x84\x82Q`\x01`\x01`@\x1B\x03\x16\x90RV[` \x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x85\x01R`@\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R``\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R`\x80\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01R`\xA0\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01R`\xC0\x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x85\x01R`\xE0\x81\x01Q`\xE0\x85\x01Ra-\xBCa\x01\0\x82\x01Qa\x01\0\x86\x01\x90a\"\xD6V[a\x01 \x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01Ra\x01@\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01R[\x01Q\x15\x15\x91\x01RV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a.\r\x81a\x05\xB3V[a.\x15aq\xFEV[P\x16_R`\t` Ra\x0B\xBD`@_ a/\x1Ea/\x14`\x04a.5a'uV[\x93a.Qa$b\x82Ta$Sa$F\x82`\x01`\x01`@\x1B\x03\x16\x90V[a.\xB9a.\xAC`\x01\x83\x01Ta.oa$\x90\x82`\x01`\x01`@\x1B\x03\x16\x90V[a.\x85`@\x82\x90\x1C`\x01`\x01`@\x1B\x03\x16a$\xB2V[a.\xA0`\x80\x82\x90\x1Cc\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16`\x80\x8A\x01RV[`\xA0\x1Cc\xFF\xFF\xFF\xFF\x16\x90V[c\xFF\xFF\xFF\xFF\x16`\xA0\x87\x01RV[`\x02\x81\x01T`\x01`\x01`\xA0\x1B\x03\x16`\xC0\x86\x01R`\x03\x81\x01T`\xE0\x86\x01R\x01Ta.\xE9`\xFF\x82\x16a\x01\0\x86\x01argV[c\xFF\xFF\xFF\xFF`\x08\x82\x90\x1C\x16a\x01 \x85\x01Rc\xFF\xFF\xFF\xFF`(\x82\x90\x1C\x16a\x01@\x85\x01R`H\x1C`\xFF\x16\x90V[\x15\x15a\x01`\x83\x01RV[`@Q\x91\x82\x91\x82a-\x0EV[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a/G\x81a\x05\xB3V[`$5a/S\x81a\x1E^V[a/[a\x87\x0FV[a/ca\x876V[a/l\x82a\x90xV[`\x04\x81\x01T`H\x1C`\xFF\x16a1\x90W_\x91_[a/\x9A\x85`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[T\x81\x10\x15a1\x88Wa\x0F\xF0a/\xE3a/\xCC\x83a/\xC7\x89`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[al$V[\x90T3\x93`\x03\x92\x90\x92\x1B\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x14a/\xF0W`\x01\x01a/\x7FV[P\x90\x91P`\x01[\x15a\x12\xA7Wa0\x1Ea\x15\xE23a\x08\xCA\x86`\x01`\x01`@\x1B\x03\x16_R`\x0C` R`@_ \x90V[a1hWa0Da\x16%3a\x08\xCA\x86`\x01`\x01`@\x1B\x03\x16_R`\x0C` R`@_ \x90V[a0\xC7`\x01a+\xF9a\x159\x82\x86\x01\x95a0\x8Ba0ka\x11\x91\x89Tc\xFF\xFF\xFF\xFF\x90`\xA0\x1C\x16\x90V[\x88Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\xA0\x91\x90\x91\x1Bc\xFF\xFF\xFF\xFF`\xA0\x1B\x16\x17\x88UV[3`\x01`\x01`@\x1B\x03\x89\x16\x7F\xCE\xDA\x1AD\xEA\xD4\xDA=:\xBA\xAA\x94\x1A\xFAm\x950\xFD\x84\xDD\x8E\x998\\\x91\x83\xD9\x86\xDC\xAB\x98\x0F_\x80\xA3T`\x01`\x01`@\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16a1!W[PPTc\xFF\xFF\xFF\xFFa1\x03a0\xFA`\xA0\x84\x90\x1C\x83\x16[\x93`\x80\x1Cc\xFF\xFF\xFF\xFF\x16\x90V[c\xFF\xFF\xFF\xFF\x16\x90V[\x91\x16\x14a1\x12Wa\0\x18a\x87nV[a1\x1B\x90a\x92\xF7V[_a\x12\x03V[`@Qc,Vz\xCD`\xE2\x1B` \x82\x01R3`$\x82\x01R`\x01`\x01`@\x1B\x03\x85\x16`D\x82\x01R`\xFF\x90\x91\x16`d\x82\x01Ra1a\x91a\t\x9A\x82`\x84\x81\x01a\t\x8CV[_\x80a0\xD7V[c\x0F+\xB0\xF1`\xE4\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R3`$R`D_\xFD[P\x90\x91a/\xF7V[c% H\xA3`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`$_\xFD[4a\x05\xAFW` `\x01`\x01`@\x1B\x03a1\xE9\x81a1\xC86a\x19\xC7V[\x91\x16_R`\x07\x84R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[T\x16\x15\x15`@Q\x90\x81R\xF3[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a2\x12\x81a\x05\xB3V[a2\x1Aa\x876V[a2#\x81a\x98\xDCV[`\x02\x81\x01\x90\x81T`\x01a2:\x82`\xFF\x90``\x1C\x16\x90V[a2C\x81a\"\xC7V[\x03a\x14=Wc\xFF\xFF\xFF\xFFa2ca0\xFA\x83\x83\x16\x93` \x1Cc\xFF\xFF\xFF\xFF\x16\x90V[\x91\x16\x11\x15a\x14=Wa2\x89a\x08k\x84`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x90a2\x9Ca\x15\x8A\x83T`\xFF\x90`\x90\x1C\x16\x90V[a4/Wa2\xB6a\x159`\x01\x92T`\x01`\x01`@\x1B\x03\x16\x90V[\x01\x80T\x90\x92\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a3\xB4W[P\x81Th\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`P\x1B\x19\x16B`P\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`P\x1B\x16\x17\x90\x91Ua3'\x90a3\x153a\x08\xFF\x86`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[Pa\x11\x96a\t\x13\x82Tc\xFF\xFF\xFF\xFF\x16\x90V[a3j`@Q\x913`\x01`\x01`@\x1B\x03\x85\x16\x7F\x8C\xE5>K`\x02\xFF\t\x0Ed\x1D\xDE\xCD\xAF~\xDD(\x13\xA9\x8E\x19\x13\x9F\xA7\xD1\xC7\x9F\xCC\xC3\xC4\xDE\xAD_\x80\xA3T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16a3\x80Wa\0\x18a\x87nV[c\x96]#\x1B`\xE0\x1B` \x83\x01R`\x01`\x01`@\x1B\x03\x90\x92\x16`$\x82\x01R3`D\x82\x01Ra\x12N\x91a\t\x9A\x82`d\x81\x01a\t\x8CV[a3\xC6\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qcr\x8Co;`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x86\x16`\x04\x82\x01R3`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90Z\xFA_\x91\x81a4\x0EW[P\x15a2\xCBW\x15a\x12\xA7W_a2\xCBV[a4(\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_a3\xFDV[cx4\x82\xE9`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R3`$R`D_\xFD[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a4l\x81a\n\xAFV[a4ta\x8E\xE5V[` \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\0[4a\x05\xAFWa\x0B\xBDa4\xDE`\x01`\x01`@\x1B\x03a4\xB26a\x19\xC7V[\x91\x90a4\xBCar\xD3V[P\x16_R`\x07` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[`\xFF`@Q\x91a4\xED\x83a&\xAEV[T`\x01`\x01`@\x1B\x03\x81\x16\x83R`\x01`\x01`@\x1B\x03\x81`@\x1C\x16` \x84\x01R\x81\x81`\x80\x1C\x16\x15\x15`@\x84\x01R`\x88\x1C\x16\x15\x15``\x82\x01R`@Q\x91\x82\x91\x82\x91\x90\x91``\x80`\x80\x83\x01\x94`\x01`\x01`@\x1B\x03\x81Q\x16\x84R`\x01`\x01`@\x1B\x03` \x82\x01Q\x16` \x85\x01R`@\x81\x01Q\x15\x15`@\x85\x01R\x01Q\x15\x15\x91\x01RV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a5\x88\x81a\x05\xB3V[a5\x90a\x876V[a5\x99\x81a\x90xV[`\x04\x81\x01\x90a5\xAD\x82T`\xFF\x90`H\x1C\x16\x90V[a1\x90W_\x91_[a5\xD0\x85`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[T\x81\x10\x15a6\xFBWa\x0F\xF0a5\xFDa/\xCC\x83a/\xC7\x89`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[\x14a6\nW`\x01\x01a5\xB5V[P\x90\x91P`\x01[\x15a\x12\xA7Wa+\xF9a\x159a6\xA6\x93a6?`\x01\x94i\x01\0\0\0\0\0\0\0\0\0`\xFF`H\x1B\x19\x82T\x16\x17\x90UV[\x80Ta6j\x90`@\x1C`\x01`\x01`\xA0\x1B\x03\x16`\x02\x83\x01T`\x01`\x01`\xA0\x1B\x03\x16`\x03\x84\x01T\x91a\xA4,V[3`\x01`\x01`@\x1B\x03\x87\x16\x7F\xC60P\xB9c\xECn,\xF3m\xF9\x0E\xCA\xCA\xA42\x12\xC0\xE7K\x8C:X\xA0\xF8\xCC\xE3\xBDZ*vu_\x80\xA3T`\x01`\x01`@\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16a6\xBDWa\0\x18a\x87nV[`@Qc\x199\xA9C`\xE3\x1B` \x82\x01R3`$\x82\x01R`\x01`\x01`@\x1B\x03\x90\x91\x16`D\x82\x01Ra6\xF4\x91a\t\x9A\x82`d\x81\x01a\t\x8CV[_\x80a\x12\x03V[P\x90\x91a6\x11V[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u\x81R\xF3[4a\x05\xAFWa7K6a\x06%V[`\x01`\x01`@\x1B\x03\x83\x92\x93\x16_R`\x1D` R`\x01\x80`\xA0\x1B\x03`@_ T`@\x1C\x163\x14\x15\x80a7\xB2W[a7\x92Wa\0\x18\x92a7\x8A\x916\x91a'\xEBV[\x903\x90a\xA4UV[c\xDD,\x7F\xB7`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R3`$R`D_\xFD[P3_\x90\x81R_\x80Q` a\xC9G\x839\x81Q\x91R` R`@\x90 T`\xFF\x16\x15a7wV[4a\x05\xAFWa\x01 6`\x03\x19\x01\x12a\x05\xAFW`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa8\x08\x906\x90`\x04\x01a\x05\xF8V[PP`$5a8\x16\x81a\n\xAFV[`\xE06`C\x19\x01\x12a\x05\xAFWa\x0B\xBD\x90a8.a\x87\x0FV[`\x04T`\x01`\x01`@\x1B\x03\x16\x90a8ca8G\x83ah\xADV[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19`\x04T\x16\x17`\x04UV[a8\xE6a8naluV[a8\xBEa8yar\xF7V[a8\xB5a8\x84a'\x85V[3\x81R\x93`\x01`\x01`\xA0\x1B\x03\x87\x16` \x86\x01RB`\x01`\x01`@\x1B\x03\x16`@\x86\x01R_``\x86\x01R`\x80\x85\x01argV[`\xA0\x83\x01arpV[`\x01`\xC0\x82\x01R[a8\xE1\x84`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[as=V[a9\ta9\x04\x83`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[at(V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R3\x90`\x01`\x01`@\x1B\x03\x84\x16\x90\x7F+\x0Fj{\x1FZ\xFDx2\xE4\x99r\xF4\x0B\x9F\xCD\x16\x99\x890\xB2O6F\x9C\x91\x005\x02\xD0\xD9\x98\x90` \x90\xA3`\x01`\x01`\xA0\x1B\x03\x81\x16a9uW[P`@Q`\x01`\x01`@\x1B\x03\x90\x91\x16\x81R\x90\x81\x90` \x82\x01\x90V[`@Qc\x0Be5\xD7`\xE0\x1B` \x82\x01R`\x01`\x01`@\x1B\x03\x83\x16`$\x82\x01R3`D\x82\x01R0`d\x82\x01Ra9\xB1\x91a!!\x82`\x84\x81\x01a\t\x8CV[_a9ZV[\x80\x15\x15\x03a\x05\xAFWV[4a\x05\xAFW``6`\x03\x19\x01\x12a\x05\xAFW`\x045a9\xDE\x81a\x05\xB3V[`$5a9\xEA\x81a9\xB7V[`D5\x91a9\xF7\x83a\x0E\xB6V[a9\xFFa\x8E\xE5V[`\x01`\x01`@\x1B\x03\x81\x16a\x0E\x10\x81\x10\x90\x81\x15a;\x07W[Pa:\xECWa\xFF\xFF\x83\x16\x80\x15\x90\x81\x15a:\xFBW[Pa:\xECWa:\xE7\x7F3\xE0A\x141\0Z\x064p\xB5T\tNb\xF6\x97:\xA3_\xCE#\x0E\xAF]Z\0y\xBEN3\x9C\x93a:\xB9a:_a'\x94V[`\x01`\x01`@\x1B\x03\x85\x16\x80\x82R\x86\x15\x15` \x83\x01\x81\x90Ra\xFF\xFF\x85\x16`@\x93\x84\x01R`\x1C\x80Tj\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x92\x17\x92\x1B`\xFF`@\x1B\x16\x91\x90\x91\x17`H\x84\x90\x1Bj\xFF\xFF\0\0\0\0\0\0\0\0\0\x16\x17\x90UV[`@Q\x93\x84\x93\x84\x91`@\x91\x94\x93a\xFF\xFF\x91`\x01`\x01`@\x1B\x03``\x86\x01\x97\x16\x85R\x15\x15` \x85\x01R\x16\x91\x01RV[\x03\x90\xA1\0[c\xD8\xF2r}`\xE0\x1B_R`\x04_\xFD[a'\x10\x91P\x11_a:*V[b'\x8D\0\x91P\x11_a:\x16V[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW` a;j`\x045a;6\x81a\n\xAFV[`$5\x90a;C\x82a\n\xAFV[`\x01\x80`\xA0\x1B\x03\x16_R`\x19\x83R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[T`@Q\x90\x81R\xF3[4a\x05\xAFWa;\x816a\x19\xC7V[`\x01`\x01`\xA0\x1B\x03a;\x92\x83a\x98\xDCV[T`@\x1C\x163\x03a,\xEEW`\x01`\x01`@\x1B\x03a\0\x18\x92\x16_R`\x13` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16\x90a\xBA\x1BV[4a\x05\xAFWa\x0B\xBDa<\x0C`\x01`\x01`@\x1B\x03a;\xE06a\x19\xC7V[\x91\x90a;\xEAar\xD3V[P\x16_R`\x11` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[`\xFF`@Q\x91a<\x1B\x83a&\xAEV[Ta\xFF\xFF\x81\x16\x83R`\x01`\x01`@\x1B\x03\x81`\x10\x1C\x16` \x84\x01R`\x01`\x01`@\x1B\x03\x81`P\x1C\x16`@\x84\x01R`\x90\x1C\x16\x15\x15``\x82\x01R`@Q\x91\x82\x91\x82\x91\x90\x91``\x80`\x80\x83\x01\x94a\xFF\xFF\x81Q\x16\x84R`\x01`\x01`@\x1B\x03` \x82\x01Q\x16` \x85\x01R`\x01`\x01`@\x1B\x03`@\x82\x01Q\x16`@\x85\x01R\x01Q\x15\x15\x91\x01RV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFWa<\xB3a\x8FTV[a<\xBBa\x87\x0FV[`\x01`\xFF\x19_\x80Q` a\xC9\x07\x839\x81Q\x91RT\x16\x17_\x80Q` a\xC9\x07\x839\x81Q\x91RU\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\0[4a\x05\xAFWa=\x1A6a\x19\xC7V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x91\x90\x82\x15a=\xB6Wa=5\x82a\x86|V[\x80T\x90\x91\x903`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a=\x96W\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x17\x90\x92U\x16\x90`\x01`\x01`@\x1B\x03\x16\x7F\xD2\xB9X\xA1\xB0\xB9x\xCE\xDE\xD4\x98kOI\xC8\xB2_\xBDn\x81,\xB8\x92^\x13\xEF\xC71\xEAJ\xA2M_\x80\xA4\0[`\x01`\x01`@\x1B\x03\x84c#N\x07\x1D`\xE0\x1B_R\x16`\x04R3`$R`D_\xFD[c\xD9.#=`\xE0\x1B_R`\x04_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q\x7FLpp\xC6\xC1\x9C\xC9\xB4'\xB9O\xE5\x97\x9E\xE0\xC5s\xF8\xED\xD0\r%Y\x1A\xFEL\x95\x10\xDE\x94y\xBA\x81R\xF3[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a>$\x81a\x05\xB3V[\x16_R`\x08` R` `@_ T`@Q\x90\x81R\xF3[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW` `\xFFa>\x8D`$5`\x045a>b\x82a\n\xAFV[_R_\x80Q` a\xC8\xE7\x839\x81Q\x91R\x84R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[T\x16`@Q\x90\x15\x15\x81R\xF3[` `\x03\x19\x82\x01\x12a\x05\xAFW`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFWa\x06]\x91`\x04\x01a\n\x7FV[4a\x05\xAFWa>\xD16a>\x99V[a>\xDA\x81ah\xCAV[\x91_\x91_[\x81\x81\x10a?:WPPPa>\xF2\x81ah\xCAV[\x91_[\x82\x81\x10a?\nW`@Q\x80a\x0B\xBD\x86\x82a\x0B\xE9V[\x80a?4a?*a?\x1D`\x01\x94\x86ai2V[Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x0C\xD9\x83\x88ai2V[\x01a>\xF5V[\x80a?Za?K`\x01\x93\x85\x87at\xEEV[5a?U\x81a\x05\xB3V[a\xA5zV[a?eW[\x01a>\xDFV[a?p\x81\x84\x86at\xEEV[5a?z\x81a\x05\xB3V[`\x01`\x01`@\x1B\x03a?\x95a?\x8E\x88at\xFEV[\x97\x89ai2V[\x91\x16\x90Ra?_V[`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a?\xB6\x81a\x05\xB3V[`$5a?\xC1a\x876V[`\x02a?\xCC\x83a\x98\xDCV[\x01T`\x01`p\x82\x90\x1C`\xFF\x16a?\xE1\x81a\"\xE3V[\x03a@\xA6W`\x01\x90`h\x1C`\xFF\x16a?\xF8\x81a\"\xE3V[\x03a\x14=W\x7F\xD2\x8D\xE7\xC5\x18\xC3\x12\xFA8\x8E\x03\xF8\xD1 =\x8FLu\x16\x1E5\x8F\xFB\x08'\xB6\xCA\xA2\xE9\xAC\x8A1`\x01`\x01`@\x1B\x03a@A\x84`\x01`\x01`@\x1B\x03\x16_R`\x14` R`@_ \x90V[\x80Ta@Z\x90`\x01`\x01`\xA0\x1B\x03\x16\x91\x85\x834\x92a\xA6ZV[`\x01`\x01`\xA0\x1B\x03\x16\x93\x84\x15\x80a@\x9DW[a@\x85W[`@Q\x93\x84R\x16\x91` \x90\xA3a\0\x18a\x87nV[a@\x98a@\x92\x854au\x1AV[3a\xA6\xECV[a@qV[P\x834\x11a@lV[c\t\x8B\xFC[`\xE3\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`$_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q_\x81R\xF3[`\xE06`\x03\x19\x01\x12a\x05\xAFW`\x045a@\xF4\x81a\x05\xB3V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaA\x13\x906\x90`\x04\x01a\n\x7FV[\x91`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaA3\x906\x90`\x04\x01a\x05\xF8V[\x92\x90\x93`d5\x93`\x01`\x01`@\x1B\x03\x85\x11a\x05\xAFWa\x0B\xBD\x95aA]a\x0B\xA3\x966\x90`\x04\x01a\n\x7FV[\x92\x90\x91aAha\x05\xE0V[\x94aAqa\n\xCDV[\x96`\xC45\x98au'V[4a\x05\xAFW` `\xFFaA\xB9`\x01`\x01`@\x1B\x03aA\x986a\x19\xC7V[\x91\x16_R`\x11\x84R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[T`\x90\x1C\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045aA\xE5\x81a\x05\xB3V[aA\xEDa\x876V[aB\x08\x81`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[\x90aB\x15a\x15\x8A\x83a\x8E\x9BV[aD\xA8W\x81T\x90`\x01`\x01`@\x1B\x03\x82\x16\x90` aBD\x83`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[_T\x90\x93\x90aB_\x90a\x1B\x1B\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x94aBq\x85T`\x01`\x01`@\x1B\x03\x16\x90V[`\x03\x88\x01T`\x04\x80\x8A\x01T`@Qc\x08\xD7\x95\xD5`\xE4\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x9A\x90\x9A\x16\x91\x8A\x01\x91\x90\x91R`\x01`\x01`@\x1B\x03\x92\x83\x16`$\x8A\x01R\x93\x90\x91\x16`D\x88\x01R`d\x87\x01R`\x84\x86\x01\x91\x90\x91R\x84\x90`\xA4\x90\x82\x90_\x90Z\xF1\x92\x83\x15a\x13cW_\x93aDrW[Pa+\xF9a\x159aC\0\x93aB\xF2\x86`\x01\x95a\xA7\xBEV[PT`\x01`\x01`@\x1B\x03\x16\x90V[\x91`\x01`\x01`\xA0\x1B\x03\x83\x16aC,W[a\x0B\xBD\x82aC\x1Ca\x87nV[`@Q\x90\x81R\x90\x81\x90` \x82\x01\x90V[_TaC@\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x90T`@\x80Qc\x1C\x9D\x11\xBD`\xE3\x1B\x81R\x90\x82\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16`\x04\x82\x01\x81\x90R\x94\x90\x92` \x90\x84\x90`$\x90\x82\x90Z\xFA\x80\x15a\x13cWa\x0B\xBD\x95a\t\x8Ca\x1C\xA2\x94a\t\x9A\x93aD2\x97_\x91aDSW[P\x80\x15aDJWa\x1CCaC\xBA\x91aC\xB4\x8BaC\xAE\x81ao#V[\x92au\xC0V[\x90aodV[a'\x10a\xFF\xFF\x82\x16\x11aDAW[a\x1CjaC\xDA\x91a\xFF\xFF`d\x91\x16\x04\x90V[\x90`d`\xFF\x83\x16\x11aD8W[aD\x16\x90`\x01`\x01`@\x1B\x03\x16\x93`@Q\x97\x88\x91` \x83\x01`\x14\x91`\x01`\x01``\x1B\x03\x19\x90``\x1B\x16\x81R\x01\x90V[`@Qc~\x14\xB9\x19`\xE0\x1B` \x82\x01R\x95\x86\x93`$\x85\x01aosV[_aC\x10V[`d\x91PaC\xE7V[Pa'\x10aC\xC8V[Pa'\x10aC\xBAV[aDl\x91P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[_aC\x93V[`\x01\x91\x93Pa\x159aC\0\x93aB\xF2aD\x9Ca+\xF9\x94` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[\x96\x94PP\x93PPaB\xDBV[c\xB4\x8B\tY`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x16`\x04R`$_\xFD[4a\x05\xAFWa\x0B\xBDaE/`\x01`\x01`@\x1B\x03aD\xDF6a\x0B\xC1V[\x91\x90_`\xA0`@QaD\xF0\x81a&\xC9V[\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x01R\x16_R`\x16` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[aE\xBBaE\xB2`\x03`@Q\x93aED\x85a&\xC9V[\x80T`\xFF\x81\x16\x86R`\x08\x81\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16` \x87\x01RaE\x7F\x90`\xA8\x1C`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`@\x87\x01RV[aE\xA0aE\x93`\x01\x83\x01Tc\xFF\xFF\xFF\xFF\x16\x90V[c\xFF\xFF\xFF\xFF\x16``\x87\x01RV[`\x02\x81\x01T`\x80\x86\x01R\x01T`\xFF\x16\x90V[\x15\x15`\xA0\x83\x01RV[`@Q\x91\x82\x91\x82\x91\x90\x91`\xA0\x80`\xC0\x83\x01\x94`\xFF\x81Q\x16\x84R`\x01\x80\x83\x1B\x03` \x82\x01Q\x16` \x85\x01R`\x01`\x01`@\x1B\x03`@\x82\x01Q\x16`@\x85\x01Rc\xFF\xFF\xFF\xFF``\x82\x01Q\x16``\x85\x01R`\x80\x81\x01Q`\x80\x85\x01R\x01Q\x15\x15\x91\x01RV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW`\x80`\x02Ta\xFF\xFF`@Q\x91\x81\x81\x16\x83R\x81\x81`\x10\x1C\x16` \x84\x01R\x81\x81` \x1C\x16`@\x84\x01R`0\x1C\x16``\x82\x01R\xF3[4a\x05\xAFW``6`\x03\x19\x01\x12a\x05\xAFWaFy`\x045a\x05\xB3V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaF\x98\x906\x90`\x04\x01a\n\x7FV[\x90`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaF\xB8\x906\x90`\x04\x01a\n\x7FV[\x90\x91aF\xC2a\x87\x0FV[aF\xCAa\x876V[\x81\x84\x03aKHWaF\xEE`\x045`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[aG\x02a\x159\x82T`\x01`\x01`@\x1B\x03\x16\x90V[_[\x86\x81\x10aG\x13Wa\0\x18a\x87nV[aG[aG3`\x045`\x01`\x01`@\x1B\x03\x16_R`\x16` R`@_ \x90V[aGFaGA\x84\x8B\x89at\xEEV[at\x1EV[`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[aG\x82a\x15\x8Aa\x0F\xB73a\x08\xCA`\x045`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[aK$W`\x03\x81\x01T`\xFF\x16aJ\xF0WaG\xC8a\x15\xE2\x89a\x08\xCAaG\xB9`\x045`\x01`\x01`@\x1B\x03\x16_R`\x17` R`@_ \x90V[aGFaGA\x883\x95\x8Dat\xEEV[aJ\xB8W\x90`\x01\x91aH\x07a\x16%\x87a\x08\xCA\x8CaGFaGA\x88aG\xFF`\x045`\x01`\x01`@\x1B\x03\x16_R`\x17` R`@_ \x90V[\x933\x96at\xEEV[aH5aH\x1Da\x11\x91\x85\x84\x01Tc\xFF\xFF\xFF\xFF\x16\x90V[\x84\x83\x01\x90c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90UV[\x82\x84\x01T\x88\x90\x87\x90`\x01`\x01`\xA0\x1B\x03\x16\x89\x8C\x86\x83aJ.W[\x92P\x90PaHa\x93PaGA\x92at\xEEV[aHl\x83\x89\x8Bau\xCDV[\x90\x7F\x8A\x04\xF9\x9F\xE22\x84\xE8t\xE8\xDD\x01sE$\x82y\xCCYp\x16\x95\xE7;\xCD\xBE\xB6$\x1B\xCD*\xC6`@Q\x80aH\xB4`\x01`\x01`@\x1B\x033\x97\x16\x95`\x01`\x01`@\x1B\x03`\x045\x16\x95\x83ag\xF1V[\x03\x90\xA4\x83\x83\x01T\x83\x90aH\xCF\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x80aI\xB5W[Pc\xFF\xFF\xFF\xFF\x80aH\xEC\x86\x85\x01Tc\xFF\xFF\xFF\xFF\x16\x90V[\x92\x16\x91\x16\x10\x15\x80aI\x9EW[aI\x04W[P\x01aG\x04V[`\x03\x81\x01\x80T`\xFF\x19\x16`\x01\x17\x90U`\x01`\x01`@\x1B\x03aI)aGA\x84\x8C\x8Aat\xEEV[\x16`\x01`\x01`@\x1B\x03`\x045\x16\x7F`\xA7d\x9Fn\x93\xE7\xA3\xCE\x1D\xC9r\x9C \xE3\xD9]\xCE(\xC6\xA6\xBD\x95|\xDE\t\xD8\xA1\xCB7\xC1\x9F_\x80\xA3`\x02\x85\x81\x01T`h\x1C`\xFF\x16aIo\x81a\"\xE3V[\x14\x80aI\x91W[\x15aH\xFDW`\x02aI\x8B\x91\x01T`\x045a\x99\x8EV[_aH\xFDV[P`\x02\x81\x01T\x15\x15aIvV[PaI\xB0a\x15\x8A`\x03\x83\x01T`\xFF\x16\x90V[aH\xF8V[\x82T`@Qc\x13\x11\x0F\x81`\xE2\x1B\x81R`\x04\x805`\x01`\x01`@\x1B\x03\x16\x90\x82\x01R`\xFF\x90\x91\x16`$\x82\x01R\x90` \x90\x82\x90`\x01`\x01`\xA0\x1B\x03\x16\x81\x80`D\x81\x01\x03\x91Z\xFA_\x91\x81aJ\x0EW[P\x15aH\xD5W\x90P_aH\xD5V[aJ'\x91\x92P` =\x81\x11a\x18\x18Wa\x18\t\x81\x83a'6V[\x90_aJ\0V[aJ\xAD\x95aJ\x8Ba\t\x8C\x92a\t\x9A\x95aJ\x85aJK\x8CT`\xFF\x16\x90V[\x99aGFaGA\x85aJaaGA\x82\x8D\x87at\xEEV[\x9AaJ\x7F`\x045`\x01`\x01`@\x1B\x03\x16_R`\x18` R`@_ \x90V[\x94at\xEEV[\x93au\xCDV[\x91`@Q\x97\x88\x95c\xC4\x0C\x80\xD1`\xE0\x1B` \x88\x01R3\x91`\x045`$\x89\x01an\rV[\x87\x86_\x89\x8C\x86aHOV[a\x07eaJ\xC9aGA\x84\x8B\x89at\xEEV[c[\xF3\xFEw`\xE1\x1B_R`\x01`\x01`@\x1B\x03`\x04\x805\x82\x16\x90R\x16`$R3`DR`d\x90V[a\x07eaK\x01aGA\x84\x8B\x89at\xEEV[c\nUQ/`\xE0\x1B_R`\x01`\x01`@\x1B\x03`\x04\x805\x82\x16\x90R\x16`$R`D\x90V[cx4\x82\xE9`\xE0\x1B_\x90\x81R`\x04\x805`\x01`\x01`@\x1B\x03\x16\x90R3`$R`D\x90\xFD[c\x1F\xECgG`\xE3\x1B_R`\x04_\xFD[`@Q\x90aKf` \x83a'6V[_\x82RV[\x80Q\x80\x83R` \x92\x91\x81\x90\x84\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[\x90` a\x0B\xE6\x92\x81\x81R\x01\x90aKkV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFWa\x0B\xBD`@QaK\xC1`@\x82a'6V[`\x05\x81Rd\x03R\xE3\x02\xE3`\xDC\x1B` \x82\x01R`@Q\x91\x82\x91` \x83R` \x83\x01\x90aKkV[4a\x05\xAFWaK\xF56a>\x99V[\x90aK\xFEa\x876V[_\x91_\x91_[\x82\x81\x10aL&W\x83\x85aL\x15a\x87nV[`@\x80Q\x91\x82R` \x82\x01\x92\x90\x92R\xF3[aLNaL7aGA\x83\x86\x86at\xEEV[`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[\x90aL[a\x15\x8A\x83a\x8E\x9BV[aN\xB9W\x81T`\x01`\x01`@\x1B\x03\x81\x16\x96` aL\x89\x89`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[_T\x90\x99\x90aL\xB4\x90aL\xA4\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x94`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x93aL\xC6\x8BT`\x01`\x01`@\x1B\x03\x16\x90V[`\x03\x88\x01T`\x04\x80\x8A\x01T`@Qc\x08\xD7\x95\xD5`\xE4\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x99\x90\x99\x16\x91\x89\x01\x91\x90\x91R`\x01`\x01`@\x1B\x03\x92\x83\x16`$\x89\x01R\x93\x90\x91\x16`D\x87\x01R`d\x86\x01R`\x84\x85\x01\x91\x90\x91R\x83\x90`\xA4\x90\x82\x90_\x90Z\xF1\x91\x82\x15a\x13cW\x86\x86\x85\x92_\x95aNpW[PaMkaMe\x86aMy\x96aM_\x82aMZaGA`\x01\x9Aa+\xF9\x9Aa\x159\x9Aat\xEEV[a\xA7\xBEV[Pau\xC0V[\x9Aat\xFEV[\x9AT`\x01`\x01`@\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16aM\x99W[PP`\x01\x91P[\x01\x93\x92\x93aL\x04V[_TaM\xAD\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x93T\x91`@\x83\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16`@Qc\x1C\x9D\x11\xBD`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R\x95\x90\x92\x90` \x90\x87\x90\x81\x80`$\x81\x01\x03\x91Z\xFA\x92\x83\x15a\x13cWa\t\x8CaN9\x95a\x1C\xA2\x95a\t\x9A\x94`\x01\x9A_\x92aNPW[P\x81\x15aN@WaN.a\x1CCaC\xDA\x93aC\xB4\x84aC\xAEa\x1Cj\x96ao#V[a\xFF\xFF`d\x91\x16\x04\x90V[_\x80aM\x89V[PPaC\xDAa\x1Cja'\x10aN.V[aNi\x91\x92P` =\x81\x11a\x13\\Wa\x13M\x81\x83a'6V[\x90_aN\rV[`\x01\x93\x95PaMea+\xF9\x93aMy\x96aM_a\x159\x95aMZaGAaN\xA7aMk\x98` =\x81\x11a\x13\\Wa\x13M\x81\x83a'6V[\x9C\x9APPP\x95PP\x96P\x93PPaM4V[`\x01\x91P\x94\x93\x94aM\x90V[\x81Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R` \x80\x84\x01Q\x90\x91\x16\x90\x82\x01R`@\x80\x83\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x82\x01R``\x80\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x82\x01R`\x80\x82\x01Q`\xE0\x82\x01\x93\x92a\x05\xD1\x92\x91`\xC0\x91\x82\x91aO\"\x81a\"\xC7V[`\x80\x85\x01Ra-\xDF`\xA0\x82\x01Q`\xA0\x86\x01\x90a\"\xEDV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045aO^\x81a\x05\xB3V[aOfaryV[P\x16_R`\x05` Ra\x0B\xBD`@_ aP\x03aO\xFA`\x02`@Q\x93aO\x8B\x85a&\x8EV[\x80T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x86R`\x01\x82\x01T\x90\x81\x16` \x87\x01RaO\xCB\x90aE\x93\x90aO\xC5`\xA0\x82\x90\x1C`\x01`\x01`@\x1B\x03\x16a$\x90V[`\xE0\x1C\x90V[\x01TaO\xDD`\xFF\x82\x16`\x80\x86\x01argV[aO\xF1`\x08\x82\x90\x1C`\xFF\x16`\xA0\x86\x01arpV[`\x10\x1C`\xFF\x16\x90V[\x15\x15`\xC0\x83\x01RV[`@Q\x91\x82\x91\x82aN\xC5V[4a\x05\xAFW`\x806`\x03\x19\x01\x12a\x05\xAFWaP(a\x8E\xE5V[`@QaP4\x81a&\xAEV[`\x045\x90aPA\x82a\x0E\xB6V[\x81\x81R`$5\x90aPQ\x82a\x0E\xB6V[\x81` \x82\x01Ra\xFF\xFF\x80`D5\x94aPh\x86a\x0E\xB6V[`@\x84\x01\x95\x86R```d5\x94aP~\x86a\x0E\xB6V[\x01\x93\x84R\x16\x92\x16\x82\x01\x80\x92\x11aP\xD8WaP\xADa\x1CCaP\xB3aP\xBC\x94aP\xADa\x1CCa'\x10\x98Qa\xFF\xFF\x16\x90V[\x90au\xC0V[\x92Qa\xFF\xFF\x16\x90V[\x03aP\xC9Wa\0\x18av\x0EV[cCtOq`\xE0\x1B_R`\x04_\xFD[ag\x83V[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90_[\x81\x81\x10aP\xFAWPPP\x90V[\x82Q`\x01`\x01`\xA0\x1B\x03\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01aP\xEDV[\x90` a\x0B\xE6\x92\x81\x81R\x01\x90aP\xDDV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045aQO\x81a\x05\xB3V[\x16_R`\x12` R`@_ `@Q\x90\x81` \x82T\x91\x82\x81R\x01\x91_R` _ \x90_[\x81\x81\x10aQ\x96Wa\x0B\xBD\x85aQ\x8A\x81\x87\x03\x82a'6V[`@Q\x91\x82\x91\x82aQ\x19V[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01aQsV[4a\x05\xAFW``6`\x03\x19\x01\x12a\x05\xAFW`\x045aQ\xC9\x81a\n\xAFV[`$5\x90aQ\xD6\x82a\n\xAFV[`D5aQ\xE2\x81a\n\xAFV[_\x80Q` a\xC9g\x839\x81Q\x91RT\x92`\x01`\x01`@\x1B\x03aR\x13`\xFF`@\x87\x90\x1C\x16\x15\x95`\x01`\x01`@\x1B\x03\x16\x90V[\x16\x80\x15\x90\x81aS,W[`\x01\x14\x90\x81aS\"W[\x15\x90\x81aS\x19W[PaS\nWaRr\x92\x84aRi`\x01`\x01`\x01`@\x1B\x03\x19_\x80Q` a\xC9g\x839\x81Q\x91RT\x16\x17_\x80Q` a\xC9g\x839\x81Q\x91RUV[aR\xD5Wa\xA8\x9BV[aRxW\0[aR\xA2`\xFF`@\x1B\x19_\x80Q` a\xC9g\x839\x81Q\x91RT\x16_\x80Q` a\xC9g\x839\x81Q\x91RUV[`@Q`\x01\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90\x80` \x81\x01a:\xE7V[aS\x05`\x01`@\x1B`\xFF`@\x1B\x19_\x80Q` a\xC9g\x839\x81Q\x91RT\x16\x17_\x80Q` a\xC9g\x839\x81Q\x91RUV[a\xA8\x9BV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[\x90P\x15_aR/V[0;\x15\x91PaR'V[\x85\x91PaR\x1DV[4a\x05\xAFWa\x01@6`\x03\x19\x01\x12a\x05\xAFW`\x045aSR\x81a\x05\xB3V[aS]`$5a\x05\xB3V[`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaS|\x906\x90`\x04\x01a\x05\xF8V[\x91\x90`d5\x906`\xC4\x11a\x05\xAFW6a\x01D\x11a\x05\xAFWaS\x9Ba\x87\x0FV[aS\xA3a\x876V[aS\xAC\x83a\x98\xDCV[\x93aS\xB9`$5\x85a\x99)V[\x94aS\xCEa\x159\x82T`\x01`\x01`@\x1B\x03\x16\x90V[\x91`\x03\x87\x01\x93aS\xDF\x85T`\xFF\x16\x90V[aW\xCDW`\x01\x84\x01T`\x01`\x01`\xA0\x1B\x03\x16_\x81aW>W[\x15aW\x0CWaT!\x90_\x90a\x1A,\x90\x8B\x90`\x01`\x01`\xA0\x1B\x03\x16\x80aVaW[PP\x88\x8Aa\xAA4V[\x80\x82\x10aV#WPP`\x845\x95`\xA45aT9a'\xB3V[\x97\x88R` \x88\x01R`@\x90aT\xE8a\x15\x8AaTS\x84a'\xC2V[`\xC4\x805\x82R\x9A`\xE45` \x83\x01RaTk\x86a'\xC2V[`@\x8D\x015\x81R``\x8D\x015` \x82\x01RaT\x84a'\xB3V[\x92\x83R` \x83\x01R\x8CaT\xE3aT\x9B6\x8B\x8Ba'\xEBV[\x80Q` \x91\x82\x01 \x89Q`\x01`\x01`\xC0\x1B\x03\x19`\xC0\x95\x86\x1B\x81\x16\x93\x82\x01\x93\x90\x93R`$5\x90\x94\x1B\x90\x91\x16`(\x84\x01R`0\x83\x01R\x81`P\x81\x01[\x03`\x1F\x19\x81\x01\x83R\x82a'6V[a\xBC\x9CV[aV\x14W`\x02\x97\x89aU\x0B`\x01\x8B\x99a+\xF9aU\x9A\x9C`\x01`\xFF\x19\x82T\x16\x17\x90UV[\x8C`\x01`\x01`\xA0\x1B\x03\x82\x16aU\xD1W[PP\x7F\xE6\xFC\xB34*\xBEC\xC2\x1A\xCCj\x04\xE3\xD7\x91$v\x83iv\xE0~\xD4}\x0B\x15\xA3t\xE2\0\xE2\xF0\x91P`\x01`\x01`@\x1B\x03\x16\x93\x84\x92aUh`\x01`\x01`@\x1B\x03`$5\x16\x97\x88\x96Q\x93\x84\x93\x84aw\x19V[\x03\x90\xA3\x7F`\xA7d\x9Fn\x93\xE7\xA3\xCE\x1D\xC9r\x9C \xE3\xD9]\xCE(\xC6\xA6\xBD\x95|\xDE\t\xD8\xA1\xCB7\xC1\x9F_\x80\xA3\x01T`h\x1C`\xFF\x16\x90V[aU\xA3\x81a\"\xE3V[\x14\x80aU\xC4W[aU\xB6Wa\0\x18a\x87nV[`\x02a6\xF4\x92\x01T\x90a\x99\x8EV[P`\x02\x82\x01T\x15\x15aU\xAAV[aV\x0B\x93a\t\x8CaU\xE6a\t\x9A\x93T`\xFF\x16\x90V[\x91`\x84\x88\x8C\x8C\x8CQ\x99\x8A\x97c\x15\x8B\xB2\xEB`\xE0\x1B` \x8A\x01R`$5\x91`$\x8A\x01av\xCCV[_\x89\x81\x8CaU\x1BV[c\xAB\x1B#k`\xE0\x1B_R`\x04_\xFD[`@Qc\n\xE5\x925`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x8A\x81\x16`\x04\x83\x01R`$\x805\x90\x91\x16\x90\x82\x01R`D\x81\x01\x92\x90\x92R`d\x82\x01R`\x84\x90\xFD[\x03\x90\xFD[aV\xB1\x91`@\x91aV}\x90`\x01`\x01`\xA0\x1B\x03\x16\x91T`\xFF\x16\x90V[\x82Qc\x12\xFEc'`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x8F\x16`\x04\x82\x01R`\xFF\x90\x91\x16`$\x82\x01R\x92\x83\x91\x90\x82\x90\x81\x90`D\x82\x01\x90V[\x03\x91Z\xFA\x90\x81_\x91_\x93aV\xD9W[PaV\xCEW[\x8C\x91PaT\x18V[\x91P\x91P_\x80aV\xC6V[\x90\x92PaV\xFE\x91P`@=`@\x11aW\x05W[aV\xF6\x81\x83a'6V[\x81\x01\x90av\xA7V[\x91_aV\xC0V[P=aV\xECV[a\x07e\x88aW\x1B\x8BT`\xFF\x16\x90V[c'\x9D\xB3u`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x90\x91\x16`\x04R`\xFF\x16`$R`D\x90V[aW\x8C` aWU`\x01`\x01`\xA0\x1B\x03\x85\x16a\x0F\xF0V[\x8CT`@Qc\x0C\xF6\xAD\xD9`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x8E\x16`\x04\x82\x01R`\xFF\x90\x91\x16`$\x82\x01R\x92\x83\x91\x90\x82\x90\x81\x90`D\x82\x01\x90V[\x03\x91Z\xFA_\x91\x81aW\xACW[PaW\xA4W[PaS\xF8V[\x90P_aW\x9EV[aW\xC6\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_aW\x98V[c\nUQ/`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x80\x88\x16`\x04R`$\x805\x91\x90\x91\x16\x90R`D_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `\x01`\x01`@\x1B\x03`\x04T\x16`@Q\x90\x81R\xF3[4a\x05\xAFWaX(6a\x06%V[aX0a\x87\x0FV[aX9\x83a\x86|V[`\x02\x81\x01TaXL\x90`\x10\x1C`\xFF\x16\x15\x90V[a[lW_TaXd\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\xEBG53`\xE0\x1B\x81R3`\x04\x82\x01R\x90\x91\x90` \x81`$\x81\x86Z\xFA\x90\x81\x15a\x13cW_\x91a[MW[P\x15a[:W`\x01`\x01`@\x1B\x03aX\xC1a\x08}3a\x08\xCA\x89`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x16a[\x1AW`@Qc\xD7u\xCBa`\xE0\x1B\x81R` \x81`\x04\x81\x86Z\xFA\x80\x15a\x13cW`\x01\x91_\x91aZ\xFBW[P\x91\x01\x80T\x90\x92`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x91\x82aZtW[`@Qc\xF4i\x13\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x82\x90R` \x81`D\x81\x86Z\xFA\x90\x81\x15a\x13cW_\x91aZUW[P\x15a\x12\xE6WP\x7F\xA9\xCF\x99\xC4\xC7[\xF0\x87Ev\xE6\xEEp\xB0\x0B\x92\x0E\x9C6U\x1EMl\x17iN\xCA\xA6\x84bM+\x93a\x07D\x93\x90\x92aZ\x10\x92P`\x01`\x01`\xA0\x1B\x03\x81\x16aZ(W[PaY\xE2`\x01`\x01`@\x1B\x03B\x16aY\xB0aY\x92a'WV[`\x01`\x01`@\x1B\x03\x83\x16\x81R\x91[`\x01`\x01`@\x1B\x03\x16` \x83\x01RV[`\x01`@\x82\x01R`\x01``\x82\x01RaY\xDD3a\x08\xCA\x8B`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[awRV[aZ\x013a\x11z\x89`\x01`\x01`@\x1B\x03\x16_R`\x08` R`@_ \x90V[Pa\t\x18a\x11\x91\x82T`\xE0\x1C\x90V[`@Q\x91\x82\x91`\x01`\x01`@\x1B\x033\x97\x16\x95\x83ag\xF1V[`@Qc3\xBC\x9Ec`\xE1\x1B` \x82\x01RaZO\x91a!!\x82a\t\x8C\x88\x8C3`$\x85\x01aw0V[_aYyV[aZn\x91P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[_aY6V[`\x04`@aZ\x8A`\x01`\x01`\xA0\x1B\x03\x86\x16a\x0F\xF0V[\x81Qc*nsa`\xE1\x1B\x81R\x92\x83\x91\x82\x90Z\xFA\x90\x81_\x91_\x93aZ\xD8W[PaZ\xB5W[PPaY\x05V[\x15\x80aZ\xCFW[aZ\xC7W[\x80aZ\xAEV[\x90P_aZ\xC1V[P\x80\x15\x15aZ\xBCV[\x90\x92PaZ\xF4\x91P`@=`@\x11a\x14\x17Wa\x14\x08\x81\x83a'6V[\x91_aZ\xA8V[a[\x14\x91P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[_aX\xECV[c\x9E\xC4\xE3\r`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x85\x16`\x04R3`$R`D_\xFD[cq\xABj\xD5`\xE1\x1B_R3`\x04R`$_\xFD[a[f\x91P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[_aX\x91V[c!\x0E\xB4\xED`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a[\xA5\x81a\x05\xB3V[a[\xADa\x876V[a[\xB6\x81a\x98\xDCV[`\x02\x81\x01T`\x01`p\x82\x90\x1C`\xFF\x16a[\xCE\x81a\"\xE3V[\x03a@\xA6W`\x01\x90`h\x1C`\xFF\x16a[\xE5\x81a\"\xE3V[\x03a\x14=W`\x01\x81\x01\x80T\x90\x92`\x01`\x01`@\x1B\x03`@\x83\x90\x1C\x16\x80\x15\x15\x90\x81a^7W[Pa^\x1CW\x90`\x01\x91a\\Pa!\xCCa\\-a!G\x87T`\x01`\x01`@\x1B\x03\x16\x90V[a!\xC7a\\D`\x02\x83\x01T`\x01`\x01`@\x1B\x03\x16\x90V[\x96\x87\x92\x01T\x95`\xC0\x1C\x90V[B\x10a^\rWa\\q\x81`\x01`\x01`@\x1B\x03\x16_R`\x14` R`@_ \x90V[`\x01\x81\x01T\x83\x81\x10a]\xF6WPa\\\x8B\x83a\\\xAA\x92a\xBE\nV[\x86T`\x01`\x01`\xC0\x1B\x03\x16B`\xC0\x1B`\x01`\x01`\xC0\x1B\x03\x19\x16\x17\x90\x96UV[a\\\xCDa\\\xC8\x82`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[a\xBB3V[\x91a\\\xD8\x83Qah\xCAV[\x93_\x96_\x97[\x85Q\x89\x10\x15a]|Wa]t`\x01\x91a]\\a]Ia]A\x8Aa]-\x8Fa] \x90a]\x1A\x8E`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x93ai2V[Q`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[Ta\xFF\xFF\x16\x90V[a]S\x8D\x8Cai2V[\x90a\xFF\xFF\x16\x90RV[aP\xADa\x1CCa]l\x8D\x8Cai2V[Qa\xFF\xFF\x16\x90V[\x98\x01\x97a\\\xDEV[\x7F$\xDCH[\xEF\x04\xB4\xD7\x90\xD9z\xC1\x03\x81\xD8\xD9\xE6lV\xDDo\xBA\x991\xB7\x03\xCA\x16\x95\x11w\x8A\x96`\x01`\x01`@\x1B\x03\x96\x85a]\xC7\x94a]\xC1a]\xEB\x98\x9CT`\x01`\x01`@\x1B\x03\x16\x90V[\x89a\xB7\xC8V[`@Q\x93\x84\x93\x16\x95\x83\x90\x92\x91`\x01`\x01`@\x1B\x03` \x91`@\x84\x01\x95\x84R\x16\x91\x01RV[\x03\x90\xA2a\0\x18a\x87nV[c\x03\x9F\xF3\xB1`\xE4\x1B_R`\x04\x84\x90R`$R`D_\xFD[c\x1A\xB7\xDAk`\xE0\x1B_R`\x04_\xFD[c|>b\x1B`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x16`\x04R`$_\xFD[a^O\x91Pa!\xCC\x90`\x01`\x01`@\x1B\x03\x85\x16ao\xA3V[B\x11_a\\\nV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` \x80T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R\xF3[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFWa\0\x18`$5`\x045a^\xA0\x82a\n\xAFV[a^\xACa\x1Ak\x82amiV[a\xA2\xCDV[4a\x05\xAFWa^\xBF6a>\x99V[a^\xC7a\x876V[_\x90_\x92\x81\x15a_nW_[\x82\x81\x10a^\xE5WPPPaL\x15a\x87nV[a_\x02a^\xF3\x82\x85\x85at\xEEV[5a^\xFD\x81a\x05\xB3V[a\xAB\xAAV[a_\x0FW[`\x01\x01a^\xD3V[\x93\x92a_fa_``\x01\x92`\x01`\x01`@\x1B\x03a_-\x89\x88\x88at\xEEV[5a_7\x81a\x05\xB3V[\x16_R`\x10` R\x83a_Xa!G`@_ `\x01`\x01`@\x1B\x03\x90T\x16\x90V[\x01T\x90au\xC0V[\x94at\xFEV[\x94\x90Pa_\x07V[c\x1F* \x05`\xE0\x1B_R`\x04_\xFD[4a\x05\xAFWa_\x8B6a\x06%V[a_\xA9a\x08k\x84`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[`\x01`\x01`@\x1B\x03a_\xC2\x82T`\x01`\x01`@\x1B\x03\x16\x90V[\x16\x15a`vW\x7F\x85G\xE9K\xD9\\\xA7\xD3\xC7\xA3\xBE\x9Bf\xA2\x9Eo6\x15\x1B\xE5J%c\xE3P\x98C\x88a\xA4\xC8q\x91a`\x01a\x07D\x92`\x01`\x01`@\x1B\x03B\x16\x90ag\xA9V[a`!`\x01a+\xF9\x87`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16a`IW[P`@Q\x91\x82\x91`\x01`\x01`@\x1B\x033\x97\x16\x95\x83ag\xF1V[`@Qcz\xC7\x103`\xE1\x1B` \x82\x01Ra`p\x91a\t\x9A\x82a\t\x8C\x86\x8A3`$\x85\x01aw0V[_a`0V[c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R3`$R`D_\xFD[4a\x05\xAFWa`\xA46a\x06%V[`\x01`\x01`\xA0\x1B\x03a`\xB5\x84a\x86|V[T\x163\x03aa\x07W\x90\x7F0\xFCE\xE0Z3\xFD\x90h\xCFj\xE1\xA8\xF3\xDB+\x9D\x157-\xD6IN\xCC\xC8\xCD]0_\xDF8\xB3\x91`\x01`\x01`@\x1B\x03a`\xFF`@Q\x93\x84\x93` \x85R` \x85\x01\x91ag\xD1V[\x94\x16\x93\x03\x90\xA2\0[`\x01`\x01`@\x1B\x03\x83c#N\x07\x1D`\xE0\x1B_R\x16`\x04R3`$R`D_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x81R\xF3[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaa\x91\x906\x90`\x04\x01a\x05\xF8V[PPa\x0B\xBD`$5aa\xA2\x81a\n\xAFV[aa\xAAa\x87\x0FV[`\x04T`\x01`\x01`@\x1B\x03\x16\x90aa\xC3a8G\x83ah\xADV[a9\taa\xCEa'\x85V[3\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01RB`\x01`\x01`@\x1B\x03\x16`@\x82\x01R_``\x82\x01R_`\x80\x82\x01R_`\xA0\x82\x01Ra8\xC6`\xC0\x82\x01`\x01\x90RV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045ab3\x81a\x05\xB3V[ab;ar\xD3V[P\x16_R`\x14` Ra\x0B\xBD`@_ `\x03`@Q\x91abZ\x83a&\xAEV[\x80T`\x01`\x01`\xA0\x1B\x03\x16\x80\x84R`\x01\x82\x01T` \x80\x86\x01\x91\x82R`\x02\x84\x01T`@\x80\x88\x01\x91\x82R\x95\x90\x94\x01T``\x96\x87\x01\x90\x81R\x85Q\x93\x84R\x91Q\x90\x83\x01R\x91Q\x92\x81\x01\x92\x90\x92RQ\x91\x81\x01\x91\x90\x91R\x90\x81\x90`\x80\x82\x01\x90V[\x91\x81`\x1F\x84\x01\x12\x15a\x05\xAFW\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFW` \x80\x85\x01\x94\x84`\x07\x1B\x01\x01\x11a\x05\xAFWV[a\x01\x006`\x03\x19\x01\x12a\x05\xAFWab\xFAa\x05\xC4V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWac\x19\x906\x90`\x04\x01a\n\x7FV[\x91`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWac9\x906\x90`\x04\x01ab\xB5V[\x92\x90\x93`d5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWac[\x906\x90`\x04\x01a\x05\xF8V[\x94\x90\x95`\x845\x95`\x01`\x01`@\x1B\x03\x87\x11a\x05\xAFWa\x0B\xBD\x97ac\x85a\x0B\xA3\x986\x90`\x04\x01a\n\x7FV[\x94\x90\x93ac\x90a\x05\xD3V[\x96ac\x99a\n\xC0V[\x98`\xE45\x9Aaw\xC3V[`\x04\x11\x15a\"\xD1WV[\x90a\"\xE0\x82ac\xA3V[a\x01`a\x01 a\x0B\xE6\x93` \x84Rac\xDB` \x85\x01\x82Q`\x01`\x01`@\x1B\x03\x16\x90RV[` \x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16`@\x85\x01R`@\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16``\x85\x01R``\x81\x01Q`\x80\x85\x01R`\x80\x81\x01Q`\xA0\x85\x01R`\xA0\x81\x01Q`\xC0\x85\x01Rad9`\xC0\x82\x01Q`\xE0\x86\x01\x90`\x01`\x01`@\x1B\x03\x16\x90RV[`\xE0\x81\x01Q`\x01`\x01`@\x1B\x03\x16a\x01\0\x85\x01Rad_a\x01\0\x82\x01Q\x83\x86\x01\x90ac\xADV[\x01Q\x91a\x01@\x80\x82\x01R\x01\x90aKkV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045ad\x95\x81a\x05\xB3V[``a\x01 `@Qad\xA6\x81a&\xE4V[_\x81R_` \x82\x01R_`@\x82\x01R_\x83\x82\x01R_`\x80\x82\x01R_`\xA0\x82\x01R_`\xC0\x82\x01R_`\xE0\x82\x01R_a\x01\0\x82\x01R\x01R\x16_R`\x1D` Ra\x0B\xBD`@_ ae\xBB`\x06ad\xF7a'\xA3V[\x92ae0ae \x82Ta$Sae\x13\x82`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16\x88RV[`\x01`\x01`\xA0\x1B\x03\x16` \x86\x01RV[`\x01\x81\x01T`\x01`\x01`\xA0\x1B\x03\x16`@\x85\x01R`\x02\x81\x01T``\x85\x01R`\x03\x81\x01T`\x80\x85\x01R`\x04\x81\x01T`\xA0\x85\x01Rae\xB5ae\xAB`\x05\x83\x01Tae\x8Fae\x7F\x82`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16`\xC0\x89\x01RV[`\x01`\x01`@\x1B\x03`@\x82\x90\x1C\x16`\xE0\x88\x01R`\x80\x1C`\xFF\x16\x90V[a\x01\0\x86\x01a{\x14V[\x01a{\x1DV[a\x01 \x82\x01R`@Q\x91\x82\x91\x82ac\xB7V[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045ae\xEA\x81a\n\xAFV[ae\xF2a\x876V[ae\xFC\x813a\xA3\xC0V[\x90\x81af\x15W`\x01_\x80Q` a\xC9'\x839\x81Q\x91RU\0[`@Q\x91\x82R`\x01`\x01`\xA0\x1B\x03\x16\x903\x90\x7F\x93\x10\xCC\xFC\xB8\xDEr?W\x8A\x9EB\x82\xEA\x9FR\x1F\x05\xAE@\xDC\x08\xF3\x06\x8D\xFA\xD5(\xA6^\xE3\xC7\x90` \x90\xA3_\x80a\"lV[`\xA06`\x03\x19\x01\x12a\x05\xAFW`\x045afl\x81a\x05\xB3V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaf\x8B\x906\x90`\x04\x01a\n\x7FV[\x90\x91`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaf\xAC\x906\x90`\x04\x01a\x05\xF8V[\x92\x90\x93`d5\x93`\x01`\x01`@\x1B\x03\x85\x11a\x05\xAFWa\x0B\xBD\x95af\xD6a\x0B\xA3\x966\x90`\x04\x01a\n\x7FV[\x94\x90\x93`\x845\x96af\xE6\x88a\x05\xB3V[a{\xBBV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045ag\x08\x81a\n\xAFV[ag\x10a\x8E\xE5V[`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a=\xB6W`\x01`\x01``\x1B\x03`\xA0\x1B`\x01T\x16\x17`\x01U_\x80\xF3[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q\x7F\x18\x9A\xB7\xA9$M\xF0\x84\x81\"\x15C\x15\xAFq\xFE\x14\x0F=\xB0\xFE\x01@1x;\tF\xB8\xC9\xD2\xE3\x81R\xF3[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[c\xFF\xFF\xFF\xFF\x16\x80\x15aP\xD8W_\x19\x01\x90V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x82T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17\x90UV[\x90\x80` \x93\x92\x81\x84R\x84\x84\x017_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[\x91` a\x0B\xE6\x93\x81\x81R\x01\x91ag\xD1V[\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x9Bah\x14a\x87\x0FV[ah\x1Ca\x876V[\x8C\x83\x03aKHWah,\x8Dah\x96V[\x93ah:`@Q\x95\x86a'6V[\x8D\x85R` \x85\x01\x9D`\x05\x1B\x81\x01\x906\x82\x11a\x05\xAFW\x9D\x81\x8F[\x10ahyWPPahe\x9B\x9CPa\x89\xC0V[`\x01_\x80Q` a\xC9'\x839\x81Q\x91RU\x90V[` \x8F\x91\x81\x925ah\x89\x81a\x0E\xB6V[\x81R\x01\x9E\x01\x9D\x81\x8FahSV[`\x01`\x01`@\x1B\x03\x81\x11a&\xA9W`\x05\x1B` \x01\x90V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x81\x14aP\xD8W`\x01\x01\x90V[\x90ah\xD4\x82ah\x96V[ah\xE1`@Q\x91\x82a'6V[\x82\x81R\x80\x92ah\xF2`\x1F\x19\x91ah\x96V[\x01\x90` 6\x91\x017V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80Q\x15ai\x1DW` \x01\x90V[ah\xFCV[\x80Q`\x01\x10\x15ai\x1DW`@\x01\x90V[\x80Q\x82\x10\x15ai\x1DW` \x91`\x05\x1B\x01\x01\x90V[\x90\x91aiPa\x87\x0FV[aiXa\x876V[aia\x82a\x90xV[\x90ait`\x04\x83\x01T`\xFF\x90`H\x1C\x16\x90V[a1\x90W_\x93_[ai\x97\x85`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[T\x81\x10\x15al\x1AWa\x0F\xF0ai\xC4a/\xCC\x83a/\xC7\x89`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[\x14ai\xD1W`\x01\x01ai|V[P\x90\x91\x92\x93P`\x01[\x15a\x12\xA7Waj\x01a\x15\xE23a\x08\xCA\x87`\x01`\x01`@\x1B\x03\x16_R`\x0C` R`@_ \x90V[ak\xFAWaj \x84`\x01`\x01`@\x1B\x03\x16_R`\x0E` R`@_ \x90V[\x82\x82\x82Tak\xE9W[PPP_[\x82\x81\x10ak\xADWPajXa\x16%3a\x08\xCA\x87`\x01`\x01`@\x1B\x03\x16_R`\x0C` R`@_ \x90V[aj\xD7a\x159`\x01\x85\x01\x94aj\x9Baj{a\x11\x91\x88Tc\xFF\xFF\xFF\xFF\x90`\xA0\x1C\x16\x90V[\x87Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\xA0\x91\x90\x91\x1Bc\xFF\xFF\xFF\xFF`\xA0\x1B\x16\x17\x87UV[3`\x01`\x01`@\x1B\x03\x88\x16\x7F\xCE\xDA\x1AD\xEA\xD4\xDA=:\xBA\xAA\x94\x1A\xFAm\x950\xFD\x84\xDD\x8E\x998\\\x91\x83\xD9\x86\xDC\xAB\x98\x0F_\x80\xA3T`\x01`\x01`@\x1B\x03\x16\x90V[\x91\x80\x15ak\x9EWaj\xFEa\x1CjaN.`@aj\xF8`\x01\x95ak\r\x97al9V[\x01al\x95V[\x92\x01T`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16akWW[PPTc\xFF\xFF\xFF\xFFak7a0\xFA`\xA0\x84\x90\x1C\x83\x16a0\xEDV[\x91\x16\x14akHW[Pa\x05\xD1a\x87nV[akQ\x90a\x92\xF7V[_ak?V[`@Qc,Vz\xCD`\xE2\x1B` \x82\x01R3`$\x82\x01R`\x01`\x01`@\x1B\x03\x85\x16`D\x82\x01R`\xFF\x90\x91\x16`d\x82\x01Rak\x97\x91a\t\x9A\x82`\x84\x81\x01a\t\x8CV[_\x80ak\x1DV[PPak\r`\x01`d\x92a+\xF9V[`\x01\x90ak\xE3ak\xD23a\x08\xCA\x89`\x01`\x01`@\x1B\x03\x16_R`\x0F` R`@_ \x90V[ak\xDD\x83\x87\x87alBV[\x90al\x9FV[\x01aj.V[ak\xF2\x92a\x90\xB2V[_\x82\x82aj)V[c\x0F+\xB0\xF1`\xE4\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R3`$R`D_\xFD[P\x90\x91\x92\x93ai\xDAV[\x80T\x82\x10\x15ai\x1DW_R` _ \x01\x90_\x90V[\x90\x15ai\x1DW\x90V[\x91\x90\x81\x10\x15ai\x1DW``\x02\x01\x90V[\x80T\x82\x10\x15ai\x1DW_R` _ \x90`\x01\x1B\x01\x90_\x90V[`\x02\x11\x15a\x05\xAFWV[`D5a\x0B\xE6\x81alkV[5a\x0B\xE6\x81alkV[5a\x0B\xE6\x81a\n\xAFV[5a\x0B\xE6\x81a\x0E\xB6V[\x80T`\x01`@\x1B\x81\x10\x15a&\xA9Wal\xBC\x91`\x01\x82\x01\x81UalRV[am9W`\x01`@\x83a\x05\xD1\x945al\xD3\x81alkV[al\xDC\x81a\"\xC7V[`\xFF\x80\x19\x86T\x16\x91\x16\x17\x84Uam\x1B` \x82\x015al\xF9\x81a\n\xAFV[\x85Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x85UV[\x015\x91am'\x83a\x0E\xB6V[\x01\x90a\xFF\xFF\x16a\xFF\xFF\x19\x82T\x16\x17\x90UV[agpV[c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x81\x14aP\xD8W`\x01\x01\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` R`\x01`@_ \x01T\x90V[\x90\x81` \x91\x03\x12a\x05\xAFWQ\x90V[`@Q=_\x82>=\x90\xFD[\x91\x90\x82`@\x91\x03\x12a\x05\xAFW` \x82Qam\xBA\x81a9\xB7V[\x92\x01Q\x90V[\x90\x81` \x91\x03\x12a\x05\xAFWQa\x0B\xE6\x81a9\xB7V[\x90`\x01\x82\x81\x1C\x92\x16\x80\x15an\x03W[` \x83\x10\x14am\xEFWV[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x91`\x7F\x16\x91am\xE4V[`\x01`\x01`@\x1B\x03\x91\x82\x16\x81R`\xFF\x90\x92\x16` \x83\x01R\x90\x91\x16`@\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16``\x82\x01R`\xC0`\x80\x82\x01R\x81T\x94\x93_\x93\x90\x92\x90\x91\x90anW\x87am\xD5V[\x96\x87`\xC0\x84\x01R`\x01\x81\x16\x90\x81_\x14an\xC5WP`\x01\x14an\x87W[Pa\x0B\xE6\x94\x95P`\xA0\x81\x85\x03\x91\x01Rag\xD1V[\x90\x93P_R` _ _\x90[\x86\x82\x10an\xAEWP\x93\x94P\x84\x93\x83\x01`\xE0\x01\x92a\x0B\xE6ansV[`\x01\x81` \x92T`\xE0\x85\x89\x01\x01R\x01\x91\x01\x90an\x93V[\x90P`\xE0\x92\x95Pa\x0B\xE6\x96\x97\x91P`\xFF\x19\x16\x82\x86\x01R\x15\x15`\x05\x1B\x84\x01\x01\x92\x85\x94ansV[c\xFF\xFF\xFF\xFF\x81\x16\x03a\x05\xAFWV[\x90\x81` \x91\x03\x12a\x05\xAFWQa\x0B\xE6\x81an\xEBV[\x90\x81` \x91\x03\x12a\x05\xAFWQa\x0B\xE6\x81a\n\xAFV[\x90a'\x10\x82\x02\x91\x80\x83\x04a'\x10\x14\x90\x15\x17\x15aP\xD8WV[\x90`\x06\x82\x02\x91\x80\x83\x04`\x06\x14\x90\x15\x17\x15aP\xD8WV[\x81\x81\x02\x92\x91\x81\x15\x91\x84\x04\x14\x17\x15aP\xD8WV[\x81\x15aonW\x04\x90V[amUV[\x91ao\x9C`\xFF\x91`\x01`\x01`@\x1B\x03`@\x94\x97\x96\x97\x16\x85R``` \x86\x01R``\x85\x01\x90aKkV[\x94\x16\x91\x01RV[\x90`\x01`\x01`@\x1B\x03\x80\x91\x16\x91\x16\x01\x90`\x01`\x01`@\x1B\x03\x82\x11aP\xD8WV[\x81Q\x81T` \x84\x01Qa\x01\0`\x01`\xA8\x1B\x03`\x08\x91\x90\x91\x1B\x16`\xFF\x90\x92\x16`\x01`\x01`\xA8\x1B\x03\x19\x90\x91\x16\x17\x17\x81Ua\x05\xD1\x91`\x03\x90apc\x90`\xA0\x90`@\x81\x01Q\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA8\x1B\x19\x16`\xA8\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA8\x1B\x16\x17\x85U``\x81\x01QapR\x90c\xFF\xFF\xFF\xFF\x16`\x01\x87\x01\x90c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90UV[`\x80\x81\x01Q`\x02\x86\x01U\x01Q\x15\x15\x90V[\x91\x01\x90`\xFF\x80\x19\x83T\x16\x91\x15\x15\x16\x17\x90UV[\x91ap\x8F\x91\x83T\x90`\x03\x1B\x91\x82\x1B\x91_\x19\x90\x1B\x19\x16\x17\x90V[\x90UV[`\x1F\x82\x11ap\xA0WPPPV[_R` _ \x90` `\x1F\x84\x01`\x05\x1C\x83\x01\x93\x10ap\xD8W[`\x1F\x01`\x05\x1C\x01\x90[\x81\x81\x10ap\xCDWPPV[_\x81U`\x01\x01ap\xC2V[\x90\x91P\x81\x90ap\xB9V[\x90\x92\x91`\x01`\x01`@\x1B\x03\x81\x11a&\xA9Waq\x07\x81aq\x01\x84Tam\xD5V[\x84ap\x93V[_`\x1F\x82\x11`\x01\x14aqAW\x81\x90ap\x8F\x93\x94\x95_\x92aq6W[PP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[\x015\x90P_\x80aq\"V[`\x1F\x19\x82\x16\x94aqT\x84_R` _ \x90V[\x91_[\x87\x81\x10aq\x8EWP\x83`\x01\x95\x96\x97\x10aquW[PPP\x81\x1B\x01\x90UV[\x015_\x19`\x03\x84\x90\x1B`\xF8\x16\x1C\x19\x16\x90U_\x80\x80aqkV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01aqWV[\x90a\x0B\xE6\x95\x93`\xFF`\x80\x94`\x01`\x01`@\x1B\x03\x80\x94\x16\x85R\x16` \x84\x01R\x16`@\x82\x01R\x81``\x82\x01R\x01\x91ag\xD1V[a\x0B\xE6\x94\x92`\xFF``\x93\x16\x82R`\x01\x80`\xA0\x1B\x03\x16` \x82\x01R\x81`@\x82\x01R\x01\x91ag\xD1V[`@Q\x90a\x01\x80\x82\x01\x82\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@R_a\x01`\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x82`\xC0\x82\x01R\x82`\xE0\x82\x01R\x82a\x01\0\x82\x01R\x82a\x01 \x82\x01R\x82a\x01@\x82\x01R\x01RV[a\"\xE0\x82a\"\xC7V[a\"\xE0\x82a\"\xE3V[`@Q\x90ar\x86\x82a&\x8EV[_`\xC0\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x01RV[\x90ar\xB9\x81a\"\xE3V[\x81T`\xFF`p\x1B\x19\x16`p\x91\x90\x91\x1B`\xFF`p\x1B\x16\x17\x90UV[`@Q\x90ar\xE0\x82a&\xAEV[_``\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x01RV[`d5`\x03\x81\x10\x15a\x05\xAFW\x90V[\x90as\x10\x81a\"\xC7V[`\xFF\x80\x19\x83T\x16\x91\x16\x17\x90UV[\x90as(\x81a\"\xE3V[a\xFF\0\x82T\x91`\x08\x1B\x16\x90a\xFF\0\x19\x16\x17\x90UV[\x81Q\x81T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x81Ua\x05\xD1\x91\x90at\x06\x90`\xC0\x90`\x02\x90` \x85\x01Q`\x01\x82\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x81Uas\xCF\x90`@\x87\x01Q\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\xA0\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x16\x17\x81U``\x87\x01Qc\xFF\xFF\xFF\xFF\x16a\t\x18V[\x01\x92as\xE8`\x80\x82\x01Qas\xE2\x81a\"\xC7V[\x85as\x06V[as\xFF`\xA0\x82\x01Qas\xF9\x81a\"\xE3V[\x85as\x1EV[\x01Q\x15\x15\x90V[\x81Tb\xFF\0\0\x19\x16\x90\x15\x15`\x10\x1Bb\xFF\0\0\x16\x17\x90UV[5a\x0B\xE6\x81a\x05\xB3V[at=`D5at7\x81alkV[\x82as\x06V[`d5`\x03\x81\x10\x15a\x05\xAFWatS\x90\x82as\x1EV[`\x845at_\x81an\xEBV[e\xFF\xFF\xFF\xFF\0\0\x82T\x91`\x10\x1B\x16\x90e\xFF\xFF\xFF\xFF\0\0\x19\x16\x17\x81Uat\xAF`\xA45at\x89\x81an\xEBV[\x82Ti\xFF\xFF\xFF\xFF\0\0\0\0\0\0\x19\x16`0\x91\x90\x91\x1Bi\xFF\xFF\xFF\xFF\0\0\0\0\0\0\x16\x17\x82UV[`\xC45`\x01\x82\x01Uat\xE3at\xC4`\xE4at\x1EV[`\x02\x83\x01\x90`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90UV[`\x03a\x01\x045\x91\x01UV[\x91\x90\x81\x10\x15ai\x1DW`\x05\x1B\x01\x90V[_\x19\x81\x14aP\xD8W`\x01\x01\x90V[_\x19\x81\x01\x91\x90\x82\x11aP\xD8WV[\x91\x90\x82\x03\x91\x82\x11aP\xD8WV[\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90au9a\x87\x0FV[auAa\x876V[auJ\x82ah\xCAV[\x9A_[\x83\x81\x10aubWP\x90ahe\x9A\x9B\x92\x91a\x89\xC0V[\x80a'\x10aus\x8F\x93`\x01\x94ai2V[R\x01auMV[\x90`\x01\x82\x01\x80\x92\x11aP\xD8WV[\x90`\x02\x82\x01\x80\x92\x11aP\xD8WV[\x90`\x03\x82\x01\x80\x92\x11aP\xD8WV[\x90`\x04\x82\x01\x80\x92\x11aP\xD8WV[\x90`\x05\x82\x01\x80\x92\x11aP\xD8WV[\x91\x90\x82\x01\x80\x92\x11aP\xD8WV[\x91\x90\x81\x10\x15ai\x1DW`\x05\x1B\x81\x015\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x05\xAFW\x01\x90\x815\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFW` \x01\x826\x03\x81\x13a\x05\xAFW\x91\x90V[a\xFF\xFF`\x045av\x1D\x81a\x0E\xB6V[\x16a\xFF\xFF\x19`\x02T\x16\x17`\x02U`$5av6\x81a\x0E\xB6V[c\xFF\xFF\0\0`\x02T\x91`\x10\x1B\x16\x90c\xFF\xFF\0\0\x19\x16\x17`\x02U`D5av[\x81a\x0E\xB6V[e\xFF\xFF\0\0\0\0`\x02T\x91` \x1B\x16\x90e\xFF\xFF\0\0\0\0\x19\x16\x17`\x02U`d5av\x84\x81a\x0E\xB6V[g\xFF\xFF\0\0\0\0\0\0`\x02T\x91`0\x1B\x16\x90g\xFF\xFF\0\0\0\0\0\0\x19\x16\x17`\x02UV[\x91\x90\x82`@\x91\x03\x12a\x05\xAFW` \x82Qav\xC0\x81a\x0E\xB6V[\x92\x01Qa\x0B\xE6\x81a\x1E^V[\x93`\xE0\x95`\x01`\x01`@\x1B\x03`@\x95`\xFF`\x80\x9B\x96\x83\x9B\x9E\x9D\x9Baw\x0B\x97\x16\x8AR\x16` \x89\x01R\x16\x85\x87\x01Ra\x01```\x87\x01Ra\x01`\x86\x01\x91ag\xD1V[\x97\x86\x84\x01R`\xA0\x83\x017\x017V[`@\x90a\x0B\xE6\x94\x92\x81R\x81` \x82\x01R\x01\x91ag\xD1V[`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R`@` \x82\x01\x81\x90Ra\x0B\xE6\x93\x91\x01\x91ag\xD1V[\x81Q\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x91\x90\x91\x16\x17\x81U\x90aw\x88`\x01`\x01`@\x1B\x03` \x83\x01Q\x16\x83ag\xA9V[`@\x81\x01Q\x82T`\xFF`\x80\x1B\x19\x16\x90\x15\x15`\x80\x1B`\xFF`\x80\x1B\x16\x17``\x90\x91\x01Q`\xFF`\x88\x1B\x19\x90\x91\x16\x90\x15\x15`\x88\x1B`\xFF`\x88\x1B\x16\x17\x90UV[\x98\x92\x99\x93\x95\x9B\x9A\x94\x9B\x97\x91\x97\x96\x90\x96aw\xDAa\x87\x0FV[aw\xE2a\x876V[\x86\x15ay@W_[\x87\x8C\x81\x83\x10ax\xD1WPPPaw\xFF\x89ah\xCAV[\x9C_[\x8A\x81\x10ax\xB3WP\x8A\x9B\x9C\x9D\x8A\x8Aax\x1C\x9A\x9B\x9C\x9Da\x89\xC0V[\x94_[\x82\x81\x10ax{WP\x90\x7F\xE9\xB9\xD9A\xD3\x17b\xEB\xEBz\0\0\x8BL\xF9^\x9A\x19%\\\xB6i\\\x9D5!\\\x91J~\x84\x86\x91axp`@Q\x92\x83\x92`\x01`\x01`@\x1B\x033\x99\x16\x97`\x01`\x01`@\x1B\x03\x8B\x16\x97\x85azlV[\x03\x90\xA4a\x0B\xE6a\x87nV[`\x01\x90ax\xADax\x9C\x89`\x01`\x01`@\x1B\x03\x16_R`\x0E` R`@_ \x90V[ax\xA7\x83\x87\x87ayOV[\x90ay_V[\x01ax\x1FV[\x80\x8Fax\xC4`\x01\x93ax\xCB\x92ai2V[a'\x10\x90RV[\x01ax\x02V[ax\xDC\x91\x83\x91ayOV[`@\x81\x01ax\xECa\x1CC\x82al\x95V[\x15ay1Wax\xFC``\x91al\x95V[\x91\x01\x90a\xFF\xFFay\x0Ea\x1CC\x84al\x95V[\x91\x16\x11ay1Way$a\x1CCa'\x10\x92al\x95V[\x11ay1W`\x01\x01aw\xEAV[ci#\xAF\xCF`\xE0\x1B_R`\x04_\xFD[c@\xEB~\xB5`\xE1\x1B_R`\x04_\xFD[\x91\x90\x81\x10\x15ai\x1DW`\x07\x1B\x01\x90V[\x80T`\x01`@\x1B\x81\x10\x15a&\xA9Way|\x91`\x01\x82\x01\x81UalRV[\x91\x90\x91am9W```\x01a\x05\xD1\x93\x835ay\x96\x81alkV[ay\x9F\x81a\"\xC7V[`\xFF\x80\x19\x83T\x16\x91\x16\x17\x81Uay\xDE` \x85\x015ay\xBC\x81a\n\xAFV[\x82Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x82UV[\x01\x91az\x03`@\x82\x015ay\xF1\x81a\x0E\xB6V[\x84Ta\xFF\xFF\x19\x16a\xFF\xFF\x90\x91\x16\x17\x84UV[\x015\x90az\x0F\x82a\x0E\xB6V[\x90c\xFF\xFF\0\0\x82T\x91`\x10\x1B\x16\x90c\xFF\xFF\0\0\x19\x16\x17\x90UV[\x91` \x90\x82\x81R\x01\x91\x90_[\x81\x81\x10azBWPPP\x90V[\x90\x91\x92` \x80`\x01\x92\x865azV\x81a\n\xAFV[\x84\x80`\xA0\x1B\x03\x16\x81R\x01\x94\x01\x91\x01\x91\x90\x91az5V[\x90az\x85\x90` \x93\x95\x94\x95`@\x84R`@\x84\x01\x91az)V[\x90\x82\x81\x83\x03\x91\x01R\x82\x81R\x01\x91\x90_[\x81\x81\x10az\xA2WPPP\x90V[\x90\x91\x92`\x80\x80`\x01\x92\x865az\xB6\x81alkV[az\xBF\x81a\"\xC7V[\x81R` \x87\x015az\xCF\x81a\n\xAFV[\x84\x80`\xA0\x1B\x03\x16` \x82\x01Ra\xFF\xFF`@\x88\x015az\xEC\x81a\x0E\xB6V[\x16`@\x82\x01Ra\xFF\xFF``\x88\x015a{\x03\x81a\x0E\xB6V[\x16``\x82\x01R\x01\x94\x01\x92\x91\x01az\x95V[a\"\xE0\x82ac\xA3V[\x90`@Q\x91\x82_\x82T\x92a{0\x84am\xD5V[\x80\x84R\x93`\x01\x81\x16\x90\x81\x15a{\x99WP`\x01\x14a{UW[Pa\x05\xD1\x92P\x03\x83a'6V[\x90P_\x92\x91\x92R` _ \x90_\x91[\x81\x83\x10a{}WPP\x90` a\x05\xD1\x92\x82\x01\x01_a{HV[` \x91\x93P\x80`\x01\x91T\x83\x85\x89\x01\x01R\x01\x91\x01\x90\x91\x84\x92a{dV[\x90P` \x92Pa\x05\xD1\x94\x91P`\xFF\x19\x16\x82\x84\x01R\x15\x15`\x05\x1B\x82\x01\x01_a{HV[\x96\x90\x95\x97\x93\x92\x94\x91\x97a{\xCCa\x87\x0FV[a{\xD4a\x876V[a{\xDD\x88a\x86|V[\x98`\x02\x8A\x01\x97a{\xF5a\x15\x8A\x8AT`\xFF\x90`\x10\x1C\x16\x90V[a\x81AWa|\x12\x84\x8B`\x03Ta|\x0C6\x87\x87a\x82\x19V[\x90a\xAD@V[\x99\x90\x98_[\x8BQ\x81\x10\x15a|\x95Wa|Na!\xCCa\x08}\x8F\x8F\x90a] \x86a]\x1Aa]-\x93`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x15a|[W`\x01\x01a|\x17V[\x8Ca|la] a\x07e\x93\x8Fai2V[c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x90\x91\x16`\x04R`\x01`\x01`\xA0\x1B\x03\x16`$R`D\x90V[P\x90\x91\x92\x93\x94\x95\x96\x98\x9B`\x01\x90\x9B\x9A\x98\x9B\x01\x98a|\xB8\x8AT`\x01\x80`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x15\x80a\x818W[a\x80\xB1W[P\x8C4\x10a\x80\x99W\x86\x94\x92\x8D\x8A\x99\x97\x95\x93a}:\x9E\x9F\x99\x93\x8E\x94\x8C\x8Fa}\x04\x90\x864\x11a\x80\x87W[T`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x92`\x01`\x01`\xA0\x1B\x03\x84\x16a\x80SW[PPPPPPa}ga}3`\x04T`\x01`\x01`@\x1B\x03\x90`\x80\x1C\x16\x90V[\x9D\x8Eah\xADV[`\x04\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x92\x90\x92\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x91\x90\x91\x17\x90UV[a}\x82\x82`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[`\x01`\x01`@\x1B\x03B\x16\x91a}\x9B\x8BQc\xFF\xFF\xFF\xFF\x16\x90V[\x91Tc\xFF\xFF\xFF\xFF`\x10\x82\x90\x1C\x16\x80\x15a\x80GW\x90`0\x1Cc\xFF\xFF\xFF\xFF\x16[\x91T\x92`\xFF\x84\x16\x93`\x08\x1C`\xFF\x16\x94a}\xD0a'uV[`\x01`\x01`@\x1B\x03\x90\x97\x16\x87R3` \x88\x01R`\x01`\x01`@\x1B\x03\x81\x16`@\x88\x01R`\x01`\x01`@\x1B\x03\x8B\x16``\x88\x01R_`\x80\x88\x01R`\x01`\x01`@\x1B\x03\x16`\xA0\x87\x01Rc\xFF\xFF\xFF\xFF\x16`\xC0\x86\x01Rc\xFF\xFF\xFF\xFF\x16`\xE0\x85\x01Rc\xFF\xFF\xFF\xFF\x16a\x01\0\x84\x01Ra~E\x90a\x01 \x84\x01argV[a~S\x90a\x01@\x83\x01arpV[`\x01a\x01`\x82\x01Ra~v\x8C`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[\x90a~\x80\x91a\x845V[\x86Qa~\x8B\x90ah\xCAV[\x97a~\x98\x92\x89\x92\x8Da\xAFmV[\x963a~\xB5\x8B`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[\x90a~\xBF\x91a\x99\x16V[P_[\x82\x81\x10a\x80\x0BWPa\x7F\x1E\x90`\x01`\x01`@\x1B\x03\x8A\x16_`\x01`\x01`@\x1B\x03\x8D\x16\x7Ft\x1E\x97\xEE\x1F\xF8\x87\xC4\xD8\x82\xF4\xC4\x9A\xD2\x80\xEA}a\xD05\xE4\xE8\xA4q\xE51\x95\x15P'P#\x82\x80\xA4\x80Ta|\xF7\x903\x90`\x01`\x01`\xA0\x1B\x03\x16\x8Da\xB0\xD9V[\x92`\x01`\x01`\xA0\x1B\x03\x84\x16a\x7FYW[PPPP\x80a\x7FEW[PPPPPa\x0B\xE6a\x87nV[a\x7FO\x94\x86a\xB5VV[_\x80\x80\x80\x80a\x7F8V[\x91\x81\x89\x93a\x7Foa\x7Fj\x8D\x95auzV[ah\xCAV[\x91a\x7F\x8C3a\x7F}\x85ai\x10V[`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90RV[_[\x81\x81\x10a\x7F\xCCWPPP\x91a\t\x8Ca\t\x9A\x92a\x7F\xC3\x96\x94`@Q\x96\x87\x94c \xA8{9`\xE2\x1B` \x87\x01R3\x91`$\x87\x01a\x86\x13V[_\x80\x80\x80a\x7F.V[\x90\x92\x94P\x81\x93\x95Pa\x7F\xFEa\x7F\xECa\x7F\xE7\x83\x86`\x01\x96at\xEEV[al\x8BV[a\x7F}a\x7F\xF8\x84auzV[\x88ai2V[\x01\x91\x8B\x93\x91\x8B\x95\x93a\x7F\x8EV[`\x01\x90a\x80@a\x80,\x8D`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[a\x80:a\x7F\xE7\x84\x88\x8Bat\xEEV[\x90a\x99\x16V[P\x01a~\xC2V[Pa}\xB9`\x01\x91a*\xD1V[a\x80|\x95a!!\x93a\t\x8C\x92`@Q\x97\x88\x95caFl\t`\xE1\x1B` \x88\x01R3`$\x88\x01a\x83bV[\x87_\x80\x88\x8C\x82a}\x14V[a\x80\x94a@\x92\x884au\x1AV[a|\xF7V[c\x9Aj\xE6\r`\xE0\x1B_R`\x04\x8D\x90R4`$R`D_\xFD[a\x80\xC3\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\xE3\x90\xFC\xDB`\xE0\x1B\x81R_`\x04\x82\x01\x81\x90R`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90Z\xFA_\x91\x81a\x81\x17W[P\x15a|\xCFW\x15a\x81\x03W_a|\xCFV[c\tD\x03\xB7`\xE4\x1B_\x90\x81R`\x04R`$_\xFD[a\x811\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_a\x80\xF2V[P\x8D\x15\x15a|\xCAV[c!\x0E\xB4\xED`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x8A\x16`\x04R`$_\xFD[\x81`\x1F\x82\x01\x12\x15a\x05\xAFW\x805\x90a\x81t\x82ah\x96V[\x92a\x81\x82`@Q\x94\x85a'6V[\x82\x84R` ``\x81\x86\x01\x94\x02\x83\x01\x01\x91\x81\x83\x11a\x05\xAFW` \x01\x92[\x82\x84\x10a\x81\xACWPPPP\x90V[\x83\x82\x03``\x81\x12a\x05\xAFW`@\x80Q\x91a\x81\xC5\x83a'\0V[\x12a\x05\xAFW``\x91` \x91`@Qa\x81\xDC\x81a'\0V[\x875a\x81\xE7\x81alkV[\x81R\x83\x88\x015a\x81\xF6\x81a\n\xAFV[\x84\x82\x01R\x81R`@\x87\x015a\x82\n\x81a\x0E\xB6V[\x83\x82\x01R\x81R\x01\x93\x01\x92a\x81\x9EV[\x92\x91\x90\x92a\x82&\x84ah\x96V[\x93a\x824`@Q\x95\x86a'6V[` \x85\x82\x81R\x01\x90`\x05\x1B\x82\x01\x91\x83\x83\x11a\x05\xAFW\x80\x91[\x83\x83\x10a\x82ZWPPPPPV[\x825`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFW\x82\x01\x90``\x82\x87\x03\x12a\x05\xAFW`@Q\x90a\x82\x84\x82a'\x1BV[\x825`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFW\x83\x01`\xC0\x81\x89\x03\x12a\x05\xAFW`@Q\x90a\x82\xAD\x82a&\xC9V[\x805a\x82\xB8\x81a\x05\xB3V[\x82Ra\x82\xC6` \x82\x01a\x05\xEDV[` \x83\x01R`@\x81\x015`@\x83\x01Ra\x82\xE1``\x82\x01a\x05\xEDV[``\x83\x01Ra\x82\xF2`\x80\x82\x01a\x05\xEDV[`\x80\x83\x01R`\xA0\x81\x015\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFWa\x83\x17\x91\x8A\x91\x01a\x81]V[`\xA0\x82\x01R\x82R` \x83\x015\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFWa\x83R`@\x85a\x83H\x8B` \x98\x97\x89\x98\x01a(!V[\x86\x85\x01R\x01a\n\xDAV[`@\x82\x01R\x81R\x01\x92\x01\x91a\x82LV[\x92`\xC0\x94a\x83\x9B`\x01`\x01`@\x1B\x03\x94a\x83\xA9\x94\x9A\x99\x98\x9A_\x88R`\x01\x80`\xA0\x1B\x03\x16` \x88\x01R`\xE0`@\x88\x01R`\xE0\x87\x01\x90aP\xDDV[\x91\x85\x83\x03``\x87\x01Rag\xD1V[\x95\x16`\x80\x82\x01R_`\xA0\x82\x01R\x01RV[\x80Th\x01\0\0\0\0\0\0\0\0`\x01`\xE0\x1B\x03\x19\x16`@\x92\x90\x92\x1Bh\x01\0\0\0\0\0\0\0\0`\x01`\xE0\x1B\x03\x16\x91\x90\x91\x17\x90UV[\x90a\x83\xF7\x81a\"\xC7V[\x81T`\xFF``\x1B\x19\x16``\x91\x90\x91\x1B`\xFF``\x1B\x16\x17\x90UV[\x90a\x84\x1B\x81a\"\xE3V[\x81T`\xFF`h\x1B\x19\x16`h\x91\x90\x91\x1B`\xFF`h\x1B\x16\x17\x90UV[\x90a\x01``\x02a\x05\xD1\x93a\x84pa\x84S\x85Q`\x01`\x01`@\x1B\x03\x16\x90V[\x82Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x90\x91\x16\x17\x82UV[` \x84\x01Qa\x84\x89\x90`\x01`\x01`\xA0\x1B\x03\x16[\x82a\x83\xBAV[a\x851`\x01\x82\x01a\x84\xA7a\x84S`@\x88\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x84\xC4a\x84\xBE``\x88\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[\x82ag\xA9V[a\x85\x03a\x84\xDB`\x80\x88\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[\x82Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x82UV[`\xA0\x86\x01Q`\x01`\x01`@\x1B\x03\x16\x81T`\x01`\x01`\xC0\x1B\x03\x16`\xC0\x91\x90\x91\x1B`\x01`\x01`\xC0\x1B\x03\x19\x16\x17\x90UV[\x01\x91a\x85]a\x85G`\xC0\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x84Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x84UV[a\x85\x93a\x85q`\xE0\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x84Tg\xFF\xFF\xFF\xFF\0\0\0\0\x19\x16` \x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\0\0\0\0\x16\x17\x84UV[a\x85\xD2a\x85\xA8a\x01\0\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x84Tk\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x19\x16`@\x91\x90\x91\x1Bk\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x16\x17\x84UV[a\x85\xEAa\x01 \x82\x01Qa\x85\xE4\x81a\"\xC7V[\x84a\x83\xEDV[a\x86\x02a\x01@\x82\x01Qa\x85\xFC\x81a\"\xE3V[\x84a\x84\x11V[\x01Q\x90a\x86\x0E\x82a\"\xE3V[ar\xAFV[\x93`\xA0\x93`\x01`\x01`@\x1B\x03\x80\x94\x81ao\x9C\x95\x9A\x99\x9A\x16\x88R_` \x89\x01R\x16`@\x87\x01R`\x01\x80\x86\x1B\x03\x16``\x86\x01R`\xC0`\x80\x86\x01R`\xC0\x85\x01\x90aP\xDDV[\x90ap\x8F\x90a\x86c\x81ac\xA3V[\x82T`\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1B`\xFF`\x80\x1B\x16\x17\x90V[`\x01`\x01`@\x1B\x03\x80`\x04T\x16\x91\x16\x90\x81\x10\x15a\x86\xA1W_R`\x05` R`@_ \x90V[c\x17\xF4\x92;`\xE2\x1B_R`\x04R`$_\xFD[=\x15a\x86\xDDW=\x90a\x86\xC4\x82a'\xD0V[\x91a\x86\xD2`@Q\x93\x84a'6V[\x82R=_` \x84\x01>V[``\x90V[_\x91\x82\x91\x82` \x83Q\x93\x01\x91Z\xF1Pa\x86\xF9a\x86\xB3V[PV[a\x0B\xE6\x91`\x01`\x01`\xA0\x1B\x03\x16\x90a\xB3\xDCV[`\xFF_\x80Q` a\xC9\x07\x839\x81Q\x91RT\x16a\x87'WV[c\xD9<\x06e`\xE0\x1B_R`\x04_\xFD[`\x02_\x80Q` a\xC9'\x839\x81Q\x91RT\x14a\x87_W`\x02_\x80Q` a\xC9'\x839\x81Q\x91RUV[c>\xE5\xAE\xB5`\xE0\x1B_R`\x04_\xFD[`\x01_\x80Q` a\xC9'\x839\x81Q\x91RUV[\x90a\x88\xFBa\x01``\x04a\x05\xD1\x94a\x87\xA2a\x84S\x86Q`\x01`\x01`@\x1B\x03\x16\x90V[` \x85\x01Qa\x87\xB9\x90`\x01`\x01`\xA0\x1B\x03\x16a\x84\x83V[a\x88M`\x01\x82\x01a\x87\xD7a\x84S`@\x89\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x87\xEEa\x84\xBE``\x89\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x88\"a\x88\x02`\x80\x89\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x82Tc\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bc\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x82UV[`\xA0\x87\x01Qc\xFF\xFF\xFF\xFF\x16\x81Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\xA0\x91\x90\x91\x1Bc\xFF\xFF\xFF\xFF`\xA0\x1B\x16\x17\x90UV[`\xC0\x85\x01Q`\x02\x82\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90\x91\x17\x90U`\xE0\x85\x01Q`\x03\x82\x01U\x01\x92a\x88\x91a\x01\0\x82\x01Qas\xE2\x81a\"\xC7V[a\x88\xC2a\x88\xA6a\x01 \x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x85Td\xFF\xFF\xFF\xFF\0\x19\x16`\x08\x91\x90\x91\x1Bd\xFF\xFF\xFF\xFF\0\x16\x17\x85UV[as\xFFa\x88\xD7a\x01@\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x85Th\xFF\xFF\xFF\xFF\0\0\0\0\0\x19\x16`(\x91\x90\x91\x1Bh\xFF\xFF\xFF\xFF\0\0\0\0\0\x16\x17\x85UV[\x81Ti\xFF\0\0\0\0\0\0\0\0\0\x19\x16\x90\x15\x15`H\x1B`\xFF`H\x1B\x16\x17\x90UV[\x80T`\x01`@\x1B\x81\x10\x15a&\xA9Wa\x898\x91`\x01\x82\x01\x81Ual$V[\x81T`\x01`\x01`\xA0\x1B\x03\x93\x84\x16`\x03\x92\x90\x92\x1B\x91\x82\x1B\x93\x90\x91\x1B\x19\x16\x91\x90\x91\x17\x90UV[\x95\x90a\x89\xA7\x93`\x01`\x01`@\x1B\x03\x95`\xC0\x99\x9C\x9B\x9A\x97\x94\x87a\x89\x99\x94\x16\x8AR`\x01\x80`\xA0\x1B\x03\x16` \x8A\x01R`\xE0`@\x8A\x01R`\xE0\x89\x01\x91az)V[\x91\x86\x83\x03``\x88\x01Rag\xD1V[\x96\x16`\x80\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16`\xA0\x82\x01R\x01RV[\x97\x90\x94\x96\x9A\x99\x92\x93\x98\x91\x95\x86\x15a\x8E\x8CWa\x15\x8A\x9Ba\x89\xDE\x8Aa\x86|V[a\x89\xF2`\x02\x82\x01\x9E\x8FT`\xFF\x90`\x10\x1C\x16\x90V[a\x8EpW`\x01\x01\x80T\x90\x92\x90`\x01`\x01`\xA0\x1B\x03\x16\x80\x15\x15\x80a\x8EgW[a\x8D\xD0W[P_[\x88\x8C\x8B\x80\x84\x10a\x8DlWPPPPa\x8A14\x87\x87a\xA1\xF3V[`\x04T`@\x1C`\x01`\x01`@\x1B\x03\x16\x96a\x8Ava\x8AM\x89ah\xADV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B`\x04T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17`\x04UV[\x87\x9Ea\x8A\x93\x8D`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[Tc\xFF\xFF\xFF\xFF`\x10\x82\x90\x1C\x16\x90\x81\x15a\x8DeW\x81[\x8Dc\xFF\xFF\xFF\xFF\x82\x16\x11a\x8DFWP`0\x1Cc\xFF\xFF\xFF\xFF\x16\x91c\xFF\xFF\xFF\xFF\x83\x16\x80\x15\x15\x90\x81a\x8D<W[Pa\x8D\x1DWT\x8E\x92\x91\x90`\xFF\x16\x90c\xFF\xFF\xFF\xFF\x81\x16\x15a\x8D\x14W\x90[a\x8A\xF5a'uV[`\x01`\x01`@\x1B\x03\x90\x94\x16\x84R3` \x85\x01R`\x01`\x01`@\x1B\x03B\x16`@\x85\x01R`\x01`\x01`@\x1B\x03\x89\x16``\x85\x01R\x8Dc\xFF\xFF\xFF\xFF\x16`\x80\x85\x01R_`\xA0\x85\x01R`\x01`\x01`\xA0\x1B\x03\x8A\x16`\xC0\x85\x01R\x8A`\xE0\x85\x01Ra\x01\0\x84\x01\x90a\x8B\\\x91argV[c\xFF\xFF\xFF\xFF\x16a\x01 \x83\x01Rc\xFF\xFF\xFF\xFF\x16a\x01@\x82\x01Ra\x01`\x81\x01_\x90Ra\x8B\x97\x89`\x01`\x01`@\x1B\x03\x16_R`\t` R`@_ \x90V[\x90a\x8B\xA1\x91a\x87\x81V[\x89_[\x8A\x8A\x83\x83\x10a\x8C\x98WPPPPP_[\x82\x81\x10a\x8C]WPPPa\x8C\x0C\x90`@Q\x99`\x01`\x01`@\x1B\x033\x91\x16`\x01`\x01`@\x1B\x03\x88\x16\x7F\xBD\x1F\xDD\xA3\x93\xB6y\xE6\xC4\xF8s\xE23\xB3N,N\xA8(:?v4]\xBC\x14;\x86\xEA\x04vy_\x80\xA4T`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x96`\x01`\x01`\xA0\x1B\x03\x88\x16a\x8C(W[PPPPPPPPPPV[caFl\t`\xE1\x1B` \x8A\x01Ra\x8CN\x99a!!\x97\x8A\x97a\t\x8C\x973\x90`$\x8B\x01a\x89\\V[_\x80\x80\x80\x80\x80\x80\x80\x80\x80a\x8C\x1CV[`\x01\x90a\x8C\x92a\x8C~\x8A`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[a\x8C\x8Ca\x7F\xE7\x84\x88\x88at\xEEV[\x90a\x89\x1BV[\x01a\x8B\xB4V[a\x8C\xFB\x82a]-a\x7F\xE7\x86\x88aJ\x7Fa\x8C\xE3a]l\x84\x8Ea\x8C\xDE`\x01\x9F\x9Da\x8C\x8Ca\x8D\x0C\x9F\x8Fa\x7F\xE7\x91aJ\x7F\x88\x92`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[ai2V[\x97`\x01`\x01`@\x1B\x03\x16_R`\x0B` R`@_ \x90V[\x90a\xFF\xFF\x16a\xFF\xFF\x19\x82T\x16\x17\x90UV[\x01\x8A\x90a\x8B\xA4V[P`\x01\x90a\x8A\xEDV[c\x1F\x8C\xFA9`\xE2\x1B_Rc\xFF\xFF\xFF\xFF\x80\x84\x16`\x04R\x8D\x16`$R`D_\xFD[\x90P\x8D\x11_a\x8A\xD1V[c\xEB\x8E\x17]`\xE0\x1B_Rc\xFF\xFF\xFF\xFF\x90\x81\x16`\x04R\x8D\x16`$R`D_\xFD[`\x01a\x8A\xA8V[a\x8D\x99\x92a]-a\x7F\xE7\x86a\x08}\x94aJ\x7Fa!\xCC\x97`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x15a\x8D\xBEWa'\x10a\x8D\xB1a\x1CCa]l\x84\x8Cai2V[\x11a\x14=W`\x01\x01a\x8A\x18V[\x8Ba|la\x7F\xE7a\x07e\x93\x8D\x8Dat\xEEV[a\x8D\xE2\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\xE3\x90\xFC\xDB`\xE0\x1B\x81R_`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x87\x16`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90Z\xFA_\x91\x81a\x8EFW[P\x15a\x8A\x15W\x15a\x8E*W_a\x8A\x15V[c\tD\x03\xB7`\xE4\x1B_R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04R`$_\xFD[a\x8E`\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_a\x8E\x19V[P\x86\x15\x15a\x8A\x10V[c!\x0E\xB4\xED`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x8B\x16`\x04R`$_\xFD[c\xDD\xF9\xD2E`\xE0\x1B_R`\x04_\xFD[`\x05\x01T`\xFF\x81`\x80\x1C\x16a\x8E\xAF\x81ac\xA3V[`\x01\x81\x14a\x8E\xDFWa\x8E\xC0\x81ac\xA3V[\x15\x90\x81a\x8E\xCBWP\x90V[`\x01`\x01`@\x1B\x03\x91P`@\x1C\x16B\x10\x15\x90V[PP_\x90V[3_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 T`\xFF\x16\x15a\x8F\x1DWV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u`$R`D_\xFD[3_\x90\x81R\x7FuD+\n\x96\x08\x8BTV\xBCN\xD0\x13\x94\xC9jO\xEE\xC0\xF8\x83\xC9IBW\xD7k\x96\xAB\x1C\x9Bk` R`@\x90 T`\xFF\x16\x15a\x8F\x8CWV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*`$R`D_\xFD[3_\x90\x81R\x7F\xABq\xE3\xF3&ftM$n\xDF\xF3\xF9nK\xDA\xFE\xE2\xE9\x86p\x98\xCD\xD1\x18\xA9y\xA7FG\x86\xA8` R`@\x90 T`\xFF\x16\x15a\x8F\xFBWV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7F\x18\x9A\xB7\xA9$M\xF0\x84\x81\"\x15C\x15\xAFq\xFE\x14\x0F=\xB0\xFE\x01@1x;\tF\xB8\xC9\xD2\xE3`$R`D_\xFD[_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 T`\xFF\x16\x15a\x90bWPV[c\xE2Q}?`\xE0\x1B_R3`\x04R`$R`D_\xFD[`\x01`\x01`@\x1B\x03\x80`\x04T`@\x1C\x16\x91\x16\x90\x81\x10\x15a\x90\xA0W_R`\t` R`@_ \x90V[c\x126\x16\xB3`\xE1\x1B_R`\x04R`$_\xFD[\x91\x90\x91_[\x81T\x81\x10\x15a\x92[Wa\x90\xCA\x81\x83alRV[P\x80T`\x01`\x01`\xA0\x1B\x03`\x08\x82\x90\x1C\x16\x91_\x91\x83\x91\x90\x83[\x88\x8A\x81\x83\x10a\x91\x1CW[PPPPPP\x15a\x91\x01WP`\x01\x01a\x90\xB7V[c\x10\xC8\xEB!`\xE3\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`$_\xFD[a\x0F\xF0` a\x910\x85\x89\x95a\x916\x95alBV[\x01al\x8BV[\x14\x80a\x92*W[a\x91IW`\x01\x01a\x90\xE3V[\x92PP\x91P`\x01a\x91``@aj\xF8\x84\x8A\x8CalBV[\x92\x01T\x91a\xFF\xFF\x80\x84\x16\x91\x16\x81\x11a\x91\xECWPa\x91\x91a\x91\x86`@aj\xF8\x84\x8A\x8CalBV[\x92`\x10\x1Ca\xFF\xFF\x16\x90V[\x91a\xFF\xFF\x80\x84\x16\x91\x16\x11a\x91\xAEWPP`\x01_\x80\x80\x80\x88\x8Aa\x90\xEDV[\x91a\x91\xC2`@aj\xF8a\x07e\x95\x89\x8BalBV[cm\x10\0\xB7`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04Ra\xFF\xFF\x90\x81\x16`$R\x16`DR`d\x90V[\x83a\x92\0`@aj\xF8a\x07e\x95\x8B\x8DalBV[c\x94\xF4|\xCB`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04Ra\xFF\xFF\x90\x81\x16`$R\x16`DR`d\x90V[Pa\x92>a\x929\x82\x8B\x8DalBV[al\x81V[`\xFF\x83\x16\x90a\x92L\x82a\"\xC7V[a\x92U\x81a\"\xC7V[\x14a\x91=V[PPPPV[\x90`@Q\x91\x82\x81T\x91\x82\x82R` \x82\x01\x90_R` _ \x92_[\x81\x81\x10a\x92\x90WPPa\x05\xD1\x92P\x03\x83a'6V[\x84T`\x01`\x01`\xA0\x1B\x03\x16\x83R`\x01\x94\x85\x01\x94\x87\x94P` \x90\x93\x01\x92\x01a\x92{V[\x94\x90\x93`\x01`\x01`@\x1B\x03\x80\x94\x81ao\x9C\x95\x81`\xA0\x99\x9C\x9B\x9C\x16\x8AR\x16` \x89\x01R\x16`@\x87\x01R`\x01\x80\x86\x1B\x03\x16``\x86\x01R`\xC0`\x80\x86\x01R`\xC0\x85\x01\x90aP\xDDV[a\x93\x12\x81`\x01`\x01`@\x1B\x03\x16_R`\t` R`@_ \x90V[`\x04T\x90\x91\x90`\x80\x1C`\x01`\x01`@\x1B\x03\x16\x90a\x93.\x82ah\xADV[`\x04\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x92\x90\x92\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x91\x90\x91\x17\x90U\x82T\x90`\x01`\x01`@\x1B\x03\x82\x16\x90a\x93\x82\x82`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[\x92a\x93\x9E\x83`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[P`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x94B`\x01`\x01`@\x1B\x03\x16\x93`\x01\x82\x01\x93\x84T\x97a\x93\xD3\x89`\x01`\x01`@\x1B\x03\x90`@\x1C\x16\x90V[\x98`\x80\x1Cc\xFF\xFF\xFF\xFF\x16`\x04\x85\x01T`\x08\x81\x90\x1Cc\xFF\xFF\xFF\xFF\x16`(\x82\x90\x1Cc\xFF\xFF\xFF\xFF\x16\x91`\xFF\x16\x92`\x02\x87\x01\x9C\x8DTa\x94\x12\x90`\xFF\x90`\x08\x1C\x16\x90V[\x95a\x94\x1Ba'uV[`\x01`\x01`@\x1B\x03\x90\x98\x16\x88R`\x01`\x01`\xA0\x1B\x03\x16` \x88\x01R`\x01`\x01`@\x1B\x03\x8C\x16`@\x88\x01R`\x01`\x01`@\x1B\x03\x16``\x87\x01R_`\x80\x87\x01R`\x01`\x01`@\x1B\x03\x8B\x16`\xA0\x87\x01Rc\xFF\xFF\xFF\xFF\x16`\xC0\x86\x01Rc\xFF\xFF\xFF\xFF\x16`\xE0\x85\x01Rc\xFF\xFF\xFF\xFF\x16a\x01\0\x84\x01Ra\x94\x98\x90a\x01 \x84\x01argV[a\x94\xA6\x90a\x01@\x83\x01arpV[`\x01a\x01`\x82\x01Ra\x94\xC9\x87`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[\x90a\x94\xD3\x91a\x845V[_\x97a\x94\xF0\x84`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[a\x94\xF9\x90a\x92aV[\x92\x83Qa\x95\x05\x90ah\xCAV[\x95_\x9A[\x85Q\x8C\x10\x15a\x95\xD7Wa\x95\xCF`\x01\x91a\xFF\xFF\x8Ea\x95\xC7a\x08\xCA\x8F\x8F\x90\x8F\x8F\x92\x8Fa\x95\xB0\x92a]Sa\x95da]Aa\x11z\x98a\x95Ja] \x8Ea\x95l\x98ai2V[\x9A\x8B\x91`\x01`\x01`@\x1B\x03\x16_R`\x0B` R`@_ \x90V[\x99\x8A\x92ai2V[a\x95\x84a\x95wa'WV[a\xFF\xFF\x89\x16\x81R\x91aY\xA0V[_`@\x82\x01R`\x01``\x82\x01Ra\x10\xD9\x85a\x08\xCA\x85`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[P\x16\x90au\xC0V[\x9B\x01\x9Aa\x95\tV[\x93\x99\x91\x96\x92\x97P\x94\x99Pa\x96\x12a\x95\xFF\x89`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[\x87T`@\x1C`\x01`\x01`\xA0\x1B\x03\x16a\x80:V[P_[a\x960\x8B`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[T\x81\x10\x15a\x96\x99W\x80a\x96\x92\x8Ca\x80:a\x96}`\x01\x95a/\xC7\x8Fa\x96e\x90`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[\x94`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[\x90T`\x03\x91\x90\x91\x1B\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[P\x01a\x96\x15V[P\x90a\x97*a\x96\xCD\x94\x93\x92a\x97 `\x01\x89\x9C\x8E\x9B\x9E\x8D`\x01`\x01`@\x1B\x03\x80\x80a\x97k\x9E\x9FT\x9D\x8E`\x01`\x01`@\x1B\x03\x16\x90V[\x16\x93\x16\x91\x16\x7Ft\x1E\x97\xEE\x1F\xF8\x87\xC4\xD8\x82\xF4\xC4\x9A\xD2\x80\xEA}a\xD05\xE4\xE8\xA4q\xE51\x95\x15P'P#_\x80\xA4\x01\x80T\x90\x97\x90a\x97\x19\x90`\x01`\x01`\xA0\x1B\x03\x16\x91`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90\x8Ca\xB0\xD9V[T`\x08\x1C`\xFF\x16\x90V[\x92a\x974\x84a\"\xE3V[\x83\x15\x80a\x98\xCFW[\x15a\x98\x8AW\x89Ta|\xF7\x94P`\x01`\x01`@\x1B\x03\x16`\x02\x8B\x01T`\x01`\x01`\xA0\x1B\x03\x16`\x03\x8C\x01T\x91\x8Ba\xB7\xC8V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16a\x97\x82W[PPPPPV[a\x97\xADa\x7Fja\x97\xA7\x85\x96\x97\x98\x95`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[TauzV[\x95T\x94`@\x86\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16a\x97\xCB\x81a\x7F}\x8Aai\x10V[_[a\x97\xE8\x87`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[T\x81\x10\x15a\x980W\x80a\x98*a\x98\x18a\x96}`\x01\x94a/\xC7\x8C`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[a\x7F}a\x98$\x84auzV[\x8Dai2V[\x01a\x97\xCDV[P\x90a\t\x9A\x93\x94\x97a\t\x8C\x92a\x98ca\x98Ra\x98\x80\x9A`\x01`\x01`@\x1B\x03\x16\x90V[\x95T`@\x1C`\x01`\x01`@\x1B\x03\x16\x90V[\x92`@Q\x98\x89\x96c \xA8{9`\xE2\x1B` \x89\x01R`$\x88\x01a\x92\xB2V[_\x80\x80\x80\x80a\x97{V[PPP\x80a\x98\x99`\x01\x92a\"\xE3V[\x14\x80a\x98\xC2W[\x15a|\xF7W`\x02\x86\x01T`\x03\x87\x01Ta\x80\x94\x91`\x01`\x01`\xA0\x1B\x03\x16\x87a\xB4\x8CV[P`\x03\x86\x01T\x15\x15a\x98\xA0V[P`\x03\x8A\x01T\x15\x15a\x97<V[`\x01`\x01`@\x1B\x03\x80`\x04T`\x80\x1C\x16\x91\x16\x90\x81\x10\x15a\x99\x04W_R`\x10` R`@_ \x90V[cdQE\xDB`\xE1\x1B_R`\x04R`$_\xFD[a\x0B\xE6\x91`\x01`\x01`\xA0\x1B\x03\x16\x90a\xBA\x1BV[`\x01`\x01`@\x1B\x03\x90\x81\x16_\x81\x81R`\x15` R`@\x90 T\x83\x83\x16\x94\x93\x92\x16\x84\x10\x15a\x99wWa\x0B\xE6\x92\x93P_R`\x16` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[\x83\x90c%\xB1\xBA\xFF`\xE2\x1B_R`\x04R`$R`D_\xFD[\x91\x90`\x01`\x01`@\x1B\x03\x83\x16\x91\x82_R`\x10` R`@_ \x92_R`\x12` Ra\x99\xBB`@_ a\xBB3V[a\x99\xC5\x81Qah\xCAV[\x91_\x93_\x94[\x83Q\x86\x10\x15a\x9AGWa\x9A?`\x01\x91a\x9A/a\x9A%a]Aa\x99\xFE\x8D`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[a\x9A\x08\x8C\x8Bai2V[\x87\x80`\xA0\x1B\x03\x90Q\x16`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[a]S\x8A\x8Aai2V[aP\xADa\x1CCa]l\x8A\x8Aai2V[\x95\x01\x94a\x99\xCBV[\x94P\x90\x95a\x9A_a\x05\xD1\x96T`\x01`\x01`@\x1B\x03\x16\x90V[\x90a\xB5VV[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90_\x80Q` a\xC8\x87\x839\x81Q\x91R\x81\x80\xA4`\x01\x90V[P_\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x90`\x01`\x01`\xA0\x1B\x03\x16\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7FuD+\n\x96\x08\x8BTV\xBCN\xD0\x13\x94\xC9jO\xEE\xC0\xF8\x83\xC9IBW\xD7k\x96\xAB\x1C\x9Bk` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7FuD+\n\x96\x08\x8BTV\xBCN\xD0\x13\x94\xC9jO\xEE\xC0\xF8\x83\xC9IBW\xD7k\x96\xAB\x1C\x9Bk` R`@\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x90`\x01`\x01`\xA0\x1B\x03\x16\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xABq\xE3\xF3&ftM$n\xDF\xF3\xF9nK\xDA\xFE\xE2\xE9\x86p\x98\xCD\xD1\x18\xA9y\xA7FG\x86\xA8` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xABq\xE3\xF3&ftM$n\xDF\xF3\xF9nK\xDA\xFE\xE2\xE9\x86p\x98\xCD\xD1\x18\xA9y\xA7FG\x86\xA8` R`@\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x90`\x01`\x01`\xA0\x1B\x03\x16\x7F\x18\x9A\xB7\xA9$M\xF0\x84\x81\"\x15C\x15\xAFq\xFE\x14\x0F=\xB0\xFE\x01@1x;\tF\xB8\xC9\xD2\xE3_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_\x80Q` a\xC9G\x839\x81Q\x91R` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_\x80Q` a\xC9G\x839\x81Q\x91R` R`@\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x90`\x01`\x01`\xA0\x1B\x03\x16\x7FLpp\xC6\xC1\x9C\xC9\xB4'\xB9O\xE5\x97\x9E\xE0\xC5s\xF8\xED\xD0\r%Y\x1A\xFEL\x95\x10\xDE\x94y\xBA_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\xFF\x16a\x8E\xDFW_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91`\x01`\x01`\xA0\x1B\x03\x16\x90_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[\x91\x90\x91\x82Q`\x01`\x01`@\x1B\x03\x81\x11a&\xA9Wa\x9E\x8F\x81aq\x01\x84Tam\xD5V[` `\x1F\x82\x11`\x01\x14a\x9E\xC9W\x81\x90ap\x8F\x93\x94\x95_\x92a\x9E\xBEWPP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[\x01Q\x90P_\x80aq\"V[`\x1F\x19\x82\x16\x90a\x9E\xDC\x84_R` _ \x90V[\x91_[\x81\x81\x10a\x9F\x15WP\x95\x83`\x01\x95\x96\x97\x10a\x9E\xFDWPPP\x81\x1B\x01\x90UV[\x01Q_\x19`\xF8\x84`\x03\x1B\x16\x1C\x19\x16\x90U_\x80\x80aqkV[\x91\x92` `\x01\x81\x92\x86\x8B\x01Q\x81U\x01\x94\x01\x92\x01a\x9E\xDFV[`\x06a\x01 a\x05\xD1\x93a\x9Fga\x9FJ\x82Q`\x01`\x01`@\x1B\x03\x16\x90V[\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x90\x91\x16\x17\x85UV[` \x81\x01Qa\x9F\x7F\x90`\x01`\x01`\xA0\x1B\x03\x16\x85a\x83\xBAV[`@\x81\x01Q`\x01\x85\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90\x91\x17\x90U``\x81\x01Q`\x02\x85\x01U`\x80\x81\x01Q`\x03\x85\x01U`\xA0\x81\x01Q`\x04\x85\x01Ua\xA0\r`\x05\x85\x01a\x9F\xE1a\x84S`\xC0\x85\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x9F\xF8a\x84\xBE`\xE0\x85\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x01\0\x83\x01Q\x90a\xA0\x08\x82ac\xA3V[a\x86UV[\x01Q\x91\x01a\x9EnV[\x95\x94\x90\x92\x80\x15a\xA1\xBAW`\x01`\x01`\xA0\x1B\x03\x84\x16\x94\x85\x15a=\xB6Wa\xA0;\x90\x82a\xBA~V[\x96\x87\x15a\xA1\xBAWa\xA1\xB5`\x01`\x01`@\x1B\x03\x92\x7F)a[E\x7F\"\xE1c\xCCE@2}p\xF3\\\x19\x90\xA8\xEF\0\x03\xE9\x15\xAD\x17\n\xCB\x81z\xCE=\x94\x84B\x16\x9Aa\xA0\x8Fa\xA0\x89`\x1CT`\x01`\x01`@\x1B\x03\x16\x90V[\x8Dao\xA3V[\x92a\xA1ta\xA0\xA5`\x1BT`\x01`\x01`@\x1B\x03\x16\x90V[\x9Aa\xA0\xCFa\xA0\xB2\x8Dah\xADV[`\x1B\x90`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90UV[a\xA1/\x8C\x9Fa\xA0\xFCa\xA0\xDFa'\xA3V[`\x01`\x01`@\x1B\x03\x8C\x16\x81R\x93`\x01`\x01`\xA0\x1B\x03\x16` \x85\x01RV[`\x01`\x01`\xA0\x1B\x03\x8D\x16`@\x84\x01R\x84``\x84\x01R\x85`\x80\x84\x01R\x86`\xA0\x84\x01R`\xC0\x83\x01\x90`\x01`\x01`@\x1B\x03\x16\x90RV[`\x01`\x01`@\x1B\x03\x86\x16`\xE0\x82\x01R_a\x01\0\x82\x01Ra\xA1MaKWV[a\x01 \x82\x01Ra\xA1o\x8C`\x1D\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[a\x9F-V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x9A\x16\x8AR` \x8A\x01\x91\x90\x91R\x88\x01R``\x87\x01R`\x01`\x01`@\x1B\x03\x16`\x80\x86\x01R\x90\x82\x16\x94\x90\x91\x16\x92\x90\x81\x90`\xA0\x82\x01\x90V[\x03\x90\xA4V[c\xC5\x8DY5`\xE0\x1B_R`\x04_\xFD[\x80\x15a\xA1\xEFW\x80\x82\x10a\xA1\xDAWPPV[c\xB9\x9E*\xB7`\xE0\x1B_R`\x04R`$R`D_\xFD[PPV[\x81\x15a\xA2NW`\x01`\x01`\xA0\x1B\x03\x16\x80a\xA2\x13WP\x80\x82\x10a\xA1\xDAWPPV[a\x05\xD1\x92P`@Q\x91c#\xB8r\xDD`\xE0\x1B` \x84\x01R3`$\x84\x01R0`D\x84\x01R`d\x83\x01R`d\x82Ra\xA2I`\x84\x83a'6V[a\xC2\x8FV[PPPV[\x90_\x80\x91` \x81Q\x91\x01\x82\x85Z\xF1a\xA2ia\x86\xB3V[\x90\x15a\xA2sWPPV[\x80Qa\xA2\x9AWPc8\xE6\x07M`\xE1\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[`@\x80Qc\x03\xD4'a`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x93\x16`\x04\x84\x01R`$\x83\x01R\x81\x90aV]\x90`D\x83\x01\x90aKkV[_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\xFF\x16\x15a\x8E\xDFW_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16\x90U3\x91`\x01`\x01`\xA0\x1B\x03\x16\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B_\x80\xA4`\x01\x90V[\x90`\x01\x80`\xA0\x1B\x03\x82\x16\x91\x82_R`\x19` R`@_ _\x80R` R`@_ T\x92\x83\x15a\xA3\xB9W_a\x05\xD1\x92\x85\x92\x82R`\x19` R`@\x82 \x82\x80R` R\x81`@\x81 Ua\xA7<V[P_\x92PPV[`\x01`\x01`\xA0\x1B\x03\x81\x81\x16_\x81\x81R`\x19` \x90\x81R`@\x80\x83 \x94\x87\x16\x83R\x93\x90R\x91\x90\x91 T\x93\x92\x91\x90\x84\x15a\xA4$W\x91\x84\x91a\x05\xD1\x93_R`\x19` R_a\xA4\x1E\x83`@\x83 \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[Ua\xA7<V[P_\x93PPPV[\x91\x90\x81\x15\x80\x15a\xA4DW[a\xA2NWa\x05\xD1\x92a\xA7<V[P`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\xA47V[\x91\x90a\xA4s\x83`\x1D\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[\x80T`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x15a\xA5^W`\x05\x81\x01\x80T`\x80\x81\x90\x1C`\xFF\x16a\xA4\x9D\x81ac\xA3V[a\xA5BWa\xA4\xB6\x90`@\x1C`\x01`\x01`@\x1B\x03\x16a!\xCCV[B\x10\x15a\xA5&W\x80T`\xFF`\x80\x1B\x19\x16`\x01`\x80\x1B\x17\x90U\x7F\rD\x18\xCC\x07\xB1\xC8\x1FV\xE2\xD1'\x7F]\x11\xC1\xB2~\xBA\xC6\xCD\xAC\xAF\xCC\xEC\xD4\xAD\xD6t+K\x0F\x91`\x01`\x01`@\x1B\x03\x91a\xA5\x07\x90\x85\x90`\x06\x01a\x9EnV[a\xA5!`@Q\x92\x83\x92`\x01\x80`\xA0\x1B\x03\x16\x96\x16\x94\x82aK\x8FV[\x03\x90\xA3V[c3|,\x01`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x85\x16`\x04R`$_\xFD[c\x07\x97i\xAD`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x86\x16`\x04R`$_\xFD[c\x16.?\xAB`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[a\xA5\x95\x90`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[`\x02\x81\x01T`\x01`p\x82\x90\x1C`\xFF\x16a\xA5\xAD\x81a\"\xE3V[\x03a\x8E\xDFW`\x01\x90`h\x1C`\xFF\x16a\xA5\xC4\x81a\"\xE3V[\x03a\x9A\xFCW`\x01\x81\x01T\x90`\x01`\x01`@\x1B\x03`@\x83\x90\x1C\x16\x80\x15\x15\x90\x81a\xA6:W[Pa\x8E\xDFWa\xA6+\x91a\xA6%`\x02a\xA6\x16a\xA6\x0Fa!Ga!\xCC\x96T`\x01`\x01`@\x1B\x03\x16\x90V[\x93`\xC0\x1C\x90V[\x92\x01T`\x01`\x01`@\x1B\x03\x16\x90V[\x90ao\xA3V[B\x10a\xA66W`\x01\x90V[_\x90V[a\xA6R\x91Pa!\xCC\x90`\x01`\x01`@\x1B\x03\x85\x16ao\xA3V[B\x11_a\xA5\xE7V[\x92\x90\x91\x92\x83\x15a\x92[W\x83`\x02\x82\x01\x93\x84T\x15_\x14a\xA6\xB8W\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x82\x16\x17\x83U`\x01\x93a\xA6\x9A\x92\x90\x91a\xA1\xF3V[\x01\x80T\x90\x83\x82\x01\x80\x92\x11aP\xD8WU\x80T\x91\x82\x01\x80\x92\x11aP\xD8WUV[\x82T\x90\x91P`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x82\x16\x03a\xA6\xDDW`\x01\x92\x85a\xA6\x9A\x92a\xA1\xF3V[cV\xE7\xEC_`\xE0\x1B_R`\x04_\xFD[\x81\x15\x80\x15a\xA7+W[a\xA1\xEFW_\x91\x82\x91\x82\x91\x82\x91`\x01`\x01`\xA0\x1B\x03\x16Z\xF1a\xA7\x14a\x86\xB3V[P\x15a\xA7\x1CWV[c\x07\xA4\xCE\xD1`\xE5\x1B_R`\x04_\xFD[P`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\xA6\xF5V[\x90\x82\x15\x80\x15a\xA7\xADW[a\xA2NW`\x01`\x01`\xA0\x1B\x03\x16\x80a\xA7tWP_\x91\x82\x91\x82\x91\x82\x91`\x01`\x01`\xA0\x1B\x03\x16Z\xF1a\xA7\x14a\x86\xB3V[`@Qc\xA9\x05\x9C\xBB`\xE0\x1B` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`$\x83\x01R`D\x82\x01\x92\x90\x92Ra\x05\xD1\x91a\xA2I\x82`d\x81\x01a\t\x8CV[P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a\xA7FV[\x91\x90`\x01`\x01`@\x1B\x03\x83\x16_R`\x1D` R`@_ \x92\x83`\x01\x80`\xA0\x1B\x03\x81T`@\x1C\x16\x15a\xA8\x7FWa\xA7\xF5a\x15\x8A\x82a\x8E\x9BV[a\xA8cW`\x05\x81\x01\x80T`\xFF`\x80\x1B\x19\x16`\x01`\x81\x1B\x17\x90UT\x91\x7FJ\x81n\x13'\x12\xDB\xDF\xE6\xA3c\x96^[\xC6\x8F\x8E(;\x99\x9A\xE1\x1A\xFE)J1b\x97<8U`\x01`\x01`@\x1B\x03a\xA8D\x81\x86\x16a\x1B\x1BV[`@Q\x93\x84R`\x01`\x01`\xA0\x1B\x03\x16\x94\x81\x16\x93\x16\x91\x80` \x81\x01a\xA1\xB5V[c\xB4\x8B\tY`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R`$_\xFD[c\x16.?\xAB`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R`$_\xFD[\x91\x90\x91a\xA8\xA6a\xBB{V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x80\x15a\xA9\xDBW[\x80\x15a\xA9\xCAW[a=\xB6Wa\xA9Z\x92a\xA9\x1Ba\xA9=\x92a\xA8\xD6a\xBB{V[a\xA8\xDEa\xBB\xA6V[a\xA8\xE6a\xBB\xDAV[a\xA8\xEEa\xBB{V[a\xA8\xF7\x81a\x9AeV[Pa\xA9\x01\x81a\x9B\x01V[Pa\xA9\x0B\x81a\x9B\xC2V[Pa\xA9\x15\x81a\x9C\x83V[Pa\x9DDV[P_\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`\x01\x80`\xA0\x1B\x03\x16`\x01`\x01``\x1B\x03`\xA0\x1B`\x01T\x16\x17`\x01UV[a\xA9\x9Fa\xA9ea'WV[a\x13\x88\x81Ra\x03\xE8` \x82\x01Ra\x07\xD0`@\x82\x01\x81\x90R``\x90\x91\x01R`\x02\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\x07\xD0\x07\xD0\x03\xE8\x13\x88\x17\x90UV[a\xA9\xC2a\xA9\xBDa\xA9\xADa\xA9\xECV[0\x90a\xA9\xB7a\xAA\x15V[\x90a\xBB\xEAV[`\x03UV[a\x05\xD1a\xBC[V[P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a\xA8\xBFV[P`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\xA8\xB8V[`@Q\x90a\xA9\xFB`@\x83a'6V[`\x0B\x82RjTangleQuote`\xA8\x1B` \x83\x01RV[`@Q\x90a\xAA$`@\x83a'6V[`\x01\x82R`1`\xF8\x1B` \x83\x01RV[\x93\x92\x91a\xAAb`\x02a\xAAW\x87`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[\x01Tc\xFF\xFF\xFF\xFF\x16\x90V[\x91a\xAA\x81a\\\xC8\x87`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[\x93_\x94_\x94_\x94_[\x83Q\x81\x10\x15a\xAB<Wa\xAA\xBEa\xAA\xA3a] \x83\x87ai2V[a\x08\xCA\x8D`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[T`\xFF`\x90\x82\x90\x1C\x16\x15a\xAB3W`\xFF\x86\x16`\x01\x03a\xAB&Wa\xAA\xE8a\x1CCa\xAA\xEF\x92a\xFF\xFF\x16\x90V[\x80\x99au\xC0V[\x97`\x01\x80\x88\x84\x1C\x16\x14a\xAB\x08W[P`\x01\x90[\x01a\xAA\x8AV[a\xAB\x1F\x90a\xAB\x19`\x01\x93\x99\x9Bat\xFEV[\x9Aau\xC0V[\x96\x90a\xAA\xFDV[Pa\xAA\xEF`\x01\x80\x99au\xC0V[P`\x01\x90a\xAB\x02V[P\x97\x96\x95\x94\x93P\x97PP`\xFF\x16\x15_\x14a\xAB\x94WPPa\xABka\xFF\xFFc\xFF\xFF\xFF\xFFa\xABs\x93\x96\x16\x94\x16\x84aoQV[a'\x10\x90\x04\x90V[\x91\x82\x15\x90\x81a\xAB\x8AW[Pa\xAB\x84WV[`\x01\x91PV[\x90P\x15\x15_a\xAB}V[\x94P\x92a\xABs\x91Pa\xABk\x90a\xFF\xFF\x16\x84aoQV[a\xAB\xB6a\x15\x8A\x82a\xA5zV[a\x9A\xFCWa\xAB\xD5\x81`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[\x90a\xAB\xEAa!G\x83T`\x01`\x01`@\x1B\x03\x16\x90V[\x90a\xAC\x06\x81`\x01`\x01`@\x1B\x03\x16_R`\x14` R`@_ \x90V[\x90`\x01\x83\x01T\x91\x82`\x01\x82\x01T\x10a\xAD7W\x82a\xAC\"\x91a\xBE\nV[`\x01\x85\x01\x80T`\x01`\x01`\xC0\x1B\x03\x16B`\xC0\x1B`\x01`\x01`\xC0\x1B\x03\x19\x16\x17\x90U\x94a\xACaa\\\xC8\x83`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[\x92a\xACl\x84Qah\xCAV[\x94_\x97_\x98[\x86Q\x8A\x10\x15a\xAC\xCCWa\xAC\xC4`\x01\x91aP\xADa\x1CCa]l\x8Ea\x98$\x8Ea]S\x8F\x8Fa]A\x86\x92a]-a] \x85a]\x1Aa\xAC\xBE\x96`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x92ai2V[\x99\x01\x98a\xACrV[a\xAD/\x94\x99Pa\xAD!\x90\x7F$\xDCH[\xEF\x04\xB4\xD7\x90\xD9z\xC1\x03\x81\xD8\xD9\xE6lV\xDDo\xBA\x991\xB7\x03\xCA\x16\x95\x11w\x8A\x98`\x01`\x01`@\x1B\x03\x98\x86`\x02\x96\x95a\xAD\x1Ba]\xC7\x99\x9ET`\x01`\x01`@\x1B\x03\x16\x90V[\x8Ba\xB7\xC8V[\x01T`\x01`\x01`@\x1B\x03\x16\x90V[\x03\x90\xA2`\x01\x90V[PPPPP_\x90V[\x93\x92\x90\x91\x93\x82Q\x15a\xAE\xF2Wa\xADV\x83Qah\xCAV[\x90_\x93_\x94[\x81Q\x86\x10\x15a\xAE\xE8Wa\xADo\x86\x83ai2V[Q`@\x81\x01_[\x88\x81\x10a\xAE\xA2WP\x81QQ`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x8B\x16`\x01`\x01`@\x1B\x03\x82\x16\x03a\xAEsWP\x81Q` \x01Q`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x88\x16`\x01`\x01`@\x1B\x03\x82\x16\x03a\xAEDWP\x81Q`\x80\x01Q`\x01`\x01`@\x1B\x03\x16B\x81\x10a\xAE\x1BWP\x91`@\x82a\xAE\na\xAE\0`\x01\x96a] a\xAE\x13\x97\x8B`\x1Ea\xBEYV[a\x7F}\x8C\x8Bai2V[Q\x01Q\x90au\xC0V[\x95\x01\x94a\xAD\\V[\x90Qc{\xBEW\xE9`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`\x01`\x01`@\x1B\x03\x16`$R`D_\xFD[\x90Qc\xAD!\xCDe`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`\x01`\x01`@\x1B\x03\x80\x88\x16`$R\x16`DR`d_\xFD[\x90QcV\xFEa\xA3`\xE1\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`\x01`\x01`@\x1B\x03\x80\x8B\x16`$R\x16`DR`d_\xFD[a\xAE\xAFa] \x82\x89ai2V[\x82Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x16\x81\x14a\xAE\xCDWP`\x01\x01a\xADvV[c\x02xy\x17`\xE1\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`$_\xFD[\x96PPP\x92\x91PPV[c?l'\xF9`\xE0\x1B_R`\x04_\xFD[\x91\x90\x81\x10\x15ai\x1DW`\x05\x1B\x81\x015\x90`^\x19\x816\x03\x01\x82\x12\x15a\x05\xAFW\x01\x90V[\x905\x90`\xBE\x19\x816\x03\x01\x82\x12\x15a\x05\xAFW\x01\x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x05\xAFW\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFW` \x01\x91``\x82\x026\x03\x83\x13a\x05\xAFWV[\x90\x92\x91\x94\x93_\x90_\x96`\x01`\x01`@\x1B\x03B\x16\x92[\x85Q\x89\x10\x15a\xB0\x91Wa\xB0:`\x01\x91a\xFF\xFF\x8B\x8A\x8A\x8A\x8A\x8A\x8Aa'\x10\x95a\xAF\xC0a\xAF\xB6a\xAF\xB0\x8A\x85\x85a\xAF\x01V[\x80a\xAF#V[`\xA0\x81\x01\x90a\xAF8V[\x90Pa\xB0BW[PP\x94a]\x1Aa\x80:\x93a\x95\xB0a] \x94a\xAF\xEA\x89a]S\x87a\x95\xC7\x9C\x9Dai2V[a\xB0\x02a\xAF\xF5a'WV[a\xFF\xFF\x8C\x16\x81R\x91aY\xA0V[_`@\x82\x01R`\x01``\x82\x01Ra\x10\xD9a\xB0-\x84`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[a]-a] \x88\x8Cai2V[\x98\x01\x97a\xAF\x82V[a\x95\xC7\x96P\x93a\x95\xB0a] \x94a\xAF\xEA\x8A\x95a]Sa\xB0}`@aj\xF8a\xB0wa\xAF\xB6a\xAF\xB0a\x80:\x9Fa]\x1A\x9D\x8F\x91a\xAF\x01V[\x90al9V[\x9BPP\x95PP\x94PP\x93PP\x8F\x8B\x90a\xAF\xC7V[\x97PPPPPPPV[\x91\x90\x82`@\x91\x03\x12a\x05\xAFW` \x82Qa\xB0\xB4\x81a9\xB7V[\x92\x01Qa\x0B\xE6\x81a\x05\xB3V[\x91\x90\x82`@\x91\x03\x12a\x05\xAFW` \x82Qav\xC0\x81a9\xB7V[` T`\x01`\x01`\xA0\x1B\x03\x16\x92\x90\x91\x90\x83\x15a\x92[W_\x93\x84\x92`\x01`\x01`\xA0\x1B\x03\x16\x80a\xB29W[Pa\xB1\x15\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x80;\x15a\x05\xAFW`@QbWxU`\xE4\x1B\x81R`\x01`\x01`@\x1B\x03\x85\x16`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16`$\x83\x01R_\x90\x82\x90`D\x90\x82\x90\x84\x90Z\xF1a\xB2%W[P`\x01`\x01`@\x1B\x03\x83\x16\x15\x80\x15\x81a\xB2\x19W[a\xB1xWPPPPV[a\xB2\x0FW[`\xFF\x81\x16\x15a\xB2\x07W[` Ta\xB1\x9E\x90a\x0F\xF0\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[\x80;\x15a\x05\xAFW`@Qc\xB9\x9FgY`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x93\x84\x16`\x04\x82\x01R\x93\x90\x92\x16`$\x84\x01R`\xFF\x16`D\x83\x01R_\x90\x82\x90`d\x90\x82\x90\x84\x90Z\xF1a\xB1\xEDW[\x80\x80\x80a\x92[V[\x80a\xB1\xFB_a\xB2\x01\x93a'6V[\x80a\x07\xC0V[_a\xB1\xE5V[P`\x03a\xB1\x87V[a\x01,\x92Pa\xB1}V[P`\xFF\x82\x16\x15\x15a\xB1nV[\x80a\xB1\xFB_a\xB23\x93a'6V[_a\xB1ZV[`@\x80Qbh\x08\x0B`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x87\x16`\x04\x82\x01R\x90\x81`$\x81\x85Z\xFA\x90\x81_\x91_\x93a\xB3nW[Pa\xB3BW[PP`@\x80QcIe\xDB\xC7`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x87\x16`\x04\x82\x01R\x91\x82\x90`$\x90\x82\x90Z\xFA\x90\x81_\x91_\x93a\xB3\x0FW[Pa\xB2\xAEW[Pa\xB1\x02V[\x15\x80a\xB3\x03W[a\xB2\xC0W[\x80a\xB2\xA8V[\x90\x92P`\xFF\x16`P\x81\x11\x15a\xB2\xE1WPa\xB1\x15a\x0F\xF0`\x01[\x93\x91Pa\xB2\xBAV[`2\x10\x15a\xB2\xF6Wa\xB1\x15a\x0F\xF0`\x02a\xB2\xD9V[a\xB1\x15a\x0F\xF0`\x03a\xB2\xD9V[P`\xFF\x81\x16\x15\x15a\xB2\xB5V[\x90\x92Pa\xB34\x91P`@=`@\x11a\xB3;W[a\xB3,\x81\x83a'6V[\x81\x01\x90a\xB0\xC0V[\x91_a\xB2\xA2V[P=a\xB3\"V[\x15\x80a\xB3\\W[a\xB3TW[\x80a\xB2nV[\x95P_a\xB3NV[P`\x01`\x01`@\x1B\x03\x81\x16\x15\x15a\xB3IV[\x90\x92Pa\xB3\x93\x91P`@=`@\x11a\xB3\x9AW[a\xB3\x8B\x81\x83a'6V[\x81\x01\x90a\xB0\x9BV[\x91_a\xB2hV[P=a\xB3\x81V[\x80T\x80\x15a\xB3\xC8W_\x19\x01\x90a\xB3\xB7\x82\x82al$V[\x81T\x90_\x19\x90`\x03\x1B\x1B\x19\x16\x90UUV[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[`\x01\x81\x01\x91\x80_R\x82` R`@_ T\x92\x83\x15\x15_\x14a\xB4\x84W_\x19\x84\x01\x84\x81\x11aP\xD8W\x83T_\x19\x81\x01\x94\x90\x85\x11aP\xD8W_\x95\x85\x83a\xB47\x97a\xB4*\x95\x03a\xB4=W[PPPa\xB3\xA1V[\x90_R` R`@_ \x90V[U`\x01\x90V[a\xB4ma\xB4g\x91a\xB4^a\xB4Ta\xB4{\x95\x88al$V[\x90T\x90`\x03\x1B\x1C\x90V[\x92\x83\x91\x87al$V[\x90apvV[\x85\x90_R` R`@_ \x90V[U_\x80\x80a\xB4\"V[PPPP_\x90V[`\x01`\x01`@\x1B\x03\x16_\x81\x81R`\x14` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x17\x81U\x90\x91\x90`\x01\x81\x01\x90\x81T\x85\x81\x01\x80\x91\x11aP\xD8W`\x02\x92U\x01\x80T\x91\x84\x83\x01\x80\x93\x11aP\xD8W\x91\x90U`@Q\x92\x83R`\x01`\x01`\xA0\x1B\x03\x16\x91\x7F\xD2\x8D\xE7\xC5\x18\xC3\x12\xFA8\x8E\x03\xF8\xD1 =\x8FLu\x16\x1E5\x8F\xFB\x08'\xB6\xCA\xA2\xE9\xAC\x8A1\x90` \x90\xA3V[`@Q\x90a\xB5)\x82a&\xAEV[\x81``a\xFF\xFF`\x02T\x81\x81\x16\x84R\x81\x81`\x10\x1C\x16` \x85\x01R\x81\x81` \x1C\x16`@\x85\x01R`0\x1C\x16\x91\x01RV[\x93\x91\x95\x94\x92\x90\x86\x15a\xB7\xBFWa\xB5\x92a\xB5\x83a\xB5\xC5\x92`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[\x97a\xB5\x8Ca\xB5\x1CV[\x90a\xBF\xE0V[\x87T\x90\x97\x90a\xB5\xAC\x90`\x01\x90`\x01`\x01`\xA0\x1B\x03\x16aj\xFEV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\xB7>W[P_\x88Q\x91a\xA7<V[`\x01T` \x87\x01Qa\xB5\xE1\x91_\x90`\x01`\x01`\xA0\x1B\x03\x16a\xA7<V[\x82a\xB5\xEFW[PPPP\x90PV[\x85```@a\xB6\x04\x96\x98\x01Q\x91\x01Q\x90a\xC1\x0FV[_[\x81Q\x81\x10\x15a\xB70Wa\xB6Ca\xB6-a\xB6\x1F\x83\x85ai2V[QQ`\x01`\x01`\xA0\x1B\x03\x16\x90V[_` a\xB6:\x85\x87ai2V[Q\x01Q\x91a\xC2SV[`@a\xB6O\x82\x84ai2V[Q\x01Qa\xB6_W[`\x01\x01a\xB6\x06V[_Ta\xB6\x8D\x90a\xB6w\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[_`@a\xB6\x84\x85\x87ai2V[Q\x01Q\x91a\xA7<V[_Ta\xB6\xA1\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x90a\xB6\xAFa\xB6\x1F\x82\x85ai2V[`@a\xB6\xBB\x83\x86ai2V[Q\x01Q\x83;\x15a\x05\xAFW`@QcQ\xDC\xE2\xE1`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16`\x04\x83\x01R`\x01`\x01`@\x1B\x03\x87\x16`$\x83\x01R`D\x82\x01R\x91_\x90\x83\x90`d\x90\x82\x90\x84\x90Z\xF1\x91\x82\x15a\x13cW`\x01\x92a\xB7\x1CW[P\x90Pa\xB6WV[\x80a\xB1\xFB_a\xB7*\x93a'6V[_a\xB7\x14V[PP\x90P\x80_\x80\x80\x80a\xB5\xE7V[a\xB7P\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\x08\x17\x9F5`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x88\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA_\x91\x81a\xB7\x9EW[P\x15a\xB5\xBBW`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\xB5\xBBW\x90P_a\xB5\xBBV[a\xB7\xB8\x91\x92P` =` \x11a\x1D\xE0Wa\x1D\xD1\x81\x83a'6V[\x90_a\xB7\x81V[PPPPP\x90PV[\x94\x91\x93\x90\x96\x95\x92\x96\x87\x15a\xBA\x11Wa\xB8\0a\xB7\xF7a\xB83\x92`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[\x98a\xB5\x8Ca\xB5\x1CV[\x88T\x90\x98\x90a\xB8\x1A\x90`\x01\x90`\x01`\x01`\xA0\x1B\x03\x16aj\xFEV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\xB9\x90W[P\x85\x89Q\x91a\xA7<V[`\x01T` \x88\x01Qa\xB8O\x91\x86\x90`\x01`\x01`\xA0\x1B\x03\x16a\xA7<V[\x82a\xB8]WPPPPP\x90PV[\x86```@a\xB8s\x96\x97\x99\x01Q\x91\x01Q\x90a\xC1\x0FV[\x90_[\x82Q\x81\x10\x15a\xB9\x80Wa\xB8\x9Ca\xB8\x8Fa\xB6\x1F\x83\x86ai2V[\x83` a\xB6:\x85\x88ai2V[`@a\xB8\xA8\x82\x85ai2V[Q\x01Qa\xB8\xB8W[`\x01\x01a\xB8vV[_Ta\xB8\xDD\x90a\xB8\xD0\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x83`@a\xB6\x84\x85\x88ai2V[_Ta\xB8\xF1\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x90a\xB8\xFFa\xB6\x1F\x82\x86ai2V[`@a\xB9\x0B\x83\x87ai2V[Q\x01Q\x83;\x15a\x05\xAFW`@QcQ\xDC\xE2\xE1`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16`\x04\x83\x01R`\x01`\x01`@\x1B\x03\x88\x16`$\x83\x01R`D\x82\x01R\x91_\x90\x83\x90`d\x90\x82\x90\x84\x90Z\xF1\x91\x82\x15a\x13cW`\x01\x92a\xB9lW[P\x90Pa\xB8\xB0V[\x80a\xB1\xFB_a\xB9z\x93a'6V[_a\xB9dV[PPP\x90P\x80_\x80\x80\x80\x80a\xB7\xBFV[a\xB9\xA2\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\x08\x17\x9F5`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x89\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA_\x91\x81a\xB9\xF0W[P\x15a\xB8)W`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\xB8)W\x90P_a\xB8)V[a\xBA\n\x91\x92P` =` \x11a\x1D\xE0Wa\x1D\xD1\x81\x83a'6V[\x90_a\xB9\xD3V[PPPPPP\x90PV[_\x82\x81R`\x01\x82\x01` R`@\x90 Ta\x8E\xDFW\x80T\x90`\x01`@\x1B\x82\x10\x15a&\xA9W\x82a\xBAia\xBAS\x84`\x01\x80\x96\x01\x85U\x84al$V[\x81\x93\x91T\x90`\x03\x1B\x91\x82\x1B\x91_\x19\x90\x1B\x19\x16\x17\x90V[\x90U\x80T\x92_R\x01` R`@_ U`\x01\x90V[a\xBA\x90\x90a\xFF\xFFa'\x10\x93\x16\x90aoQV[\x04\x90V[\x90\x81;\x15a\xBB\x12W_\x80Q` a\xC8\xC7\x839\x81Q\x91R\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x80Q\x15a\xBA\xFAWa\x86\xF9\x91a\xC2\xE7V[PP4a\xBB\x03WV[c\xB3\x98\x97\x9F`\xE0\x1B_R`\x04_\xFD[PcL\x9C\x8C\xE3`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[\x90`@Q\x91\x82\x81T\x91\x82\x82R` \x82\x01\x90_R` _ \x92_[\x81\x81\x10a\xBBbWPPa\x05\xD1\x92P\x03\x83a'6V[\x84T\x83R`\x01\x94\x85\x01\x94\x87\x94P` \x90\x93\x01\x92\x01a\xBBMV[`\xFF_\x80Q` a\xC9g\x839\x81Q\x91RT`@\x1C\x16\x15a\xBB\x97WV[c\x1A\xFC\xD7\x9F`\xE3\x1B_R`\x04_\xFD[a\xBB\xAEa\xBB{V[a\xBB\xB6a\xBB{V[`\xFF\x19_\x80Q` a\xC9\x07\x839\x81Q\x91RT\x16_\x80Q` a\xC9\x07\x839\x81Q\x91RUV[a\xBB\xE2a\xBB{V[a\x87na\xBB{V[\x91\x90\x91` \x81Q\x91\x01 \x91` \x81Q\x91\x01 \x90`@Q\x91` \x83\x01\x93\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x85R`@\x84\x01R``\x83\x01RF`\x80\x83\x01R`\x01\x80`\xA0\x1B\x03\x16`\xA0\x82\x01R`\xA0\x81Ra\xBCU`\xC0\x82a'6V[Q\x90 \x90V[a'\x10`@\x80Qa\xBCk\x81a'\x1BV[b\t:\x80\x81R_` \x82\x01R\x01R`\x1C\x80Tj\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16j'\x10\0\0\0\0\0\0\t:\x80\x17\x90UV[a\xBC\xA8\x90\x93\x92\x93a\xC3\x1CV[\x92`@Q\x90a\xBC\xB6\x82a'\0V[\x7F\x19\x8E\x93\x93\x92\rH:r`\xBF\xB71\xFB]%\xF1\xAAI35\xA9\xE7\x12\x97\xE4\x85\xB7\xAE\xF3\x12\xC2\x82R\x7F\x18\0\xDE\xEF\x12\x1F\x1EvBj\0f^\\DygC\"\xD4\xF7^\xDA\xDDF\xDE\xBD\\\xD9\x92\xF6\xED` \x83\x01R`@Qa\xBD\x0B\x81a'\0V[\x7F\t\x06\x89\xD0X_\xF0u\xEC\x9E\x99\xADi\x0C3\x95\xBCK13p\xB3\x8E\xF3U\xAC\xDA\xDC\xD1\"\x97[\x81R\x7F\x12\xC8^\xA5\xDB\x8Cm\xEBJ\xABq\x80\x8D\xCB@\x8F\xE3\xD1\xE7i\x0CC\xD3{L\xE6\xCC\x01f\xFA}\xAA` \x82\x01R`@Q\x92a\xBDa\x84a'\0V[\x83R` \x83\x01R`@Q\x91a\xBDw``\x84a'6V[`\x02\x83R`@_[\x81\x81\x10a\xBD\xF3WPPa\xBD\xB2a\x0B\xE6\x95\x96a\xBD\x98a\xC3\xE7V[\x95a\xBD\xA2\x86ai\x10V[Ra\xBD\xAC\x85ai\x10V[Pa\xC56V[a\xBD\xBB\x84ai\"V[Ra\xBD\xC5\x83ai\"V[Pa\xBD\xCF\x84ai\x10V[Ra\xBD\xD9\x83ai\x10V[Pa\xBD\xE3\x83ai\"V[Ra\xBD\xED\x82ai\"V[Pa\xC5\xF9V[` \x90a\xBD\xFEa\xC3\x04V[\x82\x82\x88\x01\x01R\x01a\xBD\x7FV[\x90`\x01\x82\x01\x80T\x90\x82\x82\x10a\xBEBW\x82\x82\x03\x91\x82\x11aP\xD8WU`\x03\x82\x01\x80T\x91\x82\x01\x80\x92\x11aP\xD8WUT`\x01`\x01`\xA0\x1B\x03\x16\x90V[P\x90c\x03\x9F\xF3\xB1`\xE4\x1B_R`\x04R`$R`D_\xFD[\x91\x90aT\xD5a\xBF\x18\x83Q`\x01`\x01`@\x1B\x03\x81Q\x16\x90`\x01`\x01`@\x1B\x03` \x82\x01Q\x16\x90`@\x81\x01Q\x90`\x01`\x01`@\x1B\x03`\x80\x81``\x84\x01Q\x16\x92\x01Q\x16\x91`@Q\x93` \x85\x01\x95\x7F#\xDB6\xA6X\xFD\x8D\xD6\x1C\x92\x8C|\xBE\xC6\xA1\x84\x0E3\x9E6>\xFD\x87\\\xDA\xF8:\x1D`\xC8JC\x87R`@\x86\x01R``\x85\x01R`\x80\x84\x01R`\xA0\x83\x01R`\xC0\x82\x01R`\xC0\x81Ra\xBE\xEE`\xE0\x82a'6V[Q\x90 `@Q\x92\x83\x91` \x83\x01\x95\x86\x90\x91`B\x92a\x19\x01`\xF0\x1B\x83R`\x02\x83\x01R`\"\x82\x01R\x01\x90V[Q\x90 \x91a\xBF1a\x15\xE2\x84\x83\x90_R` R`@_ \x90V[a\xBF\xC0W`@a\xBFE` \x84\x01Q\x85a\xC4\\V[\x92\x01\x80Q\x90\x92`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16\x81\x90\x03a\xBF\xA5WPa\x16%\x83a\xBFu\x92\x90_R` R`@_ \x90V[Q`\x01`\x01`\xA0\x1B\x03\x16\x7F\x89\xA9\xFC\xF5/\xCD\xC4\x8F\x0Ef\x9F\xB3\xB7\x12R\x91\xDA\x85\x012Y/]\xD5\x80\xFF\xB5\x81f\xC8\xE9\xE8_\x80\xA3V[c\x08\xB1\xC5G`\xE1\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`$_\xFD[`@\x82\x01Qc\x08\xD1\x82q`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`$_\xFD[\x91\x90\x91a\xBF\xEBar\xD3V[\x92a'\x10a\xBF\xFEa\xFF\xFF\x83Q\x16\x84aoQV[\x04\x84Ra'\x10a\xC01a\xFF\xFF\x80`@\x84a\xC0\x1E\x83` \x89\x01Q\x16\x89aoQV[\x04\x95` \x8A\x01\x96\x87R\x01Q\x16\x16\x84aoQV[\x04\x90`@\x85\x01\x91\x82R\x84Q\x83\x03\x92\x83\x11aP\xD8Wa\xC0\\\x92a\xC0T\x91Q\x90au\x1AV[\x90Q\x90au\x1AV[``\x83\x01RV[`@Q\x90a\xC0r` \x83a'6V[_\x80\x83R\x82\x81[\x82\x81\x10a\xC0\x85WPPPV[` \x90`@Qa\xC0\x94\x81a'\x1BV[_\x81R_\x83\x82\x01R_`@\x82\x01R\x82\x82\x85\x01\x01R\x01a\xC0yV[\x90a\xC0\xB8\x82ah\x96V[a\xC0\xC5`@Q\x91\x82a'6V[\x82\x81R\x80\x92a\xC0\xD6`\x1F\x19\x91ah\x96V[\x01\x90_[\x82\x81\x10a\xC0\xE6WPPPV[` \x90`@Qa\xC0\xF5\x81a'\x1BV[_\x81R_\x83\x82\x01R_`@\x82\x01R\x82\x82\x85\x01\x01R\x01a\xC0\xDAV[\x91\x94\x93\x80\x15a\xC2EWa\xC1\"\x86Qa\xC0\xAEV[\x95_\x91_\x95_[\x83Q\x81\x10\x15a\xC2;W\x89a\xC1Ca\x1CCa]l\x84\x86ai2V[a\xC1M\x86Qau\x0CV[\x83\x03a\xC1\xBBWPP\x80a\xC1ea] `\x01\x93\x87ai2V[a\xC1o\x87\x8Aau\x1AV[a\xC1y\x8B\x8Aau\x1AV[\x90a\xC1\x94a\xC1\x85a'\x94V[`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x84RV[` \x83\x01R`@\x82\x01Ra\xC1\xA8\x82\x8Dai2V[Ra\xC1\xB3\x81\x8Cai2V[P[\x01a\xC1)V[a\xC2/\x88\x84\x9B\x98aM_\x86a\xC25\x96a\xC1\xF9\x8F`\x01\x9Aa\xC1\xF3\x8F\x9A\x8F\x90\x80a\xC1\xED\x83a\x1C>a\x1C>\x94a] \x99aoQV[\x9BaoQV[\x99ai2V[a\xC2\x13a\xC2\x04a'\x94V[`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x82RV[\x85` \x82\x01R\x87`@\x82\x01Ra\xC2)\x83\x83ai2V[Rai2V[\x96au\xC0V[\x97a\xC1\xB5V[PPPPPPPPV[PPPP\x90Pa\x0B\xE6a\xC0cV[\x90\x82\x15a\xA2NW`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x19` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R \x80T\x91\x82\x01\x80\x92\x11aP\xD8WUV[\x90_` \x91\x82\x81Q\x91\x01\x82\x85Z\xF1\x15am\x96W_Q=a\xC2\xDEWP`\x01`\x01`\xA0\x1B\x03\x81\x16;\x15[a\xC2\xBEWPV[cRt\xAF\xE7`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[`\x01\x14\x15a\xC2\xB7V[_\x80a\x0B\xE6\x93` \x81Q\x91\x01\x84Z\xF4a\xC2\xFEa\x86\xB3V[\x91a\xC4rV[`@Q\x90a\xC3\x11\x82a'\0V[_` \x83\x82\x81R\x01RV[a\xC3C\x90a\xC3(a\xC3\x04V[P` \x81Q\x91\x01 _\x80Q` a\xC8\xA7\x839\x81Q\x91R\x90\x06\x90V[\x90_\x90_[a\x01\0\x83\x10a\xC3`Wc\xDBJ\\\xD9`\xE0\x1B_R`\x04_\xFD[aonW_\x80Q` a\xC8\xA7\x839\x81Q\x91R`\x03\x81\x85\x81\x81\x80\t\t\x08a\xC3\x85\x81a\xC4\xD0V[\x90_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x82\x80\t\x14a\xC3\xBAWP`\x01_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x81_\x95\x08\x92\x01\x91\x92a\xC3HV[\x90\x92\x91Pa\xC3\xC6a'\xB3V[\x91\x82R` \x82\x01R\x90V[`@Q\x90a\xC3\xE0` \x83a'6V[` 6\x837V[`@Q\x90a\xC3\xF6``\x83a'6V[`\x02\x82R\x81`\x1F\x19a\xC4\x08`\x02ah\x96V[\x01\x90`@\x90_[\x83\x81\x10a\xC4\x1CWPPPPV[` \x90\x83Qa\xC4*\x81a'\0V[\x84Qa\xC46\x86\x82a'6V[\x856\x827\x81R\x84Qa\xC4H\x86\x82a'6V[\x856\x827\x83\x82\x01R\x82\x82\x85\x01\x01R\x01a\xC4\x0FV[a\x0B\xE6\x91a\xC4i\x91a\xC7NV[\x90\x92\x91\x92a\xC7\x88V[\x90a\xC4\x96WP\x80Q\x15a\xC4\x87W\x80Q\x90` \x01\xFD[c\xD6\xBD\xA2u`\xE0\x1B_R`\x04_\xFD[\x81Q\x15\x80a\xC4\xC7W[a\xC4\xA7WP\x90V[c\x99\x96\xB3\x15`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[P\x80;\x15a\xC4\x9FV[_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x90\x81\x80`\x01\x92\x06\x90[a\xC4\xF1WP\x90P\x90V[`\x01\x80\x84\x16\x14a\xC5\x1DW[_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x91\x92`\x01\x1C\x91\x81\x83\x92\t\x91\x92\x91\x90a\xC4\xE7V[_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x81\x81\x93\t\x91Pa\xC4\xFCV[a\xC5>a\xC3\x04V[P\x80Q\x90\x81\x15\x80a\xC5\xA1W[a\xC5\x9CW` _\x80Q` a\xC8\xA7\x839\x81Q\x91R\x91\x01Q\x06_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x03_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x81\x11aP\xD8W`@Q\x91a\xC5\x92\x83a'\0V[\x82R` \x82\x01R\x90V[\x90P\x90V[P` \x81\x01Q\x15a\xC5JV[\x15a\xC5\xB4WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FBN254: pairing length mismatch\0\0`D\x82\x01R`d\x90\xFD[a\xC6\x06\x81Q\x83Q\x14a\xC5\xADV[\x80Qa\xC6\x11\x81ao;V[\x92a\xC6\x1B\x84ah\xCAV[\x92_[\x83\x81\x10a\xC6hWPPPP` \x80\x92a\xC6N\x92a\xC69a\xC3\xD1V[\x94\x85\x92`\x05\x1B\x91\x01`\x08a\x07\xCF\x19Z\x01\xFA\x15\x90V[a\xC6YWQ`\x01\x14\x90V[cM\xF4^/`\xE0\x1B_R`\x04_\xFD[\x80a\xC6u`\x01\x92\x84ai2V[QQa\xC6\x83a\x7F\xF8\x83ao;V[R` a\xC6\x90\x82\x85ai2V[Q\x01Qa\xC6\xA7a\x7F\xF8a\xC6\xA2\x84ao;V[auzV[Ra\xC6\xBDa\xC6\xB5\x82\x86ai2V[QQ` \x01\x90V[Qa\xC6\xD2a\x7F\xF8a\xC6\xCD\x84ao;V[au\x88V[Ra\xC6\xDD\x81\x85ai2V[QQQa\xC6\xF4a\x7F\xF8a\xC6\xEF\x84ao;V[au\x96V[Ra\xC7\r` a\xC7\x04\x83\x87ai2V[Q\x01Q` \x01\x90V[Qa\xC7\"a\x7F\xF8a\xC7\x1D\x84ao;V[au\xA4V[R` a\xC7/\x82\x86ai2V[Q\x01QQa\xC7Ga\x7F\xF8a\xC7B\x84ao;V[au\xB2V[R\x01a\xC6\x1EV[\x81Q\x91\x90`A\x83\x03a\xC7~Wa\xC7w\x92P` \x82\x01Q\x90```@\x84\x01Q\x93\x01Q_\x1A\x90a\xC8\x04V[\x91\x92\x90\x91\x90V[PP_\x91`\x02\x91\x90V[a\xC7\x91\x81ac\xA3V[\x80a\xC7\x9AWPPV[a\xC7\xA3\x81ac\xA3V[`\x01\x81\x03a\xC7\xBAWc\xF6E\xEE\xDF`\xE0\x1B_R`\x04_\xFD[a\xC7\xC3\x81ac\xA3V[`\x02\x81\x03a\xC7\xDEWPc\xFC\xE6\x98\xF7`\xE0\x1B_R`\x04R`$_\xFD[\x80a\xC7\xEA`\x03\x92ac\xA3V[\x14a\xC7\xF2WPV[c5\xE2\xF3\x83`\xE2\x1B_R`\x04R`$_\xFD[\x91\x90\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84\x11a\xC8{W\x91` \x93`\x80\x92`\xFF_\x95`@Q\x94\x85R\x16\x86\x84\x01R`@\x83\x01R``\x82\x01R\x82\x80R`\x01Z\xFA\x15a\x13cW_Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\xC8qW\x90_\x90_\x90V[P_\x90`\x01\x90_\x90V[PPP_\x91`\x03\x91\x90V\xFE/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r0dNr\xE11\xA0)\xB8PE\xB6\x81\x81X]\x97\x81j\x91hq\xCA\x8D< \x8C\x16\xD8|\xFDG6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x9Bw\x9B\x17B-\r\xF9\"#\x01\x8B2\xB4\xD1\xFAF\xE0qr=h\x17\xE2Hm\0;\xEC\xC5_\0o$\xB3\xAC\xD9\x14O\xE9\x86\xC6\xFCF\x8F\xF9\x93\x84\x0C\x17\x93\xF5\x85\xF3\x9E\x15\xB5\xD2\x07(\xBD-\xDAA\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\xA1dsolcC\0\x08\x1A\0\n",
    );
    /// The runtime bytecode of the contract, as deployed on the network.
    ///
    /// ```text
    ///0x6080604052600436101561001a575b3615610018575f80fd5b005b5f3560e01c806301ffc9a71461055957806306079dc514610554578063062375261461054f57806307e601291461054a5780630afd3738146105455780630f33e8e114610540578063108a7d631461053b578063110f829b1461053657806318c6801714610531578063208129561461052c57806323d7b3e114610527578063248a9ca3146105225780632b9da71a1461051d5780632d07e655146105185780632dae1885146105135780632ec2bd031461050e5780632f2ff15d146105095780632f46279f1461050457806330ae289c146104ff57806331d7a262146104fa5780633413e8ee146104f557806336568abe146104f0578063372500ab146104eb5780633dc0d5fe146104e65780633f4ba83a146104e1578063449bb849146104dc5780634f1ef286146104d757806352d1902d146104d2578063563a89f9146104cd5780635b71c934146104c85780635c975abb146104c35780635f359924146104be5780635f9b4dfa146104b9578063614823b2146104b457806364462595146104af5780636778afbc146104aa5780636a64a27e146104a55780636bda42f3146104a05780636d8b88c31461049b57806375b238fc1461049657806377380c7414610491578063784486371461048c57806378867a161461048757806380ac822814610482578063815d6a261461047d578063842524bb146104785780638456cb59146104735780638a4cf7631461046e5780638c9a281d146104695780638d3f65be1461046457806391d148541461045f57806393f3ddaf1461045a578063970e08fe14610455578063a217fddf14610450578063a37b92861461044b578063a595b21e14610446578063a5bfbae414610441578063a672bc0a1461043c578063aac7416b14610437578063aacdba9f14610432578063ad3cb1cc1461042d578063b055449b14610428578063b7696dbb14610423578063b81741ac1461041e578063bb207f1f14610419578063c0c53b8b14610414578063c325ae121461040f578063c602d4fa1461040a578063cc3d19c314610405578063cf3806c614610400578063d390bbbb146103fb578063d547741f146103f6578063da232ded146103f1578063dfe62aba146103ec578063e538da66146103e7578063e63ab1e9146103e2578063e72146a9146103dd578063eb8c3bcd146103d8578063ec9f0fdd146103d3578063ef1b42a2146103ce578063ef5cfb8c146103c9578063f0411af3146103c4578063f0f44260146103bf5763f72c0d8b0361000e57616736565b6166eb565b616654565b6165cd565b616470565b6162e5565b61620e565b616161565b616127565b616096565b615f7d565b615eb1565b615e7d565b615e57565b615b88565b61581a565b6157f4565b615334565b6151ac565b61512a565b61500f565b614f39565b614be7565b614ba0565b61465d565b61461b565b6144c3565b6141c8565b61417b565b6140dc565b6140c2565b613f9e565b613ec3565b613e3b565b613dff565b613dc5565b613d0c565b613c9b565b613bc4565b613b73565b613b14565b6139c1565b6137d7565b61373d565b613703565b61356b565b613496565b61344f565b6131f5565b6131ac565b612f2a565b612de8565b612c9d565b612c6f565b612b2e565b612a4a565b612984565b61283c565b6125ef565b612571565b6123dd565b612245565b6121fd565b611e69565b611e19565b611ac6565b611a75565b611a3c565b6119ec565b61199f565b6114b4565b610ec2565b610e90565b610e26565b610ddf565b610d5d565b610c2b565b610ae5565b6109c5565b61081c565b6107f3565b6107ca565b610661565b346105af5760203660031901126105af5760043563ffffffff60e01b81168091036105af57602090637965db0b60e01b811490811561059e575b506040519015158152f35b6301ffc9a760e01b1490505f610593565b5f80fd5b6001600160401b038116036105af57565b600435906105d1826105b3565b565b60a435906105d1826105b3565b608435906105d1826105b3565b35906105d1826105b3565b9181601f840112156105af578235916001600160401b0383116105af57602083818601950101116105af57565b9060406003198301126105af5760043561063e816105b3565b91602435906001600160401b0382116105af5761065d916004016105f8565b9091565b346105af5761066f36610625565b335f9081525f8051602061c947833981519152602052604090205460ff16156107a0579061069e9136916127eb565b6106b9826001600160401b03165f52601d60205260405f2090565b805460401c6001600160a01b03161561078457600501805460801c60ff166106e0816163a3565b6002811461076857806106f46003926163a3565b1461074957805460ff60801b1916600360801b1790557fe80d1a183af30916f79b15a6c85e82470d0b88065dfdd2505d106adf0e8b7796604051806107446001600160401b033396169482614b8f565b0390a3005b6307705ccd60e41b5f526001600160401b03831660045260245ffd5b5ffd5b63532af36960e01b5f526001600160401b03841660045260245ffd5b63162e3fab60e21b5f526001600160401b03831660045260245ffd5b6001600160401b0383630393979d60e31b5f52166004523360245260445ffd5b5f9103126105af57565b346105af575f3660031901126105af5760206001600160401b0360045460801c16604051908152f35b346105af575f3660031901126105af5760206001600160401b0360045460401c16604051908152f35b346105af5760203660031901126105af57600435610839816105b3565b6108428161867c565b6001600160401b0361088a61087d61086b856001600160401b03165f52600760205260405f2090565b335f9081526020919091526040902090565b546001600160401b031690565b16156109a557600101805461093891906001600160a01b031680610969575b505f6108df336108ca866001600160401b03165f52600760205260405f2090565b9060018060a01b03165f5260205260405f2090565b55610904336108ff856001600160401b03165f52600860205260405f2090565b6186fc565b50610918610913825460e01c90565b616797565b81546001600160e01b031660e09190911b6001600160e01b031916179055565b6001600160401b033391167f88e46e95bcdf1020c0caf9f3dd5fde69c41d2151dbbca0a77c03c4e28b4d3ec15f80a3005b604051630a8d22bb60e11b602082015233602482015261099f9161099a82604481015b03601f198101845283612736565b6186e2565b5f6108a9565b639bcccbfd60e01b5f526001600160401b0382166004523360245260445ffd5b346105af576001600160401b036109db36610625565b9290911690815f526007602052610a0460405f203360018060a01b03165f5260205260405f2090565b6001600160401b0381541615610a68577f2d0e8c75ccfc606463bd5f7556ccf358b1c409ec6059cee6e51935a29bd0fdc191610a4d610a5f926001600160401b034216906167a9565b604051946020865260208601916167d1565b928033940390a3005b82639bcccbfd60e01b5f526004523360245260445ffd5b9181601f840112156105af578235916001600160401b0383116105af576020808501948460051b0101116105af57565b6001600160a01b038116036105af57565b60c435906105d182610aaf565b60a435906105d182610aaf565b35906105d182610aaf565b6101003660031901126105af57610afa6105c4565b6024356001600160401b0381116105af57610b19903690600401610a7f565b916044356001600160401b0381116105af57610b39903690600401610a7f565b9290936064356001600160401b0381116105af57610b5b9036906004016105f8565b949095608435956001600160401b0387116105af57610bbd97610b85610ba3983690600401610a7f565b949093610b906105d3565b96610b99610ac0565b9860e4359a616802565b6040516001600160401b0390911681529081906020820190565b0390f35b60409060031901126105af57600435610bd9816105b3565b90602435610be6816105b3565b90565b60206040818301928281528451809452019201905f5b818110610c0c5750505090565b82516001600160401b0316845260209384019390920191600101610bff565b346105af57610c3936610bc1565b6001600160401b03165f825b826001600160401b03821610610d0c57506001600160401b031691610c69836168ca565b925f915b836001600160401b0382161080610cfa575b15610cec5780610cab610ca6610cb4936001600160401b03165f52601d60205260405f2090565b618e9b565b610cb9576168ad565b610c6d565b610ce781610cd96001600160401b03610cd1886168ad565b971689616932565b906001600160401b03169052565b6168ad565b60405180610bbd8782610be9565b50816001600160401b03841610610c7f565b610d2a610ca6826001600160401b03165f52601d60205260405f2090565b610d40575b6001016001600160401b0316610c45565b906001610d546001600160401b03926168ad565b92915050610d2f565b346105af5760203660031901126105af57600435610d7a816105b3565b60ff6002610d878361867c565b015460101c1615610dc3576001600160401b033391167fd39ff75a15c31a272891c52e42995acfa27459ba1c12239cbac23cdb76f530845f80a3005b6001600160401b039063210eb4ed60e11b5f521660045260245ffd5b346105af5760203660031901126105af57600435610dfc81610aaf565b610e04618ee5565b601f80546001600160a01b0319166001600160a01b0392909216919091179055005b346105af5760403660031901126105af57600435610e43816105b3565b602435906001600160401b0382116105af57366023830112156105af578160040135906001600160401b0382116105af5736602460608402850101116105af576024610018930190616946565b346105af5760203660031901126105af576020610eae600435616d69565b604051908152f35b61ffff8116036105af57565b346105af5760403660031901126105af57600435610edf816105b3565b602435610eeb81610eb6565b610ef361870f565b610efb618736565b610f04826198dc565b600281019081546001610f1b8260ff9060701c1690565b610f24816122e3565b03611498576001606082901c60ff16610f3c816122c7565b0361143d5763ffffffff604082901c16801515918261146b575b505061143d57546001600160401b03166001600160401b03610f8f61087d61086b846001600160401b03165f52600760205260405f2090565b161561144c57610fc1610fb7336108ca876001600160401b03165f52601160205260405f2090565b5460901c60ff1690565b61143d57610fe0906001600160401b03165f52600560205260405f2090565b5f54610ffc906001600160a01b03165b6001600160a01b031690565b9060405163d775cb6160e01b8152602081600481865afa8015611363576001915f9161141e575b509101805490926001600160a01b039091169182611387575b60405163f46913bb60e01b815233600482015260248101829052602081604481865afa908115611363575f91611368575b50156112e65750506001600160a01b031680611256575b506111aa6111f49261115b611097612757565b61ffff87168152426001600160401b031660208201525f6040820152600160608201526110d9336108ca8a6001600160401b03165f52601160205260405f2090565b8151815461ffff191661ffff919091161781559060609060208101518354604083015171ffffffffffffffffffffffffffffffff00001990911660109290921b69ffffffffffffffff0000169190911760509190911b67ffffffffffffffff60501b161783550151815460ff60901b191690151560901b60ff60901b16179055565b61117f3361117a886001600160401b03165f52601260205260405f2090565b619916565b50611196611191825463ffffffff1690565b616d3e565b63ffffffff1663ffffffff19825416179055565b60405161ffff8416815233906001600160401b038616907f2457918796078440068385e73e422539c84f2f9045dd442e123d4284258ae24a90602090a3546001600160a01b031690565b6001600160a01b03811661120b575b61001861876e565b604051634d51354960e11b60208201526001600160401b03909316602484015233604484015261ffff909116606483015261124e919061099a826084810161098c565b5f8080611203565b60405163168e485d60e31b81526001600160401b038616600482015233602482015290602090829060449082906001600160a01b03165afa5f91816112b5575b501561108457156112a7575f611084565b6282b42960e81b5f5260045ffd5b6112d891925060203d6020116112df575b6112d08183612736565b810190616dc0565b905f611296565b503d6112c6565b604051631c9d11bd60e31b815233600482015291602090839060249082905afa90811561136357610765925f92611332575b5063936d426d60e01b5f5233600452602452604452606490565b61135591925060203d60201161135c575b61134d8183612736565b810190616d87565b9083611318565b503d611343565b616d96565b611381915060203d6020116112df576112d08183612736565b5f61106d565b6004604061139d6001600160a01b038616610ff0565b8151632a6e736160e11b815292839182905afa90815f915f936113eb575b506113c8575b505061103c565b15806113e2575b6113da575b806113c1565b90505f6113d4565b508015156113cf565b909250611410915060403d604011611417575b6114088183612736565b810190616da1565b915f6113bb565b503d6113fe565b611437915060203d60201161135c5761134d8183612736565b5f611023565b63baf3f0f760e01b5f5260045ffd5b639bcccbfd60e01b5f526001600160401b03166004523360245260445ffd5b63ffffffff91925061148361148d9163ffffffff1690565b9263ffffffff1690565b911610155f80610f56565b63098bfc5b60e31b5f526001600160401b03851660045260245ffd5b346105af5760603660031901126105af576004356114d1816105b3565b602435906114de826105b3565b6044356001600160401b0381116105af576114fd9036906004016105f8565b9061150661870f565b61150e618736565b611517836198dc565b906115228585619929565b94600161155061153985546001600160401b031690565b6001600160401b03165f52600560205260405f2090565b0180549092906001600160a01b0316806118e1575b5061158e61158a610fb761086b896001600160401b03165f52601160205260405f2090565b1590565b6118c15760038701946115a2865460ff1690565b61189f576115e96115e2336108ca866115cc8c6001600160401b03165f52601760205260405f2090565b906001600160401b03165f5260205260405f2090565b5460ff1690565b61187957916116c69593916001600160401b0395936116326116258a6108ca866115cc33936001600160401b03165f52601760205260405f2090565b805460ff19166001179055565b60018a019261166161164b611191865463ffffffff1690565b855463ffffffff191663ffffffff909116178555565b81818c858d6116768a5460018060a01b031690565b926001600160a01b03841661181f575b509150507f8a04f99fe23284e874e8dd017345248279cc59701695e73bcdbeb6241bcd2ac692508a91501698899216998a936040519182913397836167f1565b0390a49054600191906116e1906001600160a01b0316610ff0565b80611796575b5063ffffffff6116fc81925463ffffffff1690565b92169116101561170e5761001861876e565b600293611756936117278694600160ff19825416179055565b7f60a7649f6e93e7a3ce1dc9729c20e3d95dce28c6a6bd957cde09d8a1cb37c19f5f80a3015460681c60ff1690565b61175f816122e3565b1480611789575b611774575b80808080611203565b60026117829201549061998e565b5f8061176b565b5060028201541515611766565b88546040516313110f8160e21b81526001600160401b038a16600482015260ff909116602482015290602090829060449082906001600160a01b03165afa5f91816117ee575b50156116e757915063ffffffff6116e7565b61181191925060203d602011611818575b6118098183612736565b810190616ef9565b905f6117dc565b503d6117ff565b5461186e9561099a9361098c9260ff169361184f886115cc836001600160401b03165f52601860205260405f2090565b9060405198899663c40c80d160e01b6020890152339260248901616e0d565b81815f858d8f611686565b635bf3fe7760e11b5f526001600160401b0380881660045283166024523360445260645ffd5b630a55512f60e01b5f526001600160401b03808816600452831660245260445ffd5b63783482e960e01b5f526001600160401b0386166004523360245260445ffd5b6118f3906001600160a01b0316610ff0565b61193a60206119038a5460ff1690565b604051630cf6add960e11b81526001600160401b038b16600482015260ff8216602482015290939092839190829081906044820190565b03915afa5f918161197e575b50611952575b50611565565b61195c578061194c565b631dc5933760e21b5f526001600160401b03871660045260ff1660245260445ffd5b61199891925060203d6020116112df576112d08183612736565b905f611946565b346105af575f3660031901126105af57601f546040516001600160a01b039091168152602090f35b60409060031901126105af576004356119df816105b3565b90602435610be681610aaf565b346105af576020611a326001600160401b03611a07366119c7565b91165f9081526013845260408082206001600160a01b03909316825260019092016020522054151590565b6040519015158152f35b346105af5760403660031901126105af57610018602435600435611a5f82610aaf565b611a70611a6b82616d69565b619032565b619ddf565b346105af5760203660031901126105af576001600160401b03600435611a9a816105b3565b165f526010602052602060ff600260405f20015460701c16611abb816122e3565b600160405191148152f35b346105af5760803660031901126105af57600435611ae3816105b3565b60243590611af082610aaf565b6044359160643591611b01816198dc565b5492611b2b610ff0611b1b6001600160401b038716611539565b9560401c6001600160a01b031690565b33148015611dfd575b801580611de7575b611d4d575b156112a757611b65836108ca846001600160401b03165f52601160205260405f2090565b5460ff609082901c161580611d38575b611d0f57611b96611ba592611b8d60019361ffff1690565b8833888861a016565b9401546001600160a01b031690565b6001600160a01b038116611bc8575b6040516001600160401b0385168152602090f35b5f54611bdc906001600160a01b0316610ff0565b604051631c9d11bd60e31b81526001600160a01b03851660048201529590602090879060249082905afa9283156113635761098c611ccc95611ca29561099a94610bbd9a5f92611cee575b508115611ce657611c4a91611c3e611c4392616f23565b616f64565b61ffff1690565b61271061ffff821611611cdd575b611c6a611c709161ffff606491160490565b60ff1690565b90606460ff831611611cd4575b611cb090604051978891602083016014916001600160601b03199060601b1681520190565b03601f198101885287612736565b604051630881898f60e01b602082015295869360248501616f73565b5f8080611bb4565b60649150611c7d565b50612710611c58565b50505f611c4a565b611d0891925060203d60201161135c5761134d8183612736565b905f611c27565b63783482e960e01b5f526001600160401b0383166004526001600160a01b03841660245260445ffd5b50601081901c6001600160401b031615611b75565b6001850154611d6690610ff0906001600160a01b031681565b6040516374ceeb5560e01b81526001600160401b038516600482015290602090829060249082905afa5f9181611db6575b50611da3575b50611b41565b6001600160a01b0316331490505f611d9d565b611dd991925060203d602011611de0575b611dd18183612736565b810190616f0e565b905f611d97565b503d611dc7565b5060018501546001600160a01b03161515611b3c565b508354611e12906001600160a01b0316610ff0565b3314611b34565b346105af5760203660031901126105af57600435611e3681610aaf565b60018060a01b03165f52601960205260405f205f8052602052602060405f2054604051908152f35b60ff8116036105af57565b60603660031901126105af57600435611e81816105b3565b60243590611e8e82611e5e565b6044356001600160401b0381116105af57611ead9036906004016105f8565b919092611eb861870f565b611ec0618736565b611ec9826198dc565b600281015493906001607086901c60ff16611ee3816122e3565b036121e15760018101546001600160401b03604082901c1680151591826121af575b505061219357611f4961158a611f2c866001600160401b03165f52601360205260405f2090565b611f3533610ff0565b906001915f520160205260405f2054151590565b612173575f9460029060681c60ff16611f61816122e3565b1461212d575b908291611f85856001600160401b03165f52601560205260405f2090565b958654611f98906001600160401b031690565b96611fa2886168ad565b815467ffffffffffffffff19166001600160401b03909116179055611fc5612766565b60ff85168152903360208301526001600160401b0342166040830152606082015f9052608082015260a081015f905286612010876001600160401b03165f52601660205260405f2090565b9061202b91906001600160401b03165f5260205260405f2090565b9061203591616fc3565b868287612053886001600160401b03165f52601860205260405f2090565b9061206e91906001600160401b03165f5260205260405f2090565b91612078926170e2565b546001600160401b03165f90815260056020526040902060010154610bbd967fde37cc48d21778e1c9a075c4e41c5aff6918c3ea6151221f0af3ce8121a29db59390916001600160a01b031690816120f7575b50506120ec6040519283926001600160401b03808a169816963390856171d7565b0390a3610ba361876e565b612126916121218861098c87878d604051978895639838caa360e01b6020880152602487016171a6565b61a253565b5f846120cb565b93508190600361215e61214787546001600160401b031690565b6001600160401b03165f52600660205260405f2090565b01549461216b348761a1c9565b909150611f67565b63357756d160e21b5f526001600160401b0384166004523360245260445ffd5b637c3e621b60e01b5f526001600160401b03841660045260245ffd5b6121d892506121cc91906001600160401b0316616fa3565b616fa3565b6001600160401b031690565b42115f80611f05565b63098bfc5b60e31b5f526001600160401b03841660045260245ffd5b346105af5760403660031901126105af5760043560243561221d81610aaf565b336001600160a01b03821603612236576100189161a2cd565b63334bd91960e11b5f5260045ffd5b346105af575f3660031901126105af5761225d618736565b6122663361a36d565b8061227f575b60015f8051602061c92783398151915255005b5f906040519081527f9310ccfcb8de723f578a9e4282ea9f521f05ae40dc08f3068dfad528a65ee3c760203392a35f61226c565b634e487b7160e01b5f52602160045260245ffd5b600211156122d157565b6122b3565b906122e0826122c7565b52565b600311156122d157565b906122e0826122e3565b6105d1909291926101608061018083019561231b8482516001600160401b03169052565b6020818101516001600160a01b0316908501526040818101516001600160401b0316908501526060818101516001600160401b0316908501526080818101516001600160401b03169085015260a0818101516001600160401b03169085015260c08181015163ffffffff169085015260e08181015163ffffffff16908501526101008181015163ffffffff16908501526123bf6101208201516101208601906122d6565b6123d36101408201516101408601906122ed565b01519101906122ed565b346105af5760203660031901126105af576001600160401b03600435612402816105b3565b61240a6171fe565b50165f526010602052610bbd60405f2061256561255b600261242a612775565b936124726124628254612453612446826001600160401b031690565b6001600160401b03168952565b60401c6001600160a01b031690565b6001600160a01b03166020870152565b6124f96124e960018301546124a0612490826001600160401b031690565b6001600160401b031660408a0152565b6124c2604082901c6001600160401b03165b6001600160401b031660608a0152565b6124e3608082901c6001600160401b03166001600160401b031660808a0152565b60c01c90565b6001600160401b031660a0870152565b015463ffffffff811660c085015263ffffffff602082901c1660e085015263ffffffff604082901c1661010085015261253d606082901c60ff166101208601617267565b612552606882901c60ff166101408601617270565b60701c60ff1690565b6101608301617270565b604051918291826122f7565b346105af575f3660031901126105af57612589618f54565b5f8051602061c9078339815191525460ff8116156125e05760ff19165f8051602061c907833981519152557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa6020604051338152a1005b638dfc202b60e01b5f5260045ffd5b346105af5760203660031901126105af576001600160401b03600435612614816105b3565b61261d8161867c565b80546001600160a01b0316330361266257600201805462ff000019169055167fe14286f3ad49ada6d0911adda8ef90616999045bde2a33e391a7b5ae6589e7895f80a2005b5063234e071d60e01b5f52166004523360245260445ffd5b634e487b7160e01b5f52604160045260245ffd5b60e081019081106001600160401b038211176126a957604052565b61267a565b608081019081106001600160401b038211176126a957604052565b60c081019081106001600160401b038211176126a957604052565b61014081019081106001600160401b038211176126a957604052565b604081019081106001600160401b038211176126a957604052565b606081019081106001600160401b038211176126a957604052565b90601f801991011681019081106001600160401b038211176126a957604052565b604051906105d1608083612736565b604051906105d160c083612736565b604051906105d161018083612736565b604051906105d160e083612736565b604051906105d1606083612736565b604051906105d161014083612736565b604051906105d1604083612736565b906105d16040519283612736565b6001600160401b0381116126a957601f01601f191660200190565b9291926127f7826127d0565b916128056040519384612736565b8294818452818301116105af578281602093845f960137010152565b9080601f830112156105af57816020610be6933591016127eb565b60403660031901126105af5760043561285481610aaf565b6024356001600160401b0381116105af57612873903690600401612821565b906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016308114908115612962575b50612953576128b6618fc3565b6040516352d1902d60e01b8152916020836004816001600160a01b0386165afa5f9381612932575b506128ff57634c9c8ce360e01b5f526001600160a01b03821660045260245ffd5b905f8051602061c8c7833981519152830361291e57610018925061ba94565b632a87526960e21b5f52600483905260245ffd5b61294c91945060203d60201161135c5761134d8183612736565b925f6128de565b63703e46dd60e11b5f5260045ffd5b5f8051602061c8c7833981519152546001600160a01b0316141590505f6128a9565b346105af575f3660031901126105af577f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031630036129535760206040515f8051602061c8c78339815191528152f35b91909160c08060e083019480516129f1816122c7565b84526020810151612a01816122e3565b602085015263ffffffff604082015116604085015263ffffffff6060820151166060850152608081015160808501526001600160401b0360a08201511660a08501520151910152565b346105af5760203660031901126105af576001600160401b03600435612a6f816105b3565b612a77617279565b50165f526006602052610bbd60405f20600360405191612a968361268e565b612aea612add825460ff8116612aab816122c7565b8652612ac060ff8260081c1660208801617270565b63ffffffff601082901c1660408701525b60301c63ffffffff1690565b63ffffffff166060850152565b60018101546080840152612b1b612b0b60028301546001600160401b031690565b6001600160401b031660a0850152565b015460c0820152604051918291826129db565b346105af5760203660031901126105af57600435612b4b816105b3565b612b54816198dc565b805460401c6001600160a01b0316336001600160a01b0390911603612c4f5760028101805460ff60701b1916600160711b179055612c0790600190612bf99061153990808401805467ffffffffffffffff60801b19164260801b67ffffffffffffffff60801b161790556001600160401b0386167f3fd558a59bbce1d996d17eab7fde314bcd201ec3f17375a7f873b3162927e8815f80a2546001600160401b031690565b01546001600160a01b031690565b906001600160a01b038216612c1857005b604051630a24e8a960e41b60208201526001600160401b0390911660248201523360448201526100189161099a826064810161098c565b630cd567cf60e11b5f526001600160401b0382166004523360245260445ffd5b346105af575f3660031901126105af57602060ff5f8051602061c90783398151915254166040519015158152f35b346105af57612cab366119c7565b6001600160a01b03612cbc836198dc565b5460401c163303612cee576001600160401b0361001892165f52601360205260405f209060018060a01b03169061b3dc565b6001600160401b0382630cd567cf60e11b5f52166004523360245260445ffd5b6105d19092919261016080610180830195612d328482516001600160401b03169052565b6020818101516001600160a01b0316908501526040818101516001600160401b0316908501526060818101516001600160401b03169085015260808181015163ffffffff169085015260a08181015163ffffffff169085015260c0818101516001600160a01b03169085015260e081015160e0850152612dbc6101008201516101008601906122d6565b6101208181015163ffffffff16908501526101408181015163ffffffff16908501525b01511515910152565b346105af5760203660031901126105af576001600160401b03600435612e0d816105b3565b612e156171fe565b50165f526009602052610bbd60405f20612f1e612f146004612e35612775565b93612e516124628254612453612446826001600160401b031690565b612eb9612eac6001830154612e6f612490826001600160401b031690565b612e85604082901c6001600160401b03166124b2565b612ea0608082901c63ffffffff1663ffffffff1660808a0152565b60a01c63ffffffff1690565b63ffffffff1660a0870152565b60028101546001600160a01b031660c0860152600381015460e08601520154612ee960ff82166101008601617267565b63ffffffff600882901c1661012085015263ffffffff602882901c1661014085015260481c60ff1690565b1515610160830152565b60405191829182612d0e565b346105af5760403660031901126105af57600435612f47816105b3565b602435612f5381611e5e565b612f5b61870f565b612f63618736565b612f6c82619078565b600481015460481c60ff16613190575f915f5b612f9a856001600160401b03165f52600a60205260405f2090565b5481101561318857610ff0612fe3612fcc83612fc7896001600160401b03165f52600a60205260405f2090565b616c24565b9054339360039290921b1c6001600160a01b031690565b14612ff057600101612f7f565b5090915060015b156112a75761301e6115e2336108ca866001600160401b03165f52600c60205260405f2090565b61316857613044611625336108ca866001600160401b03165f52600c60205260405f2090565b6130c76001612bf96115398286019561308b61306b611191895463ffffffff9060a01c1690565b885463ffffffff60a01b191660a09190911b63ffffffff60a01b16178855565b336001600160401b0389167fceda1a44ead4da3d3abaaa941afa6d9530fd84dd8e99385c9183d986dcab980f5f80a3546001600160401b031690565b906001600160a01b038216613121575b50505463ffffffff6131036130fa60a084901c83165b9360801c63ffffffff1690565b63ffffffff1690565b9116146131125761001861876e565b61311b906192f7565b5f611203565b604051632c567acd60e21b60208201523360248201526001600160401b038516604482015260ff90911660648201526131619161099a826084810161098c565b5f806130d7565b630f2bb0f160e41b5f526001600160401b0383166004523360245260445ffd5b509091612ff7565b63252048a360e21b5f526001600160401b03831660045260245ffd5b346105af5760206001600160401b036131e9816131c8366119c7565b91165f526007845260405f209060018060a01b03165f5260205260405f2090565b54161515604051908152f35b346105af5760203660031901126105af57600435613212816105b3565b61321a618736565b613223816198dc565b60028101908154600161323a8260ff9060601c1690565b613243816122c7565b0361143d5763ffffffff6132636130fa8383169360201c63ffffffff1690565b9116111561143d5761328961086b846001600160401b03165f52601160205260405f2090565b9061329c61158a835460ff9060901c1690565b61342f576132b6611539600192546001600160401b031690565b0180549092906001600160a01b0316806133b4575b50815468ffffffffffffffffff60501b19164260501b67ffffffffffffffff60501b161790915561332790613315336108ff866001600160401b03165f52601260205260405f2090565b50611196610913825463ffffffff1690565b61336a60405191336001600160401b0385167f8ce53e4b6002ff090e641ddecdaf7edd2813a98e19139fa7d1c79fccc3c4dead5f80a3546001600160a01b031690565b6001600160a01b0381166133805761001861876e565b63965d231b60e01b60208301526001600160401b03909216602482015233604482015261124e9161099a826064810161098c565b6133c6906001600160a01b0316610ff0565b60405163728c6f3b60e11b81526001600160401b038616600482015233602482015290602090829060449082905afa5f918161340e575b50156132cb57156112a7575f6132cb565b61342891925060203d6020116112df576112d08183612736565b905f6133fd565b63783482e960e01b5f526001600160401b0384166004523360245260445ffd5b346105af5760203660031901126105af5760043561346c81610aaf565b613474618ee5565b602080546001600160a01b0319166001600160a01b0392909216919091179055005b346105af57610bbd6134de6001600160401b036134b2366119c7565b91906134bc6172d3565b50165f52600760205260405f209060018060a01b03165f5260205260405f2090565b60ff604051916134ed836126ae565b546001600160401b03811683526001600160401b038160401c166020840152818160801c161515604084015260881c16151560608201526040519182918291909160608060808301946001600160401b0381511684526001600160401b03602082015116602085015260408101511515604085015201511515910152565b346105af5760203660031901126105af57600435613588816105b3565b613590618736565b61359981619078565b60048101906135ad825460ff9060481c1690565b613190575f915f5b6135d0856001600160401b03165f52600a60205260405f2090565b548110156136fb57610ff06135fd612fcc83612fc7896001600160401b03165f52600a60205260405f2090565b1461360a576001016135b5565b5090915060015b156112a757612bf96115396136a69361363f600194690100000000000000000060ff60481b19825416179055565b805461366a9060401c6001600160a01b031660028301546001600160a01b031660038401549161a42c565b336001600160401b0387167fc63050b963ec6e2cf36df90ecacaa43212c0e74b8c3a58a0f8cce3bd5a2a76755f80a3546001600160401b031690565b906001600160a01b0382166136bd5761001861876e565b604051631939a94360e31b60208201523360248201526001600160401b0390911660448201526136f49161099a826064810161098c565b5f80611203565b509091613611565b346105af575f3660031901126105af5760206040517fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c217758152f35b346105af5761374b36610625565b6001600160401b03839293165f52601d60205260018060a01b0360405f205460401c16331415806137b2575b613792576100189261378a9136916127eb565b90339061a455565b63dd2c7fb760e01b5f526001600160401b0382166004523360245260445ffd5b50335f9081525f8051602061c947833981519152602052604090205460ff1615613777565b346105af576101203660031901126105af576004356001600160401b0381116105af576138089036906004016105f8565b505060243561381681610aaf565b60e03660431901126105af57610bbd9061382e61870f565b6004546001600160401b031690613863613847836168ad565b6001600160401b03166001600160401b03196004541617600455565b6138e661386e616c75565b6138be6138796172f7565b6138b5613884612785565b338152936001600160a01b0387166020860152426001600160401b031660408601525f606086015260808501617267565b60a08301617270565b600160c08201525b6138e1846001600160401b03165f52600560205260405f2090565b61733d565b613909613904836001600160401b03165f52600660205260405f2090565b617428565b6040516001600160a01b038216815233906001600160401b038416907f2b0f6a7b1f5afd7832e49972f40b9fcd16998930b24f36469c91003502d0d99890602090a36001600160a01b038116613975575b506040516001600160401b0390911681529081906020820190565b604051630b6535d760e01b60208201526001600160401b03831660248201523360448201523060648201526139b191612121826084810161098c565b5f61395a565b801515036105af57565b346105af5760603660031901126105af576004356139de816105b3565b6024356139ea816139b7565b604435916139f783610eb6565b6139ff618ee5565b6001600160401b038116610e108110908115613b07575b50613aec5761ffff83168015908115613afb575b50613aec57613ae77f33e0411431005a063470b554094e62f6973aa35fce230eaf5d5a0079be4e339c93613ab9613a5f612794565b6001600160401b0385168082528615156020830181905261ffff8516604093840152601c80546affffffffffffffffffffff1916909217921b60ff60401b1691909117604884901b6affff00000000000000000016179055565b6040519384938491604091949361ffff916001600160401b0360608601971685521515602085015216910152565b0390a1005b63d8f2727d60e01b5f5260045ffd5b6127109150115f613a2a565b62278d009150115f613a16565b346105af5760403660031901126105af576020613b6a600435613b3681610aaf565b60243590613b4382610aaf565b60018060a01b03165f526019835260405f209060018060a01b03165f5260205260405f2090565b54604051908152f35b346105af57613b81366119c7565b6001600160a01b03613b92836198dc565b5460401c163303612cee576001600160401b0361001892165f52601360205260405f209060018060a01b03169061ba1b565b346105af57610bbd613c0c6001600160401b03613be0366119c7565b9190613bea6172d3565b50165f52601160205260405f209060018060a01b03165f5260205260405f2090565b60ff60405191613c1b836126ae565b5461ffff811683526001600160401b038160101c1660208401526001600160401b038160501c16604084015260901c161515606082015260405191829182919091606080608083019461ffff81511684526001600160401b0360208201511660208501526001600160401b03604082015116604085015201511515910152565b346105af575f3660031901126105af57613cb3618f54565b613cbb61870f565b600160ff195f8051602061c9078339815191525416175f8051602061c907833981519152557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2586020604051338152a1005b346105af57613d1a366119c7565b6001600160a01b03811691908215613db657613d358261867c565b8054909190336001600160a01b03821603613d965782546001600160a01b0319166001600160a01b039283161790925516906001600160401b03167fd2b958a1b0b978ceded4986b4f49c8b25fbd6e812cb8925e13efc731ea4aa24d5f80a4005b6001600160401b038463234e071d60e01b5f52166004523360245260445ffd5b63d92e233d60e01b5f5260045ffd5b346105af575f3660031901126105af5760206040517f4c7070c6c19cc9b427b94fe5979ee0c573f8edd00d25591afe4c9510de9479ba8152f35b346105af5760203660031901126105af576001600160401b03600435613e24816105b3565b165f526008602052602060405f2054604051908152f35b346105af5760403660031901126105af57602060ff613e8d602435600435613e6282610aaf565b5f525f8051602061c8e7833981519152845260405f209060018060a01b03165f5260205260405f2090565b54166040519015158152f35b60206003198201126105af57600435906001600160401b0382116105af5761065d91600401610a7f565b346105af57613ed136613e99565b613eda816168ca565b915f915f5b818110613f3a57505050613ef2816168ca565b915f5b828110613f0a5760405180610bbd8682610be9565b80613f34613f2a613f1d60019486616932565b516001600160401b031690565b610cd98388616932565b01613ef5565b80613f5a613f4b60019385876174ee565b35613f55816105b3565b61a57a565b613f65575b01613edf565b613f708184866174ee565b35613f7a816105b3565b6001600160401b03613f95613f8e886174fe565b9789616932565b91169052613f5f565b60403660031901126105af57600435613fb6816105b3565b602435613fc1618736565b6002613fcc836198dc565b01546001607082901c60ff16613fe1816122e3565b036140a65760019060681c60ff16613ff8816122e3565b0361143d577fd28de7c518c312fa388e03f8d1203d8f4c75161e358ffb0827b6caa2e9ac8a316001600160401b03614041846001600160401b03165f52601460205260405f2090565b805461405a906001600160a01b0316918583349261a65a565b6001600160a01b03169384158061409d575b614085575b6040519384521691602090a361001861876e565b614098614092853461751a565b3361a6ec565b614071565b5083341161406c565b63098bfc5b60e31b5f526001600160401b03831660045260245ffd5b346105af575f3660031901126105af5760206040515f8152f35b60e03660031901126105af576004356140f4816105b3565b6024356001600160401b0381116105af57614113903690600401610a7f565b916044356001600160401b0381116105af576141339036906004016105f8565b929093606435936001600160401b0385116105af57610bbd9561415d610ba3963690600401610a7f565b9290916141686105e0565b94614171610acd565b9660c43598617527565b346105af57602060ff6141b96001600160401b03614198366119c7565b91165f526011845260405f209060018060a01b03165f5260205260405f2090565b5460901c166040519015158152f35b346105af5760203660031901126105af576004356141e5816105b3565b6141ed618736565b614208816001600160401b03165f52601d60205260405f2090565b9061421561158a83618e9b565b6144a8578154906001600160401b038216906020614244836001600160401b03165f52601060205260405f2090565b5f5490939061425f90611b1b906001600160a01b0316610ff0565b9461427185546001600160401b031690565b60038801546004808a01546040516308d795d560e41b81526001600160a01b039a909a16918a01919091526001600160401b0392831660248a015293909116604488015260648701526084860191909152849060a49082905f905af1928315611363575f93614472575b50612bf9611539614300936142f28660019561a7be565b50546001600160401b031690565b916001600160a01b03831661432c575b610bbd8261431c61876e565b6040519081529081906020820190565b5f54614340906001600160a01b0316610ff0565b905460408051631c9d11bd60e31b81529082901c6001600160a01b031660048201819052949092602090849060249082905afa801561136357610bbd9561098c611ca29461099a93614432975f91614453575b50801561444a57611c436143ba916143b48b6143ae81616f23565b926175c0565b90616f64565b61271061ffff821611614441575b611c6a6143da9161ffff606491160490565b90606460ff831611614438575b614416906001600160401b031693604051978891602083016014916001600160601b03199060601b1681520190565b604051637e14b91960e01b602082015295869360248501616f73565b5f614310565b606491506143e7565b506127106143c8565b506127106143ba565b61446c915060203d60201161135c5761134d8183612736565b5f614393565b6001919350611539614300936142f261449c612bf99460203d60201161135c5761134d8183612736565b969450509350506142db565b63b48b095960e01b5f526001600160401b031660045260245ffd5b346105af57610bbd61452f6001600160401b036144df36610bc1565b91905f60a06040516144f0816126c9565b8281528260208201528260408201528260608201528260808201520152165f52601660205260405f20906001600160401b03165f5260205260405f2090565b6145bb6145b2600360405193614544856126c9565b805460ff81168652600881901c6001600160a01b0316602087015261457f9060a81c6001600160401b03166001600160401b03166040870152565b6145a0614593600183015463ffffffff1690565b63ffffffff166060870152565b60028101546080860152015460ff1690565b151560a0830152565b6040519182918291909160a08060c083019460ff8151168452600180831b0360208201511660208501526001600160401b03604082015116604085015263ffffffff60608201511660608501526080810151608085015201511515910152565b346105af575f3660031901126105af57608060025461ffff604051918181168352818160101c166020840152818160201c16604084015260301c166060820152f35b346105af5760603660031901126105af576146796004356105b3565b6024356001600160401b0381116105af57614698903690600401610a7f565b906044356001600160401b0381116105af576146b8903690600401610a7f565b90916146c261870f565b6146ca618736565b818403614b48576146ee6004356001600160401b03165f52601060205260405f2090565b61470261153982546001600160401b031690565b5f5b8681106147135761001861876e565b61475b6147336004356001600160401b03165f52601660205260405f2090565b614746614741848b896174ee565b61741e565b6001600160401b03165f5260205260405f2090565b61478261158a610fb7336108ca6004356001600160401b03165f52601160205260405f2090565b614b2457600381015460ff16614af0576147c86115e2896108ca6147b96004356001600160401b03165f52601760205260405f2090565b6147466147418833958d6174ee565b614ab85790600191614807611625876108ca8c614746614741886147ff6004356001600160401b03165f52601760205260405f2090565b9333966174ee565b61483561481d6111918584015463ffffffff1690565b8483019063ffffffff1663ffffffff19825416179055565b82840154889087906001600160a01b0316898c8683614a2e575b925090506148619350614741926174ee565b61486c83898b6175cd565b907f8a04f99fe23284e874e8dd017345248279cc59701695e73bcdbeb6241bcd2ac6604051806148b46001600160401b03339716956001600160401b036004351695836167f1565b0390a48383015483906148cf906001600160a01b0316610ff0565b806149b5575b5063ffffffff806148ec8685015463ffffffff1690565b9216911610158061499e575b614904575b5001614704565b60038101805460ff191660011790556001600160401b03614929614741848c8a6174ee565b166001600160401b03600435167f60a7649f6e93e7a3ce1dc9729c20e3d95dce28c6a6bd957cde09d8a1cb37c19f5f80a360028581015460681c60ff1661496f816122e3565b1480614991575b156148fd57600261498b91015460043561998e565b5f6148fd565b5060028101541515614976565b506149b061158a600383015460ff1690565b6148f8565b82546040516313110f8160e21b8152600480356001600160401b03169082015260ff90911660248201529060209082906001600160a01b031681806044810103915afa5f9181614a0e575b50156148d55790505f6148d5565b614a2791925060203d8111611818576118098183612736565b905f614a00565b614aad95614a8b61098c9261099a95614a85614a4b8c5460ff1690565b9961474661474185614a61614741828d876174ee565b9a614a7f6004356001600160401b03165f52601860205260405f2090565b946174ee565b936175cd565b9160405197889563c40c80d160e01b6020880152339160043560248901616e0d565b87865f898c8661484f565b610765614ac9614741848b896174ee565b635bf3fe7760e11b5f526001600160401b0360048035821690521660245233604452606490565b610765614b01614741848b896174ee565b630a55512f60e01b5f526001600160401b03600480358216905216602452604490565b63783482e960e01b5f908152600480356001600160401b0316905233602452604490fd5b631fec674760e31b5f5260045ffd5b60405190614b66602083612736565b5f8252565b805180835260209291819084018484015e5f828201840152601f01601f1916010190565b906020610be6928181520190614b6b565b346105af575f3660031901126105af57610bbd604051614bc1604082612736565b60058152640352e302e360dc1b6020820152604051918291602083526020830190614b6b565b346105af57614bf536613e99565b90614bfe618736565b5f915f915f5b828110614c26578385614c1561876e565b604080519182526020820192909252f35b614c4e614c376147418386866174ee565b6001600160401b03165f52601d60205260405f2090565b90614c5b61158a83618e9b565b614eb95781546001600160401b038116966020614c89896001600160401b03165f52601060205260405f2090565b5f54909990614cb490614ca4906001600160a01b0316610ff0565b9460401c6001600160a01b031690565b93614cc68b546001600160401b031690565b60038801546004808a01546040516308d795d560e41b81526001600160a01b0399909916918901919091526001600160401b03928316602489015293909116604487015260648601526084850191909152839060a49082905f905af191821561136357868685925f95614e70575b50614d6b614d6586614d7996614d5f82614d5a61474160019a612bf99a6115399a6174ee565b61a7be565b506175c0565b9a6174fe565b9a546001600160401b031690565b906001600160a01b038216614d99575b5050600191505b01939293614c04565b5f54614dad906001600160a01b0316610ff0565b935491604083901c6001600160a01b0316604051631c9d11bd60e31b81526001600160a01b038216600482015295909290602090879081806024810103915afa9283156113635761098c614e3995611ca29561099a9460019a5f92614e50575b508115614e4057614e2e611c436143da936143b4846143ae611c6a96616f23565b61ffff606491160490565b5f80614d89565b50506143da611c6a612710614e2e565b614e6991925060203d811161135c5761134d8183612736565b905f614e0d565b6001939550614d65612bf993614d7996614d5f61153995614d5a614741614ea7614d6b9860203d811161135c5761134d8183612736565b9c9a5050509550509650935050614d34565b60019150949394614d90565b81516001600160a01b039081168252602080840151909116908201526040808301516001600160401b03169082015260608083015163ffffffff1690820152608082015160e0820193926105d1929160c0918291614f22816122c7565b6080850152612ddf60a082015160a08601906122ed565b346105af5760203660031901126105af576001600160401b03600435614f5e816105b3565b614f66617279565b50165f526005602052610bbd60405f20615003614ffa600260405193614f8b8561268e565b80546001600160a01b03908116865260018201549081166020870152614fcb9061459390614fc560a082901c6001600160401b0316612490565b60e01c90565b0154614fdd60ff821660808601617267565b614ff1600882901c60ff1660a08601617270565b60101c60ff1690565b151560c0830152565b60405191829182614ec5565b346105af5760803660031901126105af57615028618ee5565b604051615034816126ae565b6004359061504182610eb6565b8181526024359061505182610eb6565b81602082015261ffff806044359461506886610eb6565b6040840195865260606064359461507e86610eb6565b0193845216921682018092116150d8576150ad611c436150b36150bc946150ad611c43612710985161ffff1690565b906175c0565b925161ffff1690565b036150c95761001861760e565b6343744f7160e01b5f5260045ffd5b616783565b90602080835192838152019201905f5b8181106150fa5750505090565b82516001600160a01b03168452602093840193909201916001016150ed565b906020610be69281815201906150dd565b346105af5760203660031901126105af576001600160401b0360043561514f816105b3565b165f52601260205260405f206040519081602082549182815201915f5260205f20905f5b81811061519657610bbd8561518a81870382612736565b60405191829182615119565b8254845260209093019260019283019201615173565b346105af5760603660031901126105af576004356151c981610aaf565b602435906151d682610aaf565b6044356151e281610aaf565b5f8051602061c96783398151915254926001600160401b0361521360ff604087901c1615956001600160401b031690565b168015908161532c575b6001149081615322575b159081615319575b5061530a57615272928461526960016001600160401b03195f8051602061c9678339815191525416175f8051602061c96783398151915255565b6152d55761a89b565b61527857005b6152a260ff60401b195f8051602061c96783398151915254165f8051602061c96783398151915255565b604051600181527fc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2908060208101613ae7565b615305600160401b60ff60401b195f8051602061c9678339815191525416175f8051602061c96783398151915255565b61a89b565b63f92ee8a960e01b5f5260045ffd5b9050155f61522f565b303b159150615227565b85915061521d565b346105af576101403660031901126105af57600435615352816105b3565b61535d6024356105b3565b6044356001600160401b0381116105af5761537c9036906004016105f8565b9190606435903660c4116105af5736610144116105af5761539b61870f565b6153a3618736565b6153ac836198dc565b936153b960243585619929565b946153ce61153982546001600160401b031690565b9160038701936153df855460ff1690565b6157cd5760018401546001600160a01b03165f8161573e575b1561570c57615421905f90611a2c908b906001600160a01b031680615661575b5050888a61aa34565b8082106156235750506084359560a4356154396127b3565b97885260208801526040906154e861158a615453846127c2565b60c4803582529a60e435602083015261546b866127c2565b60408d0135815260608d013560208201526154846127b3565b92835260208301528c6154e361549b368b8b6127eb565b805160209182012089516001600160c01b031960c095861b81169382019390935260243590941b9091166028840152603083015281605081015b03601f198101835282612736565b61bc9c565b615614576002978961550b60018b99612bf961559a9c600160ff19825416179055565b8c6001600160a01b0382166155d1575b50507fe6fcb3342abe43c21acc6a04e3d7912476836976e07ed47d0b15a374e200e2f091506001600160401b03169384926155686001600160401b03602435169788965193849384617719565b0390a37f60a7649f6e93e7a3ce1dc9729c20e3d95dce28c6a6bd957cde09d8a1cb37c19f5f80a3015460681c60ff1690565b6155a3816122e3565b14806155c4575b6155b65761001861876e565b60026136f49201549061998e565b50600282015415156155aa565b61560b9361098c6155e661099a935460ff1690565b916084888c8c8c51998a9763158bb2eb60e01b60208a01526024359160248a016176cc565b5f89818c61551b565b63ab1b236b60e01b5f5260045ffd5b604051630ae5923560e11b81526001600160401b038a81166004830152602480359091169082015260448101929092526064820152608490fd5b0390fd5b6156b19160409161567d906001600160a01b0316915460ff1690565b82516312fe632760e11b81526001600160401b038f16600482015260ff909116602482015292839190829081906044820190565b03915afa90815f915f936156d9575b506156ce575b8c9150615418565b915091505f806156c6565b9092506156fe915060403d604011615705575b6156f68183612736565b8101906176a7565b915f6156c0565b503d6156ec565b6107658861571b8b5460ff1690565b63279db37560e11b5f526001600160401b0390911660045260ff16602452604490565b61578c60206157556001600160a01b038516610ff0565b8c54604051630cf6add960e11b81526001600160401b038e16600482015260ff909116602482015292839190829081906044820190565b03915afa5f91816157ac575b506157a4575b506153f8565b90505f61579e565b6157c691925060203d6020116112df576112d08183612736565b905f615798565b630a55512f60e01b5f526001600160401b038088166004526024803591909116905260445ffd5b346105af575f3660031901126105af5760206001600160401b0360045416604051908152f35b346105af5761582836610625565b61583061870f565b6158398361867c565b600281015461584c9060101c60ff161590565b615b6c575f54615864906001600160a01b0316610ff0565b60405163eb47353360e01b8152336004820152909190602081602481865afa908115611363575f91615b4d575b5015615b3a576001600160401b036158c161087d336108ca896001600160401b03165f52600760205260405f2090565b16615b1a5760405163d775cb6160e01b8152602081600481865afa8015611363576001915f91615afb575b509101805490926001600160a01b039091169182615a74575b60405163f46913bb60e01b815233600482015260248101829052602081604481865afa908115611363575f91615a55575b50156112e657507fa9cf99c4c75bf0874576e6ee70b00b920e9c36551e4d6c17694ecaa684624d2b93610744939092615a1092506001600160a01b038116615a28575b506159e26001600160401b0342166159b0615992612757565b6001600160401b0383168152915b6001600160401b03166020830152565b60016040820152600160608201526159dd336108ca8b6001600160401b03165f52600760205260405f2090565b617752565b615a013361117a896001600160401b03165f52600860205260405f2090565b50610918611191825460e01c90565b6040519182916001600160401b0333971695836167f1565b6040516333bc9e6360e11b6020820152615a4f916121218261098c888c3360248501617730565b5f615979565b615a6e915060203d6020116112df576112d08183612736565b5f615936565b60046040615a8a6001600160a01b038616610ff0565b8151632a6e736160e11b815292839182905afa90815f915f93615ad8575b50615ab5575b5050615905565b1580615acf575b615ac7575b80615aae565b90505f615ac1565b50801515615abc565b909250615af4915060403d604011611417576114088183612736565b915f615aa8565b615b14915060203d60201161135c5761134d8183612736565b5f6158ec565b639ec4e30d60e01b5f526001600160401b0385166004523360245260445ffd5b6371ab6ad560e11b5f523360045260245ffd5b615b66915060203d6020116112df576112d08183612736565b5f615891565b63210eb4ed60e11b5f526001600160401b03841660045260245ffd5b346105af5760203660031901126105af57600435615ba5816105b3565b615bad618736565b615bb6816198dc565b60028101546001607082901c60ff16615bce816122e3565b036140a65760019060681c60ff16615be5816122e3565b0361143d5760018101805490926001600160401b03604083901c168015159081615e37575b50615e1c5790600191615c506121cc615c2d61214787546001600160401b031690565b6121c7615c4460028301546001600160401b031690565b96879201549560c01c90565b4210615e0d57615c71816001600160401b03165f52601460205260405f2090565b6001810154838110615df65750615c8b83615caa9261be0a565b86546001600160c01b03164260c01b6001600160c01b03191617909655565b615ccd615cc8826001600160401b03165f52601260205260405f2090565b61bb33565b91615cd883516168ca565b935f965f975b8551891015615d7c57615d74600191615d5c615d49615d418a615d2d8f615d2090615d1a8e6001600160401b03165f52601160205260405f2090565b93616932565b516001600160a01b031690565b60018060a01b03165f5260205260405f2090565b5461ffff1690565b615d538d8c616932565b9061ffff169052565b6150ad611c43615d6c8d8c616932565b5161ffff1690565b980197615cde565b7f24dc485bef04b4d790d97ac10381d8d9e66c56dd6fba9931b703ca169511778a966001600160401b039685615dc794615dc1615deb989c546001600160401b031690565b8961b7c8565b6040519384931695839092916001600160401b036020916040840195845216910152565b0390a261001861876e565b63039ff3b160e41b5f52600484905260245260445ffd5b631ab7da6b60e01b5f5260045ffd5b637c3e621b60e01b5f526001600160401b031660045260245ffd5b615e4f91506121cc906001600160401b038516616fa3565b42115f615c0a565b346105af575f3660031901126105af57602080546040516001600160a01b039091168152f35b346105af5760403660031901126105af57610018602435600435615ea082610aaf565b615eac611a6b82616d69565b61a2cd565b346105af57615ebf36613e99565b615ec7618736565b5f905f928115615f6e575f5b828110615ee557505050614c1561876e565b615f02615ef38285856174ee565b35615efd816105b3565b61abaa565b615f0f575b600101615ed3565b9392615f66615f606001926001600160401b03615f2d8988886174ee565b35615f37816105b3565b165f52601060205283615f5861214760405f206001600160401b0390541690565b0154906175c0565b946174fe565b949050615f07565b631f2a200560e01b5f5260045ffd5b346105af57615f8b36610625565b615fa961086b846001600160401b03165f52600760205260405f2090565b6001600160401b03615fc282546001600160401b031690565b1615616076577f8547e94bd95ca7d3c7a3be9b66a29e6f36151be54a2563e35098438861a4c87191616001610744926001600160401b034216906167a9565b6160216001612bf9876001600160401b03165f52600560205260405f2090565b6001600160a01b038116616049575b506040519182916001600160401b0333971695836167f1565b604051637ac7103360e11b60208201526160709161099a8261098c868a3360248501617730565b5f616030565b639bcccbfd60e01b5f526001600160401b0384166004523360245260445ffd5b346105af576160a436610625565b6001600160a01b036160b58461867c565b5416330361610757907f30fc45e05a33fd9068cf6ae1a8f3db2b9d15372dd6494eccc8cd5d305fdf38b3916001600160401b036160ff6040519384936020855260208501916167d1565b9416930390a2005b6001600160401b038363234e071d60e01b5f52166004523360245260445ffd5b346105af575f3660031901126105af5760206040517f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a8152f35b346105af5760403660031901126105af576004356001600160401b0381116105af576161919036906004016105f8565b5050610bbd6024356161a281610aaf565b6161aa61870f565b6004546001600160401b0316906161c3613847836168ad565b6139096161ce612785565b3381526001600160a01b0383166020820152426001600160401b031660408201525f60608201525f60808201525f60a08201526138c660c0820160019052565b346105af5760203660031901126105af576001600160401b03600435616233816105b3565b61623b6172d3565b50165f526014602052610bbd60405f2060036040519161625a836126ae565b80546001600160a01b0316808452600182015460208086019182526002840154604080880191825295909401546060968701908152855193845291519083015291519281019290925251918101919091529081906080820190565b9181601f840112156105af578235916001600160401b0383116105af576020808501948460071b0101116105af57565b6101003660031901126105af576162fa6105c4565b6024356001600160401b0381116105af57616319903690600401610a7f565b916044356001600160401b0381116105af576163399036906004016162b5565b9290936064356001600160401b0381116105af5761635b9036906004016105f8565b949095608435956001600160401b0387116105af57610bbd97616385610ba3983690600401610a7f565b9490936163906105d3565b96616399610ac0565b9860e4359a6177c3565b600411156122d157565b906122e0826163a3565b610160610120610be693602084526163db6020850182516001600160401b03169052565b60208101516001600160a01b0316604085015260408101516001600160a01b0316606085015260608101516080850152608081015160a085015260a081015160c085015261643960c082015160e08601906001600160401b03169052565b60e08101516001600160401b031661010085015261645f610100820151838601906163ad565b015191610140808201520190614b6b565b346105af5760203660031901126105af576001600160401b03600435616495816105b3565b60606101206040516164a6816126e4565b5f81525f60208201525f60408201525f838201525f60808201525f60a08201525f60c08201525f60e08201525f6101008201520152165f52601d602052610bbd60405f206165bb60066164f76127a3565b926165306165208254612453616513826001600160401b031690565b6001600160401b03168852565b6001600160a01b03166020860152565b60018101546001600160a01b031660408501526002810154606085015260038101546080850152600481015460a08501526165b56165ab600583015461658f61657f826001600160401b031690565b6001600160401b031660c0890152565b6001600160401b03604082901c1660e088015260801c60ff1690565b6101008601617b14565b01617b1d565b610120820152604051918291826163b7565b346105af5760203660031901126105af576004356165ea81610aaf565b6165f2618736565b6165fc813361a3c0565b90816166155760015f8051602061c92783398151915255005b6040519182526001600160a01b03169033907f9310ccfcb8de723f578a9e4282ea9f521f05ae40dc08f3068dfad528a65ee3c790602090a35f8061226c565b60a03660031901126105af5760043561666c816105b3565b6024356001600160401b0381116105af5761668b903690600401610a7f565b90916044356001600160401b0381116105af576166ac9036906004016105f8565b929093606435936001600160401b0385116105af57610bbd956166d6610ba3963690600401610a7f565b949093608435966166e6886105b3565b617bbb565b346105af5760203660031901126105af5760043561670881610aaf565b616710618ee5565b6001600160a01b03168015613db6576001600160601b0360a01b60015416176001555f80f35b346105af575f3660031901126105af5760206040517f189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e38152f35b634e487b7160e01b5f525f60045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b63ffffffff1680156150d8575f190190565b9067ffffffffffffffff60401b82549160401b169067ffffffffffffffff60401b1916179055565b908060209392818452848401375f828201840152601f01601f1916010190565b916020610be69381815201916167d1565b9b9a999897969594939b61681461870f565b61681c618736565b8c8303614b485761682c8d616896565b9361683a6040519586612736565b8d8552602085019d60051b8101903682116105af579d818f5b106168795750506168659b9c506189c0565b60015f8051602061c9278339815191525590565b60208f9181923561688981610eb6565b8152019e019d818f616853565b6001600160401b0381116126a95760051b60200190565b6001600160401b03166001600160401b0381146150d85760010190565b906168d482616896565b6168e16040519182612736565b82815280926168f2601f1991616896565b0190602036910137565b634e487b7160e01b5f52603260045260245ffd5b80511561691d5760200190565b6168fc565b80516001101561691d5760400190565b805182101561691d5760209160051b010190565b909161695061870f565b616958618736565b61696182619078565b90616974600483015460ff9060481c1690565b613190575f935f5b616997856001600160401b03165f52600a60205260405f2090565b54811015616c1a57610ff06169c4612fcc83612fc7896001600160401b03165f52600a60205260405f2090565b146169d15760010161697c565b50909192935060015b156112a757616a016115e2336108ca876001600160401b03165f52600c60205260405f2090565b616bfa57616a20846001600160401b03165f52600e60205260405f2090565b82828254616be9575b5050505f5b828110616bad5750616a58611625336108ca876001600160401b03165f52600c60205260405f2090565b616ad76115396001850194616a9b616a7b611191885463ffffffff9060a01c1690565b875463ffffffff60a01b191660a09190911b63ffffffff60a01b16178755565b336001600160401b0388167fceda1a44ead4da3d3abaaa941afa6d9530fd84dd8e99385c9183d986dcab980f5f80a3546001600160401b031690565b918015616b9e57616afe611c6a614e2e6040616af8600195616b0d97616c39565b01616c95565b9201546001600160a01b031690565b906001600160a01b038216616b57575b50505463ffffffff616b376130fa60a084901c83166130ed565b911614616b48575b506105d161876e565b616b51906192f7565b5f616b3f565b604051632c567acd60e21b60208201523360248201526001600160401b038516604482015260ff9091166064820152616b979161099a826084810161098c565b5f80616b1d565b5050616b0d6001606492612bf9565b600190616be3616bd2336108ca896001600160401b03165f52600f60205260405f2090565b616bdd838787616c42565b90616c9f565b01616a2e565b616bf2926190b2565b5f8282616a29565b630f2bb0f160e41b5f526001600160401b0384166004523360245260445ffd5b50909192936169da565b805482101561691d575f5260205f2001905f90565b901561691d5790565b919081101561691d576060020190565b805482101561691d575f5260205f209060011b01905f90565b600211156105af57565b604435610be681616c6b565b35610be681616c6b565b35610be681610aaf565b35610be681610eb6565b8054600160401b8110156126a957616cbc91600182018155616c52565b616d395760016040836105d19435616cd381616c6b565b616cdc816122c7565b60ff80198654169116178455616d1b6020820135616cf981610aaf565b8554610100600160a81b03191660089190911b610100600160a81b0316178555565b013591616d2783610eb6565b019061ffff1661ffff19825416179055565b616770565b63ffffffff1663ffffffff81146150d85760010190565b634e487b7160e01b5f52601260045260245ffd5b5f525f8051602061c8e7833981519152602052600160405f20015490565b908160209103126105af575190565b6040513d5f823e3d90fd5b91908260409103126105af5760208251616dba816139b7565b92015190565b908160209103126105af5751610be6816139b7565b90600182811c92168015616e03575b6020831014616def57565b634e487b7160e01b5f52602260045260245ffd5b91607f1691616de4565b6001600160401b03918216815260ff909216602083015290911660408201526001600160a01b03909116606082015260c06080820152815494935f939092909190616e5787616dd5565b968760c08401526001811690815f14616ec55750600114616e87575b50610be694955060a08185039101526167d1565b9093505f5260205f205f905b868210616eae57509394508493830160e00192610be6616e73565b6001816020925460e0858901015201910190616e93565b905060e0929550610be69697915060ff191682860152151560051b840101928594616e73565b63ffffffff8116036105af57565b908160209103126105af5751610be681616eeb565b908160209103126105af5751610be681610aaf565b9061271082029180830461271014901517156150d857565b906006820291808304600614901517156150d857565b818102929181159184041417156150d857565b8115616f6e570490565b616d55565b91616f9c60ff916001600160401b03604094979697168552606060208601526060850190614b6b565b9416910152565b906001600160401b03809116911601906001600160401b0382116150d857565b815181546020840151610100600160a81b0360089190911b1660ff9092166001600160a81b0319909116171781556105d1916003906170639060a0906040810151855467ffffffffffffffff60a81b191660a89190911b67ffffffffffffffff60a81b1617855560608101516170529063ffffffff16600187019063ffffffff1663ffffffff19825416179055565b608081015160028601550151151590565b91019060ff801983541691151516179055565b9161708f9183549060031b91821b915f19901b19161790565b9055565b601f82116170a057505050565b5f5260205f20906020601f840160051c830193106170d8575b601f0160051c01905b8181106170cd575050565b5f81556001016170c2565b90915081906170b9565b9092916001600160401b0381116126a957617107816171018454616dd5565b84617093565b5f601f821160011461714157819061708f9394955f92617136575b50508160011b915f199060031b1c19161790565b013590505f80617122565b601f19821694617154845f5260205f2090565b915f5b87811061718e575083600195969710617175575b505050811b019055565b01355f19600384901b60f8161c191690555f808061716b565b90926020600181928686013581550194019101617157565b90610be6959360ff6080946001600160401b03809416855216602084015216604082015281606082015201916167d1565b610be6949260ff60609316825260018060a01b0316602082015281604082015201916167d1565b6040519061018082018281106001600160401b038211176126a9576040525f610160838281528260208201528260408201528260608201528260808201528260a08201528260c08201528260e08201528261010082015282610120820152826101408201520152565b6122e0826122c7565b6122e0826122e3565b604051906172868261268e565b5f60c0838281528260208201528260408201528260608201528260808201528260a08201520152565b906172b9816122e3565b815460ff60701b191660709190911b60ff60701b16179055565b604051906172e0826126ae565b5f6060838281528260208201528260408201520152565b60643560038110156105af5790565b90617310816122c7565b60ff80198354169116179055565b90617328816122e3565b61ff0082549160081b169061ff001916179055565b815181546001600160a01b0319166001600160a01b03919091161781556105d191906174069060c09060029060208501516001820180546001600160a01b0319166001600160a01b03929092169190911781556173cf906040870151815467ffffffffffffffff60a01b191660a09190911b67ffffffffffffffff60a01b16178155606087015163ffffffff16610918565b01926173e860808201516173e2816122c7565b85617306565b6173ff60a08201516173f9816122e3565b8561731e565b0151151590565b815462ff0000191690151560101b62ff000016179055565b35610be6816105b3565b61743d60443561743781616c6b565b82617306565b60643560038110156105af57617453908261731e565b60843561745f81616eeb565b65ffffffff000082549160101b169065ffffffff000019161781556174af60a43561748981616eeb565b825469ffffffff000000000000191660309190911b69ffffffff00000000000016178255565b60c43560018201556174e36174c460e461741e565b60028301906001600160401b03166001600160401b0319825416179055565b600361010435910155565b919081101561691d5760051b0190565b5f1981146150d85760010190565b5f198101919082116150d857565b919082039182116150d857565b9998979695949392919061753961870f565b617541618736565b61754a826168ca565b9a5f5b8381106175625750906168659a9b92916189c0565b806127106175738f93600194616932565b520161754d565b90600182018092116150d857565b90600282018092116150d857565b90600382018092116150d857565b90600482018092116150d857565b90600582018092116150d857565b919082018092116150d857565b919081101561691d5760051b81013590601e19813603018212156105af5701908135916001600160401b0383116105af5760200182360381136105af579190565b61ffff60043561761d81610eb6565b1661ffff19600254161760025560243561763681610eb6565b63ffff00006002549160101b169063ffff000019161760025560443561765b81610eb6565b65ffff000000006002549160201b169065ffff0000000019161760025560643561768481610eb6565b67ffff0000000000006002549160301b169067ffff000000000000191617600255565b91908260409103126105af57602082516176c081610eb6565b920151610be681611e5e565b9360e0956001600160401b0360409560ff60809b96839b9e9d9b61770b97168a52166020890152168587015261016060608701526101608601916167d1565b978684015260a08301370137565b604090610be69492815281602082015201916167d1565b6001600160a01b039091168152604060208201819052610be6939101916167d1565b8151815467ffffffffffffffff19166001600160401b0391909116178155906177886001600160401b03602083015116836167a9565b6040810151825460ff60801b191690151560801b60ff60801b161760609091015160ff60881b1990911690151560881b60ff60881b16179055565b98929993959b9a949b9791979690966177da61870f565b6177e2618736565b8615617940575f5b878c8183106178d1575050506177ff896168ca565b9c5f5b8a81106178b357508a9b9c9d8a8a61781c9a9b9c9d6189c0565b945f5b82811061787b5750907fe9b9d941d31762ebeb7a00008b4cf95e9a19255cb6695c9d35215c914a7e8486916178706040519283926001600160401b03339916976001600160401b038b169785617a6c565b0390a4610be661876e565b6001906178ad61789c896001600160401b03165f52600e60205260405f2090565b6178a783878761794f565b9061795f565b0161781f565b808f6178c46001936178cb92616932565b6127109052565b01617802565b6178dc91839161794f565b604081016178ec611c4382616c95565b15617931576178fc606091616c95565b91019061ffff61790e611c4384616c95565b91161161793157617924611c4361271092616c95565b11617931576001016177ea565b636923afcf60e01b5f5260045ffd5b6340eb7eb560e11b5f5260045ffd5b919081101561691d5760071b0190565b8054600160401b8110156126a95761797c91600182018155616c52565b919091616d3957606060016105d193833561799681616c6b565b61799f816122c7565b60ff801983541691161781556179de60208501356179bc81610aaf565b8254610100600160a81b03191660089190911b610100600160a81b0316178255565b0191617a0360408201356179f181610eb6565b845461ffff191661ffff909116178455565b013590617a0f82610eb6565b9063ffff000082549160101b169063ffff00001916179055565b916020908281520191905f5b818110617a425750505090565b9091926020806001928635617a5681610aaf565b848060a01b031681520194019101919091617a35565b90617a8590602093959495604084526040840191617a29565b90828183039101528281520191905f5b818110617aa25750505090565b9091926080806001928635617ab681616c6b565b617abf816122c7565b81526020870135617acf81610aaf565b848060a01b0316602082015261ffff6040880135617aec81610eb6565b16604082015261ffff6060880135617b0381610eb6565b166060820152019401929101617a95565b6122e0826163a3565b9060405191825f825492617b3084616dd5565b8084529360018116908115617b995750600114617b55575b506105d192500383612736565b90505f9291925260205f20905f915b818310617b7d5750509060206105d1928201015f617b48565b6020919350806001915483858901015201910190918492617b64565b9050602092506105d194915060ff191682840152151560051b8201015f617b48565b969095979392949197617bcc61870f565b617bd4618736565b617bdd8861867c565b9860028a0197617bf561158a8a5460ff9060101c1690565b61814157617c12848b600354617c0c368787618219565b9061ad40565b9990985f5b8b51811015617c9557617c4e6121cc61087d8f8f90615d2086615d1a615d2d936001600160401b03165f52600760205260405f2090565b15617c5b57600101617c17565b8c617c6c615d20610765938f616932565b639bcccbfd60e01b5f526001600160401b039091166004526001600160a01b0316602452604490565b5090919293949596989b6001909b9a989b0198617cb88a5460018060a01b031690565b6001600160a01b038116151580618138575b6180b1575b508c3410618099578694928d8a99979593617d3a9e9f99938e948c8f617d0490863411618087575b546001600160a01b031690565b926001600160a01b038416618053575b505050505050617d67617d336004546001600160401b039060801c1690565b9d8e6168ad565b6004805467ffffffffffffffff60801b191660809290921b67ffffffffffffffff60801b16919091179055565b617d82826001600160401b03165f52600660205260405f2090565b6001600160401b03421691617d9b8b5163ffffffff1690565b915463ffffffff601082901c168015618047579060301c63ffffffff165b91549260ff84169360081c60ff1694617dd0612775565b6001600160401b0390971687523360208801526001600160401b03811660408801526001600160401b038b1660608801525f60808801526001600160401b031660a087015263ffffffff1660c086015263ffffffff1660e085015263ffffffff16610100840152617e45906101208401617267565b617e53906101408301617270565b6001610160820152617e768c6001600160401b03165f52601060205260405f2090565b90617e8091618435565b8651617e8b906168ca565b97617e989289928d61af6d565b9633617eb58b6001600160401b03165f52601360205260405f2090565b90617ebf91619916565b505f5b82811061800b5750617f1e906001600160401b038a165f6001600160401b038d167f741e97ee1ff887c4d882f4c49ad280ea7d61d035e4e8a471e5319515502750238280a48054617cf79033906001600160a01b03168d61b0d9565b926001600160a01b038416617f59575b5050505080617f45575b5050505050610be661876e565b617f4f948661b556565b5f80808080617f38565b91818993617f6f617f6a8d9561757a565b6168ca565b91617f8c33617f7d85616910565b6001600160a01b039091169052565b5f5b818110617fcc575050509161098c61099a92617fc396946040519687946320a87b3960e21b6020870152339160248701618613565b5f808080617f2e565b9092945081939550617ffe617fec617fe783866001966174ee565b616c8b565b617f7d617ff88461757a565b88616932565b01918b93918b9593617f8e565b60019061804061802c8d6001600160401b03165f52601360205260405f2090565b61803a617fe784888b6174ee565b90619916565b5001617ec2565b50617db9600191612ad1565b61807c956121219361098c926040519788956361466c0960e11b60208801523360248801618362565b875f80888c82617d14565b618094614092883461751a565b617cf7565b639a6ae60d60e01b5f5260048d90523460245260445ffd5b6180c3906001600160a01b0316610ff0565b60405163e390fcdb60e01b81525f60048201819052602482015290602090829060449082905afa5f9181618117575b5015617ccf5715618103575f617ccf565b63094403b760e41b5f90815260045260245ffd5b61813191925060203d6020116112df576112d08183612736565b905f6180f2565b508d1515617cca565b63210eb4ed60e11b5f526001600160401b038a1660045260245ffd5b81601f820112156105af5780359061817482616896565b926181826040519485612736565b828452602060608186019402830101918183116105af57602001925b8284106181ac575050505090565b838203606081126105af5760408051916181c583612700565b126105af576060916020916040516181dc81612700565b87356181e781616c6b565b8152838801356181f681610aaf565b848201528152604087013561820a81610eb6565b8382015281520193019261819e565b9291909261822684616896565b936182346040519586612736565b602085828152019060051b8201918383116105af5780915b83831061825a575050505050565b82356001600160401b0381116105af578201906060828703126105af57604051906182848261271b565b82356001600160401b0381116105af57830160c0818903126105af57604051906182ad826126c9565b80356182b8816105b3565b82526182c6602082016105ed565b6020830152604081013560408301526182e1606082016105ed565b60608301526182f2608082016105ed565b608083015260a0810135906001600160401b0382116105af57618317918a910161815d565b60a082015282526020830135916001600160401b0383116105af576183526040856183488b60209897899801612821565b8685015201610ada565b604082015281520192019161824c565b9260c09461839b6001600160401b03946183a9949a99989a5f885260018060a01b0316602088015260e0604088015260e08701906150dd565b9185830360608701526167d1565b951660808201525f60a08201520152565b805468010000000000000000600160e01b03191660409290921b68010000000000000000600160e01b0316919091179055565b906183f7816122c7565b815460ff60601b191660609190911b60ff60601b16179055565b9061841b816122e3565b815460ff60681b191660689190911b60ff60681b16179055565b9061016060026105d19361847061845385516001600160401b031690565b825467ffffffffffffffff19166001600160401b03909116178255565b6020840151618489906001600160a01b03165b826183ba565b618531600182016184a761845360408801516001600160401b031690565b6184c46184be60608801516001600160401b031690565b826167a9565b6185036184db60808801516001600160401b031690565b825467ffffffffffffffff60801b191660809190911b67ffffffffffffffff60801b16178255565b60a08601516001600160401b031681546001600160c01b031660c09190911b6001600160c01b031916179055565b019161855d61854760c083015163ffffffff1690565b845463ffffffff191663ffffffff909116178455565b61859361857160e083015163ffffffff1690565b845467ffffffff00000000191660209190911b67ffffffff0000000016178455565b6185d26185a861010083015163ffffffff1690565b84546bffffffff0000000000000000191660409190911b6bffffffff000000000000000016178455565b6185ea6101208201516185e4816122c7565b846183ed565b6186026101408201516185fc816122e3565b84618411565b01519061860e826122e3565b6172af565b9360a0936001600160401b03809481616f9c959a999a1688525f6020890152166040870152600180861b0316606086015260c0608086015260c08501906150dd565b9061708f90618663816163a3565b825460ff60801b191660809190911b60ff60801b161790565b6001600160401b0380600454169116908110156186a1575f52600560205260405f2090565b6317f4923b60e21b5f5260045260245ffd5b3d156186dd573d906186c4826127d0565b916186d26040519384612736565b82523d5f602084013e565b606090565b5f91829182602083519301915af1506186f96186b3565b50565b610be6916001600160a01b03169061b3dc565b60ff5f8051602061c907833981519152541661872757565b63d93c066560e01b5f5260045ffd5b60025f8051602061c927833981519152541461875f5760025f8051602061c92783398151915255565b633ee5aeb560e01b5f5260045ffd5b60015f8051602061c92783398151915255565b906188fb61016060046105d1946187a261845386516001600160401b031690565b60208501516187b9906001600160a01b0316618483565b61884d600182016187d761845360408901516001600160401b031690565b6187ee6184be60608901516001600160401b031690565b618822618802608089015163ffffffff1690565b825463ffffffff60801b191660809190911b63ffffffff60801b16178255565b60a087015163ffffffff16815463ffffffff60a01b191660a09190911b63ffffffff60a01b16179055565b60c08501516002820180546001600160a01b0319166001600160a01b0390921691909117905560e0850151600382015501926188916101008201516173e2816122c7565b6188c26188a661012083015163ffffffff1690565b855464ffffffff00191660089190911b64ffffffff0016178555565b6173ff6188d761014083015163ffffffff1690565b855468ffffffff0000000000191660289190911b68ffffffff000000000016178555565b815469ff000000000000000000191690151560481b60ff60481b16179055565b8054600160401b8110156126a95761893891600182018155616c24565b81546001600160a01b0393841660039290921b91821b9390911b1916919091179055565b95906189a7936001600160401b039560c0999c9b9a97948761899994168a5260018060a01b031660208a015260e060408a015260e0890191617a29565b9186830360608801526167d1565b961660808301526001600160a01b031660a08201520152565b979094969a9992939891958615618e8c5761158a9b6189de8a61867c565b6189f2600282019e8f5460ff9060101c1690565b618e705760010180549092906001600160a01b031680151580618e67575b618dd0575b505f5b888c8b808410618d6c5750505050618a3134878761a1f3565b60045460401c6001600160401b031696618a76618a4d896168ad565b67ffffffffffffffff60401b6004549160401b169067ffffffffffffffff60401b191617600455565b879e618a938d6001600160401b03165f52600660205260405f2090565b5463ffffffff601082901c16908115618d6557815b8d63ffffffff821611618d46575060301c63ffffffff169163ffffffff83168015159081618d3c575b50618d1d57548e92919060ff169063ffffffff811615618d1457905b618af5612775565b6001600160401b0390941684523360208501526001600160401b03421660408501526001600160401b03891660608501528d63ffffffff1660808501525f60a08501526001600160a01b038a1660c08501528a60e0850152610100840190618b5c91617267565b63ffffffff1661012083015263ffffffff1661014082015261016081015f9052618b97896001600160401b03165f52600960205260405f2090565b90618ba191618781565b895f5b8a8a838310618c985750505050505f5b828110618c5d57505050618c0c90604051996001600160401b033391166001600160401b0388167fbd1fdda393b679e6c4f873e233b34e2c4ea8283a3f76345dbc143b86ea0476795f80a4546001600160a01b031690565b966001600160a01b038816618c28575b50505050505050505050565b6361466c0960e11b60208a0152618c4e99612121978a9761098c97339060248b0161895c565b5f808080808080808080618c1c565b600190618c92618c7e8a6001600160401b03165f52600d60205260405f2090565b618c8c617fe78488886174ee565b9061891b565b01618bb4565b618cfb82615d2d617fe78688614a7f618ce3615d6c848e618cde60019f9d618c8c618d0c9f8f617fe791614a7f88926001600160401b03165f52600a60205260405f2090565b616932565b976001600160401b03165f52600b60205260405f2090565b9061ffff1661ffff19825416179055565b018a90618ba4565b50600190618aed565b631f8cfa3960e21b5f5263ffffffff8084166004528d1660245260445ffd5b90508d115f618ad1565b63eb8e175d60e01b5f5263ffffffff9081166004528d1660245260445ffd5b6001618aa8565b618d9992615d2d617fe78661087d94614a7f6121cc976001600160401b03165f52600760205260405f2090565b15618dbe57612710618db1611c43615d6c848c616932565b1161143d57600101618a18565b8b617c6c617fe7610765938d8d6174ee565b618de2906001600160a01b0316610ff0565b60405163e390fcdb60e01b81525f60048201526001600160a01b038716602482015290602090829060449082905afa5f9181618e46575b5015618a155715618e2a575f618a15565b63094403b760e41b5f526001600160a01b03851660045260245ffd5b618e6091925060203d6020116112df576112d08183612736565b905f618e19565b50861515618a10565b63210eb4ed60e11b5f526001600160401b038b1660045260245ffd5b63ddf9d24560e01b5f5260045ffd5b6005015460ff8160801c16618eaf816163a3565b60018114618edf57618ec0816163a3565b159081618ecb575090565b6001600160401b03915060401c1642101590565b50505f90565b335f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c602052604090205460ff1615618f1d57565b63e2517d3f60e01b5f52336004527fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c2177560245260445ffd5b335f9081527f75442b0a96088b5456bc4ed01394c96a4feec0f883c9494257d76b96ab1c9b6b602052604090205460ff1615618f8c57565b63e2517d3f60e01b5f52336004527f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a60245260445ffd5b335f9081527fab71e3f32666744d246edff3f96e4bdafee2e9867098cdd118a979a7464786a8602052604090205460ff1615618ffb57565b63e2517d3f60e01b5f52336004527f189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e360245260445ffd5b5f8181525f8051602061c8e78339815191526020908152604080832033845290915290205460ff16156190625750565b63e2517d3f60e01b5f523360045260245260445ffd5b6001600160401b038060045460401c169116908110156190a0575f52600960205260405f2090565b63123616b360e11b5f5260045260245ffd5b9190915f5b815481101561925b576190ca8183616c52565b5080546001600160a01b03600882901c16915f91839190835b888a81831061911c575b5050505050501561910157506001016190b7565b6310c8eb2160e31b5f526001600160a01b031660045260245ffd5b610ff0602061913085899561913695616c42565b01616c8b565b148061922a575b619149576001016190e3565b925050915060016191606040616af8848a8c616c42565b9201549161ffff808416911681116191ec57506191916191866040616af8848a8c616c42565b9260101c61ffff1690565b9161ffff8084169116116191ae57505060015f808080888a6190ed565b916191c26040616af861076595898b616c42565b636d1000b760e01b5f526001600160a01b0390911660045261ffff90811660245216604452606490565b836192006040616af8610765958b8d616c42565b6394f47ccb60e01b5f526001600160a01b0390911660045261ffff90811660245216604452606490565b5061923e619239828b8d616c42565b616c81565b60ff83169061924c826122c7565b619255816122c7565b1461913d565b50505050565b90604051918281549182825260208201905f5260205f20925f5b8181106192905750506105d192500383612736565b84546001600160a01b031683526001948501948794506020909301920161927b565b9490936001600160401b03809481616f9c958160a0999c9b9c168a52166020890152166040870152600180861b0316606086015260c0608086015260c08501906150dd565b619312816001600160401b03165f52600960205260405f2090565b60045490919060801c6001600160401b03169061932e826168ad565b6004805467ffffffffffffffff60801b191660809290921b67ffffffffffffffff60801b169190911790558254906001600160401b03821690619382826001600160401b03165f52600560205260405f2090565b9261939e836001600160401b03165f52600660205260405f2090565b5060401c6001600160a01b031694426001600160401b03169360018201938454976193d3896001600160401b039060401c1690565b9860801c63ffffffff166004850154600881901c63ffffffff16602882901c63ffffffff169160ff1692600287019c8d546194129060ff9060081c1690565b9561941b612775565b6001600160401b0390981688526001600160a01b031660208801526001600160401b038c1660408801526001600160401b031660608701525f60808701526001600160401b038b1660a087015263ffffffff1660c086015263ffffffff1660e085015263ffffffff16610100840152619498906101208401617267565b6194a6906101408301617270565b60016101608201526194c9876001600160401b03165f52601060205260405f2090565b906194d391618435565b5f976194f0846001600160401b03165f52600a60205260405f2090565b6194f990619261565b928351619505906168ca565b955f9a5b85518c10156195d7576195cf60019161ffff8e6195c76108ca8f8f908f8f928f6195b092615d53619564615d4161117a9861954a615d208e61956c98616932565b9a8b916001600160401b03165f52600b60205260405f2090565b998a92616932565b619584619577612757565b61ffff89168152916159a0565b5f6040820152600160608201526110d9856108ca856001600160401b03165f52601160205260405f2090565b6001600160401b03165f52601260205260405f2090565b5016906175c0565b9b019a619509565b939991969297509499506196126195ff896001600160401b03165f52601360205260405f2090565b875460401c6001600160a01b031661803a565b505f5b6196308b6001600160401b03165f52600d60205260405f2090565b5481101561969957806196928c61803a61967d600195612fc78f619665906001600160401b03165f52601360205260405f2090565b946001600160401b03165f52600d60205260405f2090565b905460039190911b1c6001600160a01b031690565b5001619615565b509061972a6196cd9493926197206001899c8e9b9e8d6001600160401b03808061976b9e9f549d8e6001600160401b031690565b16931691167f741e97ee1ff887c4d882f4c49ad280ea7d61d035e4e8a471e5319515502750235f80a4018054909790619719906001600160a01b03169160401c6001600160a01b031690565b908c61b0d9565b5460081c60ff1690565b92619734846122e3565b8315806198cf575b1561988a578954617cf794506001600160401b031660028b01546001600160a01b031660038c0154918b61b7c8565b906001600160a01b038216619782575b5050505050565b6197ad617f6a6197a785969798956001600160401b03165f52600d60205260405f2090565b5461757a565b955494604086901c6001600160a01b03166197cb81617f7d8a616910565b5f5b6197e8876001600160401b03165f52600d60205260405f2090565b54811015619830578061982a61981861967d600194612fc78c6001600160401b03165f52600d60205260405f2090565b617f7d6198248461757a565b8d616932565b016197cd565b509061099a93949761098c926198636198526198809a6001600160401b031690565b955460401c6001600160401b031690565b926040519889966320a87b3960e21b6020890152602488016192b2565b5f8080808061977b565b505050806198996001926122e3565b14806198c2575b15617cf75760028601546003870154618094916001600160a01b03168761b48c565b50600386015415156198a0565b5060038a0154151561973c565b6001600160401b038060045460801c16911690811015619904575f52601060205260405f2090565b63645145db60e11b5f5260045260245ffd5b610be6916001600160a01b03169061ba1b565b6001600160401b039081165f818152601560205260409020548383169493921684101561997757610be69293505f52601660205260405f20906001600160401b03165f5260205260405f2090565b83906325b1baff60e21b5f5260045260245260445ffd5b91906001600160401b03831691825f52601060205260405f20925f5260126020526199bb60405f2061bb33565b6199c581516168ca565b915f935f945b8351861015619a4757619a3f600191619a2f619a25615d416199fe8d6001600160401b03165f52601160205260405f2090565b619a088c8b616932565b878060a01b0390511660018060a01b03165f5260205260405f2090565b615d538a8a616932565b6150ad611c43615d6c8a8a616932565b9501946199cb565b94509095619a5f6105d196546001600160401b031690565b9061b556565b6001600160a01b0381165f9081527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d602052604090205460ff16619afc576001600160a01b03165f8181527fb7db2dd08fcb62d0c9e08c51941cae53c267786a0b75803fb7960902fc8ef97d60205260408120805460ff191660011790553391905f8051602061c8878339815191528180a4600190565b505f90565b6001600160a01b0381165f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c602052604090205460ff16619afc576001600160a01b0381165f9081527fb16e88c42fd4e48df2dd6a2eabd6bc9aec654ec170056b470819f8892cc6431c60205260409020805460ff1916600117905533906001600160a01b03167fa49807205ce4d355092ef5a8a18f56e8913cf4a201fbe287825b095693c217755f8051602061c8878339815191525f80a4600190565b6001600160a01b0381165f9081527f75442b0a96088b5456bc4ed01394c96a4feec0f883c9494257d76b96ab1c9b6b602052604090205460ff16619afc576001600160a01b0381165f9081527f75442b0a96088b5456bc4ed01394c96a4feec0f883c9494257d76b96ab1c9b6b60205260409020805460ff1916600117905533906001600160a01b03167f65d7a28e3265b37a6474929f336521b332c1681b933f6cb9f3376673440d862a5f8051602061c8878339815191525f80a4600190565b6001600160a01b0381165f9081527fab71e3f32666744d246edff3f96e4bdafee2e9867098cdd118a979a7464786a8602052604090205460ff16619afc576001600160a01b0381165f9081527fab71e3f32666744d246edff3f96e4bdafee2e9867098cdd118a979a7464786a860205260409020805460ff1916600117905533906001600160a01b03167f189ab7a9244df0848122154315af71fe140f3db0fe014031783b0946b8c9d2e35f8051602061c8878339815191525f80a4600190565b6001600160a01b0381165f9081525f8051602061c947833981519152602052604090205460ff16619afc576001600160a01b0381165f9081525f8051602061c94783398151915260205260409020805460ff1916600117905533906001600160a01b03167f4c7070c6c19cc9b427b94fe5979ee0c573f8edd00d25591afe4c9510de9479ba5f8051602061c8878339815191525f80a4600190565b5f8181525f8051602061c8e7833981519152602090815260408083206001600160a01b038616845290915290205460ff16618edf575f8181525f8051602061c8e7833981519152602090815260408083206001600160a01b03861684529091529020805460ff1916600117905533916001600160a01b0316905f8051602061c8878339815191525f80a4600190565b91909182516001600160401b0381116126a957619e8f816171018454616dd5565b6020601f8211600114619ec957819061708f9394955f92619ebe5750508160011b915f199060031b1c19161790565b015190505f80617122565b601f19821690619edc845f5260205f2090565b915f5b818110619f1557509583600195969710619efd57505050811b019055565b01515f1960f88460031b161c191690555f808061716b565b9192602060018192868b015181550194019201619edf565b60066101206105d193619f67619f4a82516001600160401b031690565b855467ffffffffffffffff19166001600160401b03909116178555565b6020810151619f7f906001600160a01b0316856183ba565b60408101516001850180546001600160a01b0319166001600160a01b03909216919091179055606081015160028501556080810151600385015560a0810151600485015561a00d60058501619fe161845360c08501516001600160401b031690565b619ff86184be60e08501516001600160401b031690565b6101008301519061a008826163a3565b618655565b01519101619e6e565b95949092801561a1ba576001600160a01b038416948515613db65761a03b908261ba7e565b96871561a1ba5761a1b56001600160401b03927f29615b457f22e163cc4540327d70f35c1990a8ef0003e915ad170acb817ace3d948442169a61a08f61a089601c546001600160401b031690565b8d616fa3565b9261a17461a0a5601b546001600160401b031690565b9a61a0cf61a0b28d6168ad565b601b906001600160401b03166001600160401b0319825416179055565b61a12f8c9f61a0fc61a0df6127a3565b6001600160401b038c168152936001600160a01b03166020850152565b6001600160a01b038d1660408401528460608401528560808401528660a084015260c08301906001600160401b03169052565b6001600160401b03861660e08201525f61010082015261a14d614b57565b61012082015261a16f8c601d906001600160401b03165f5260205260405f2090565b619f2d565b604080516001600160a01b03909a168a5260208a019190915288015260608701526001600160401b03166080860152908216949091169290819060a0820190565b0390a4565b63c58d593560e01b5f5260045ffd5b801561a1ef5780821061a1da575050565b63b99e2ab760e01b5f5260045260245260445ffd5b5050565b811561a24e576001600160a01b03168061a213575080821061a1da575050565b6105d19250604051916323b872dd60e01b602084015233602484015230604484015260648301526064825261a249608483612736565b61c28f565b505050565b905f809160208151910182855af161a2696186b3565b901561a273575050565b805161a29a57506338e6074d60e11b5f9081526001600160a01b0391909116600452602490fd5b604080516303d4276160e11b81526001600160a01b0390931660048401526024830152819061565d906044830190614b6b565b5f8181525f8051602061c8e7833981519152602090815260408083206001600160a01b038616845290915290205460ff1615618edf575f8181525f8051602061c8e7833981519152602090815260408083206001600160a01b03861684529091529020805460ff1916905533916001600160a01b0316907ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b5f80a4600190565b9060018060a01b03821691825f52601960205260405f205f805260205260405f205492831561a3b9575f6105d1928592825260196020526040822082805260205281604081205561a73c565b505f925050565b6001600160a01b038181165f8181526019602090815260408083209487168352939052919091205493929190841561a424579184916105d1935f5260196020525f61a41e83604083209060018060a01b03165f5260205260405f2090565b5561a73c565b505f93505050565b91908115801561a444575b61a24e576105d19261a73c565b506001600160a01b0383161561a437565b919061a47383601d906001600160401b03165f5260205260405f2090565b805460401c6001600160a01b03161561a55e57600581018054608081901c60ff1661a49d816163a3565b61a5425761a4b69060401c6001600160401b03166121cc565b42101561a52657805460ff60801b1916600160801b1790557f0d4418cc07b1c81f56e2d1277f5d11c1b27ebac6cdacafccecd4add6742b4b0f916001600160401b039161a507908590600601619e6e565b61a52160405192839260018060a01b031696169482614b8f565b0390a3565b63337c2c0160e01b5f526001600160401b03851660045260245ffd5b63079769ad60e11b5f526001600160401b03861660045260245ffd5b63162e3fab60e21b5f526001600160401b03841660045260245ffd5b61a595906001600160401b03165f52601060205260405f2090565b60028101546001607082901c60ff1661a5ad816122e3565b03618edf5760019060681c60ff1661a5c4816122e3565b03619afc576001810154906001600160401b03604083901c16801515908161a63a575b50618edf5761a62b9161a625600261a61661a60f6121476121cc96546001600160401b031690565b9360c01c90565b9201546001600160401b031690565b90616fa3565b421061a63657600190565b5f90565b61a65291506121cc906001600160401b038516616fa3565b42115f61a5e7565b92909192831561925b578360028201938454155f1461a6b85782546001600160a01b0319166001600160a01b03821617835560019361a69a92909161a1f3565b018054908382018092116150d8575580549182018092116150d85755565b82549091506001600160a01b039081169082160361a6dd576001928561a69a9261a1f3565b6356e7ec5f60e01b5f5260045ffd5b8115801561a72b575b61a1ef575f918291829182916001600160a01b03165af161a7146186b3565b501561a71c57565b6307a4ced160e51b5f5260045ffd5b506001600160a01b0381161561a6f5565b908215801561a7ad575b61a24e576001600160a01b03168061a77457505f918291829182916001600160a01b03165af161a7146186b3565b60405163a9059cbb60e01b60208201526001600160a01b03909216602483015260448201929092526105d19161a249826064810161098c565b506001600160a01b0382161561a746565b91906001600160401b0383165f52601d60205260405f20928360018060a01b03815460401c161561a87f5761a7f561158a82618e9b565b61a8635760058101805460ff60801b1916600160811b17905554917f4a816e132712dbdfe6a363965e5bc68f8e283b999ae11afe294a3162973c38556001600160401b0361a844818616611b1b565b6040519384526001600160a01b0316948116931691806020810161a1b5565b63b48b095960e01b5f526001600160401b03821660045260245ffd5b63162e3fab60e21b5f526001600160401b03821660045260245ffd5b91909161a8a661bb7b565b6001600160a01b03811615801561a9db575b801561a9ca575b613db65761a95a9261a91b61a93d9261a8d661bb7b565b61a8de61bba6565b61a8e661bbda565b61a8ee61bb7b565b61a8f781619a65565b5061a90181619b01565b5061a90b81619bc2565b5061a91581619c83565b50619d44565b505f80546001600160a01b0319166001600160a01b0392909216919091179055565b60018060a01b03166001600160601b0360a01b6001541617600155565b61a99f61a965612757565b61138881526103e860208201526107d0604082018190526060909101526002805467ffffffffffffffff19166707d007d003e81388179055565b61a9c261a9bd61a9ad61a9ec565b309061a9b761aa15565b9061bbea565b600355565b6105d161bc5b565b506001600160a01b0382161561a8bf565b506001600160a01b0383161561a8b8565b6040519061a9fb604083612736565b600b82526a54616e676c6551756f746560a81b6020830152565b6040519061aa24604083612736565b60018252603160f81b6020830152565b93929161aa62600261aa57876001600160401b03165f52601060205260405f2090565b015463ffffffff1690565b9161aa81615cc8876001600160401b03165f52601260205260405f2090565b935f945f945f945f5b835181101561ab3c5761aabe61aaa3615d208387616932565b6108ca8d6001600160401b03165f52601160205260405f2090565b5460ff609082901c161561ab335760ff861660010361ab265761aae8611c4361aaef9261ffff1690565b80996175c0565b9760018088841c161461ab08575b506001905b0161aa8a565b61ab1f9061ab19600193999b6174fe565b9a6175c0565b969061aafd565b5061aaef600180996175c0565b5060019061ab02565b5097969594935097505060ff16155f1461ab9457505061ab6b61ffff63ffffffff61ab73939616941684616f51565b612710900490565b918215908161ab8a575b5061ab8457565b60019150565b905015155f61ab7d565b94509261ab73915061ab6b9061ffff1684616f51565b61abb661158a8261a57a565b619afc5761abd5816001600160401b03165f52601060205260405f2090565b9061abea61214783546001600160401b031690565b9061ac06816001600160401b03165f52601460205260405f2090565b906001830154918260018201541061ad37578261ac229161be0a565b6001850180546001600160c01b03164260c01b6001600160c01b0319161790559461ac61615cc8836001600160401b03165f52601260205260405f2090565b9261ac6c84516168ca565b945f975f985b86518a101561accc5761acc46001916150ad611c43615d6c8e6198248e615d538f8f615d418692615d2d615d2085615d1a61acbe966001600160401b03165f52601160205260405f2090565b92616932565b99019861ac72565b61ad2f94995061ad21907f24dc485bef04b4d790d97ac10381d8d9e66c56dd6fba9931b703ca169511778a986001600160401b0398866002969561ad1b615dc7999e546001600160401b031690565b8b61b7c8565b01546001600160401b031690565b0390a2600190565b50505050505f90565b939290919382511561aef25761ad5683516168ca565b905f935f945b815186101561aee85761ad6f8683616932565b51604081015f5b88811061aea257508151516001600160401b03166001600160401b038b166001600160401b0382160361ae7357508151602001516001600160401b03166001600160401b0388166001600160401b0382160361ae4457508151608001516001600160401b031642811061ae1b57509160408261ae0a61ae00600196615d2061ae13978b601e61be59565b617f7d8c8b616932565b510151906175c0565b95019461ad5c565b9051637bbe57e960e01b5f526001600160a01b03166004526001600160401b031660245260445ffd5b905163ad21cd6560e01b5f526001600160a01b03166004526001600160401b038088166024521660445260645ffd5b90516356fe61a360e11b5f526001600160a01b03166004526001600160401b03808b166024521660445260645ffd5b61aeaf615d208289616932565b82516001600160a01b039081169116811461aecd575060010161ad76565b630278791760e11b5f526001600160a01b031660045260245ffd5b9650505092915050565b633f6c27f960e01b5f5260045ffd5b919081101561691d5760051b81013590605e19813603018212156105af570190565b90359060be19813603018212156105af570190565b903590601e19813603018212156105af57018035906001600160401b0382116105af576020019160608202360383136105af57565b90929194935f905f966001600160401b034216925b855189101561b0915761b03a60019161ffff8b8a8a8a8a8a8a6127109561afc061afb661afb08a858561af01565b8061af23565b60a081019061af38565b905061b042575b505094615d1a61803a936195b0615d209461afea89615d53876195c79c9d616932565b61b00261aff5612757565b61ffff8c168152916159a0565b5f6040820152600160608201526110d961b02d846001600160401b03165f52601160205260405f2090565b615d2d615d20888c616932565b98019761af82565b6195c79650936195b0615d209461afea8a95615d5361b07d6040616af861b07761afb661afb061803a9f615d1a9d8f9161af01565b90616c39565b9b50509550509450509350508f8b9061afc7565b9750505050505050565b91908260409103126105af576020825161b0b4816139b7565b920151610be6816105b3565b91908260409103126105af57602082516176c0816139b7565b6020546001600160a01b031692909190831561925b575f9384926001600160a01b03168061b239575b5061b115906001600160a01b0316610ff0565b803b156105af576040516257785560e41b81526001600160401b03851660048201526001600160a01b039290921660248301525f908290604490829084905af161b225575b506001600160401b0383161580158161b219575b61b1785750505050565b61b20f575b60ff81161561b207575b60205461b19e90610ff0906001600160a01b031681565b803b156105af5760405163b99f675960e01b81526001600160401b03938416600482015293909216602484015260ff1660448301525f908290606490829084905af161b1ed575b80808061925b565b8061b1fb5f61b20193612736565b806107c0565b5f61b1e5565b50600361b187565b61012c925061b17d565b5060ff8216151561b16e565b8061b1fb5f61b23393612736565b5f61b15a565b604080516268080b60e01b81526001600160401b03871660048201529081602481855afa90815f915f9361b36e575b5061b342575b505060408051634965dbc760e11b81526001600160401b038716600482015291829060249082905afa90815f915f9361b30f575b5061b2ae575b5061b102565b158061b303575b61b2c0575b8061b2a8565b90925060ff16605081111561b2e1575061b115610ff060015b93915061b2ba565b6032101561b2f65761b115610ff0600261b2d9565b61b115610ff0600361b2d9565b5060ff8116151561b2b5565b90925061b334915060403d60401161b33b575b61b32c8183612736565b81019061b0c0565b915f61b2a2565b503d61b322565b158061b35c575b61b354575b8061b26e565b95505f61b34e565b506001600160401b038116151561b349565b90925061b393915060403d60401161b39a575b61b38b8183612736565b81019061b09b565b915f61b268565b503d61b381565b8054801561b3c8575f19019061b3b78282616c24565b8154905f199060031b1b1916905555565b634e487b7160e01b5f52603160045260245ffd5b6001810191805f528260205260405f2054928315155f1461b484575f1984018481116150d85783545f198101949085116150d8575f95858361b4379761b42a950361b43d575b50505061b3a1565b905f5260205260405f2090565b55600190565b61b46d61b4679161b45e61b45461b47b9588616c24565b90549060031b1c90565b92839187616c24565b90617076565b85905f5260205260405f2090565b555f808061b422565b505050505f90565b6001600160401b03165f81815260146020526040902080546001600160a01b0319166001600160a01b038416178155909190600181019081548581018091116150d85760029255018054918483018093116150d8579190556040519283526001600160a01b0316917fd28de7c518c312fa388e03f8d1203d8f4c75161e358ffb0827b6caa2e9ac8a3190602090a3565b6040519061b529826126ae565b81606061ffff6002548181168452818160101c166020850152818160201c16604085015260301c16910152565b939195949290861561b7bf5761b59261b58361b5c5926001600160401b03165f52600560205260405f2090565b9761b58c61b51c565b9061bfe0565b875490979061b5ac906001906001600160a01b0316616afe565b6001600160a01b03811661b73e575b505f88519161a73c565b600154602087015161b5e1915f906001600160a01b031661a73c565b8261b5ef575b505050509050565b856060604061b604969801519101519061c10f565b5f5b815181101561b7305761b64361b62d61b61f8385616932565b51516001600160a01b031690565b5f602061b63a8587616932565b5101519161c253565b604061b64f8284616932565b51015161b65f575b60010161b606565b5f5461b68d9061b677906001600160a01b0316610ff0565b5f604061b6848587616932565b5101519161a73c565b5f5461b6a1906001600160a01b0316610ff0565b9061b6af61b61f8285616932565b604061b6bb8386616932565b510151833b156105af576040516351dce2e160e11b81526001600160a01b039290921660048301526001600160401b03871660248301526044820152915f908390606490829084905af19182156113635760019261b71c575b50905061b657565b8061b1fb5f61b72a93612736565b5f61b714565b50509050805f80808061b5e7565b61b750906001600160a01b0316610ff0565b6040516308179f3560e01b81526001600160401b038816600482015290602090829060249082905afa5f918161b79e575b501561b5bb576001600160a01b0316801561b5bb5790505f61b5bb565b61b7b891925060203d602011611de057611dd18183612736565b905f61b781565b50505050509050565b9491939096959296871561ba115761b80061b7f761b833926001600160401b03165f52600560205260405f2090565b9861b58c61b51c565b885490989061b81a906001906001600160a01b0316616afe565b6001600160a01b03811661b990575b508589519161a73c565b600154602088015161b84f9186906001600160a01b031661a73c565b8261b85d5750505050509050565b866060604061b87396979901519101519061c10f565b905f5b825181101561b9805761b89c61b88f61b61f8386616932565b83602061b63a8588616932565b604061b8a88285616932565b51015161b8b8575b60010161b876565b5f5461b8dd9061b8d0906001600160a01b0316610ff0565b83604061b6848588616932565b5f5461b8f1906001600160a01b0316610ff0565b9061b8ff61b61f8286616932565b604061b90b8387616932565b510151833b156105af576040516351dce2e160e11b81526001600160a01b039290921660048301526001600160401b03881660248301526044820152915f908390606490829084905af19182156113635760019261b96c575b50905061b8b0565b8061b1fb5f61b97a93612736565b5f61b964565b5050509050805f8080808061b7bf565b61b9a2906001600160a01b0316610ff0565b6040516308179f3560e01b81526001600160401b038916600482015290602090829060249082905afa5f918161b9f0575b501561b829576001600160a01b0316801561b8295790505f61b829565b61ba0a91925060203d602011611de057611dd18183612736565b905f61b9d3565b5050505050509050565b5f828152600182016020526040902054618edf57805490600160401b8210156126a9578261ba6961ba53846001809601855584616c24565b819391549060031b91821b915f19901b19161790565b90558054925f520160205260405f2055600190565b61ba909061ffff612710931690616f51565b0490565b90813b1561bb12575f8051602061c8c783398151915280546001600160a01b0319166001600160a01b0384169081179091557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a280511561bafa576186f99161c2e7565b50503461bb0357565b63b398979f60e01b5f5260045ffd5b50634c9c8ce360e01b5f9081526001600160a01b0391909116600452602490fd5b90604051918281549182825260208201905f5260205f20925f5b81811061bb625750506105d192500383612736565b845483526001948501948794506020909301920161bb4d565b60ff5f8051602061c9678339815191525460401c161561bb9757565b631afcd79f60e31b5f5260045ffd5b61bbae61bb7b565b61bbb661bb7b565b60ff195f8051602061c90783398151915254165f8051602061c90783398151915255565b61bbe261bb7b565b61876e61bb7b565b919091602081519101209160208151910120906040519160208301937f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f85526040840152606083015246608083015260018060a01b031660a082015260a0815261bc5560c082612736565b51902090565b6127106040805161bc6b8161271b565b62093a8081525f60208201520152601c80546affffffffffffffffffffff19166a2710000000000000093a80179055565b61bca89093929361c31c565b926040519061bcb682612700565b7f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c282527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed602083015260405161bd0b81612700565b7f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b81527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa60208201526040519261bd6184612700565b835260208301526040519161bd77606084612736565b6002835260405f5b81811061bdf357505061bdb2610be6959661bd9861c3e7565b9561bda286616910565b5261bdac85616910565b5061c536565b61bdbb84616922565b5261bdc583616922565b5061bdcf84616910565b5261bdd983616910565b5061bde383616922565b5261bded82616922565b5061c5f9565b60209061bdfe61c304565b8282880101520161bd7f565b906001820180549082821061be42578282039182116150d857556003820180549182018092116150d85755546001600160a01b031690565b509063039ff3b160e41b5f5260045260245260445ffd5b91906154d561bf1883516001600160401b03815116906001600160401b03602082015116906040810151906001600160401b0360808160608401511692015116916040519360208501957f23db36a658fd8dd61c928c7cbec6a1840e339e363efd875cdaf83a1d60c84a43875260408601526060850152608084015260a083015260c082015260c0815261beee60e082612736565b519020604051928391602083019586909160429261190160f01b8352600283015260228201520190565b5190209161bf316115e28483905f5260205260405f2090565b61bfc057604061bf4560208401518561c45c565b9201805190926001600160a01b03918216911681900361bfa557506116258361bf7592905f5260205260405f2090565b516001600160a01b03167f89a9fcf52fcdc48f0e669fb3b7125291da850132592f5dd580ffb58166c8e9e85f80a3565b6308b1c54760e11b5f526001600160a01b031660045260245ffd5b60408201516308d1827160e01b5f526001600160a01b031660045260245ffd5b91909161bfeb6172d3565b9261271061bffe61ffff83511684616f51565b04845261271061c03161ffff8060408461c01e8360208901511689616f51565b049560208a019687520151161684616f51565b049060408501918252845183039283116150d85761c05c9261c05491519061751a565b90519061751a565b6060830152565b6040519061c072602083612736565b5f80835282815b82811061c08557505050565b60209060405161c0948161271b565b5f81525f838201525f60408201528282850101520161c079565b9061c0b882616896565b61c0c56040519182612736565b828152809261c0d6601f1991616896565b01905f5b82811061c0e657505050565b60209060405161c0f58161271b565b5f81525f838201525f60408201528282850101520161c0da565b919493801561c2455761c122865161c0ae565b955f915f955f5b835181101561c23b578961c143611c43615d6c8486616932565b61c14d865161750c565b830361c1bb5750508061c165615d2060019387616932565b61c16f878a61751a565b61c1798b8a61751a565b9061c19461c185612794565b6001600160a01b039094168452565b6020830152604082015261c1a8828d616932565b5261c1b3818c616932565b505b0161c129565b61c22f88849b98614d5f8661c2359661c1f98f60019a61c1f38f9a8f908061c1ed83611c3e611c3e94615d2099616f51565b9b616f51565b99616932565b61c21361c204612794565b6001600160a01b039092168252565b85602082015287604082015261c2298383616932565b52616932565b966175c0565b9761c1b5565b5050505050505050565b505050509050610be661c063565b90821561a24e576001600160a01b039182165f908152601960209081526040808320939094168252919091522080549182018092116150d85755565b905f602091828151910182855af115616d96575f513d61c2de57506001600160a01b0381163b155b61c2be5750565b635274afe760e01b5f9081526001600160a01b0391909116600452602490fd5b6001141561c2b7565b5f80610be693602081519101845af461c2fe6186b3565b9161c472565b6040519061c31182612700565b5f6020838281520152565b61c3439061c32861c304565b50602081519101205f8051602061c8a7833981519152900690565b905f905f5b610100831061c3605763db4a5cd960e01b5f5260045ffd5b616f6e575f8051602061c8a78339815191526003818581818009090861c3858161c4d0565b905f8051602061c8a78339815191528280091461c3ba575060015f8051602061c8a7833981519152815f95089201919261c348565b9092915061c3c66127b3565b918252602082015290565b6040519061c3e0602083612736565b6020368337565b6040519061c3f6606083612736565b6002825281601f1961c4086002616896565b01906040905f5b83811061c41c5750505050565b602090835161c42a81612700565b845161c4368682612736565b853682378152845161c4488682612736565b85368237838201528282850101520161c40f565b610be69161c4699161c74e565b9092919261c788565b9061c496575080511561c48757805190602001fd5b63d6bda27560e01b5f5260045ffd5b8151158061c4c7575b61c4a7575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561c49f565b5f8051602061c8a783398151915290818060019206905b61c4f15750905090565b60018084161461c51d575b5f8051602061c8a7833981519152919260011c91818392099192919061c4e7565b5f8051602061c8a783398151915281819309915061c4fc565b61c53e61c304565b5080519081158061c5a1575b61c59c5760205f8051602061c8a7833981519152910151065f8051602061c8a7833981519152035f8051602061c8a783398151915281116150d8576040519161c59283612700565b8252602082015290565b905090565b5060208101511561c54a565b1561c5b457565b60405162461bcd60e51b815260206004820152601e60248201527f424e3235343a2070616972696e67206c656e677468206d69736d6174636800006044820152606490fd5b61c606815183511461c5ad565b805161c61181616f3b565b9261c61b846168ca565b925f5b83811061c66857505050506020809261c64e9261c63961c3d1565b94859260051b910160086107cf195a01fa1590565b61c659575160011490565b634df45e2f60e01b5f5260045ffd5b8061c67560019284616932565b515161c683617ff883616f3b565b52602061c6908285616932565b51015161c6a7617ff861c6a284616f3b565b61757a565b5261c6bd61c6b58286616932565b515160200190565b5161c6d2617ff861c6cd84616f3b565b617588565b5261c6dd8185616932565b51515161c6f4617ff861c6ef84616f3b565b617596565b5261c70d602061c7048387616932565b51015160200190565b5161c722617ff861c71d84616f3b565b6175a4565b52602061c72f8286616932565b5101515161c747617ff861c74284616f3b565b6175b2565b520161c61e565b815191906041830361c77e5761c7779250602082015190606060408401519301515f1a9061c804565b9192909190565b50505f9160029190565b61c791816163a3565b8061c79a575050565b61c7a3816163a3565b6001810361c7ba5763f645eedf60e01b5f5260045ffd5b61c7c3816163a3565b6002810361c7de575063fce698f760e01b5f5260045260245ffd5b8061c7ea6003926163a3565b1461c7f25750565b6335e2f38360e21b5f5260045260245ffd5b91907f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0841161c87b579160209360809260ff5f9560405194855216868401526040830152606082015282805260015afa15611363575f516001600160a01b0381161561c87157905f905f90565b505f906001905f90565b5050505f916003919056fe2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800cd5ed15c6e187e77e9aee88184c21f4f2182ab5827cb3b7e07fbedcd63f033009b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f006f24b3acd9144fe986c6fc468ff993840c1793f585f39e15b5d20728bd2dda41f0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00a164736f6c634300081a000a
    /// ```
    #[rustfmt::skip]
    #[allow(clippy::all)]
    pub static DEPLOYED_BYTECODE: alloy_sol_types::private::Bytes = alloy_sol_types::private::Bytes::from_static(
        b"`\x80`@R`\x046\x10\x15a\0\x1AW[6\x15a\0\x18W_\x80\xFD[\0[_5`\xE0\x1C\x80c\x01\xFF\xC9\xA7\x14a\x05YW\x80c\x06\x07\x9D\xC5\x14a\x05TW\x80c\x06#u&\x14a\x05OW\x80c\x07\xE6\x01)\x14a\x05JW\x80c\n\xFD78\x14a\x05EW\x80c\x0F3\xE8\xE1\x14a\x05@W\x80c\x10\x8A}c\x14a\x05;W\x80c\x11\x0F\x82\x9B\x14a\x056W\x80c\x18\xC6\x80\x17\x14a\x051W\x80c \x81)V\x14a\x05,W\x80c#\xD7\xB3\xE1\x14a\x05'W\x80c$\x8A\x9C\xA3\x14a\x05\"W\x80c+\x9D\xA7\x1A\x14a\x05\x1DW\x80c-\x07\xE6U\x14a\x05\x18W\x80c-\xAE\x18\x85\x14a\x05\x13W\x80c.\xC2\xBD\x03\x14a\x05\x0EW\x80c//\xF1]\x14a\x05\tW\x80c/F'\x9F\x14a\x05\x04W\x80c0\xAE(\x9C\x14a\x04\xFFW\x80c1\xD7\xA2b\x14a\x04\xFAW\x80c4\x13\xE8\xEE\x14a\x04\xF5W\x80c6V\x8A\xBE\x14a\x04\xF0W\x80c7%\0\xAB\x14a\x04\xEBW\x80c=\xC0\xD5\xFE\x14a\x04\xE6W\x80c?K\xA8:\x14a\x04\xE1W\x80cD\x9B\xB8I\x14a\x04\xDCW\x80cO\x1E\xF2\x86\x14a\x04\xD7W\x80cR\xD1\x90-\x14a\x04\xD2W\x80cV:\x89\xF9\x14a\x04\xCDW\x80c[q\xC94\x14a\x04\xC8W\x80c\\\x97Z\xBB\x14a\x04\xC3W\x80c_5\x99$\x14a\x04\xBEW\x80c_\x9BM\xFA\x14a\x04\xB9W\x80caH#\xB2\x14a\x04\xB4W\x80cdF%\x95\x14a\x04\xAFW\x80cgx\xAF\xBC\x14a\x04\xAAW\x80cjd\xA2~\x14a\x04\xA5W\x80ck\xDAB\xF3\x14a\x04\xA0W\x80cm\x8B\x88\xC3\x14a\x04\x9BW\x80cu\xB28\xFC\x14a\x04\x96W\x80cw8\x0Ct\x14a\x04\x91W\x80cxD\x867\x14a\x04\x8CW\x80cx\x86z\x16\x14a\x04\x87W\x80c\x80\xAC\x82(\x14a\x04\x82W\x80c\x81]j&\x14a\x04}W\x80c\x84%$\xBB\x14a\x04xW\x80c\x84V\xCBY\x14a\x04sW\x80c\x8AL\xF7c\x14a\x04nW\x80c\x8C\x9A(\x1D\x14a\x04iW\x80c\x8D?e\xBE\x14a\x04dW\x80c\x91\xD1HT\x14a\x04_W\x80c\x93\xF3\xDD\xAF\x14a\x04ZW\x80c\x97\x0E\x08\xFE\x14a\x04UW\x80c\xA2\x17\xFD\xDF\x14a\x04PW\x80c\xA3{\x92\x86\x14a\x04KW\x80c\xA5\x95\xB2\x1E\x14a\x04FW\x80c\xA5\xBF\xBA\xE4\x14a\x04AW\x80c\xA6r\xBC\n\x14a\x04<W\x80c\xAA\xC7Ak\x14a\x047W\x80c\xAA\xCD\xBA\x9F\x14a\x042W\x80c\xAD<\xB1\xCC\x14a\x04-W\x80c\xB0UD\x9B\x14a\x04(W\x80c\xB7im\xBB\x14a\x04#W\x80c\xB8\x17A\xAC\x14a\x04\x1EW\x80c\xBB \x7F\x1F\x14a\x04\x19W\x80c\xC0\xC5;\x8B\x14a\x04\x14W\x80c\xC3%\xAE\x12\x14a\x04\x0FW\x80c\xC6\x02\xD4\xFA\x14a\x04\nW\x80c\xCC=\x19\xC3\x14a\x04\x05W\x80c\xCF8\x06\xC6\x14a\x04\0W\x80c\xD3\x90\xBB\xBB\x14a\x03\xFBW\x80c\xD5Gt\x1F\x14a\x03\xF6W\x80c\xDA#-\xED\x14a\x03\xF1W\x80c\xDF\xE6*\xBA\x14a\x03\xECW\x80c\xE58\xDAf\x14a\x03\xE7W\x80c\xE6:\xB1\xE9\x14a\x03\xE2W\x80c\xE7!F\xA9\x14a\x03\xDDW\x80c\xEB\x8C;\xCD\x14a\x03\xD8W\x80c\xEC\x9F\x0F\xDD\x14a\x03\xD3W\x80c\xEF\x1BB\xA2\x14a\x03\xCEW\x80c\xEF\\\xFB\x8C\x14a\x03\xC9W\x80c\xF0A\x1A\xF3\x14a\x03\xC4W\x80c\xF0\xF4B`\x14a\x03\xBFWc\xF7,\r\x8B\x03a\0\x0EWag6V[af\xEBV[afTV[ae\xCDV[adpV[ab\xE5V[ab\x0EV[aaaV[aa'V[a`\x96V[a_}V[a^\xB1V[a^}V[a^WV[a[\x88V[aX\x1AV[aW\xF4V[aS4V[aQ\xACV[aQ*V[aP\x0FV[aO9V[aK\xE7V[aK\xA0V[aF]V[aF\x1BV[aD\xC3V[aA\xC8V[aA{V[a@\xDCV[a@\xC2V[a?\x9EV[a>\xC3V[a>;V[a=\xFFV[a=\xC5V[a=\x0CV[a<\x9BV[a;\xC4V[a;sV[a;\x14V[a9\xC1V[a7\xD7V[a7=V[a7\x03V[a5kV[a4\x96V[a4OV[a1\xF5V[a1\xACV[a/*V[a-\xE8V[a,\x9DV[a,oV[a+.V[a*JV[a)\x84V[a(<V[a%\xEFV[a%qV[a#\xDDV[a\"EV[a!\xFDV[a\x1EiV[a\x1E\x19V[a\x1A\xC6V[a\x1AuV[a\x1A<V[a\x19\xECV[a\x19\x9FV[a\x14\xB4V[a\x0E\xC2V[a\x0E\x90V[a\x0E&V[a\r\xDFV[a\r]V[a\x0C+V[a\n\xE5V[a\t\xC5V[a\x08\x1CV[a\x07\xF3V[a\x07\xCAV[a\x06aV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045c\xFF\xFF\xFF\xFF`\xE0\x1B\x81\x16\x80\x91\x03a\x05\xAFW` \x90cye\xDB\x0B`\xE0\x1B\x81\x14\x90\x81\x15a\x05\x9EW[P`@Q\x90\x15\x15\x81R\xF3[c\x01\xFF\xC9\xA7`\xE0\x1B\x14\x90P_a\x05\x93V[_\x80\xFD[`\x01`\x01`@\x1B\x03\x81\x16\x03a\x05\xAFWV[`\x045\x90a\x05\xD1\x82a\x05\xB3V[V[`\xA45\x90a\x05\xD1\x82a\x05\xB3V[`\x845\x90a\x05\xD1\x82a\x05\xB3V[5\x90a\x05\xD1\x82a\x05\xB3V[\x91\x81`\x1F\x84\x01\x12\x15a\x05\xAFW\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFW` \x83\x81\x86\x01\x95\x01\x01\x11a\x05\xAFWV[\x90`@`\x03\x19\x83\x01\x12a\x05\xAFW`\x045a\x06>\x81a\x05\xB3V[\x91`$5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFWa\x06]\x91`\x04\x01a\x05\xF8V[\x90\x91V[4a\x05\xAFWa\x06o6a\x06%V[3_\x90\x81R_\x80Q` a\xC9G\x839\x81Q\x91R` R`@\x90 T`\xFF\x16\x15a\x07\xA0W\x90a\x06\x9E\x916\x91a'\xEBV[a\x06\xB9\x82`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[\x80T`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x15a\x07\x84W`\x05\x01\x80T`\x80\x1C`\xFF\x16a\x06\xE0\x81ac\xA3V[`\x02\x81\x14a\x07hW\x80a\x06\xF4`\x03\x92ac\xA3V[\x14a\x07IW\x80T`\xFF`\x80\x1B\x19\x16`\x03`\x80\x1B\x17\x90U\x7F\xE8\r\x1A\x18:\xF3\t\x16\xF7\x9B\x15\xA6\xC8^\x82G\r\x0B\x88\x06]\xFD\xD2P]\x10j\xDF\x0E\x8Bw\x96`@Q\x80a\x07D`\x01`\x01`@\x1B\x033\x96\x16\x94\x82aK\x8FV[\x03\x90\xA3\0[c\x07p\\\xCD`\xE4\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`$_\xFD[_\xFD[cS*\xF3i`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[c\x16.?\xAB`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`$_\xFD[`\x01`\x01`@\x1B\x03\x83c\x03\x93\x97\x9D`\xE3\x1B_R\x16`\x04R3`$R`D_\xFD[_\x91\x03\x12a\x05\xAFWV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `\x01`\x01`@\x1B\x03`\x04T`\x80\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `\x01`\x01`@\x1B\x03`\x04T`@\x1C\x16`@Q\x90\x81R\xF3[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x089\x81a\x05\xB3V[a\x08B\x81a\x86|V[`\x01`\x01`@\x1B\x03a\x08\x8Aa\x08}a\x08k\x85`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[3_\x90\x81R` \x91\x90\x91R`@\x90 \x90V[T`\x01`\x01`@\x1B\x03\x16\x90V[\x16\x15a\t\xA5W`\x01\x01\x80Ta\t8\x91\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a\tiW[P_a\x08\xDF3a\x08\xCA\x86`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[Ua\t\x043a\x08\xFF\x85`\x01`\x01`@\x1B\x03\x16_R`\x08` R`@_ \x90V[a\x86\xFCV[Pa\t\x18a\t\x13\x82T`\xE0\x1C\x90V[ag\x97V[\x81T`\x01`\x01`\xE0\x1B\x03\x16`\xE0\x91\x90\x91\x1B`\x01`\x01`\xE0\x1B\x03\x19\x16\x17\x90UV[`\x01`\x01`@\x1B\x033\x91\x16\x7F\x88\xE4n\x95\xBC\xDF\x10 \xC0\xCA\xF9\xF3\xDD_\xDEi\xC4\x1D!Q\xDB\xBC\xA0\xA7|\x03\xC4\xE2\x8BM>\xC1_\x80\xA3\0[`@Qc\n\x8D\"\xBB`\xE1\x1B` \x82\x01R3`$\x82\x01Ra\t\x9F\x91a\t\x9A\x82`D\x81\x01[\x03`\x1F\x19\x81\x01\x84R\x83a'6V[a\x86\xE2V[_a\x08\xA9V[c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R3`$R`D_\xFD[4a\x05\xAFW`\x01`\x01`@\x1B\x03a\t\xDB6a\x06%V[\x92\x90\x91\x16\x90\x81_R`\x07` Ra\n\x04`@_ 3`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[`\x01`\x01`@\x1B\x03\x81T\x16\x15a\nhW\x7F-\x0E\x8Cu\xCC\xFC`dc\xBD_uV\xCC\xF3X\xB1\xC4\t\xEC`Y\xCE\xE6\xE5\x195\xA2\x9B\xD0\xFD\xC1\x91a\nMa\n_\x92`\x01`\x01`@\x1B\x03B\x16\x90ag\xA9V[`@Q\x94` \x86R` \x86\x01\x91ag\xD1V[\x92\x803\x94\x03\x90\xA3\0[\x82c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x04R3`$R`D_\xFD[\x91\x81`\x1F\x84\x01\x12\x15a\x05\xAFW\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFW` \x80\x85\x01\x94\x84`\x05\x1B\x01\x01\x11a\x05\xAFWV[`\x01`\x01`\xA0\x1B\x03\x81\x16\x03a\x05\xAFWV[`\xC45\x90a\x05\xD1\x82a\n\xAFV[`\xA45\x90a\x05\xD1\x82a\n\xAFV[5\x90a\x05\xD1\x82a\n\xAFV[a\x01\x006`\x03\x19\x01\x12a\x05\xAFWa\n\xFAa\x05\xC4V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x0B\x19\x906\x90`\x04\x01a\n\x7FV[\x91`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x0B9\x906\x90`\x04\x01a\n\x7FV[\x92\x90\x93`d5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x0B[\x906\x90`\x04\x01a\x05\xF8V[\x94\x90\x95`\x845\x95`\x01`\x01`@\x1B\x03\x87\x11a\x05\xAFWa\x0B\xBD\x97a\x0B\x85a\x0B\xA3\x986\x90`\x04\x01a\n\x7FV[\x94\x90\x93a\x0B\x90a\x05\xD3V[\x96a\x0B\x99a\n\xC0V[\x98`\xE45\x9Aah\x02V[`@Q`\x01`\x01`@\x1B\x03\x90\x91\x16\x81R\x90\x81\x90` \x82\x01\x90V[\x03\x90\xF3[`@\x90`\x03\x19\x01\x12a\x05\xAFW`\x045a\x0B\xD9\x81a\x05\xB3V[\x90`$5a\x0B\xE6\x81a\x05\xB3V[\x90V[` `@\x81\x83\x01\x92\x82\x81R\x84Q\x80\x94R\x01\x92\x01\x90_[\x81\x81\x10a\x0C\x0CWPPP\x90V[\x82Q`\x01`\x01`@\x1B\x03\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01a\x0B\xFFV[4a\x05\xAFWa\x0C96a\x0B\xC1V[`\x01`\x01`@\x1B\x03\x16_\x82[\x82`\x01`\x01`@\x1B\x03\x82\x16\x10a\r\x0CWP`\x01`\x01`@\x1B\x03\x16\x91a\x0Ci\x83ah\xCAV[\x92_\x91[\x83`\x01`\x01`@\x1B\x03\x82\x16\x10\x80a\x0C\xFAW[\x15a\x0C\xECW\x80a\x0C\xABa\x0C\xA6a\x0C\xB4\x93`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[a\x8E\x9BV[a\x0C\xB9Wah\xADV[a\x0CmV[a\x0C\xE7\x81a\x0C\xD9`\x01`\x01`@\x1B\x03a\x0C\xD1\x88ah\xADV[\x97\x16\x89ai2V[\x90`\x01`\x01`@\x1B\x03\x16\x90RV[ah\xADV[`@Q\x80a\x0B\xBD\x87\x82a\x0B\xE9V[P\x81`\x01`\x01`@\x1B\x03\x84\x16\x10a\x0C\x7FV[a\r*a\x0C\xA6\x82`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[a\r@W[`\x01\x01`\x01`\x01`@\x1B\x03\x16a\x0CEV[\x90`\x01a\rT`\x01`\x01`@\x1B\x03\x92ah\xADV[\x92\x91PPa\r/V[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a\rz\x81a\x05\xB3V[`\xFF`\x02a\r\x87\x83a\x86|V[\x01T`\x10\x1C\x16\x15a\r\xC3W`\x01`\x01`@\x1B\x033\x91\x16\x7F\xD3\x9F\xF7Z\x15\xC3\x1A'(\x91\xC5.B\x99Z\xCF\xA2tY\xBA\x1C\x12#\x9C\xBA\xC2<\xDBv\xF50\x84_\x80\xA3\0[`\x01`\x01`@\x1B\x03\x90c!\x0E\xB4\xED`\xE1\x1B_R\x16`\x04R`$_\xFD[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a\r\xFC\x81a\n\xAFV[a\x0E\x04a\x8E\xE5V[`\x1F\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\0[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x0EC\x81a\x05\xB3V[`$5\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFW6`#\x83\x01\x12\x15a\x05\xAFW\x81`\x04\x015\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFW6`$``\x84\x02\x85\x01\x01\x11a\x05\xAFW`$a\0\x18\x93\x01\x90aiFV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW` a\x0E\xAE`\x045amiV[`@Q\x90\x81R\xF3[a\xFF\xFF\x81\x16\x03a\x05\xAFWV[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x0E\xDF\x81a\x05\xB3V[`$5a\x0E\xEB\x81a\x0E\xB6V[a\x0E\xF3a\x87\x0FV[a\x0E\xFBa\x876V[a\x0F\x04\x82a\x98\xDCV[`\x02\x81\x01\x90\x81T`\x01a\x0F\x1B\x82`\xFF\x90`p\x1C\x16\x90V[a\x0F$\x81a\"\xE3V[\x03a\x14\x98W`\x01``\x82\x90\x1C`\xFF\x16a\x0F<\x81a\"\xC7V[\x03a\x14=Wc\xFF\xFF\xFF\xFF`@\x82\x90\x1C\x16\x80\x15\x15\x91\x82a\x14kW[PPa\x14=WT`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03a\x0F\x8Fa\x08}a\x08k\x84`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x16\x15a\x14LWa\x0F\xC1a\x0F\xB73a\x08\xCA\x87`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[T`\x90\x1C`\xFF\x16\x90V[a\x14=Wa\x0F\xE0\x90`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[_Ta\x0F\xFC\x90`\x01`\x01`\xA0\x1B\x03\x16[`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90`@Qc\xD7u\xCBa`\xE0\x1B\x81R` \x81`\x04\x81\x86Z\xFA\x80\x15a\x13cW`\x01\x91_\x91a\x14\x1EW[P\x91\x01\x80T\x90\x92`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x91\x82a\x13\x87W[`@Qc\xF4i\x13\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x82\x90R` \x81`D\x81\x86Z\xFA\x90\x81\x15a\x13cW_\x91a\x13hW[P\x15a\x12\xE6WPP`\x01`\x01`\xA0\x1B\x03\x16\x80a\x12VW[Pa\x11\xAAa\x11\xF4\x92a\x11[a\x10\x97a'WV[a\xFF\xFF\x87\x16\x81RB`\x01`\x01`@\x1B\x03\x16` \x82\x01R_`@\x82\x01R`\x01``\x82\x01Ra\x10\xD93a\x08\xCA\x8A`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x81Q\x81Ta\xFF\xFF\x19\x16a\xFF\xFF\x91\x90\x91\x16\x17\x81U\x90``\x90` \x81\x01Q\x83T`@\x83\x01Qq\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\x19\x90\x91\x16`\x10\x92\x90\x92\x1Bi\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\0\0\x16\x91\x90\x91\x17`P\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`P\x1B\x16\x17\x83U\x01Q\x81T`\xFF`\x90\x1B\x19\x16\x90\x15\x15`\x90\x1B`\xFF`\x90\x1B\x16\x17\x90UV[a\x11\x7F3a\x11z\x88`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[a\x99\x16V[Pa\x11\x96a\x11\x91\x82Tc\xFF\xFF\xFF\xFF\x16\x90V[am>V[c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90UV[`@Qa\xFF\xFF\x84\x16\x81R3\x90`\x01`\x01`@\x1B\x03\x86\x16\x90\x7F$W\x91\x87\x96\x07\x84@\x06\x83\x85\xE7>B%9\xC8O/\x90E\xDDD.\x12=B\x84%\x8A\xE2J\x90` \x90\xA3T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x12\x0BW[a\0\x18a\x87nV[`@QcMQ5I`\xE1\x1B` \x82\x01R`\x01`\x01`@\x1B\x03\x90\x93\x16`$\x84\x01R3`D\x84\x01Ra\xFF\xFF\x90\x91\x16`d\x83\x01Ra\x12N\x91\x90a\t\x9A\x82`\x84\x81\x01a\t\x8CV[_\x80\x80a\x12\x03V[`@Qc\x16\x8EH]`\xE3\x1B\x81R`\x01`\x01`@\x1B\x03\x86\x16`\x04\x82\x01R3`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xFA_\x91\x81a\x12\xB5W[P\x15a\x10\x84W\x15a\x12\xA7W_a\x10\x84V[b\x82\xB4)`\xE8\x1B_R`\x04_\xFD[a\x12\xD8\x91\x92P` =` \x11a\x12\xDFW[a\x12\xD0\x81\x83a'6V[\x81\x01\x90am\xC0V[\x90_a\x12\x96V[P=a\x12\xC6V[`@Qc\x1C\x9D\x11\xBD`\xE3\x1B\x81R3`\x04\x82\x01R\x91` \x90\x83\x90`$\x90\x82\x90Z\xFA\x90\x81\x15a\x13cWa\x07e\x92_\x92a\x132W[Pc\x93mBm`\xE0\x1B_R3`\x04R`$R`DR`d\x90V[a\x13U\x91\x92P` =` \x11a\x13\\W[a\x13M\x81\x83a'6V[\x81\x01\x90am\x87V[\x90\x83a\x13\x18V[P=a\x13CV[am\x96V[a\x13\x81\x91P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[_a\x10mV[`\x04`@a\x13\x9D`\x01`\x01`\xA0\x1B\x03\x86\x16a\x0F\xF0V[\x81Qc*nsa`\xE1\x1B\x81R\x92\x83\x91\x82\x90Z\xFA\x90\x81_\x91_\x93a\x13\xEBW[Pa\x13\xC8W[PPa\x10<V[\x15\x80a\x13\xE2W[a\x13\xDAW[\x80a\x13\xC1V[\x90P_a\x13\xD4V[P\x80\x15\x15a\x13\xCFV[\x90\x92Pa\x14\x10\x91P`@=`@\x11a\x14\x17W[a\x14\x08\x81\x83a'6V[\x81\x01\x90am\xA1V[\x91_a\x13\xBBV[P=a\x13\xFEV[a\x147\x91P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[_a\x10#V[c\xBA\xF3\xF0\xF7`\xE0\x1B_R`\x04_\xFD[c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x16`\x04R3`$R`D_\xFD[c\xFF\xFF\xFF\xFF\x91\x92Pa\x14\x83a\x14\x8D\x91c\xFF\xFF\xFF\xFF\x16\x90V[\x92c\xFF\xFF\xFF\xFF\x16\x90V[\x91\x16\x10\x15_\x80a\x0FVV[c\t\x8B\xFC[`\xE3\x1B_R`\x01`\x01`@\x1B\x03\x85\x16`\x04R`$_\xFD[4a\x05\xAFW``6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x14\xD1\x81a\x05\xB3V[`$5\x90a\x14\xDE\x82a\x05\xB3V[`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x14\xFD\x906\x90`\x04\x01a\x05\xF8V[\x90a\x15\x06a\x87\x0FV[a\x15\x0Ea\x876V[a\x15\x17\x83a\x98\xDCV[\x90a\x15\"\x85\x85a\x99)V[\x94`\x01a\x15Pa\x159\x85T`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[\x01\x80T\x90\x92\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a\x18\xE1W[Pa\x15\x8Ea\x15\x8Aa\x0F\xB7a\x08k\x89`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x15\x90V[a\x18\xC1W`\x03\x87\x01\x94a\x15\xA2\x86T`\xFF\x16\x90V[a\x18\x9FWa\x15\xE9a\x15\xE23a\x08\xCA\x86a\x15\xCC\x8C`\x01`\x01`@\x1B\x03\x16_R`\x17` R`@_ \x90V[\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[T`\xFF\x16\x90V[a\x18yW\x91a\x16\xC6\x95\x93\x91`\x01`\x01`@\x1B\x03\x95\x93a\x162a\x16%\x8Aa\x08\xCA\x86a\x15\xCC3\x93`\x01`\x01`@\x1B\x03\x16_R`\x17` R`@_ \x90V[\x80T`\xFF\x19\x16`\x01\x17\x90UV[`\x01\x8A\x01\x92a\x16aa\x16Ka\x11\x91\x86Tc\xFF\xFF\xFF\xFF\x16\x90V[\x85Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x85UV[\x81\x81\x8C\x85\x8Da\x16v\x8AT`\x01\x80`\xA0\x1B\x03\x16\x90V[\x92`\x01`\x01`\xA0\x1B\x03\x84\x16a\x18\x1FW[P\x91PP\x7F\x8A\x04\xF9\x9F\xE22\x84\xE8t\xE8\xDD\x01sE$\x82y\xCCYp\x16\x95\xE7;\xCD\xBE\xB6$\x1B\xCD*\xC6\x92P\x8A\x91P\x16\x98\x89\x92\x16\x99\x8A\x93`@Q\x91\x82\x913\x97\x83ag\xF1V[\x03\x90\xA4\x90T`\x01\x91\x90a\x16\xE1\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x80a\x17\x96W[Pc\xFF\xFF\xFF\xFFa\x16\xFC\x81\x92Tc\xFF\xFF\xFF\xFF\x16\x90V[\x92\x16\x91\x16\x10\x15a\x17\x0EWa\0\x18a\x87nV[`\x02\x93a\x17V\x93a\x17'\x86\x94`\x01`\xFF\x19\x82T\x16\x17\x90UV[\x7F`\xA7d\x9Fn\x93\xE7\xA3\xCE\x1D\xC9r\x9C \xE3\xD9]\xCE(\xC6\xA6\xBD\x95|\xDE\t\xD8\xA1\xCB7\xC1\x9F_\x80\xA3\x01T`h\x1C`\xFF\x16\x90V[a\x17_\x81a\"\xE3V[\x14\x80a\x17\x89W[a\x17tW[\x80\x80\x80\x80a\x12\x03V[`\x02a\x17\x82\x92\x01T\x90a\x99\x8EV[_\x80a\x17kV[P`\x02\x82\x01T\x15\x15a\x17fV[\x88T`@Qc\x13\x11\x0F\x81`\xE2\x1B\x81R`\x01`\x01`@\x1B\x03\x8A\x16`\x04\x82\x01R`\xFF\x90\x91\x16`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90`\x01`\x01`\xA0\x1B\x03\x16Z\xFA_\x91\x81a\x17\xEEW[P\x15a\x16\xE7W\x91Pc\xFF\xFF\xFF\xFFa\x16\xE7V[a\x18\x11\x91\x92P` =` \x11a\x18\x18W[a\x18\t\x81\x83a'6V[\x81\x01\x90an\xF9V[\x90_a\x17\xDCV[P=a\x17\xFFV[Ta\x18n\x95a\t\x9A\x93a\t\x8C\x92`\xFF\x16\x93a\x18O\x88a\x15\xCC\x83`\x01`\x01`@\x1B\x03\x16_R`\x18` R`@_ \x90V[\x90`@Q\x98\x89\x96c\xC4\x0C\x80\xD1`\xE0\x1B` \x89\x01R3\x92`$\x89\x01an\rV[\x81\x81_\x85\x8D\x8Fa\x16\x86V[c[\xF3\xFEw`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x80\x88\x16`\x04R\x83\x16`$R3`DR`d_\xFD[c\nUQ/`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x80\x88\x16`\x04R\x83\x16`$R`D_\xFD[cx4\x82\xE9`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x86\x16`\x04R3`$R`D_\xFD[a\x18\xF3\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[a\x19:` a\x19\x03\x8AT`\xFF\x16\x90V[`@Qc\x0C\xF6\xAD\xD9`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x8B\x16`\x04\x82\x01R`\xFF\x82\x16`$\x82\x01R\x90\x93\x90\x92\x83\x91\x90\x82\x90\x81\x90`D\x82\x01\x90V[\x03\x91Z\xFA_\x91\x81a\x19~W[Pa\x19RW[Pa\x15eV[a\x19\\W\x80a\x19LV[c\x1D\xC5\x937`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x87\x16`\x04R`\xFF\x16`$R`D_\xFD[a\x19\x98\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_a\x19FV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW`\x1FT`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R` \x90\xF3[`@\x90`\x03\x19\x01\x12a\x05\xAFW`\x045a\x19\xDF\x81a\x05\xB3V[\x90`$5a\x0B\xE6\x81a\n\xAFV[4a\x05\xAFW` a\x1A2`\x01`\x01`@\x1B\x03a\x1A\x076a\x19\xC7V[\x91\x16_\x90\x81R`\x13\x84R`@\x80\x82 `\x01`\x01`\xA0\x1B\x03\x90\x93\x16\x82R`\x01\x90\x92\x01` R T\x15\x15\x90V[`@Q\x90\x15\x15\x81R\xF3[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFWa\0\x18`$5`\x045a\x1A_\x82a\n\xAFV[a\x1Apa\x1Ak\x82amiV[a\x902V[a\x9D\xDFV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a\x1A\x9A\x81a\x05\xB3V[\x16_R`\x10` R` `\xFF`\x02`@_ \x01T`p\x1C\x16a\x1A\xBB\x81a\"\xE3V[`\x01`@Q\x91\x14\x81R\xF3[4a\x05\xAFW`\x806`\x03\x19\x01\x12a\x05\xAFW`\x045a\x1A\xE3\x81a\x05\xB3V[`$5\x90a\x1A\xF0\x82a\n\xAFV[`D5\x91`d5\x91a\x1B\x01\x81a\x98\xDCV[T\x92a\x1B+a\x0F\xF0a\x1B\x1B`\x01`\x01`@\x1B\x03\x87\x16a\x159V[\x95`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[3\x14\x80\x15a\x1D\xFDW[\x80\x15\x80a\x1D\xE7W[a\x1DMW[\x15a\x12\xA7Wa\x1Be\x83a\x08\xCA\x84`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[T`\xFF`\x90\x82\x90\x1C\x16\x15\x80a\x1D8W[a\x1D\x0FWa\x1B\x96a\x1B\xA5\x92a\x1B\x8D`\x01\x93a\xFF\xFF\x16\x90V[\x883\x88\x88a\xA0\x16V[\x94\x01T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16a\x1B\xC8W[`@Q`\x01`\x01`@\x1B\x03\x85\x16\x81R` \x90\xF3[_Ta\x1B\xDC\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\x1C\x9D\x11\xBD`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04\x82\x01R\x95\x90` \x90\x87\x90`$\x90\x82\x90Z\xFA\x92\x83\x15a\x13cWa\t\x8Ca\x1C\xCC\x95a\x1C\xA2\x95a\t\x9A\x94a\x0B\xBD\x9A_\x92a\x1C\xEEW[P\x81\x15a\x1C\xE6Wa\x1CJ\x91a\x1C>a\x1CC\x92ao#V[aodV[a\xFF\xFF\x16\x90V[a'\x10a\xFF\xFF\x82\x16\x11a\x1C\xDDW[a\x1Cja\x1Cp\x91a\xFF\xFF`d\x91\x16\x04\x90V[`\xFF\x16\x90V[\x90`d`\xFF\x83\x16\x11a\x1C\xD4W[a\x1C\xB0\x90`@Q\x97\x88\x91` \x83\x01`\x14\x91`\x01`\x01``\x1B\x03\x19\x90``\x1B\x16\x81R\x01\x90V[\x03`\x1F\x19\x81\x01\x88R\x87a'6V[`@Qc\x08\x81\x89\x8F`\xE0\x1B` \x82\x01R\x95\x86\x93`$\x85\x01aosV[_\x80\x80a\x1B\xB4V[`d\x91Pa\x1C}V[Pa'\x10a\x1CXV[PP_a\x1CJV[a\x1D\x08\x91\x92P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[\x90_a\x1C'V[cx4\x82\xE9`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`\x01`\x01`\xA0\x1B\x03\x84\x16`$R`D_\xFD[P`\x10\x81\x90\x1C`\x01`\x01`@\x1B\x03\x16\x15a\x1BuV[`\x01\x85\x01Ta\x1Df\x90a\x0F\xF0\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[`@Qct\xCE\xEBU`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x85\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA_\x91\x81a\x1D\xB6W[Pa\x1D\xA3W[Pa\x1BAV[`\x01`\x01`\xA0\x1B\x03\x163\x14\x90P_a\x1D\x9DV[a\x1D\xD9\x91\x92P` =` \x11a\x1D\xE0W[a\x1D\xD1\x81\x83a'6V[\x81\x01\x90ao\x0EV[\x90_a\x1D\x97V[P=a\x1D\xC7V[P`\x01\x85\x01T`\x01`\x01`\xA0\x1B\x03\x16\x15\x15a\x1B<V[P\x83Ta\x1E\x12\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[3\x14a\x1B4V[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x1E6\x81a\n\xAFV[`\x01\x80`\xA0\x1B\x03\x16_R`\x19` R`@_ _\x80R` R` `@_ T`@Q\x90\x81R\xF3[`\xFF\x81\x16\x03a\x05\xAFWV[``6`\x03\x19\x01\x12a\x05\xAFW`\x045a\x1E\x81\x81a\x05\xB3V[`$5\x90a\x1E\x8E\x82a\x1E^V[`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa\x1E\xAD\x906\x90`\x04\x01a\x05\xF8V[\x91\x90\x92a\x1E\xB8a\x87\x0FV[a\x1E\xC0a\x876V[a\x1E\xC9\x82a\x98\xDCV[`\x02\x81\x01T\x93\x90`\x01`p\x86\x90\x1C`\xFF\x16a\x1E\xE3\x81a\"\xE3V[\x03a!\xE1W`\x01\x81\x01T`\x01`\x01`@\x1B\x03`@\x82\x90\x1C\x16\x80\x15\x15\x91\x82a!\xAFW[PPa!\x93Wa\x1FIa\x15\x8Aa\x1F,\x86`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[a\x1F53a\x0F\xF0V[\x90`\x01\x91_R\x01` R`@_ T\x15\x15\x90V[a!sW_\x94`\x02\x90`h\x1C`\xFF\x16a\x1Fa\x81a\"\xE3V[\x14a!-W[\x90\x82\x91a\x1F\x85\x85`\x01`\x01`@\x1B\x03\x16_R`\x15` R`@_ \x90V[\x95\x86Ta\x1F\x98\x90`\x01`\x01`@\x1B\x03\x16\x90V[\x96a\x1F\xA2\x88ah\xADV[\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x90\x91\x16\x17\x90Ua\x1F\xC5a'fV[`\xFF\x85\x16\x81R\x903` \x83\x01R`\x01`\x01`@\x1B\x03B\x16`@\x83\x01R``\x82\x01_\x90R`\x80\x82\x01R`\xA0\x81\x01_\x90R\x86a \x10\x87`\x01`\x01`@\x1B\x03\x16_R`\x16` R`@_ \x90V[\x90a +\x91\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[\x90a 5\x91ao\xC3V[\x86\x82\x87a S\x88`\x01`\x01`@\x1B\x03\x16_R`\x18` R`@_ \x90V[\x90a n\x91\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[\x91a x\x92ap\xE2V[T`\x01`\x01`@\x1B\x03\x16_\x90\x81R`\x05` R`@\x90 `\x01\x01Ta\x0B\xBD\x96\x7F\xDE7\xCCH\xD2\x17x\xE1\xC9\xA0u\xC4\xE4\x1CZ\xFFi\x18\xC3\xEAaQ\"\x1F\n\xF3\xCE\x81!\xA2\x9D\xB5\x93\x90\x91`\x01`\x01`\xA0\x1B\x03\x16\x90\x81a \xF7W[PPa \xEC`@Q\x92\x83\x92`\x01`\x01`@\x1B\x03\x80\x8A\x16\x98\x16\x963\x90\x85aq\xD7V[\x03\x90\xA3a\x0B\xA3a\x87nV[a!&\x91a!!\x88a\t\x8C\x87\x87\x8D`@Q\x97\x88\x95c\x988\xCA\xA3`\xE0\x1B` \x88\x01R`$\x87\x01aq\xA6V[a\xA2SV[_\x84a \xCBV[\x93P\x81\x90`\x03a!^a!G\x87T`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[\x01T\x94a!k4\x87a\xA1\xC9V[\x90\x91Pa\x1FgV[c5wV\xD1`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R3`$R`D_\xFD[c|>b\x1B`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[a!\xD8\x92Pa!\xCC\x91\x90`\x01`\x01`@\x1B\x03\x16ao\xA3V[ao\xA3V[`\x01`\x01`@\x1B\x03\x16\x90V[B\x11_\x80a\x1F\x05V[c\t\x8B\xFC[`\xE3\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045`$5a\"\x1D\x81a\n\xAFV[3`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a\"6Wa\0\x18\x91a\xA2\xCDV[c3K\xD9\x19`\xE1\x1B_R`\x04_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFWa\"]a\x876V[a\"f3a\xA3mV[\x80a\"\x7FW[`\x01_\x80Q` a\xC9'\x839\x81Q\x91RU\0[_\x90`@Q\x90\x81R\x7F\x93\x10\xCC\xFC\xB8\xDEr?W\x8A\x9EB\x82\xEA\x9FR\x1F\x05\xAE@\xDC\x08\xF3\x06\x8D\xFA\xD5(\xA6^\xE3\xC7` 3\x92\xA3_a\"lV[cNH{q`\xE0\x1B_R`!`\x04R`$_\xFD[`\x02\x11\x15a\"\xD1WV[a\"\xB3V[\x90a\"\xE0\x82a\"\xC7V[RV[`\x03\x11\x15a\"\xD1WV[\x90a\"\xE0\x82a\"\xE3V[a\x05\xD1\x90\x92\x91\x92a\x01`\x80a\x01\x80\x83\x01\x95a#\x1B\x84\x82Q`\x01`\x01`@\x1B\x03\x16\x90RV[` \x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x85\x01R`@\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R``\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R`\x80\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R`\xA0\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R`\xC0\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01R`\xE0\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01Ra\x01\0\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01Ra#\xBFa\x01 \x82\x01Qa\x01 \x86\x01\x90a\"\xD6V[a#\xD3a\x01@\x82\x01Qa\x01@\x86\x01\x90a\"\xEDV[\x01Q\x91\x01\x90a\"\xEDV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a$\x02\x81a\x05\xB3V[a$\naq\xFEV[P\x16_R`\x10` Ra\x0B\xBD`@_ a%ea%[`\x02a$*a'uV[\x93a$ra$b\x82Ta$Sa$F\x82`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16\x89RV[`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x16` \x87\x01RV[a$\xF9a$\xE9`\x01\x83\x01Ta$\xA0a$\x90\x82`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16`@\x8A\x01RV[a$\xC2`@\x82\x90\x1C`\x01`\x01`@\x1B\x03\x16[`\x01`\x01`@\x1B\x03\x16``\x8A\x01RV[a$\xE3`\x80\x82\x90\x1C`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`\x80\x8A\x01RV[`\xC0\x1C\x90V[`\x01`\x01`@\x1B\x03\x16`\xA0\x87\x01RV[\x01Tc\xFF\xFF\xFF\xFF\x81\x16`\xC0\x85\x01Rc\xFF\xFF\xFF\xFF` \x82\x90\x1C\x16`\xE0\x85\x01Rc\xFF\xFF\xFF\xFF`@\x82\x90\x1C\x16a\x01\0\x85\x01Ra%=``\x82\x90\x1C`\xFF\x16a\x01 \x86\x01argV[a%R`h\x82\x90\x1C`\xFF\x16a\x01@\x86\x01arpV[`p\x1C`\xFF\x16\x90V[a\x01`\x83\x01arpV[`@Q\x91\x82\x91\x82a\"\xF7V[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFWa%\x89a\x8FTV[_\x80Q` a\xC9\x07\x839\x81Q\x91RT`\xFF\x81\x16\x15a%\xE0W`\xFF\x19\x16_\x80Q` a\xC9\x07\x839\x81Q\x91RU\x7F]\xB9\xEE\nI[\xF2\xE6\xFF\x9C\x91\xA7\x83L\x1B\xA4\xFD\xD2D\xA5\xE8\xAANS{\xD3\x8A\xEA\xE4\xB0s\xAA` `@Q3\x81R\xA1\0[c\x8D\xFC +`\xE0\x1B_R`\x04_\xFD[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a&\x14\x81a\x05\xB3V[a&\x1D\x81a\x86|V[\x80T`\x01`\x01`\xA0\x1B\x03\x163\x03a&bW`\x02\x01\x80Tb\xFF\0\0\x19\x16\x90U\x16\x7F\xE1B\x86\xF3\xADI\xAD\xA6\xD0\x91\x1A\xDD\xA8\xEF\x90ai\x99\x04[\xDE*3\xE3\x91\xA7\xB5\xAEe\x89\xE7\x89_\x80\xA2\0[Pc#N\x07\x1D`\xE0\x1B_R\x16`\x04R3`$R`D_\xFD[cNH{q`\xE0\x1B_R`A`\x04R`$_\xFD[`\xE0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[a&zV[`\x80\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[`\xC0\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[a\x01@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[`@\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[``\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[\x90`\x1F\x80\x19\x91\x01\x16\x81\x01\x90\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@RV[`@Q\x90a\x05\xD1`\x80\x83a'6V[`@Q\x90a\x05\xD1`\xC0\x83a'6V[`@Q\x90a\x05\xD1a\x01\x80\x83a'6V[`@Q\x90a\x05\xD1`\xE0\x83a'6V[`@Q\x90a\x05\xD1``\x83a'6V[`@Q\x90a\x05\xD1a\x01@\x83a'6V[`@Q\x90a\x05\xD1`@\x83a'6V[\x90a\x05\xD1`@Q\x92\x83a'6V[`\x01`\x01`@\x1B\x03\x81\x11a&\xA9W`\x1F\x01`\x1F\x19\x16` \x01\x90V[\x92\x91\x92a'\xF7\x82a'\xD0V[\x91a(\x05`@Q\x93\x84a'6V[\x82\x94\x81\x84R\x81\x83\x01\x11a\x05\xAFW\x82\x81` \x93\x84_\x96\x017\x01\x01RV[\x90\x80`\x1F\x83\x01\x12\x15a\x05\xAFW\x81` a\x0B\xE6\x935\x91\x01a'\xEBV[`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a(T\x81a\n\xAFV[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa(s\x906\x90`\x04\x01a(!V[\x90`\x01`\x01`\xA0\x1B\x03\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x160\x81\x14\x90\x81\x15a)bW[Pa)SWa(\xB6a\x8F\xC3V[`@QcR\xD1\x90-`\xE0\x1B\x81R\x91` \x83`\x04\x81`\x01`\x01`\xA0\x1B\x03\x86\x16Z\xFA_\x93\x81a)2W[Pa(\xFFWcL\x9C\x8C\xE3`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04R`$_\xFD[\x90_\x80Q` a\xC8\xC7\x839\x81Q\x91R\x83\x03a)\x1EWa\0\x18\x92Pa\xBA\x94V[c*\x87Ri`\xE2\x1B_R`\x04\x83\x90R`$_\xFD[a)L\x91\x94P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[\x92_a(\xDEV[cp>F\xDD`\xE1\x1B_R`\x04_\xFD[_\x80Q` a\xC8\xC7\x839\x81Q\x91RT`\x01`\x01`\xA0\x1B\x03\x16\x14\x15\x90P_a(\xA9V[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW\x7F\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0`\x01`\x01`\xA0\x1B\x03\x160\x03a)SW` `@Q_\x80Q` a\xC8\xC7\x839\x81Q\x91R\x81R\xF3[\x91\x90\x91`\xC0\x80`\xE0\x83\x01\x94\x80Qa)\xF1\x81a\"\xC7V[\x84R` \x81\x01Qa*\x01\x81a\"\xE3V[` \x85\x01Rc\xFF\xFF\xFF\xFF`@\x82\x01Q\x16`@\x85\x01Rc\xFF\xFF\xFF\xFF``\x82\x01Q\x16``\x85\x01R`\x80\x81\x01Q`\x80\x85\x01R`\x01`\x01`@\x1B\x03`\xA0\x82\x01Q\x16`\xA0\x85\x01R\x01Q\x91\x01RV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a*o\x81a\x05\xB3V[a*waryV[P\x16_R`\x06` Ra\x0B\xBD`@_ `\x03`@Q\x91a*\x96\x83a&\x8EV[a*\xEAa*\xDD\x82T`\xFF\x81\x16a*\xAB\x81a\"\xC7V[\x86Ra*\xC0`\xFF\x82`\x08\x1C\x16` \x88\x01arpV[c\xFF\xFF\xFF\xFF`\x10\x82\x90\x1C\x16`@\x87\x01R[`0\x1Cc\xFF\xFF\xFF\xFF\x16\x90V[c\xFF\xFF\xFF\xFF\x16``\x85\x01RV[`\x01\x81\x01T`\x80\x84\x01Ra+\x1Ba+\x0B`\x02\x83\x01T`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16`\xA0\x85\x01RV[\x01T`\xC0\x82\x01R`@Q\x91\x82\x91\x82a)\xDBV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a+K\x81a\x05\xB3V[a+T\x81a\x98\xDCV[\x80T`@\x1C`\x01`\x01`\xA0\x1B\x03\x163`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x03a,OW`\x02\x81\x01\x80T`\xFF`p\x1B\x19\x16`\x01`q\x1B\x17\x90Ua,\x07\x90`\x01\x90a+\xF9\x90a\x159\x90\x80\x84\x01\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16B`\x80\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x90U`\x01`\x01`@\x1B\x03\x86\x16\x7F?\xD5X\xA5\x9B\xBC\xE1\xD9\x96\xD1~\xAB\x7F\xDE1K\xCD \x1E\xC3\xF1su\xA7\xF8s\xB3\x16)'\xE8\x81_\x80\xA2T`\x01`\x01`@\x1B\x03\x16\x90V[\x01T`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16a,\x18W\0[`@Qc\n$\xE8\xA9`\xE4\x1B` \x82\x01R`\x01`\x01`@\x1B\x03\x90\x91\x16`$\x82\x01R3`D\x82\x01Ra\0\x18\x91a\t\x9A\x82`d\x81\x01a\t\x8CV[c\x0C\xD5g\xCF`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R3`$R`D_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `\xFF_\x80Q` a\xC9\x07\x839\x81Q\x91RT\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xAFWa,\xAB6a\x19\xC7V[`\x01`\x01`\xA0\x1B\x03a,\xBC\x83a\x98\xDCV[T`@\x1C\x163\x03a,\xEEW`\x01`\x01`@\x1B\x03a\0\x18\x92\x16_R`\x13` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16\x90a\xB3\xDCV[`\x01`\x01`@\x1B\x03\x82c\x0C\xD5g\xCF`\xE1\x1B_R\x16`\x04R3`$R`D_\xFD[a\x05\xD1\x90\x92\x91\x92a\x01`\x80a\x01\x80\x83\x01\x95a-2\x84\x82Q`\x01`\x01`@\x1B\x03\x16\x90RV[` \x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x85\x01R`@\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R``\x81\x81\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x85\x01R`\x80\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01R`\xA0\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01R`\xC0\x81\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16\x90\x85\x01R`\xE0\x81\x01Q`\xE0\x85\x01Ra-\xBCa\x01\0\x82\x01Qa\x01\0\x86\x01\x90a\"\xD6V[a\x01 \x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01Ra\x01@\x81\x81\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x85\x01R[\x01Q\x15\x15\x91\x01RV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a.\r\x81a\x05\xB3V[a.\x15aq\xFEV[P\x16_R`\t` Ra\x0B\xBD`@_ a/\x1Ea/\x14`\x04a.5a'uV[\x93a.Qa$b\x82Ta$Sa$F\x82`\x01`\x01`@\x1B\x03\x16\x90V[a.\xB9a.\xAC`\x01\x83\x01Ta.oa$\x90\x82`\x01`\x01`@\x1B\x03\x16\x90V[a.\x85`@\x82\x90\x1C`\x01`\x01`@\x1B\x03\x16a$\xB2V[a.\xA0`\x80\x82\x90\x1Cc\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x16`\x80\x8A\x01RV[`\xA0\x1Cc\xFF\xFF\xFF\xFF\x16\x90V[c\xFF\xFF\xFF\xFF\x16`\xA0\x87\x01RV[`\x02\x81\x01T`\x01`\x01`\xA0\x1B\x03\x16`\xC0\x86\x01R`\x03\x81\x01T`\xE0\x86\x01R\x01Ta.\xE9`\xFF\x82\x16a\x01\0\x86\x01argV[c\xFF\xFF\xFF\xFF`\x08\x82\x90\x1C\x16a\x01 \x85\x01Rc\xFF\xFF\xFF\xFF`(\x82\x90\x1C\x16a\x01@\x85\x01R`H\x1C`\xFF\x16\x90V[\x15\x15a\x01`\x83\x01RV[`@Q\x91\x82\x91\x82a-\x0EV[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a/G\x81a\x05\xB3V[`$5a/S\x81a\x1E^V[a/[a\x87\x0FV[a/ca\x876V[a/l\x82a\x90xV[`\x04\x81\x01T`H\x1C`\xFF\x16a1\x90W_\x91_[a/\x9A\x85`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[T\x81\x10\x15a1\x88Wa\x0F\xF0a/\xE3a/\xCC\x83a/\xC7\x89`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[al$V[\x90T3\x93`\x03\x92\x90\x92\x1B\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x14a/\xF0W`\x01\x01a/\x7FV[P\x90\x91P`\x01[\x15a\x12\xA7Wa0\x1Ea\x15\xE23a\x08\xCA\x86`\x01`\x01`@\x1B\x03\x16_R`\x0C` R`@_ \x90V[a1hWa0Da\x16%3a\x08\xCA\x86`\x01`\x01`@\x1B\x03\x16_R`\x0C` R`@_ \x90V[a0\xC7`\x01a+\xF9a\x159\x82\x86\x01\x95a0\x8Ba0ka\x11\x91\x89Tc\xFF\xFF\xFF\xFF\x90`\xA0\x1C\x16\x90V[\x88Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\xA0\x91\x90\x91\x1Bc\xFF\xFF\xFF\xFF`\xA0\x1B\x16\x17\x88UV[3`\x01`\x01`@\x1B\x03\x89\x16\x7F\xCE\xDA\x1AD\xEA\xD4\xDA=:\xBA\xAA\x94\x1A\xFAm\x950\xFD\x84\xDD\x8E\x998\\\x91\x83\xD9\x86\xDC\xAB\x98\x0F_\x80\xA3T`\x01`\x01`@\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16a1!W[PPTc\xFF\xFF\xFF\xFFa1\x03a0\xFA`\xA0\x84\x90\x1C\x83\x16[\x93`\x80\x1Cc\xFF\xFF\xFF\xFF\x16\x90V[c\xFF\xFF\xFF\xFF\x16\x90V[\x91\x16\x14a1\x12Wa\0\x18a\x87nV[a1\x1B\x90a\x92\xF7V[_a\x12\x03V[`@Qc,Vz\xCD`\xE2\x1B` \x82\x01R3`$\x82\x01R`\x01`\x01`@\x1B\x03\x85\x16`D\x82\x01R`\xFF\x90\x91\x16`d\x82\x01Ra1a\x91a\t\x9A\x82`\x84\x81\x01a\t\x8CV[_\x80a0\xD7V[c\x0F+\xB0\xF1`\xE4\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R3`$R`D_\xFD[P\x90\x91a/\xF7V[c% H\xA3`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`$_\xFD[4a\x05\xAFW` `\x01`\x01`@\x1B\x03a1\xE9\x81a1\xC86a\x19\xC7V[\x91\x16_R`\x07\x84R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[T\x16\x15\x15`@Q\x90\x81R\xF3[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a2\x12\x81a\x05\xB3V[a2\x1Aa\x876V[a2#\x81a\x98\xDCV[`\x02\x81\x01\x90\x81T`\x01a2:\x82`\xFF\x90``\x1C\x16\x90V[a2C\x81a\"\xC7V[\x03a\x14=Wc\xFF\xFF\xFF\xFFa2ca0\xFA\x83\x83\x16\x93` \x1Cc\xFF\xFF\xFF\xFF\x16\x90V[\x91\x16\x11\x15a\x14=Wa2\x89a\x08k\x84`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x90a2\x9Ca\x15\x8A\x83T`\xFF\x90`\x90\x1C\x16\x90V[a4/Wa2\xB6a\x159`\x01\x92T`\x01`\x01`@\x1B\x03\x16\x90V[\x01\x80T\x90\x92\x90`\x01`\x01`\xA0\x1B\x03\x16\x80a3\xB4W[P\x81Th\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`P\x1B\x19\x16B`P\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`P\x1B\x16\x17\x90\x91Ua3'\x90a3\x153a\x08\xFF\x86`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[Pa\x11\x96a\t\x13\x82Tc\xFF\xFF\xFF\xFF\x16\x90V[a3j`@Q\x913`\x01`\x01`@\x1B\x03\x85\x16\x7F\x8C\xE5>K`\x02\xFF\t\x0Ed\x1D\xDE\xCD\xAF~\xDD(\x13\xA9\x8E\x19\x13\x9F\xA7\xD1\xC7\x9F\xCC\xC3\xC4\xDE\xAD_\x80\xA3T`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16a3\x80Wa\0\x18a\x87nV[c\x96]#\x1B`\xE0\x1B` \x83\x01R`\x01`\x01`@\x1B\x03\x90\x92\x16`$\x82\x01R3`D\x82\x01Ra\x12N\x91a\t\x9A\x82`d\x81\x01a\t\x8CV[a3\xC6\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qcr\x8Co;`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x86\x16`\x04\x82\x01R3`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90Z\xFA_\x91\x81a4\x0EW[P\x15a2\xCBW\x15a\x12\xA7W_a2\xCBV[a4(\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_a3\xFDV[cx4\x82\xE9`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R3`$R`D_\xFD[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a4l\x81a\n\xAFV[a4ta\x8E\xE5V[` \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90U\0[4a\x05\xAFWa\x0B\xBDa4\xDE`\x01`\x01`@\x1B\x03a4\xB26a\x19\xC7V[\x91\x90a4\xBCar\xD3V[P\x16_R`\x07` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[`\xFF`@Q\x91a4\xED\x83a&\xAEV[T`\x01`\x01`@\x1B\x03\x81\x16\x83R`\x01`\x01`@\x1B\x03\x81`@\x1C\x16` \x84\x01R\x81\x81`\x80\x1C\x16\x15\x15`@\x84\x01R`\x88\x1C\x16\x15\x15``\x82\x01R`@Q\x91\x82\x91\x82\x91\x90\x91``\x80`\x80\x83\x01\x94`\x01`\x01`@\x1B\x03\x81Q\x16\x84R`\x01`\x01`@\x1B\x03` \x82\x01Q\x16` \x85\x01R`@\x81\x01Q\x15\x15`@\x85\x01R\x01Q\x15\x15\x91\x01RV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a5\x88\x81a\x05\xB3V[a5\x90a\x876V[a5\x99\x81a\x90xV[`\x04\x81\x01\x90a5\xAD\x82T`\xFF\x90`H\x1C\x16\x90V[a1\x90W_\x91_[a5\xD0\x85`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[T\x81\x10\x15a6\xFBWa\x0F\xF0a5\xFDa/\xCC\x83a/\xC7\x89`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[\x14a6\nW`\x01\x01a5\xB5V[P\x90\x91P`\x01[\x15a\x12\xA7Wa+\xF9a\x159a6\xA6\x93a6?`\x01\x94i\x01\0\0\0\0\0\0\0\0\0`\xFF`H\x1B\x19\x82T\x16\x17\x90UV[\x80Ta6j\x90`@\x1C`\x01`\x01`\xA0\x1B\x03\x16`\x02\x83\x01T`\x01`\x01`\xA0\x1B\x03\x16`\x03\x84\x01T\x91a\xA4,V[3`\x01`\x01`@\x1B\x03\x87\x16\x7F\xC60P\xB9c\xECn,\xF3m\xF9\x0E\xCA\xCA\xA42\x12\xC0\xE7K\x8C:X\xA0\xF8\xCC\xE3\xBDZ*vu_\x80\xA3T`\x01`\x01`@\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16a6\xBDWa\0\x18a\x87nV[`@Qc\x199\xA9C`\xE3\x1B` \x82\x01R3`$\x82\x01R`\x01`\x01`@\x1B\x03\x90\x91\x16`D\x82\x01Ra6\xF4\x91a\t\x9A\x82`d\x81\x01a\t\x8CV[_\x80a\x12\x03V[P\x90\x91a6\x11V[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u\x81R\xF3[4a\x05\xAFWa7K6a\x06%V[`\x01`\x01`@\x1B\x03\x83\x92\x93\x16_R`\x1D` R`\x01\x80`\xA0\x1B\x03`@_ T`@\x1C\x163\x14\x15\x80a7\xB2W[a7\x92Wa\0\x18\x92a7\x8A\x916\x91a'\xEBV[\x903\x90a\xA4UV[c\xDD,\x7F\xB7`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R3`$R`D_\xFD[P3_\x90\x81R_\x80Q` a\xC9G\x839\x81Q\x91R` R`@\x90 T`\xFF\x16\x15a7wV[4a\x05\xAFWa\x01 6`\x03\x19\x01\x12a\x05\xAFW`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWa8\x08\x906\x90`\x04\x01a\x05\xF8V[PP`$5a8\x16\x81a\n\xAFV[`\xE06`C\x19\x01\x12a\x05\xAFWa\x0B\xBD\x90a8.a\x87\x0FV[`\x04T`\x01`\x01`@\x1B\x03\x16\x90a8ca8G\x83ah\xADV[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19`\x04T\x16\x17`\x04UV[a8\xE6a8naluV[a8\xBEa8yar\xF7V[a8\xB5a8\x84a'\x85V[3\x81R\x93`\x01`\x01`\xA0\x1B\x03\x87\x16` \x86\x01RB`\x01`\x01`@\x1B\x03\x16`@\x86\x01R_``\x86\x01R`\x80\x85\x01argV[`\xA0\x83\x01arpV[`\x01`\xC0\x82\x01R[a8\xE1\x84`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[as=V[a9\ta9\x04\x83`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[at(V[`@Q`\x01`\x01`\xA0\x1B\x03\x82\x16\x81R3\x90`\x01`\x01`@\x1B\x03\x84\x16\x90\x7F+\x0Fj{\x1FZ\xFDx2\xE4\x99r\xF4\x0B\x9F\xCD\x16\x99\x890\xB2O6F\x9C\x91\x005\x02\xD0\xD9\x98\x90` \x90\xA3`\x01`\x01`\xA0\x1B\x03\x81\x16a9uW[P`@Q`\x01`\x01`@\x1B\x03\x90\x91\x16\x81R\x90\x81\x90` \x82\x01\x90V[`@Qc\x0Be5\xD7`\xE0\x1B` \x82\x01R`\x01`\x01`@\x1B\x03\x83\x16`$\x82\x01R3`D\x82\x01R0`d\x82\x01Ra9\xB1\x91a!!\x82`\x84\x81\x01a\t\x8CV[_a9ZV[\x80\x15\x15\x03a\x05\xAFWV[4a\x05\xAFW``6`\x03\x19\x01\x12a\x05\xAFW`\x045a9\xDE\x81a\x05\xB3V[`$5a9\xEA\x81a9\xB7V[`D5\x91a9\xF7\x83a\x0E\xB6V[a9\xFFa\x8E\xE5V[`\x01`\x01`@\x1B\x03\x81\x16a\x0E\x10\x81\x10\x90\x81\x15a;\x07W[Pa:\xECWa\xFF\xFF\x83\x16\x80\x15\x90\x81\x15a:\xFBW[Pa:\xECWa:\xE7\x7F3\xE0A\x141\0Z\x064p\xB5T\tNb\xF6\x97:\xA3_\xCE#\x0E\xAF]Z\0y\xBEN3\x9C\x93a:\xB9a:_a'\x94V[`\x01`\x01`@\x1B\x03\x85\x16\x80\x82R\x86\x15\x15` \x83\x01\x81\x90Ra\xFF\xFF\x85\x16`@\x93\x84\x01R`\x1C\x80Tj\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16\x90\x92\x17\x92\x1B`\xFF`@\x1B\x16\x91\x90\x91\x17`H\x84\x90\x1Bj\xFF\xFF\0\0\0\0\0\0\0\0\0\x16\x17\x90UV[`@Q\x93\x84\x93\x84\x91`@\x91\x94\x93a\xFF\xFF\x91`\x01`\x01`@\x1B\x03``\x86\x01\x97\x16\x85R\x15\x15` \x85\x01R\x16\x91\x01RV[\x03\x90\xA1\0[c\xD8\xF2r}`\xE0\x1B_R`\x04_\xFD[a'\x10\x91P\x11_a:*V[b'\x8D\0\x91P\x11_a:\x16V[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW` a;j`\x045a;6\x81a\n\xAFV[`$5\x90a;C\x82a\n\xAFV[`\x01\x80`\xA0\x1B\x03\x16_R`\x19\x83R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[T`@Q\x90\x81R\xF3[4a\x05\xAFWa;\x816a\x19\xC7V[`\x01`\x01`\xA0\x1B\x03a;\x92\x83a\x98\xDCV[T`@\x1C\x163\x03a,\xEEW`\x01`\x01`@\x1B\x03a\0\x18\x92\x16_R`\x13` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16\x90a\xBA\x1BV[4a\x05\xAFWa\x0B\xBDa<\x0C`\x01`\x01`@\x1B\x03a;\xE06a\x19\xC7V[\x91\x90a;\xEAar\xD3V[P\x16_R`\x11` R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[`\xFF`@Q\x91a<\x1B\x83a&\xAEV[Ta\xFF\xFF\x81\x16\x83R`\x01`\x01`@\x1B\x03\x81`\x10\x1C\x16` \x84\x01R`\x01`\x01`@\x1B\x03\x81`P\x1C\x16`@\x84\x01R`\x90\x1C\x16\x15\x15``\x82\x01R`@Q\x91\x82\x91\x82\x91\x90\x91``\x80`\x80\x83\x01\x94a\xFF\xFF\x81Q\x16\x84R`\x01`\x01`@\x1B\x03` \x82\x01Q\x16` \x85\x01R`\x01`\x01`@\x1B\x03`@\x82\x01Q\x16`@\x85\x01R\x01Q\x15\x15\x91\x01RV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFWa<\xB3a\x8FTV[a<\xBBa\x87\x0FV[`\x01`\xFF\x19_\x80Q` a\xC9\x07\x839\x81Q\x91RT\x16\x17_\x80Q` a\xC9\x07\x839\x81Q\x91RU\x7Fb\xE7\x8C\xEA\x01\xBE\xE3 \xCDNB\x02p\xB5\xEAt\0\r\x11\xB0\xC9\xF7GT\xEB\xDB\xFCTK\x05\xA2X` `@Q3\x81R\xA1\0[4a\x05\xAFWa=\x1A6a\x19\xC7V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x91\x90\x82\x15a=\xB6Wa=5\x82a\x86|V[\x80T\x90\x91\x903`\x01`\x01`\xA0\x1B\x03\x82\x16\x03a=\x96W\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x83\x16\x17\x90\x92U\x16\x90`\x01`\x01`@\x1B\x03\x16\x7F\xD2\xB9X\xA1\xB0\xB9x\xCE\xDE\xD4\x98kOI\xC8\xB2_\xBDn\x81,\xB8\x92^\x13\xEF\xC71\xEAJ\xA2M_\x80\xA4\0[`\x01`\x01`@\x1B\x03\x84c#N\x07\x1D`\xE0\x1B_R\x16`\x04R3`$R`D_\xFD[c\xD9.#=`\xE0\x1B_R`\x04_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q\x7FLpp\xC6\xC1\x9C\xC9\xB4'\xB9O\xE5\x97\x9E\xE0\xC5s\xF8\xED\xD0\r%Y\x1A\xFEL\x95\x10\xDE\x94y\xBA\x81R\xF3[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045a>$\x81a\x05\xB3V[\x16_R`\x08` R` `@_ T`@Q\x90\x81R\xF3[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW` `\xFFa>\x8D`$5`\x045a>b\x82a\n\xAFV[_R_\x80Q` a\xC8\xE7\x839\x81Q\x91R\x84R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[T\x16`@Q\x90\x15\x15\x81R\xF3[` `\x03\x19\x82\x01\x12a\x05\xAFW`\x045\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFWa\x06]\x91`\x04\x01a\n\x7FV[4a\x05\xAFWa>\xD16a>\x99V[a>\xDA\x81ah\xCAV[\x91_\x91_[\x81\x81\x10a?:WPPPa>\xF2\x81ah\xCAV[\x91_[\x82\x81\x10a?\nW`@Q\x80a\x0B\xBD\x86\x82a\x0B\xE9V[\x80a?4a?*a?\x1D`\x01\x94\x86ai2V[Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x0C\xD9\x83\x88ai2V[\x01a>\xF5V[\x80a?Za?K`\x01\x93\x85\x87at\xEEV[5a?U\x81a\x05\xB3V[a\xA5zV[a?eW[\x01a>\xDFV[a?p\x81\x84\x86at\xEEV[5a?z\x81a\x05\xB3V[`\x01`\x01`@\x1B\x03a?\x95a?\x8E\x88at\xFEV[\x97\x89ai2V[\x91\x16\x90Ra?_V[`@6`\x03\x19\x01\x12a\x05\xAFW`\x045a?\xB6\x81a\x05\xB3V[`$5a?\xC1a\x876V[`\x02a?\xCC\x83a\x98\xDCV[\x01T`\x01`p\x82\x90\x1C`\xFF\x16a?\xE1\x81a\"\xE3V[\x03a@\xA6W`\x01\x90`h\x1C`\xFF\x16a?\xF8\x81a\"\xE3V[\x03a\x14=W\x7F\xD2\x8D\xE7\xC5\x18\xC3\x12\xFA8\x8E\x03\xF8\xD1 =\x8FLu\x16\x1E5\x8F\xFB\x08'\xB6\xCA\xA2\xE9\xAC\x8A1`\x01`\x01`@\x1B\x03a@A\x84`\x01`\x01`@\x1B\x03\x16_R`\x14` R`@_ \x90V[\x80Ta@Z\x90`\x01`\x01`\xA0\x1B\x03\x16\x91\x85\x834\x92a\xA6ZV[`\x01`\x01`\xA0\x1B\x03\x16\x93\x84\x15\x80a@\x9DW[a@\x85W[`@Q\x93\x84R\x16\x91` \x90\xA3a\0\x18a\x87nV[a@\x98a@\x92\x854au\x1AV[3a\xA6\xECV[a@qV[P\x834\x11a@lV[c\t\x8B\xFC[`\xE3\x1B_R`\x01`\x01`@\x1B\x03\x83\x16`\x04R`$_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q_\x81R\xF3[`\xE06`\x03\x19\x01\x12a\x05\xAFW`\x045a@\xF4\x81a\x05\xB3V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaA\x13\x906\x90`\x04\x01a\n\x7FV[\x91`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaA3\x906\x90`\x04\x01a\x05\xF8V[\x92\x90\x93`d5\x93`\x01`\x01`@\x1B\x03\x85\x11a\x05\xAFWa\x0B\xBD\x95aA]a\x0B\xA3\x966\x90`\x04\x01a\n\x7FV[\x92\x90\x91aAha\x05\xE0V[\x94aAqa\n\xCDV[\x96`\xC45\x98au'V[4a\x05\xAFW` `\xFFaA\xB9`\x01`\x01`@\x1B\x03aA\x986a\x19\xC7V[\x91\x16_R`\x11\x84R`@_ \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[T`\x90\x1C\x16`@Q\x90\x15\x15\x81R\xF3[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045aA\xE5\x81a\x05\xB3V[aA\xEDa\x876V[aB\x08\x81`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[\x90aB\x15a\x15\x8A\x83a\x8E\x9BV[aD\xA8W\x81T\x90`\x01`\x01`@\x1B\x03\x82\x16\x90` aBD\x83`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[_T\x90\x93\x90aB_\x90a\x1B\x1B\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x94aBq\x85T`\x01`\x01`@\x1B\x03\x16\x90V[`\x03\x88\x01T`\x04\x80\x8A\x01T`@Qc\x08\xD7\x95\xD5`\xE4\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x9A\x90\x9A\x16\x91\x8A\x01\x91\x90\x91R`\x01`\x01`@\x1B\x03\x92\x83\x16`$\x8A\x01R\x93\x90\x91\x16`D\x88\x01R`d\x87\x01R`\x84\x86\x01\x91\x90\x91R\x84\x90`\xA4\x90\x82\x90_\x90Z\xF1\x92\x83\x15a\x13cW_\x93aDrW[Pa+\xF9a\x159aC\0\x93aB\xF2\x86`\x01\x95a\xA7\xBEV[PT`\x01`\x01`@\x1B\x03\x16\x90V[\x91`\x01`\x01`\xA0\x1B\x03\x83\x16aC,W[a\x0B\xBD\x82aC\x1Ca\x87nV[`@Q\x90\x81R\x90\x81\x90` \x82\x01\x90V[_TaC@\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x90T`@\x80Qc\x1C\x9D\x11\xBD`\xE3\x1B\x81R\x90\x82\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16`\x04\x82\x01\x81\x90R\x94\x90\x92` \x90\x84\x90`$\x90\x82\x90Z\xFA\x80\x15a\x13cWa\x0B\xBD\x95a\t\x8Ca\x1C\xA2\x94a\t\x9A\x93aD2\x97_\x91aDSW[P\x80\x15aDJWa\x1CCaC\xBA\x91aC\xB4\x8BaC\xAE\x81ao#V[\x92au\xC0V[\x90aodV[a'\x10a\xFF\xFF\x82\x16\x11aDAW[a\x1CjaC\xDA\x91a\xFF\xFF`d\x91\x16\x04\x90V[\x90`d`\xFF\x83\x16\x11aD8W[aD\x16\x90`\x01`\x01`@\x1B\x03\x16\x93`@Q\x97\x88\x91` \x83\x01`\x14\x91`\x01`\x01``\x1B\x03\x19\x90``\x1B\x16\x81R\x01\x90V[`@Qc~\x14\xB9\x19`\xE0\x1B` \x82\x01R\x95\x86\x93`$\x85\x01aosV[_aC\x10V[`d\x91PaC\xE7V[Pa'\x10aC\xC8V[Pa'\x10aC\xBAV[aDl\x91P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[_aC\x93V[`\x01\x91\x93Pa\x159aC\0\x93aB\xF2aD\x9Ca+\xF9\x94` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[\x96\x94PP\x93PPaB\xDBV[c\xB4\x8B\tY`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x16`\x04R`$_\xFD[4a\x05\xAFWa\x0B\xBDaE/`\x01`\x01`@\x1B\x03aD\xDF6a\x0B\xC1V[\x91\x90_`\xA0`@QaD\xF0\x81a&\xC9V[\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x01R\x16_R`\x16` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[aE\xBBaE\xB2`\x03`@Q\x93aED\x85a&\xC9V[\x80T`\xFF\x81\x16\x86R`\x08\x81\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16` \x87\x01RaE\x7F\x90`\xA8\x1C`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x16`@\x87\x01RV[aE\xA0aE\x93`\x01\x83\x01Tc\xFF\xFF\xFF\xFF\x16\x90V[c\xFF\xFF\xFF\xFF\x16``\x87\x01RV[`\x02\x81\x01T`\x80\x86\x01R\x01T`\xFF\x16\x90V[\x15\x15`\xA0\x83\x01RV[`@Q\x91\x82\x91\x82\x91\x90\x91`\xA0\x80`\xC0\x83\x01\x94`\xFF\x81Q\x16\x84R`\x01\x80\x83\x1B\x03` \x82\x01Q\x16` \x85\x01R`\x01`\x01`@\x1B\x03`@\x82\x01Q\x16`@\x85\x01Rc\xFF\xFF\xFF\xFF``\x82\x01Q\x16``\x85\x01R`\x80\x81\x01Q`\x80\x85\x01R\x01Q\x15\x15\x91\x01RV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW`\x80`\x02Ta\xFF\xFF`@Q\x91\x81\x81\x16\x83R\x81\x81`\x10\x1C\x16` \x84\x01R\x81\x81` \x1C\x16`@\x84\x01R`0\x1C\x16``\x82\x01R\xF3[4a\x05\xAFW``6`\x03\x19\x01\x12a\x05\xAFWaFy`\x045a\x05\xB3V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaF\x98\x906\x90`\x04\x01a\n\x7FV[\x90`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaF\xB8\x906\x90`\x04\x01a\n\x7FV[\x90\x91aF\xC2a\x87\x0FV[aF\xCAa\x876V[\x81\x84\x03aKHWaF\xEE`\x045`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[aG\x02a\x159\x82T`\x01`\x01`@\x1B\x03\x16\x90V[_[\x86\x81\x10aG\x13Wa\0\x18a\x87nV[aG[aG3`\x045`\x01`\x01`@\x1B\x03\x16_R`\x16` R`@_ \x90V[aGFaGA\x84\x8B\x89at\xEEV[at\x1EV[`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[aG\x82a\x15\x8Aa\x0F\xB73a\x08\xCA`\x045`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[aK$W`\x03\x81\x01T`\xFF\x16aJ\xF0WaG\xC8a\x15\xE2\x89a\x08\xCAaG\xB9`\x045`\x01`\x01`@\x1B\x03\x16_R`\x17` R`@_ \x90V[aGFaGA\x883\x95\x8Dat\xEEV[aJ\xB8W\x90`\x01\x91aH\x07a\x16%\x87a\x08\xCA\x8CaGFaGA\x88aG\xFF`\x045`\x01`\x01`@\x1B\x03\x16_R`\x17` R`@_ \x90V[\x933\x96at\xEEV[aH5aH\x1Da\x11\x91\x85\x84\x01Tc\xFF\xFF\xFF\xFF\x16\x90V[\x84\x83\x01\x90c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90UV[\x82\x84\x01T\x88\x90\x87\x90`\x01`\x01`\xA0\x1B\x03\x16\x89\x8C\x86\x83aJ.W[\x92P\x90PaHa\x93PaGA\x92at\xEEV[aHl\x83\x89\x8Bau\xCDV[\x90\x7F\x8A\x04\xF9\x9F\xE22\x84\xE8t\xE8\xDD\x01sE$\x82y\xCCYp\x16\x95\xE7;\xCD\xBE\xB6$\x1B\xCD*\xC6`@Q\x80aH\xB4`\x01`\x01`@\x1B\x033\x97\x16\x95`\x01`\x01`@\x1B\x03`\x045\x16\x95\x83ag\xF1V[\x03\x90\xA4\x83\x83\x01T\x83\x90aH\xCF\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x80aI\xB5W[Pc\xFF\xFF\xFF\xFF\x80aH\xEC\x86\x85\x01Tc\xFF\xFF\xFF\xFF\x16\x90V[\x92\x16\x91\x16\x10\x15\x80aI\x9EW[aI\x04W[P\x01aG\x04V[`\x03\x81\x01\x80T`\xFF\x19\x16`\x01\x17\x90U`\x01`\x01`@\x1B\x03aI)aGA\x84\x8C\x8Aat\xEEV[\x16`\x01`\x01`@\x1B\x03`\x045\x16\x7F`\xA7d\x9Fn\x93\xE7\xA3\xCE\x1D\xC9r\x9C \xE3\xD9]\xCE(\xC6\xA6\xBD\x95|\xDE\t\xD8\xA1\xCB7\xC1\x9F_\x80\xA3`\x02\x85\x81\x01T`h\x1C`\xFF\x16aIo\x81a\"\xE3V[\x14\x80aI\x91W[\x15aH\xFDW`\x02aI\x8B\x91\x01T`\x045a\x99\x8EV[_aH\xFDV[P`\x02\x81\x01T\x15\x15aIvV[PaI\xB0a\x15\x8A`\x03\x83\x01T`\xFF\x16\x90V[aH\xF8V[\x82T`@Qc\x13\x11\x0F\x81`\xE2\x1B\x81R`\x04\x805`\x01`\x01`@\x1B\x03\x16\x90\x82\x01R`\xFF\x90\x91\x16`$\x82\x01R\x90` \x90\x82\x90`\x01`\x01`\xA0\x1B\x03\x16\x81\x80`D\x81\x01\x03\x91Z\xFA_\x91\x81aJ\x0EW[P\x15aH\xD5W\x90P_aH\xD5V[aJ'\x91\x92P` =\x81\x11a\x18\x18Wa\x18\t\x81\x83a'6V[\x90_aJ\0V[aJ\xAD\x95aJ\x8Ba\t\x8C\x92a\t\x9A\x95aJ\x85aJK\x8CT`\xFF\x16\x90V[\x99aGFaGA\x85aJaaGA\x82\x8D\x87at\xEEV[\x9AaJ\x7F`\x045`\x01`\x01`@\x1B\x03\x16_R`\x18` R`@_ \x90V[\x94at\xEEV[\x93au\xCDV[\x91`@Q\x97\x88\x95c\xC4\x0C\x80\xD1`\xE0\x1B` \x88\x01R3\x91`\x045`$\x89\x01an\rV[\x87\x86_\x89\x8C\x86aHOV[a\x07eaJ\xC9aGA\x84\x8B\x89at\xEEV[c[\xF3\xFEw`\xE1\x1B_R`\x01`\x01`@\x1B\x03`\x04\x805\x82\x16\x90R\x16`$R3`DR`d\x90V[a\x07eaK\x01aGA\x84\x8B\x89at\xEEV[c\nUQ/`\xE0\x1B_R`\x01`\x01`@\x1B\x03`\x04\x805\x82\x16\x90R\x16`$R`D\x90V[cx4\x82\xE9`\xE0\x1B_\x90\x81R`\x04\x805`\x01`\x01`@\x1B\x03\x16\x90R3`$R`D\x90\xFD[c\x1F\xECgG`\xE3\x1B_R`\x04_\xFD[`@Q\x90aKf` \x83a'6V[_\x82RV[\x80Q\x80\x83R` \x92\x91\x81\x90\x84\x01\x84\x84\x01^_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[\x90` a\x0B\xE6\x92\x81\x81R\x01\x90aKkV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFWa\x0B\xBD`@QaK\xC1`@\x82a'6V[`\x05\x81Rd\x03R\xE3\x02\xE3`\xDC\x1B` \x82\x01R`@Q\x91\x82\x91` \x83R` \x83\x01\x90aKkV[4a\x05\xAFWaK\xF56a>\x99V[\x90aK\xFEa\x876V[_\x91_\x91_[\x82\x81\x10aL&W\x83\x85aL\x15a\x87nV[`@\x80Q\x91\x82R` \x82\x01\x92\x90\x92R\xF3[aLNaL7aGA\x83\x86\x86at\xEEV[`\x01`\x01`@\x1B\x03\x16_R`\x1D` R`@_ \x90V[\x90aL[a\x15\x8A\x83a\x8E\x9BV[aN\xB9W\x81T`\x01`\x01`@\x1B\x03\x81\x16\x96` aL\x89\x89`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[_T\x90\x99\x90aL\xB4\x90aL\xA4\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x94`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x93aL\xC6\x8BT`\x01`\x01`@\x1B\x03\x16\x90V[`\x03\x88\x01T`\x04\x80\x8A\x01T`@Qc\x08\xD7\x95\xD5`\xE4\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x99\x90\x99\x16\x91\x89\x01\x91\x90\x91R`\x01`\x01`@\x1B\x03\x92\x83\x16`$\x89\x01R\x93\x90\x91\x16`D\x87\x01R`d\x86\x01R`\x84\x85\x01\x91\x90\x91R\x83\x90`\xA4\x90\x82\x90_\x90Z\xF1\x91\x82\x15a\x13cW\x86\x86\x85\x92_\x95aNpW[PaMkaMe\x86aMy\x96aM_\x82aMZaGA`\x01\x9Aa+\xF9\x9Aa\x159\x9Aat\xEEV[a\xA7\xBEV[Pau\xC0V[\x9Aat\xFEV[\x9AT`\x01`\x01`@\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16aM\x99W[PP`\x01\x91P[\x01\x93\x92\x93aL\x04V[_TaM\xAD\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x93T\x91`@\x83\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16`@Qc\x1C\x9D\x11\xBD`\xE3\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x82\x16`\x04\x82\x01R\x95\x90\x92\x90` \x90\x87\x90\x81\x80`$\x81\x01\x03\x91Z\xFA\x92\x83\x15a\x13cWa\t\x8CaN9\x95a\x1C\xA2\x95a\t\x9A\x94`\x01\x9A_\x92aNPW[P\x81\x15aN@WaN.a\x1CCaC\xDA\x93aC\xB4\x84aC\xAEa\x1Cj\x96ao#V[a\xFF\xFF`d\x91\x16\x04\x90V[_\x80aM\x89V[PPaC\xDAa\x1Cja'\x10aN.V[aNi\x91\x92P` =\x81\x11a\x13\\Wa\x13M\x81\x83a'6V[\x90_aN\rV[`\x01\x93\x95PaMea+\xF9\x93aMy\x96aM_a\x159\x95aMZaGAaN\xA7aMk\x98` =\x81\x11a\x13\\Wa\x13M\x81\x83a'6V[\x9C\x9APPP\x95PP\x96P\x93PPaM4V[`\x01\x91P\x94\x93\x94aM\x90V[\x81Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x82R` \x80\x84\x01Q\x90\x91\x16\x90\x82\x01R`@\x80\x83\x01Q`\x01`\x01`@\x1B\x03\x16\x90\x82\x01R``\x80\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90\x82\x01R`\x80\x82\x01Q`\xE0\x82\x01\x93\x92a\x05\xD1\x92\x91`\xC0\x91\x82\x91aO\"\x81a\"\xC7V[`\x80\x85\x01Ra-\xDF`\xA0\x82\x01Q`\xA0\x86\x01\x90a\"\xEDV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045aO^\x81a\x05\xB3V[aOfaryV[P\x16_R`\x05` Ra\x0B\xBD`@_ aP\x03aO\xFA`\x02`@Q\x93aO\x8B\x85a&\x8EV[\x80T`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x86R`\x01\x82\x01T\x90\x81\x16` \x87\x01RaO\xCB\x90aE\x93\x90aO\xC5`\xA0\x82\x90\x1C`\x01`\x01`@\x1B\x03\x16a$\x90V[`\xE0\x1C\x90V[\x01TaO\xDD`\xFF\x82\x16`\x80\x86\x01argV[aO\xF1`\x08\x82\x90\x1C`\xFF\x16`\xA0\x86\x01arpV[`\x10\x1C`\xFF\x16\x90V[\x15\x15`\xC0\x83\x01RV[`@Q\x91\x82\x91\x82aN\xC5V[4a\x05\xAFW`\x806`\x03\x19\x01\x12a\x05\xAFWaP(a\x8E\xE5V[`@QaP4\x81a&\xAEV[`\x045\x90aPA\x82a\x0E\xB6V[\x81\x81R`$5\x90aPQ\x82a\x0E\xB6V[\x81` \x82\x01Ra\xFF\xFF\x80`D5\x94aPh\x86a\x0E\xB6V[`@\x84\x01\x95\x86R```d5\x94aP~\x86a\x0E\xB6V[\x01\x93\x84R\x16\x92\x16\x82\x01\x80\x92\x11aP\xD8WaP\xADa\x1CCaP\xB3aP\xBC\x94aP\xADa\x1CCa'\x10\x98Qa\xFF\xFF\x16\x90V[\x90au\xC0V[\x92Qa\xFF\xFF\x16\x90V[\x03aP\xC9Wa\0\x18av\x0EV[cCtOq`\xE0\x1B_R`\x04_\xFD[ag\x83V[\x90` \x80\x83Q\x92\x83\x81R\x01\x92\x01\x90_[\x81\x81\x10aP\xFAWPPP\x90V[\x82Q`\x01`\x01`\xA0\x1B\x03\x16\x84R` \x93\x84\x01\x93\x90\x92\x01\x91`\x01\x01aP\xEDV[\x90` a\x0B\xE6\x92\x81\x81R\x01\x90aP\xDDV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045aQO\x81a\x05\xB3V[\x16_R`\x12` R`@_ `@Q\x90\x81` \x82T\x91\x82\x81R\x01\x91_R` _ \x90_[\x81\x81\x10aQ\x96Wa\x0B\xBD\x85aQ\x8A\x81\x87\x03\x82a'6V[`@Q\x91\x82\x91\x82aQ\x19V[\x82T\x84R` \x90\x93\x01\x92`\x01\x92\x83\x01\x92\x01aQsV[4a\x05\xAFW``6`\x03\x19\x01\x12a\x05\xAFW`\x045aQ\xC9\x81a\n\xAFV[`$5\x90aQ\xD6\x82a\n\xAFV[`D5aQ\xE2\x81a\n\xAFV[_\x80Q` a\xC9g\x839\x81Q\x91RT\x92`\x01`\x01`@\x1B\x03aR\x13`\xFF`@\x87\x90\x1C\x16\x15\x95`\x01`\x01`@\x1B\x03\x16\x90V[\x16\x80\x15\x90\x81aS,W[`\x01\x14\x90\x81aS\"W[\x15\x90\x81aS\x19W[PaS\nWaRr\x92\x84aRi`\x01`\x01`\x01`@\x1B\x03\x19_\x80Q` a\xC9g\x839\x81Q\x91RT\x16\x17_\x80Q` a\xC9g\x839\x81Q\x91RUV[aR\xD5Wa\xA8\x9BV[aRxW\0[aR\xA2`\xFF`@\x1B\x19_\x80Q` a\xC9g\x839\x81Q\x91RT\x16_\x80Q` a\xC9g\x839\x81Q\x91RUV[`@Q`\x01\x81R\x7F\xC7\xF5\x05\xB2\xF3q\xAE!u\xEEI\x13\xF4I\x9E\x1F&3\xA7\xB5\x93c!\xEE\xD1\xCD\xAE\xB6\x11Q\x81\xD2\x90\x80` \x81\x01a:\xE7V[aS\x05`\x01`@\x1B`\xFF`@\x1B\x19_\x80Q` a\xC9g\x839\x81Q\x91RT\x16\x17_\x80Q` a\xC9g\x839\x81Q\x91RUV[a\xA8\x9BV[c\xF9.\xE8\xA9`\xE0\x1B_R`\x04_\xFD[\x90P\x15_aR/V[0;\x15\x91PaR'V[\x85\x91PaR\x1DV[4a\x05\xAFWa\x01@6`\x03\x19\x01\x12a\x05\xAFW`\x045aSR\x81a\x05\xB3V[aS]`$5a\x05\xB3V[`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaS|\x906\x90`\x04\x01a\x05\xF8V[\x91\x90`d5\x906`\xC4\x11a\x05\xAFW6a\x01D\x11a\x05\xAFWaS\x9Ba\x87\x0FV[aS\xA3a\x876V[aS\xAC\x83a\x98\xDCV[\x93aS\xB9`$5\x85a\x99)V[\x94aS\xCEa\x159\x82T`\x01`\x01`@\x1B\x03\x16\x90V[\x91`\x03\x87\x01\x93aS\xDF\x85T`\xFF\x16\x90V[aW\xCDW`\x01\x84\x01T`\x01`\x01`\xA0\x1B\x03\x16_\x81aW>W[\x15aW\x0CWaT!\x90_\x90a\x1A,\x90\x8B\x90`\x01`\x01`\xA0\x1B\x03\x16\x80aVaW[PP\x88\x8Aa\xAA4V[\x80\x82\x10aV#WPP`\x845\x95`\xA45aT9a'\xB3V[\x97\x88R` \x88\x01R`@\x90aT\xE8a\x15\x8AaTS\x84a'\xC2V[`\xC4\x805\x82R\x9A`\xE45` \x83\x01RaTk\x86a'\xC2V[`@\x8D\x015\x81R``\x8D\x015` \x82\x01RaT\x84a'\xB3V[\x92\x83R` \x83\x01R\x8CaT\xE3aT\x9B6\x8B\x8Ba'\xEBV[\x80Q` \x91\x82\x01 \x89Q`\x01`\x01`\xC0\x1B\x03\x19`\xC0\x95\x86\x1B\x81\x16\x93\x82\x01\x93\x90\x93R`$5\x90\x94\x1B\x90\x91\x16`(\x84\x01R`0\x83\x01R\x81`P\x81\x01[\x03`\x1F\x19\x81\x01\x83R\x82a'6V[a\xBC\x9CV[aV\x14W`\x02\x97\x89aU\x0B`\x01\x8B\x99a+\xF9aU\x9A\x9C`\x01`\xFF\x19\x82T\x16\x17\x90UV[\x8C`\x01`\x01`\xA0\x1B\x03\x82\x16aU\xD1W[PP\x7F\xE6\xFC\xB34*\xBEC\xC2\x1A\xCCj\x04\xE3\xD7\x91$v\x83iv\xE0~\xD4}\x0B\x15\xA3t\xE2\0\xE2\xF0\x91P`\x01`\x01`@\x1B\x03\x16\x93\x84\x92aUh`\x01`\x01`@\x1B\x03`$5\x16\x97\x88\x96Q\x93\x84\x93\x84aw\x19V[\x03\x90\xA3\x7F`\xA7d\x9Fn\x93\xE7\xA3\xCE\x1D\xC9r\x9C \xE3\xD9]\xCE(\xC6\xA6\xBD\x95|\xDE\t\xD8\xA1\xCB7\xC1\x9F_\x80\xA3\x01T`h\x1C`\xFF\x16\x90V[aU\xA3\x81a\"\xE3V[\x14\x80aU\xC4W[aU\xB6Wa\0\x18a\x87nV[`\x02a6\xF4\x92\x01T\x90a\x99\x8EV[P`\x02\x82\x01T\x15\x15aU\xAAV[aV\x0B\x93a\t\x8CaU\xE6a\t\x9A\x93T`\xFF\x16\x90V[\x91`\x84\x88\x8C\x8C\x8CQ\x99\x8A\x97c\x15\x8B\xB2\xEB`\xE0\x1B` \x8A\x01R`$5\x91`$\x8A\x01av\xCCV[_\x89\x81\x8CaU\x1BV[c\xAB\x1B#k`\xE0\x1B_R`\x04_\xFD[`@Qc\n\xE5\x925`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x8A\x81\x16`\x04\x83\x01R`$\x805\x90\x91\x16\x90\x82\x01R`D\x81\x01\x92\x90\x92R`d\x82\x01R`\x84\x90\xFD[\x03\x90\xFD[aV\xB1\x91`@\x91aV}\x90`\x01`\x01`\xA0\x1B\x03\x16\x91T`\xFF\x16\x90V[\x82Qc\x12\xFEc'`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x8F\x16`\x04\x82\x01R`\xFF\x90\x91\x16`$\x82\x01R\x92\x83\x91\x90\x82\x90\x81\x90`D\x82\x01\x90V[\x03\x91Z\xFA\x90\x81_\x91_\x93aV\xD9W[PaV\xCEW[\x8C\x91PaT\x18V[\x91P\x91P_\x80aV\xC6V[\x90\x92PaV\xFE\x91P`@=`@\x11aW\x05W[aV\xF6\x81\x83a'6V[\x81\x01\x90av\xA7V[\x91_aV\xC0V[P=aV\xECV[a\x07e\x88aW\x1B\x8BT`\xFF\x16\x90V[c'\x9D\xB3u`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x90\x91\x16`\x04R`\xFF\x16`$R`D\x90V[aW\x8C` aWU`\x01`\x01`\xA0\x1B\x03\x85\x16a\x0F\xF0V[\x8CT`@Qc\x0C\xF6\xAD\xD9`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x8E\x16`\x04\x82\x01R`\xFF\x90\x91\x16`$\x82\x01R\x92\x83\x91\x90\x82\x90\x81\x90`D\x82\x01\x90V[\x03\x91Z\xFA_\x91\x81aW\xACW[PaW\xA4W[PaS\xF8V[\x90P_aW\x9EV[aW\xC6\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_aW\x98V[c\nUQ/`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x80\x88\x16`\x04R`$\x805\x91\x90\x91\x16\x90R`D_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `\x01`\x01`@\x1B\x03`\x04T\x16`@Q\x90\x81R\xF3[4a\x05\xAFWaX(6a\x06%V[aX0a\x87\x0FV[aX9\x83a\x86|V[`\x02\x81\x01TaXL\x90`\x10\x1C`\xFF\x16\x15\x90V[a[lW_TaXd\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\xEBG53`\xE0\x1B\x81R3`\x04\x82\x01R\x90\x91\x90` \x81`$\x81\x86Z\xFA\x90\x81\x15a\x13cW_\x91a[MW[P\x15a[:W`\x01`\x01`@\x1B\x03aX\xC1a\x08}3a\x08\xCA\x89`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x16a[\x1AW`@Qc\xD7u\xCBa`\xE0\x1B\x81R` \x81`\x04\x81\x86Z\xFA\x80\x15a\x13cW`\x01\x91_\x91aZ\xFBW[P\x91\x01\x80T\x90\x92`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x91\x82aZtW[`@Qc\xF4i\x13\xBB`\xE0\x1B\x81R3`\x04\x82\x01R`$\x81\x01\x82\x90R` \x81`D\x81\x86Z\xFA\x90\x81\x15a\x13cW_\x91aZUW[P\x15a\x12\xE6WP\x7F\xA9\xCF\x99\xC4\xC7[\xF0\x87Ev\xE6\xEEp\xB0\x0B\x92\x0E\x9C6U\x1EMl\x17iN\xCA\xA6\x84bM+\x93a\x07D\x93\x90\x92aZ\x10\x92P`\x01`\x01`\xA0\x1B\x03\x81\x16aZ(W[PaY\xE2`\x01`\x01`@\x1B\x03B\x16aY\xB0aY\x92a'WV[`\x01`\x01`@\x1B\x03\x83\x16\x81R\x91[`\x01`\x01`@\x1B\x03\x16` \x83\x01RV[`\x01`@\x82\x01R`\x01``\x82\x01RaY\xDD3a\x08\xCA\x8B`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[awRV[aZ\x013a\x11z\x89`\x01`\x01`@\x1B\x03\x16_R`\x08` R`@_ \x90V[Pa\t\x18a\x11\x91\x82T`\xE0\x1C\x90V[`@Q\x91\x82\x91`\x01`\x01`@\x1B\x033\x97\x16\x95\x83ag\xF1V[`@Qc3\xBC\x9Ec`\xE1\x1B` \x82\x01RaZO\x91a!!\x82a\t\x8C\x88\x8C3`$\x85\x01aw0V[_aYyV[aZn\x91P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[_aY6V[`\x04`@aZ\x8A`\x01`\x01`\xA0\x1B\x03\x86\x16a\x0F\xF0V[\x81Qc*nsa`\xE1\x1B\x81R\x92\x83\x91\x82\x90Z\xFA\x90\x81_\x91_\x93aZ\xD8W[PaZ\xB5W[PPaY\x05V[\x15\x80aZ\xCFW[aZ\xC7W[\x80aZ\xAEV[\x90P_aZ\xC1V[P\x80\x15\x15aZ\xBCV[\x90\x92PaZ\xF4\x91P`@=`@\x11a\x14\x17Wa\x14\x08\x81\x83a'6V[\x91_aZ\xA8V[a[\x14\x91P` =` \x11a\x13\\Wa\x13M\x81\x83a'6V[_aX\xECV[c\x9E\xC4\xE3\r`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x85\x16`\x04R3`$R`D_\xFD[cq\xABj\xD5`\xE1\x1B_R3`\x04R`$_\xFD[a[f\x91P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[_aX\x91V[c!\x0E\xB4\xED`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045a[\xA5\x81a\x05\xB3V[a[\xADa\x876V[a[\xB6\x81a\x98\xDCV[`\x02\x81\x01T`\x01`p\x82\x90\x1C`\xFF\x16a[\xCE\x81a\"\xE3V[\x03a@\xA6W`\x01\x90`h\x1C`\xFF\x16a[\xE5\x81a\"\xE3V[\x03a\x14=W`\x01\x81\x01\x80T\x90\x92`\x01`\x01`@\x1B\x03`@\x83\x90\x1C\x16\x80\x15\x15\x90\x81a^7W[Pa^\x1CW\x90`\x01\x91a\\Pa!\xCCa\\-a!G\x87T`\x01`\x01`@\x1B\x03\x16\x90V[a!\xC7a\\D`\x02\x83\x01T`\x01`\x01`@\x1B\x03\x16\x90V[\x96\x87\x92\x01T\x95`\xC0\x1C\x90V[B\x10a^\rWa\\q\x81`\x01`\x01`@\x1B\x03\x16_R`\x14` R`@_ \x90V[`\x01\x81\x01T\x83\x81\x10a]\xF6WPa\\\x8B\x83a\\\xAA\x92a\xBE\nV[\x86T`\x01`\x01`\xC0\x1B\x03\x16B`\xC0\x1B`\x01`\x01`\xC0\x1B\x03\x19\x16\x17\x90\x96UV[a\\\xCDa\\\xC8\x82`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[a\xBB3V[\x91a\\\xD8\x83Qah\xCAV[\x93_\x96_\x97[\x85Q\x89\x10\x15a]|Wa]t`\x01\x91a]\\a]Ia]A\x8Aa]-\x8Fa] \x90a]\x1A\x8E`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x93ai2V[Q`\x01`\x01`\xA0\x1B\x03\x16\x90V[`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[Ta\xFF\xFF\x16\x90V[a]S\x8D\x8Cai2V[\x90a\xFF\xFF\x16\x90RV[aP\xADa\x1CCa]l\x8D\x8Cai2V[Qa\xFF\xFF\x16\x90V[\x98\x01\x97a\\\xDEV[\x7F$\xDCH[\xEF\x04\xB4\xD7\x90\xD9z\xC1\x03\x81\xD8\xD9\xE6lV\xDDo\xBA\x991\xB7\x03\xCA\x16\x95\x11w\x8A\x96`\x01`\x01`@\x1B\x03\x96\x85a]\xC7\x94a]\xC1a]\xEB\x98\x9CT`\x01`\x01`@\x1B\x03\x16\x90V[\x89a\xB7\xC8V[`@Q\x93\x84\x93\x16\x95\x83\x90\x92\x91`\x01`\x01`@\x1B\x03` \x91`@\x84\x01\x95\x84R\x16\x91\x01RV[\x03\x90\xA2a\0\x18a\x87nV[c\x03\x9F\xF3\xB1`\xE4\x1B_R`\x04\x84\x90R`$R`D_\xFD[c\x1A\xB7\xDAk`\xE0\x1B_R`\x04_\xFD[c|>b\x1B`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x16`\x04R`$_\xFD[a^O\x91Pa!\xCC\x90`\x01`\x01`@\x1B\x03\x85\x16ao\xA3V[B\x11_a\\\nV[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` \x80T`@Q`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R\xF3[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFWa\0\x18`$5`\x045a^\xA0\x82a\n\xAFV[a^\xACa\x1Ak\x82amiV[a\xA2\xCDV[4a\x05\xAFWa^\xBF6a>\x99V[a^\xC7a\x876V[_\x90_\x92\x81\x15a_nW_[\x82\x81\x10a^\xE5WPPPaL\x15a\x87nV[a_\x02a^\xF3\x82\x85\x85at\xEEV[5a^\xFD\x81a\x05\xB3V[a\xAB\xAAV[a_\x0FW[`\x01\x01a^\xD3V[\x93\x92a_fa_``\x01\x92`\x01`\x01`@\x1B\x03a_-\x89\x88\x88at\xEEV[5a_7\x81a\x05\xB3V[\x16_R`\x10` R\x83a_Xa!G`@_ `\x01`\x01`@\x1B\x03\x90T\x16\x90V[\x01T\x90au\xC0V[\x94at\xFEV[\x94\x90Pa_\x07V[c\x1F* \x05`\xE0\x1B_R`\x04_\xFD[4a\x05\xAFWa_\x8B6a\x06%V[a_\xA9a\x08k\x84`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[`\x01`\x01`@\x1B\x03a_\xC2\x82T`\x01`\x01`@\x1B\x03\x16\x90V[\x16\x15a`vW\x7F\x85G\xE9K\xD9\\\xA7\xD3\xC7\xA3\xBE\x9Bf\xA2\x9Eo6\x15\x1B\xE5J%c\xE3P\x98C\x88a\xA4\xC8q\x91a`\x01a\x07D\x92`\x01`\x01`@\x1B\x03B\x16\x90ag\xA9V[a`!`\x01a+\xF9\x87`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16a`IW[P`@Q\x91\x82\x91`\x01`\x01`@\x1B\x033\x97\x16\x95\x83ag\xF1V[`@Qcz\xC7\x103`\xE1\x1B` \x82\x01Ra`p\x91a\t\x9A\x82a\t\x8C\x86\x8A3`$\x85\x01aw0V[_a`0V[c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R3`$R`D_\xFD[4a\x05\xAFWa`\xA46a\x06%V[`\x01`\x01`\xA0\x1B\x03a`\xB5\x84a\x86|V[T\x163\x03aa\x07W\x90\x7F0\xFCE\xE0Z3\xFD\x90h\xCFj\xE1\xA8\xF3\xDB+\x9D\x157-\xD6IN\xCC\xC8\xCD]0_\xDF8\xB3\x91`\x01`\x01`@\x1B\x03a`\xFF`@Q\x93\x84\x93` \x85R` \x85\x01\x91ag\xD1V[\x94\x16\x93\x03\x90\xA2\0[`\x01`\x01`@\x1B\x03\x83c#N\x07\x1D`\xE0\x1B_R\x16`\x04R3`$R`D_\xFD[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*\x81R\xF3[4a\x05\xAFW`@6`\x03\x19\x01\x12a\x05\xAFW`\x045`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaa\x91\x906\x90`\x04\x01a\x05\xF8V[PPa\x0B\xBD`$5aa\xA2\x81a\n\xAFV[aa\xAAa\x87\x0FV[`\x04T`\x01`\x01`@\x1B\x03\x16\x90aa\xC3a8G\x83ah\xADV[a9\taa\xCEa'\x85V[3\x81R`\x01`\x01`\xA0\x1B\x03\x83\x16` \x82\x01RB`\x01`\x01`@\x1B\x03\x16`@\x82\x01R_``\x82\x01R_`\x80\x82\x01R_`\xA0\x82\x01Ra8\xC6`\xC0\x82\x01`\x01\x90RV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045ab3\x81a\x05\xB3V[ab;ar\xD3V[P\x16_R`\x14` Ra\x0B\xBD`@_ `\x03`@Q\x91abZ\x83a&\xAEV[\x80T`\x01`\x01`\xA0\x1B\x03\x16\x80\x84R`\x01\x82\x01T` \x80\x86\x01\x91\x82R`\x02\x84\x01T`@\x80\x88\x01\x91\x82R\x95\x90\x94\x01T``\x96\x87\x01\x90\x81R\x85Q\x93\x84R\x91Q\x90\x83\x01R\x91Q\x92\x81\x01\x92\x90\x92RQ\x91\x81\x01\x91\x90\x91R\x90\x81\x90`\x80\x82\x01\x90V[\x91\x81`\x1F\x84\x01\x12\x15a\x05\xAFW\x825\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFW` \x80\x85\x01\x94\x84`\x07\x1B\x01\x01\x11a\x05\xAFWV[a\x01\x006`\x03\x19\x01\x12a\x05\xAFWab\xFAa\x05\xC4V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWac\x19\x906\x90`\x04\x01a\n\x7FV[\x91`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWac9\x906\x90`\x04\x01ab\xB5V[\x92\x90\x93`d5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWac[\x906\x90`\x04\x01a\x05\xF8V[\x94\x90\x95`\x845\x95`\x01`\x01`@\x1B\x03\x87\x11a\x05\xAFWa\x0B\xBD\x97ac\x85a\x0B\xA3\x986\x90`\x04\x01a\n\x7FV[\x94\x90\x93ac\x90a\x05\xD3V[\x96ac\x99a\n\xC0V[\x98`\xE45\x9Aaw\xC3V[`\x04\x11\x15a\"\xD1WV[\x90a\"\xE0\x82ac\xA3V[a\x01`a\x01 a\x0B\xE6\x93` \x84Rac\xDB` \x85\x01\x82Q`\x01`\x01`@\x1B\x03\x16\x90RV[` \x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16`@\x85\x01R`@\x81\x01Q`\x01`\x01`\xA0\x1B\x03\x16``\x85\x01R``\x81\x01Q`\x80\x85\x01R`\x80\x81\x01Q`\xA0\x85\x01R`\xA0\x81\x01Q`\xC0\x85\x01Rad9`\xC0\x82\x01Q`\xE0\x86\x01\x90`\x01`\x01`@\x1B\x03\x16\x90RV[`\xE0\x81\x01Q`\x01`\x01`@\x1B\x03\x16a\x01\0\x85\x01Rad_a\x01\0\x82\x01Q\x83\x86\x01\x90ac\xADV[\x01Q\x91a\x01@\x80\x82\x01R\x01\x90aKkV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x01`\x01`@\x1B\x03`\x045ad\x95\x81a\x05\xB3V[``a\x01 `@Qad\xA6\x81a&\xE4V[_\x81R_` \x82\x01R_`@\x82\x01R_\x83\x82\x01R_`\x80\x82\x01R_`\xA0\x82\x01R_`\xC0\x82\x01R_`\xE0\x82\x01R_a\x01\0\x82\x01R\x01R\x16_R`\x1D` Ra\x0B\xBD`@_ ae\xBB`\x06ad\xF7a'\xA3V[\x92ae0ae \x82Ta$Sae\x13\x82`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16\x88RV[`\x01`\x01`\xA0\x1B\x03\x16` \x86\x01RV[`\x01\x81\x01T`\x01`\x01`\xA0\x1B\x03\x16`@\x85\x01R`\x02\x81\x01T``\x85\x01R`\x03\x81\x01T`\x80\x85\x01R`\x04\x81\x01T`\xA0\x85\x01Rae\xB5ae\xAB`\x05\x83\x01Tae\x8Fae\x7F\x82`\x01`\x01`@\x1B\x03\x16\x90V[`\x01`\x01`@\x1B\x03\x16`\xC0\x89\x01RV[`\x01`\x01`@\x1B\x03`@\x82\x90\x1C\x16`\xE0\x88\x01R`\x80\x1C`\xFF\x16\x90V[a\x01\0\x86\x01a{\x14V[\x01a{\x1DV[a\x01 \x82\x01R`@Q\x91\x82\x91\x82ac\xB7V[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045ae\xEA\x81a\n\xAFV[ae\xF2a\x876V[ae\xFC\x813a\xA3\xC0V[\x90\x81af\x15W`\x01_\x80Q` a\xC9'\x839\x81Q\x91RU\0[`@Q\x91\x82R`\x01`\x01`\xA0\x1B\x03\x16\x903\x90\x7F\x93\x10\xCC\xFC\xB8\xDEr?W\x8A\x9EB\x82\xEA\x9FR\x1F\x05\xAE@\xDC\x08\xF3\x06\x8D\xFA\xD5(\xA6^\xE3\xC7\x90` \x90\xA3_\x80a\"lV[`\xA06`\x03\x19\x01\x12a\x05\xAFW`\x045afl\x81a\x05\xB3V[`$5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaf\x8B\x906\x90`\x04\x01a\n\x7FV[\x90\x91`D5`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFWaf\xAC\x906\x90`\x04\x01a\x05\xF8V[\x92\x90\x93`d5\x93`\x01`\x01`@\x1B\x03\x85\x11a\x05\xAFWa\x0B\xBD\x95af\xD6a\x0B\xA3\x966\x90`\x04\x01a\n\x7FV[\x94\x90\x93`\x845\x96af\xE6\x88a\x05\xB3V[a{\xBBV[4a\x05\xAFW` 6`\x03\x19\x01\x12a\x05\xAFW`\x045ag\x08\x81a\n\xAFV[ag\x10a\x8E\xE5V[`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a=\xB6W`\x01`\x01``\x1B\x03`\xA0\x1B`\x01T\x16\x17`\x01U_\x80\xF3[4a\x05\xAFW_6`\x03\x19\x01\x12a\x05\xAFW` `@Q\x7F\x18\x9A\xB7\xA9$M\xF0\x84\x81\"\x15C\x15\xAFq\xFE\x14\x0F=\xB0\xFE\x01@1x;\tF\xB8\xC9\xD2\xE3\x81R\xF3[cNH{q`\xE0\x1B_R_`\x04R`$_\xFD[cNH{q`\xE0\x1B_R`\x11`\x04R`$_\xFD[c\xFF\xFF\xFF\xFF\x16\x80\x15aP\xD8W_\x19\x01\x90V[\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x82T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17\x90UV[\x90\x80` \x93\x92\x81\x84R\x84\x84\x017_\x82\x82\x01\x84\x01R`\x1F\x01`\x1F\x19\x16\x01\x01\x90V[\x91` a\x0B\xE6\x93\x81\x81R\x01\x91ag\xD1V[\x9B\x9A\x99\x98\x97\x96\x95\x94\x93\x9Bah\x14a\x87\x0FV[ah\x1Ca\x876V[\x8C\x83\x03aKHWah,\x8Dah\x96V[\x93ah:`@Q\x95\x86a'6V[\x8D\x85R` \x85\x01\x9D`\x05\x1B\x81\x01\x906\x82\x11a\x05\xAFW\x9D\x81\x8F[\x10ahyWPPahe\x9B\x9CPa\x89\xC0V[`\x01_\x80Q` a\xC9'\x839\x81Q\x91RU\x90V[` \x8F\x91\x81\x925ah\x89\x81a\x0E\xB6V[\x81R\x01\x9E\x01\x9D\x81\x8FahSV[`\x01`\x01`@\x1B\x03\x81\x11a&\xA9W`\x05\x1B` \x01\x90V[`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x81\x14aP\xD8W`\x01\x01\x90V[\x90ah\xD4\x82ah\x96V[ah\xE1`@Q\x91\x82a'6V[\x82\x81R\x80\x92ah\xF2`\x1F\x19\x91ah\x96V[\x01\x90` 6\x91\x017V[cNH{q`\xE0\x1B_R`2`\x04R`$_\xFD[\x80Q\x15ai\x1DW` \x01\x90V[ah\xFCV[\x80Q`\x01\x10\x15ai\x1DW`@\x01\x90V[\x80Q\x82\x10\x15ai\x1DW` \x91`\x05\x1B\x01\x01\x90V[\x90\x91aiPa\x87\x0FV[aiXa\x876V[aia\x82a\x90xV[\x90ait`\x04\x83\x01T`\xFF\x90`H\x1C\x16\x90V[a1\x90W_\x93_[ai\x97\x85`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[T\x81\x10\x15al\x1AWa\x0F\xF0ai\xC4a/\xCC\x83a/\xC7\x89`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[\x14ai\xD1W`\x01\x01ai|V[P\x90\x91\x92\x93P`\x01[\x15a\x12\xA7Waj\x01a\x15\xE23a\x08\xCA\x87`\x01`\x01`@\x1B\x03\x16_R`\x0C` R`@_ \x90V[ak\xFAWaj \x84`\x01`\x01`@\x1B\x03\x16_R`\x0E` R`@_ \x90V[\x82\x82\x82Tak\xE9W[PPP_[\x82\x81\x10ak\xADWPajXa\x16%3a\x08\xCA\x87`\x01`\x01`@\x1B\x03\x16_R`\x0C` R`@_ \x90V[aj\xD7a\x159`\x01\x85\x01\x94aj\x9Baj{a\x11\x91\x88Tc\xFF\xFF\xFF\xFF\x90`\xA0\x1C\x16\x90V[\x87Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\xA0\x91\x90\x91\x1Bc\xFF\xFF\xFF\xFF`\xA0\x1B\x16\x17\x87UV[3`\x01`\x01`@\x1B\x03\x88\x16\x7F\xCE\xDA\x1AD\xEA\xD4\xDA=:\xBA\xAA\x94\x1A\xFAm\x950\xFD\x84\xDD\x8E\x998\\\x91\x83\xD9\x86\xDC\xAB\x98\x0F_\x80\xA3T`\x01`\x01`@\x1B\x03\x16\x90V[\x91\x80\x15ak\x9EWaj\xFEa\x1CjaN.`@aj\xF8`\x01\x95ak\r\x97al9V[\x01al\x95V[\x92\x01T`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16akWW[PPTc\xFF\xFF\xFF\xFFak7a0\xFA`\xA0\x84\x90\x1C\x83\x16a0\xEDV[\x91\x16\x14akHW[Pa\x05\xD1a\x87nV[akQ\x90a\x92\xF7V[_ak?V[`@Qc,Vz\xCD`\xE2\x1B` \x82\x01R3`$\x82\x01R`\x01`\x01`@\x1B\x03\x85\x16`D\x82\x01R`\xFF\x90\x91\x16`d\x82\x01Rak\x97\x91a\t\x9A\x82`\x84\x81\x01a\t\x8CV[_\x80ak\x1DV[PPak\r`\x01`d\x92a+\xF9V[`\x01\x90ak\xE3ak\xD23a\x08\xCA\x89`\x01`\x01`@\x1B\x03\x16_R`\x0F` R`@_ \x90V[ak\xDD\x83\x87\x87alBV[\x90al\x9FV[\x01aj.V[ak\xF2\x92a\x90\xB2V[_\x82\x82aj)V[c\x0F+\xB0\xF1`\xE4\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R3`$R`D_\xFD[P\x90\x91\x92\x93ai\xDAV[\x80T\x82\x10\x15ai\x1DW_R` _ \x01\x90_\x90V[\x90\x15ai\x1DW\x90V[\x91\x90\x81\x10\x15ai\x1DW``\x02\x01\x90V[\x80T\x82\x10\x15ai\x1DW_R` _ \x90`\x01\x1B\x01\x90_\x90V[`\x02\x11\x15a\x05\xAFWV[`D5a\x0B\xE6\x81alkV[5a\x0B\xE6\x81alkV[5a\x0B\xE6\x81a\n\xAFV[5a\x0B\xE6\x81a\x0E\xB6V[\x80T`\x01`@\x1B\x81\x10\x15a&\xA9Wal\xBC\x91`\x01\x82\x01\x81UalRV[am9W`\x01`@\x83a\x05\xD1\x945al\xD3\x81alkV[al\xDC\x81a\"\xC7V[`\xFF\x80\x19\x86T\x16\x91\x16\x17\x84Uam\x1B` \x82\x015al\xF9\x81a\n\xAFV[\x85Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x85UV[\x015\x91am'\x83a\x0E\xB6V[\x01\x90a\xFF\xFF\x16a\xFF\xFF\x19\x82T\x16\x17\x90UV[agpV[c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x81\x14aP\xD8W`\x01\x01\x90V[cNH{q`\xE0\x1B_R`\x12`\x04R`$_\xFD[_R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` R`\x01`@_ \x01T\x90V[\x90\x81` \x91\x03\x12a\x05\xAFWQ\x90V[`@Q=_\x82>=\x90\xFD[\x91\x90\x82`@\x91\x03\x12a\x05\xAFW` \x82Qam\xBA\x81a9\xB7V[\x92\x01Q\x90V[\x90\x81` \x91\x03\x12a\x05\xAFWQa\x0B\xE6\x81a9\xB7V[\x90`\x01\x82\x81\x1C\x92\x16\x80\x15an\x03W[` \x83\x10\x14am\xEFWV[cNH{q`\xE0\x1B_R`\"`\x04R`$_\xFD[\x91`\x7F\x16\x91am\xE4V[`\x01`\x01`@\x1B\x03\x91\x82\x16\x81R`\xFF\x90\x92\x16` \x83\x01R\x90\x91\x16`@\x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16``\x82\x01R`\xC0`\x80\x82\x01R\x81T\x94\x93_\x93\x90\x92\x90\x91\x90anW\x87am\xD5V[\x96\x87`\xC0\x84\x01R`\x01\x81\x16\x90\x81_\x14an\xC5WP`\x01\x14an\x87W[Pa\x0B\xE6\x94\x95P`\xA0\x81\x85\x03\x91\x01Rag\xD1V[\x90\x93P_R` _ _\x90[\x86\x82\x10an\xAEWP\x93\x94P\x84\x93\x83\x01`\xE0\x01\x92a\x0B\xE6ansV[`\x01\x81` \x92T`\xE0\x85\x89\x01\x01R\x01\x91\x01\x90an\x93V[\x90P`\xE0\x92\x95Pa\x0B\xE6\x96\x97\x91P`\xFF\x19\x16\x82\x86\x01R\x15\x15`\x05\x1B\x84\x01\x01\x92\x85\x94ansV[c\xFF\xFF\xFF\xFF\x81\x16\x03a\x05\xAFWV[\x90\x81` \x91\x03\x12a\x05\xAFWQa\x0B\xE6\x81an\xEBV[\x90\x81` \x91\x03\x12a\x05\xAFWQa\x0B\xE6\x81a\n\xAFV[\x90a'\x10\x82\x02\x91\x80\x83\x04a'\x10\x14\x90\x15\x17\x15aP\xD8WV[\x90`\x06\x82\x02\x91\x80\x83\x04`\x06\x14\x90\x15\x17\x15aP\xD8WV[\x81\x81\x02\x92\x91\x81\x15\x91\x84\x04\x14\x17\x15aP\xD8WV[\x81\x15aonW\x04\x90V[amUV[\x91ao\x9C`\xFF\x91`\x01`\x01`@\x1B\x03`@\x94\x97\x96\x97\x16\x85R``` \x86\x01R``\x85\x01\x90aKkV[\x94\x16\x91\x01RV[\x90`\x01`\x01`@\x1B\x03\x80\x91\x16\x91\x16\x01\x90`\x01`\x01`@\x1B\x03\x82\x11aP\xD8WV[\x81Q\x81T` \x84\x01Qa\x01\0`\x01`\xA8\x1B\x03`\x08\x91\x90\x91\x1B\x16`\xFF\x90\x92\x16`\x01`\x01`\xA8\x1B\x03\x19\x90\x91\x16\x17\x17\x81Ua\x05\xD1\x91`\x03\x90apc\x90`\xA0\x90`@\x81\x01Q\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA8\x1B\x19\x16`\xA8\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA8\x1B\x16\x17\x85U``\x81\x01QapR\x90c\xFF\xFF\xFF\xFF\x16`\x01\x87\x01\x90c\xFF\xFF\xFF\xFF\x16c\xFF\xFF\xFF\xFF\x19\x82T\x16\x17\x90UV[`\x80\x81\x01Q`\x02\x86\x01U\x01Q\x15\x15\x90V[\x91\x01\x90`\xFF\x80\x19\x83T\x16\x91\x15\x15\x16\x17\x90UV[\x91ap\x8F\x91\x83T\x90`\x03\x1B\x91\x82\x1B\x91_\x19\x90\x1B\x19\x16\x17\x90V[\x90UV[`\x1F\x82\x11ap\xA0WPPPV[_R` _ \x90` `\x1F\x84\x01`\x05\x1C\x83\x01\x93\x10ap\xD8W[`\x1F\x01`\x05\x1C\x01\x90[\x81\x81\x10ap\xCDWPPV[_\x81U`\x01\x01ap\xC2V[\x90\x91P\x81\x90ap\xB9V[\x90\x92\x91`\x01`\x01`@\x1B\x03\x81\x11a&\xA9Waq\x07\x81aq\x01\x84Tam\xD5V[\x84ap\x93V[_`\x1F\x82\x11`\x01\x14aqAW\x81\x90ap\x8F\x93\x94\x95_\x92aq6W[PP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[\x015\x90P_\x80aq\"V[`\x1F\x19\x82\x16\x94aqT\x84_R` _ \x90V[\x91_[\x87\x81\x10aq\x8EWP\x83`\x01\x95\x96\x97\x10aquW[PPP\x81\x1B\x01\x90UV[\x015_\x19`\x03\x84\x90\x1B`\xF8\x16\x1C\x19\x16\x90U_\x80\x80aqkV[\x90\x92` `\x01\x81\x92\x86\x86\x015\x81U\x01\x94\x01\x91\x01aqWV[\x90a\x0B\xE6\x95\x93`\xFF`\x80\x94`\x01`\x01`@\x1B\x03\x80\x94\x16\x85R\x16` \x84\x01R\x16`@\x82\x01R\x81``\x82\x01R\x01\x91ag\xD1V[a\x0B\xE6\x94\x92`\xFF``\x93\x16\x82R`\x01\x80`\xA0\x1B\x03\x16` \x82\x01R\x81`@\x82\x01R\x01\x91ag\xD1V[`@Q\x90a\x01\x80\x82\x01\x82\x81\x10`\x01`\x01`@\x1B\x03\x82\x11\x17a&\xA9W`@R_a\x01`\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x82`\xC0\x82\x01R\x82`\xE0\x82\x01R\x82a\x01\0\x82\x01R\x82a\x01 \x82\x01R\x82a\x01@\x82\x01R\x01RV[a\"\xE0\x82a\"\xC7V[a\"\xE0\x82a\"\xE3V[`@Q\x90ar\x86\x82a&\x8EV[_`\xC0\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x82``\x82\x01R\x82`\x80\x82\x01R\x82`\xA0\x82\x01R\x01RV[\x90ar\xB9\x81a\"\xE3V[\x81T`\xFF`p\x1B\x19\x16`p\x91\x90\x91\x1B`\xFF`p\x1B\x16\x17\x90UV[`@Q\x90ar\xE0\x82a&\xAEV[_``\x83\x82\x81R\x82` \x82\x01R\x82`@\x82\x01R\x01RV[`d5`\x03\x81\x10\x15a\x05\xAFW\x90V[\x90as\x10\x81a\"\xC7V[`\xFF\x80\x19\x83T\x16\x91\x16\x17\x90UV[\x90as(\x81a\"\xE3V[a\xFF\0\x82T\x91`\x08\x1B\x16\x90a\xFF\0\x19\x16\x17\x90UV[\x81Q\x81T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16\x17\x81Ua\x05\xD1\x91\x90at\x06\x90`\xC0\x90`\x02\x90` \x85\x01Q`\x01\x82\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x81Uas\xCF\x90`@\x87\x01Q\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\xA0\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\xA0\x1B\x16\x17\x81U``\x87\x01Qc\xFF\xFF\xFF\xFF\x16a\t\x18V[\x01\x92as\xE8`\x80\x82\x01Qas\xE2\x81a\"\xC7V[\x85as\x06V[as\xFF`\xA0\x82\x01Qas\xF9\x81a\"\xE3V[\x85as\x1EV[\x01Q\x15\x15\x90V[\x81Tb\xFF\0\0\x19\x16\x90\x15\x15`\x10\x1Bb\xFF\0\0\x16\x17\x90UV[5a\x0B\xE6\x81a\x05\xB3V[at=`D5at7\x81alkV[\x82as\x06V[`d5`\x03\x81\x10\x15a\x05\xAFWatS\x90\x82as\x1EV[`\x845at_\x81an\xEBV[e\xFF\xFF\xFF\xFF\0\0\x82T\x91`\x10\x1B\x16\x90e\xFF\xFF\xFF\xFF\0\0\x19\x16\x17\x81Uat\xAF`\xA45at\x89\x81an\xEBV[\x82Ti\xFF\xFF\xFF\xFF\0\0\0\0\0\0\x19\x16`0\x91\x90\x91\x1Bi\xFF\xFF\xFF\xFF\0\0\0\0\0\0\x16\x17\x82UV[`\xC45`\x01\x82\x01Uat\xE3at\xC4`\xE4at\x1EV[`\x02\x83\x01\x90`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90UV[`\x03a\x01\x045\x91\x01UV[\x91\x90\x81\x10\x15ai\x1DW`\x05\x1B\x01\x90V[_\x19\x81\x14aP\xD8W`\x01\x01\x90V[_\x19\x81\x01\x91\x90\x82\x11aP\xD8WV[\x91\x90\x82\x03\x91\x82\x11aP\xD8WV[\x99\x98\x97\x96\x95\x94\x93\x92\x91\x90au9a\x87\x0FV[auAa\x876V[auJ\x82ah\xCAV[\x9A_[\x83\x81\x10aubWP\x90ahe\x9A\x9B\x92\x91a\x89\xC0V[\x80a'\x10aus\x8F\x93`\x01\x94ai2V[R\x01auMV[\x90`\x01\x82\x01\x80\x92\x11aP\xD8WV[\x90`\x02\x82\x01\x80\x92\x11aP\xD8WV[\x90`\x03\x82\x01\x80\x92\x11aP\xD8WV[\x90`\x04\x82\x01\x80\x92\x11aP\xD8WV[\x90`\x05\x82\x01\x80\x92\x11aP\xD8WV[\x91\x90\x82\x01\x80\x92\x11aP\xD8WV[\x91\x90\x81\x10\x15ai\x1DW`\x05\x1B\x81\x015\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x05\xAFW\x01\x90\x815\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFW` \x01\x826\x03\x81\x13a\x05\xAFW\x91\x90V[a\xFF\xFF`\x045av\x1D\x81a\x0E\xB6V[\x16a\xFF\xFF\x19`\x02T\x16\x17`\x02U`$5av6\x81a\x0E\xB6V[c\xFF\xFF\0\0`\x02T\x91`\x10\x1B\x16\x90c\xFF\xFF\0\0\x19\x16\x17`\x02U`D5av[\x81a\x0E\xB6V[e\xFF\xFF\0\0\0\0`\x02T\x91` \x1B\x16\x90e\xFF\xFF\0\0\0\0\x19\x16\x17`\x02U`d5av\x84\x81a\x0E\xB6V[g\xFF\xFF\0\0\0\0\0\0`\x02T\x91`0\x1B\x16\x90g\xFF\xFF\0\0\0\0\0\0\x19\x16\x17`\x02UV[\x91\x90\x82`@\x91\x03\x12a\x05\xAFW` \x82Qav\xC0\x81a\x0E\xB6V[\x92\x01Qa\x0B\xE6\x81a\x1E^V[\x93`\xE0\x95`\x01`\x01`@\x1B\x03`@\x95`\xFF`\x80\x9B\x96\x83\x9B\x9E\x9D\x9Baw\x0B\x97\x16\x8AR\x16` \x89\x01R\x16\x85\x87\x01Ra\x01```\x87\x01Ra\x01`\x86\x01\x91ag\xD1V[\x97\x86\x84\x01R`\xA0\x83\x017\x017V[`@\x90a\x0B\xE6\x94\x92\x81R\x81` \x82\x01R\x01\x91ag\xD1V[`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x81R`@` \x82\x01\x81\x90Ra\x0B\xE6\x93\x91\x01\x91ag\xD1V[\x81Q\x81Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x91\x90\x91\x16\x17\x81U\x90aw\x88`\x01`\x01`@\x1B\x03` \x83\x01Q\x16\x83ag\xA9V[`@\x81\x01Q\x82T`\xFF`\x80\x1B\x19\x16\x90\x15\x15`\x80\x1B`\xFF`\x80\x1B\x16\x17``\x90\x91\x01Q`\xFF`\x88\x1B\x19\x90\x91\x16\x90\x15\x15`\x88\x1B`\xFF`\x88\x1B\x16\x17\x90UV[\x98\x92\x99\x93\x95\x9B\x9A\x94\x9B\x97\x91\x97\x96\x90\x96aw\xDAa\x87\x0FV[aw\xE2a\x876V[\x86\x15ay@W_[\x87\x8C\x81\x83\x10ax\xD1WPPPaw\xFF\x89ah\xCAV[\x9C_[\x8A\x81\x10ax\xB3WP\x8A\x9B\x9C\x9D\x8A\x8Aax\x1C\x9A\x9B\x9C\x9Da\x89\xC0V[\x94_[\x82\x81\x10ax{WP\x90\x7F\xE9\xB9\xD9A\xD3\x17b\xEB\xEBz\0\0\x8BL\xF9^\x9A\x19%\\\xB6i\\\x9D5!\\\x91J~\x84\x86\x91axp`@Q\x92\x83\x92`\x01`\x01`@\x1B\x033\x99\x16\x97`\x01`\x01`@\x1B\x03\x8B\x16\x97\x85azlV[\x03\x90\xA4a\x0B\xE6a\x87nV[`\x01\x90ax\xADax\x9C\x89`\x01`\x01`@\x1B\x03\x16_R`\x0E` R`@_ \x90V[ax\xA7\x83\x87\x87ayOV[\x90ay_V[\x01ax\x1FV[\x80\x8Fax\xC4`\x01\x93ax\xCB\x92ai2V[a'\x10\x90RV[\x01ax\x02V[ax\xDC\x91\x83\x91ayOV[`@\x81\x01ax\xECa\x1CC\x82al\x95V[\x15ay1Wax\xFC``\x91al\x95V[\x91\x01\x90a\xFF\xFFay\x0Ea\x1CC\x84al\x95V[\x91\x16\x11ay1Way$a\x1CCa'\x10\x92al\x95V[\x11ay1W`\x01\x01aw\xEAV[ci#\xAF\xCF`\xE0\x1B_R`\x04_\xFD[c@\xEB~\xB5`\xE1\x1B_R`\x04_\xFD[\x91\x90\x81\x10\x15ai\x1DW`\x07\x1B\x01\x90V[\x80T`\x01`@\x1B\x81\x10\x15a&\xA9Way|\x91`\x01\x82\x01\x81UalRV[\x91\x90\x91am9W```\x01a\x05\xD1\x93\x835ay\x96\x81alkV[ay\x9F\x81a\"\xC7V[`\xFF\x80\x19\x83T\x16\x91\x16\x17\x81Uay\xDE` \x85\x015ay\xBC\x81a\n\xAFV[\x82Ta\x01\0`\x01`\xA8\x1B\x03\x19\x16`\x08\x91\x90\x91\x1Ba\x01\0`\x01`\xA8\x1B\x03\x16\x17\x82UV[\x01\x91az\x03`@\x82\x015ay\xF1\x81a\x0E\xB6V[\x84Ta\xFF\xFF\x19\x16a\xFF\xFF\x90\x91\x16\x17\x84UV[\x015\x90az\x0F\x82a\x0E\xB6V[\x90c\xFF\xFF\0\0\x82T\x91`\x10\x1B\x16\x90c\xFF\xFF\0\0\x19\x16\x17\x90UV[\x91` \x90\x82\x81R\x01\x91\x90_[\x81\x81\x10azBWPPP\x90V[\x90\x91\x92` \x80`\x01\x92\x865azV\x81a\n\xAFV[\x84\x80`\xA0\x1B\x03\x16\x81R\x01\x94\x01\x91\x01\x91\x90\x91az5V[\x90az\x85\x90` \x93\x95\x94\x95`@\x84R`@\x84\x01\x91az)V[\x90\x82\x81\x83\x03\x91\x01R\x82\x81R\x01\x91\x90_[\x81\x81\x10az\xA2WPPP\x90V[\x90\x91\x92`\x80\x80`\x01\x92\x865az\xB6\x81alkV[az\xBF\x81a\"\xC7V[\x81R` \x87\x015az\xCF\x81a\n\xAFV[\x84\x80`\xA0\x1B\x03\x16` \x82\x01Ra\xFF\xFF`@\x88\x015az\xEC\x81a\x0E\xB6V[\x16`@\x82\x01Ra\xFF\xFF``\x88\x015a{\x03\x81a\x0E\xB6V[\x16``\x82\x01R\x01\x94\x01\x92\x91\x01az\x95V[a\"\xE0\x82ac\xA3V[\x90`@Q\x91\x82_\x82T\x92a{0\x84am\xD5V[\x80\x84R\x93`\x01\x81\x16\x90\x81\x15a{\x99WP`\x01\x14a{UW[Pa\x05\xD1\x92P\x03\x83a'6V[\x90P_\x92\x91\x92R` _ \x90_\x91[\x81\x83\x10a{}WPP\x90` a\x05\xD1\x92\x82\x01\x01_a{HV[` \x91\x93P\x80`\x01\x91T\x83\x85\x89\x01\x01R\x01\x91\x01\x90\x91\x84\x92a{dV[\x90P` \x92Pa\x05\xD1\x94\x91P`\xFF\x19\x16\x82\x84\x01R\x15\x15`\x05\x1B\x82\x01\x01_a{HV[\x96\x90\x95\x97\x93\x92\x94\x91\x97a{\xCCa\x87\x0FV[a{\xD4a\x876V[a{\xDD\x88a\x86|V[\x98`\x02\x8A\x01\x97a{\xF5a\x15\x8A\x8AT`\xFF\x90`\x10\x1C\x16\x90V[a\x81AWa|\x12\x84\x8B`\x03Ta|\x0C6\x87\x87a\x82\x19V[\x90a\xAD@V[\x99\x90\x98_[\x8BQ\x81\x10\x15a|\x95Wa|Na!\xCCa\x08}\x8F\x8F\x90a] \x86a]\x1Aa]-\x93`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x15a|[W`\x01\x01a|\x17V[\x8Ca|la] a\x07e\x93\x8Fai2V[c\x9B\xCC\xCB\xFD`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x90\x91\x16`\x04R`\x01`\x01`\xA0\x1B\x03\x16`$R`D\x90V[P\x90\x91\x92\x93\x94\x95\x96\x98\x9B`\x01\x90\x9B\x9A\x98\x9B\x01\x98a|\xB8\x8AT`\x01\x80`\xA0\x1B\x03\x16\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x15\x80a\x818W[a\x80\xB1W[P\x8C4\x10a\x80\x99W\x86\x94\x92\x8D\x8A\x99\x97\x95\x93a}:\x9E\x9F\x99\x93\x8E\x94\x8C\x8Fa}\x04\x90\x864\x11a\x80\x87W[T`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x92`\x01`\x01`\xA0\x1B\x03\x84\x16a\x80SW[PPPPPPa}ga}3`\x04T`\x01`\x01`@\x1B\x03\x90`\x80\x1C\x16\x90V[\x9D\x8Eah\xADV[`\x04\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x92\x90\x92\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x91\x90\x91\x17\x90UV[a}\x82\x82`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[`\x01`\x01`@\x1B\x03B\x16\x91a}\x9B\x8BQc\xFF\xFF\xFF\xFF\x16\x90V[\x91Tc\xFF\xFF\xFF\xFF`\x10\x82\x90\x1C\x16\x80\x15a\x80GW\x90`0\x1Cc\xFF\xFF\xFF\xFF\x16[\x91T\x92`\xFF\x84\x16\x93`\x08\x1C`\xFF\x16\x94a}\xD0a'uV[`\x01`\x01`@\x1B\x03\x90\x97\x16\x87R3` \x88\x01R`\x01`\x01`@\x1B\x03\x81\x16`@\x88\x01R`\x01`\x01`@\x1B\x03\x8B\x16``\x88\x01R_`\x80\x88\x01R`\x01`\x01`@\x1B\x03\x16`\xA0\x87\x01Rc\xFF\xFF\xFF\xFF\x16`\xC0\x86\x01Rc\xFF\xFF\xFF\xFF\x16`\xE0\x85\x01Rc\xFF\xFF\xFF\xFF\x16a\x01\0\x84\x01Ra~E\x90a\x01 \x84\x01argV[a~S\x90a\x01@\x83\x01arpV[`\x01a\x01`\x82\x01Ra~v\x8C`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[\x90a~\x80\x91a\x845V[\x86Qa~\x8B\x90ah\xCAV[\x97a~\x98\x92\x89\x92\x8Da\xAFmV[\x963a~\xB5\x8B`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[\x90a~\xBF\x91a\x99\x16V[P_[\x82\x81\x10a\x80\x0BWPa\x7F\x1E\x90`\x01`\x01`@\x1B\x03\x8A\x16_`\x01`\x01`@\x1B\x03\x8D\x16\x7Ft\x1E\x97\xEE\x1F\xF8\x87\xC4\xD8\x82\xF4\xC4\x9A\xD2\x80\xEA}a\xD05\xE4\xE8\xA4q\xE51\x95\x15P'P#\x82\x80\xA4\x80Ta|\xF7\x903\x90`\x01`\x01`\xA0\x1B\x03\x16\x8Da\xB0\xD9V[\x92`\x01`\x01`\xA0\x1B\x03\x84\x16a\x7FYW[PPPP\x80a\x7FEW[PPPPPa\x0B\xE6a\x87nV[a\x7FO\x94\x86a\xB5VV[_\x80\x80\x80\x80a\x7F8V[\x91\x81\x89\x93a\x7Foa\x7Fj\x8D\x95auzV[ah\xCAV[\x91a\x7F\x8C3a\x7F}\x85ai\x10V[`\x01`\x01`\xA0\x1B\x03\x90\x91\x16\x90RV[_[\x81\x81\x10a\x7F\xCCWPPP\x91a\t\x8Ca\t\x9A\x92a\x7F\xC3\x96\x94`@Q\x96\x87\x94c \xA8{9`\xE2\x1B` \x87\x01R3\x91`$\x87\x01a\x86\x13V[_\x80\x80\x80a\x7F.V[\x90\x92\x94P\x81\x93\x95Pa\x7F\xFEa\x7F\xECa\x7F\xE7\x83\x86`\x01\x96at\xEEV[al\x8BV[a\x7F}a\x7F\xF8\x84auzV[\x88ai2V[\x01\x91\x8B\x93\x91\x8B\x95\x93a\x7F\x8EV[`\x01\x90a\x80@a\x80,\x8D`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[a\x80:a\x7F\xE7\x84\x88\x8Bat\xEEV[\x90a\x99\x16V[P\x01a~\xC2V[Pa}\xB9`\x01\x91a*\xD1V[a\x80|\x95a!!\x93a\t\x8C\x92`@Q\x97\x88\x95caFl\t`\xE1\x1B` \x88\x01R3`$\x88\x01a\x83bV[\x87_\x80\x88\x8C\x82a}\x14V[a\x80\x94a@\x92\x884au\x1AV[a|\xF7V[c\x9Aj\xE6\r`\xE0\x1B_R`\x04\x8D\x90R4`$R`D_\xFD[a\x80\xC3\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\xE3\x90\xFC\xDB`\xE0\x1B\x81R_`\x04\x82\x01\x81\x90R`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90Z\xFA_\x91\x81a\x81\x17W[P\x15a|\xCFW\x15a\x81\x03W_a|\xCFV[c\tD\x03\xB7`\xE4\x1B_\x90\x81R`\x04R`$_\xFD[a\x811\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_a\x80\xF2V[P\x8D\x15\x15a|\xCAV[c!\x0E\xB4\xED`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x8A\x16`\x04R`$_\xFD[\x81`\x1F\x82\x01\x12\x15a\x05\xAFW\x805\x90a\x81t\x82ah\x96V[\x92a\x81\x82`@Q\x94\x85a'6V[\x82\x84R` ``\x81\x86\x01\x94\x02\x83\x01\x01\x91\x81\x83\x11a\x05\xAFW` \x01\x92[\x82\x84\x10a\x81\xACWPPPP\x90V[\x83\x82\x03``\x81\x12a\x05\xAFW`@\x80Q\x91a\x81\xC5\x83a'\0V[\x12a\x05\xAFW``\x91` \x91`@Qa\x81\xDC\x81a'\0V[\x875a\x81\xE7\x81alkV[\x81R\x83\x88\x015a\x81\xF6\x81a\n\xAFV[\x84\x82\x01R\x81R`@\x87\x015a\x82\n\x81a\x0E\xB6V[\x83\x82\x01R\x81R\x01\x93\x01\x92a\x81\x9EV[\x92\x91\x90\x92a\x82&\x84ah\x96V[\x93a\x824`@Q\x95\x86a'6V[` \x85\x82\x81R\x01\x90`\x05\x1B\x82\x01\x91\x83\x83\x11a\x05\xAFW\x80\x91[\x83\x83\x10a\x82ZWPPPPPV[\x825`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFW\x82\x01\x90``\x82\x87\x03\x12a\x05\xAFW`@Q\x90a\x82\x84\x82a'\x1BV[\x825`\x01`\x01`@\x1B\x03\x81\x11a\x05\xAFW\x83\x01`\xC0\x81\x89\x03\x12a\x05\xAFW`@Q\x90a\x82\xAD\x82a&\xC9V[\x805a\x82\xB8\x81a\x05\xB3V[\x82Ra\x82\xC6` \x82\x01a\x05\xEDV[` \x83\x01R`@\x81\x015`@\x83\x01Ra\x82\xE1``\x82\x01a\x05\xEDV[``\x83\x01Ra\x82\xF2`\x80\x82\x01a\x05\xEDV[`\x80\x83\x01R`\xA0\x81\x015\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFWa\x83\x17\x91\x8A\x91\x01a\x81]V[`\xA0\x82\x01R\x82R` \x83\x015\x91`\x01`\x01`@\x1B\x03\x83\x11a\x05\xAFWa\x83R`@\x85a\x83H\x8B` \x98\x97\x89\x98\x01a(!V[\x86\x85\x01R\x01a\n\xDAV[`@\x82\x01R\x81R\x01\x92\x01\x91a\x82LV[\x92`\xC0\x94a\x83\x9B`\x01`\x01`@\x1B\x03\x94a\x83\xA9\x94\x9A\x99\x98\x9A_\x88R`\x01\x80`\xA0\x1B\x03\x16` \x88\x01R`\xE0`@\x88\x01R`\xE0\x87\x01\x90aP\xDDV[\x91\x85\x83\x03``\x87\x01Rag\xD1V[\x95\x16`\x80\x82\x01R_`\xA0\x82\x01R\x01RV[\x80Th\x01\0\0\0\0\0\0\0\0`\x01`\xE0\x1B\x03\x19\x16`@\x92\x90\x92\x1Bh\x01\0\0\0\0\0\0\0\0`\x01`\xE0\x1B\x03\x16\x91\x90\x91\x17\x90UV[\x90a\x83\xF7\x81a\"\xC7V[\x81T`\xFF``\x1B\x19\x16``\x91\x90\x91\x1B`\xFF``\x1B\x16\x17\x90UV[\x90a\x84\x1B\x81a\"\xE3V[\x81T`\xFF`h\x1B\x19\x16`h\x91\x90\x91\x1B`\xFF`h\x1B\x16\x17\x90UV[\x90a\x01``\x02a\x05\xD1\x93a\x84pa\x84S\x85Q`\x01`\x01`@\x1B\x03\x16\x90V[\x82Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x90\x91\x16\x17\x82UV[` \x84\x01Qa\x84\x89\x90`\x01`\x01`\xA0\x1B\x03\x16[\x82a\x83\xBAV[a\x851`\x01\x82\x01a\x84\xA7a\x84S`@\x88\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x84\xC4a\x84\xBE``\x88\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[\x82ag\xA9V[a\x85\x03a\x84\xDB`\x80\x88\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[\x82Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x82UV[`\xA0\x86\x01Q`\x01`\x01`@\x1B\x03\x16\x81T`\x01`\x01`\xC0\x1B\x03\x16`\xC0\x91\x90\x91\x1B`\x01`\x01`\xC0\x1B\x03\x19\x16\x17\x90UV[\x01\x91a\x85]a\x85G`\xC0\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x84Tc\xFF\xFF\xFF\xFF\x19\x16c\xFF\xFF\xFF\xFF\x90\x91\x16\x17\x84UV[a\x85\x93a\x85q`\xE0\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x84Tg\xFF\xFF\xFF\xFF\0\0\0\0\x19\x16` \x91\x90\x91\x1Bg\xFF\xFF\xFF\xFF\0\0\0\0\x16\x17\x84UV[a\x85\xD2a\x85\xA8a\x01\0\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x84Tk\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x19\x16`@\x91\x90\x91\x1Bk\xFF\xFF\xFF\xFF\0\0\0\0\0\0\0\0\x16\x17\x84UV[a\x85\xEAa\x01 \x82\x01Qa\x85\xE4\x81a\"\xC7V[\x84a\x83\xEDV[a\x86\x02a\x01@\x82\x01Qa\x85\xFC\x81a\"\xE3V[\x84a\x84\x11V[\x01Q\x90a\x86\x0E\x82a\"\xE3V[ar\xAFV[\x93`\xA0\x93`\x01`\x01`@\x1B\x03\x80\x94\x81ao\x9C\x95\x9A\x99\x9A\x16\x88R_` \x89\x01R\x16`@\x87\x01R`\x01\x80\x86\x1B\x03\x16``\x86\x01R`\xC0`\x80\x86\x01R`\xC0\x85\x01\x90aP\xDDV[\x90ap\x8F\x90a\x86c\x81ac\xA3V[\x82T`\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1B`\xFF`\x80\x1B\x16\x17\x90V[`\x01`\x01`@\x1B\x03\x80`\x04T\x16\x91\x16\x90\x81\x10\x15a\x86\xA1W_R`\x05` R`@_ \x90V[c\x17\xF4\x92;`\xE2\x1B_R`\x04R`$_\xFD[=\x15a\x86\xDDW=\x90a\x86\xC4\x82a'\xD0V[\x91a\x86\xD2`@Q\x93\x84a'6V[\x82R=_` \x84\x01>V[``\x90V[_\x91\x82\x91\x82` \x83Q\x93\x01\x91Z\xF1Pa\x86\xF9a\x86\xB3V[PV[a\x0B\xE6\x91`\x01`\x01`\xA0\x1B\x03\x16\x90a\xB3\xDCV[`\xFF_\x80Q` a\xC9\x07\x839\x81Q\x91RT\x16a\x87'WV[c\xD9<\x06e`\xE0\x1B_R`\x04_\xFD[`\x02_\x80Q` a\xC9'\x839\x81Q\x91RT\x14a\x87_W`\x02_\x80Q` a\xC9'\x839\x81Q\x91RUV[c>\xE5\xAE\xB5`\xE0\x1B_R`\x04_\xFD[`\x01_\x80Q` a\xC9'\x839\x81Q\x91RUV[\x90a\x88\xFBa\x01``\x04a\x05\xD1\x94a\x87\xA2a\x84S\x86Q`\x01`\x01`@\x1B\x03\x16\x90V[` \x85\x01Qa\x87\xB9\x90`\x01`\x01`\xA0\x1B\x03\x16a\x84\x83V[a\x88M`\x01\x82\x01a\x87\xD7a\x84S`@\x89\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x87\xEEa\x84\xBE``\x89\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x88\"a\x88\x02`\x80\x89\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x82Tc\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x91\x90\x91\x1Bc\xFF\xFF\xFF\xFF`\x80\x1B\x16\x17\x82UV[`\xA0\x87\x01Qc\xFF\xFF\xFF\xFF\x16\x81Tc\xFF\xFF\xFF\xFF`\xA0\x1B\x19\x16`\xA0\x91\x90\x91\x1Bc\xFF\xFF\xFF\xFF`\xA0\x1B\x16\x17\x90UV[`\xC0\x85\x01Q`\x02\x82\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90\x91\x17\x90U`\xE0\x85\x01Q`\x03\x82\x01U\x01\x92a\x88\x91a\x01\0\x82\x01Qas\xE2\x81a\"\xC7V[a\x88\xC2a\x88\xA6a\x01 \x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x85Td\xFF\xFF\xFF\xFF\0\x19\x16`\x08\x91\x90\x91\x1Bd\xFF\xFF\xFF\xFF\0\x16\x17\x85UV[as\xFFa\x88\xD7a\x01@\x83\x01Qc\xFF\xFF\xFF\xFF\x16\x90V[\x85Th\xFF\xFF\xFF\xFF\0\0\0\0\0\x19\x16`(\x91\x90\x91\x1Bh\xFF\xFF\xFF\xFF\0\0\0\0\0\x16\x17\x85UV[\x81Ti\xFF\0\0\0\0\0\0\0\0\0\x19\x16\x90\x15\x15`H\x1B`\xFF`H\x1B\x16\x17\x90UV[\x80T`\x01`@\x1B\x81\x10\x15a&\xA9Wa\x898\x91`\x01\x82\x01\x81Ual$V[\x81T`\x01`\x01`\xA0\x1B\x03\x93\x84\x16`\x03\x92\x90\x92\x1B\x91\x82\x1B\x93\x90\x91\x1B\x19\x16\x91\x90\x91\x17\x90UV[\x95\x90a\x89\xA7\x93`\x01`\x01`@\x1B\x03\x95`\xC0\x99\x9C\x9B\x9A\x97\x94\x87a\x89\x99\x94\x16\x8AR`\x01\x80`\xA0\x1B\x03\x16` \x8A\x01R`\xE0`@\x8A\x01R`\xE0\x89\x01\x91az)V[\x91\x86\x83\x03``\x88\x01Rag\xD1V[\x96\x16`\x80\x83\x01R`\x01`\x01`\xA0\x1B\x03\x16`\xA0\x82\x01R\x01RV[\x97\x90\x94\x96\x9A\x99\x92\x93\x98\x91\x95\x86\x15a\x8E\x8CWa\x15\x8A\x9Ba\x89\xDE\x8Aa\x86|V[a\x89\xF2`\x02\x82\x01\x9E\x8FT`\xFF\x90`\x10\x1C\x16\x90V[a\x8EpW`\x01\x01\x80T\x90\x92\x90`\x01`\x01`\xA0\x1B\x03\x16\x80\x15\x15\x80a\x8EgW[a\x8D\xD0W[P_[\x88\x8C\x8B\x80\x84\x10a\x8DlWPPPPa\x8A14\x87\x87a\xA1\xF3V[`\x04T`@\x1C`\x01`\x01`@\x1B\x03\x16\x96a\x8Ava\x8AM\x89ah\xADV[g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B`\x04T\x91`@\x1B\x16\x90g\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`@\x1B\x19\x16\x17`\x04UV[\x87\x9Ea\x8A\x93\x8D`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[Tc\xFF\xFF\xFF\xFF`\x10\x82\x90\x1C\x16\x90\x81\x15a\x8DeW\x81[\x8Dc\xFF\xFF\xFF\xFF\x82\x16\x11a\x8DFWP`0\x1Cc\xFF\xFF\xFF\xFF\x16\x91c\xFF\xFF\xFF\xFF\x83\x16\x80\x15\x15\x90\x81a\x8D<W[Pa\x8D\x1DWT\x8E\x92\x91\x90`\xFF\x16\x90c\xFF\xFF\xFF\xFF\x81\x16\x15a\x8D\x14W\x90[a\x8A\xF5a'uV[`\x01`\x01`@\x1B\x03\x90\x94\x16\x84R3` \x85\x01R`\x01`\x01`@\x1B\x03B\x16`@\x85\x01R`\x01`\x01`@\x1B\x03\x89\x16``\x85\x01R\x8Dc\xFF\xFF\xFF\xFF\x16`\x80\x85\x01R_`\xA0\x85\x01R`\x01`\x01`\xA0\x1B\x03\x8A\x16`\xC0\x85\x01R\x8A`\xE0\x85\x01Ra\x01\0\x84\x01\x90a\x8B\\\x91argV[c\xFF\xFF\xFF\xFF\x16a\x01 \x83\x01Rc\xFF\xFF\xFF\xFF\x16a\x01@\x82\x01Ra\x01`\x81\x01_\x90Ra\x8B\x97\x89`\x01`\x01`@\x1B\x03\x16_R`\t` R`@_ \x90V[\x90a\x8B\xA1\x91a\x87\x81V[\x89_[\x8A\x8A\x83\x83\x10a\x8C\x98WPPPPP_[\x82\x81\x10a\x8C]WPPPa\x8C\x0C\x90`@Q\x99`\x01`\x01`@\x1B\x033\x91\x16`\x01`\x01`@\x1B\x03\x88\x16\x7F\xBD\x1F\xDD\xA3\x93\xB6y\xE6\xC4\xF8s\xE23\xB3N,N\xA8(:?v4]\xBC\x14;\x86\xEA\x04vy_\x80\xA4T`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x96`\x01`\x01`\xA0\x1B\x03\x88\x16a\x8C(W[PPPPPPPPPPV[caFl\t`\xE1\x1B` \x8A\x01Ra\x8CN\x99a!!\x97\x8A\x97a\t\x8C\x973\x90`$\x8B\x01a\x89\\V[_\x80\x80\x80\x80\x80\x80\x80\x80\x80a\x8C\x1CV[`\x01\x90a\x8C\x92a\x8C~\x8A`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[a\x8C\x8Ca\x7F\xE7\x84\x88\x88at\xEEV[\x90a\x89\x1BV[\x01a\x8B\xB4V[a\x8C\xFB\x82a]-a\x7F\xE7\x86\x88aJ\x7Fa\x8C\xE3a]l\x84\x8Ea\x8C\xDE`\x01\x9F\x9Da\x8C\x8Ca\x8D\x0C\x9F\x8Fa\x7F\xE7\x91aJ\x7F\x88\x92`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[ai2V[\x97`\x01`\x01`@\x1B\x03\x16_R`\x0B` R`@_ \x90V[\x90a\xFF\xFF\x16a\xFF\xFF\x19\x82T\x16\x17\x90UV[\x01\x8A\x90a\x8B\xA4V[P`\x01\x90a\x8A\xEDV[c\x1F\x8C\xFA9`\xE2\x1B_Rc\xFF\xFF\xFF\xFF\x80\x84\x16`\x04R\x8D\x16`$R`D_\xFD[\x90P\x8D\x11_a\x8A\xD1V[c\xEB\x8E\x17]`\xE0\x1B_Rc\xFF\xFF\xFF\xFF\x90\x81\x16`\x04R\x8D\x16`$R`D_\xFD[`\x01a\x8A\xA8V[a\x8D\x99\x92a]-a\x7F\xE7\x86a\x08}\x94aJ\x7Fa!\xCC\x97`\x01`\x01`@\x1B\x03\x16_R`\x07` R`@_ \x90V[\x15a\x8D\xBEWa'\x10a\x8D\xB1a\x1CCa]l\x84\x8Cai2V[\x11a\x14=W`\x01\x01a\x8A\x18V[\x8Ba|la\x7F\xE7a\x07e\x93\x8D\x8Dat\xEEV[a\x8D\xE2\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\xE3\x90\xFC\xDB`\xE0\x1B\x81R_`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x87\x16`$\x82\x01R\x90` \x90\x82\x90`D\x90\x82\x90Z\xFA_\x91\x81a\x8EFW[P\x15a\x8A\x15W\x15a\x8E*W_a\x8A\x15V[c\tD\x03\xB7`\xE4\x1B_R`\x01`\x01`\xA0\x1B\x03\x85\x16`\x04R`$_\xFD[a\x8E`\x91\x92P` =` \x11a\x12\xDFWa\x12\xD0\x81\x83a'6V[\x90_a\x8E\x19V[P\x86\x15\x15a\x8A\x10V[c!\x0E\xB4\xED`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x8B\x16`\x04R`$_\xFD[c\xDD\xF9\xD2E`\xE0\x1B_R`\x04_\xFD[`\x05\x01T`\xFF\x81`\x80\x1C\x16a\x8E\xAF\x81ac\xA3V[`\x01\x81\x14a\x8E\xDFWa\x8E\xC0\x81ac\xA3V[\x15\x90\x81a\x8E\xCBWP\x90V[`\x01`\x01`@\x1B\x03\x91P`@\x1C\x16B\x10\x15\x90V[PP_\x90V[3_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 T`\xFF\x16\x15a\x8F\x1DWV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u`$R`D_\xFD[3_\x90\x81R\x7FuD+\n\x96\x08\x8BTV\xBCN\xD0\x13\x94\xC9jO\xEE\xC0\xF8\x83\xC9IBW\xD7k\x96\xAB\x1C\x9Bk` R`@\x90 T`\xFF\x16\x15a\x8F\x8CWV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*`$R`D_\xFD[3_\x90\x81R\x7F\xABq\xE3\xF3&ftM$n\xDF\xF3\xF9nK\xDA\xFE\xE2\xE9\x86p\x98\xCD\xD1\x18\xA9y\xA7FG\x86\xA8` R`@\x90 T`\xFF\x16\x15a\x8F\xFBWV[c\xE2Q}?`\xE0\x1B_R3`\x04R\x7F\x18\x9A\xB7\xA9$M\xF0\x84\x81\"\x15C\x15\xAFq\xFE\x14\x0F=\xB0\xFE\x01@1x;\tF\xB8\xC9\xD2\xE3`$R`D_\xFD[_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 3\x84R\x90\x91R\x90 T`\xFF\x16\x15a\x90bWPV[c\xE2Q}?`\xE0\x1B_R3`\x04R`$R`D_\xFD[`\x01`\x01`@\x1B\x03\x80`\x04T`@\x1C\x16\x91\x16\x90\x81\x10\x15a\x90\xA0W_R`\t` R`@_ \x90V[c\x126\x16\xB3`\xE1\x1B_R`\x04R`$_\xFD[\x91\x90\x91_[\x81T\x81\x10\x15a\x92[Wa\x90\xCA\x81\x83alRV[P\x80T`\x01`\x01`\xA0\x1B\x03`\x08\x82\x90\x1C\x16\x91_\x91\x83\x91\x90\x83[\x88\x8A\x81\x83\x10a\x91\x1CW[PPPPPP\x15a\x91\x01WP`\x01\x01a\x90\xB7V[c\x10\xC8\xEB!`\xE3\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`$_\xFD[a\x0F\xF0` a\x910\x85\x89\x95a\x916\x95alBV[\x01al\x8BV[\x14\x80a\x92*W[a\x91IW`\x01\x01a\x90\xE3V[\x92PP\x91P`\x01a\x91``@aj\xF8\x84\x8A\x8CalBV[\x92\x01T\x91a\xFF\xFF\x80\x84\x16\x91\x16\x81\x11a\x91\xECWPa\x91\x91a\x91\x86`@aj\xF8\x84\x8A\x8CalBV[\x92`\x10\x1Ca\xFF\xFF\x16\x90V[\x91a\xFF\xFF\x80\x84\x16\x91\x16\x11a\x91\xAEWPP`\x01_\x80\x80\x80\x88\x8Aa\x90\xEDV[\x91a\x91\xC2`@aj\xF8a\x07e\x95\x89\x8BalBV[cm\x10\0\xB7`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04Ra\xFF\xFF\x90\x81\x16`$R\x16`DR`d\x90V[\x83a\x92\0`@aj\xF8a\x07e\x95\x8B\x8DalBV[c\x94\xF4|\xCB`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x90\x91\x16`\x04Ra\xFF\xFF\x90\x81\x16`$R\x16`DR`d\x90V[Pa\x92>a\x929\x82\x8B\x8DalBV[al\x81V[`\xFF\x83\x16\x90a\x92L\x82a\"\xC7V[a\x92U\x81a\"\xC7V[\x14a\x91=V[PPPPV[\x90`@Q\x91\x82\x81T\x91\x82\x82R` \x82\x01\x90_R` _ \x92_[\x81\x81\x10a\x92\x90WPPa\x05\xD1\x92P\x03\x83a'6V[\x84T`\x01`\x01`\xA0\x1B\x03\x16\x83R`\x01\x94\x85\x01\x94\x87\x94P` \x90\x93\x01\x92\x01a\x92{V[\x94\x90\x93`\x01`\x01`@\x1B\x03\x80\x94\x81ao\x9C\x95\x81`\xA0\x99\x9C\x9B\x9C\x16\x8AR\x16` \x89\x01R\x16`@\x87\x01R`\x01\x80\x86\x1B\x03\x16``\x86\x01R`\xC0`\x80\x86\x01R`\xC0\x85\x01\x90aP\xDDV[a\x93\x12\x81`\x01`\x01`@\x1B\x03\x16_R`\t` R`@_ \x90V[`\x04T\x90\x91\x90`\x80\x1C`\x01`\x01`@\x1B\x03\x16\x90a\x93.\x82ah\xADV[`\x04\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x19\x16`\x80\x92\x90\x92\x1Bg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF`\x80\x1B\x16\x91\x90\x91\x17\x90U\x82T\x90`\x01`\x01`@\x1B\x03\x82\x16\x90a\x93\x82\x82`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[\x92a\x93\x9E\x83`\x01`\x01`@\x1B\x03\x16_R`\x06` R`@_ \x90V[P`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x94B`\x01`\x01`@\x1B\x03\x16\x93`\x01\x82\x01\x93\x84T\x97a\x93\xD3\x89`\x01`\x01`@\x1B\x03\x90`@\x1C\x16\x90V[\x98`\x80\x1Cc\xFF\xFF\xFF\xFF\x16`\x04\x85\x01T`\x08\x81\x90\x1Cc\xFF\xFF\xFF\xFF\x16`(\x82\x90\x1Cc\xFF\xFF\xFF\xFF\x16\x91`\xFF\x16\x92`\x02\x87\x01\x9C\x8DTa\x94\x12\x90`\xFF\x90`\x08\x1C\x16\x90V[\x95a\x94\x1Ba'uV[`\x01`\x01`@\x1B\x03\x90\x98\x16\x88R`\x01`\x01`\xA0\x1B\x03\x16` \x88\x01R`\x01`\x01`@\x1B\x03\x8C\x16`@\x88\x01R`\x01`\x01`@\x1B\x03\x16``\x87\x01R_`\x80\x87\x01R`\x01`\x01`@\x1B\x03\x8B\x16`\xA0\x87\x01Rc\xFF\xFF\xFF\xFF\x16`\xC0\x86\x01Rc\xFF\xFF\xFF\xFF\x16`\xE0\x85\x01Rc\xFF\xFF\xFF\xFF\x16a\x01\0\x84\x01Ra\x94\x98\x90a\x01 \x84\x01argV[a\x94\xA6\x90a\x01@\x83\x01arpV[`\x01a\x01`\x82\x01Ra\x94\xC9\x87`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[\x90a\x94\xD3\x91a\x845V[_\x97a\x94\xF0\x84`\x01`\x01`@\x1B\x03\x16_R`\n` R`@_ \x90V[a\x94\xF9\x90a\x92aV[\x92\x83Qa\x95\x05\x90ah\xCAV[\x95_\x9A[\x85Q\x8C\x10\x15a\x95\xD7Wa\x95\xCF`\x01\x91a\xFF\xFF\x8Ea\x95\xC7a\x08\xCA\x8F\x8F\x90\x8F\x8F\x92\x8Fa\x95\xB0\x92a]Sa\x95da]Aa\x11z\x98a\x95Ja] \x8Ea\x95l\x98ai2V[\x9A\x8B\x91`\x01`\x01`@\x1B\x03\x16_R`\x0B` R`@_ \x90V[\x99\x8A\x92ai2V[a\x95\x84a\x95wa'WV[a\xFF\xFF\x89\x16\x81R\x91aY\xA0V[_`@\x82\x01R`\x01``\x82\x01Ra\x10\xD9\x85a\x08\xCA\x85`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[P\x16\x90au\xC0V[\x9B\x01\x9Aa\x95\tV[\x93\x99\x91\x96\x92\x97P\x94\x99Pa\x96\x12a\x95\xFF\x89`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[\x87T`@\x1C`\x01`\x01`\xA0\x1B\x03\x16a\x80:V[P_[a\x960\x8B`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[T\x81\x10\x15a\x96\x99W\x80a\x96\x92\x8Ca\x80:a\x96}`\x01\x95a/\xC7\x8Fa\x96e\x90`\x01`\x01`@\x1B\x03\x16_R`\x13` R`@_ \x90V[\x94`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[\x90T`\x03\x91\x90\x91\x1B\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[P\x01a\x96\x15V[P\x90a\x97*a\x96\xCD\x94\x93\x92a\x97 `\x01\x89\x9C\x8E\x9B\x9E\x8D`\x01`\x01`@\x1B\x03\x80\x80a\x97k\x9E\x9FT\x9D\x8E`\x01`\x01`@\x1B\x03\x16\x90V[\x16\x93\x16\x91\x16\x7Ft\x1E\x97\xEE\x1F\xF8\x87\xC4\xD8\x82\xF4\xC4\x9A\xD2\x80\xEA}a\xD05\xE4\xE8\xA4q\xE51\x95\x15P'P#_\x80\xA4\x01\x80T\x90\x97\x90a\x97\x19\x90`\x01`\x01`\xA0\x1B\x03\x16\x91`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x90V[\x90\x8Ca\xB0\xD9V[T`\x08\x1C`\xFF\x16\x90V[\x92a\x974\x84a\"\xE3V[\x83\x15\x80a\x98\xCFW[\x15a\x98\x8AW\x89Ta|\xF7\x94P`\x01`\x01`@\x1B\x03\x16`\x02\x8B\x01T`\x01`\x01`\xA0\x1B\x03\x16`\x03\x8C\x01T\x91\x8Ba\xB7\xC8V[\x90`\x01`\x01`\xA0\x1B\x03\x82\x16a\x97\x82W[PPPPPV[a\x97\xADa\x7Fja\x97\xA7\x85\x96\x97\x98\x95`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[TauzV[\x95T\x94`@\x86\x90\x1C`\x01`\x01`\xA0\x1B\x03\x16a\x97\xCB\x81a\x7F}\x8Aai\x10V[_[a\x97\xE8\x87`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[T\x81\x10\x15a\x980W\x80a\x98*a\x98\x18a\x96}`\x01\x94a/\xC7\x8C`\x01`\x01`@\x1B\x03\x16_R`\r` R`@_ \x90V[a\x7F}a\x98$\x84auzV[\x8Dai2V[\x01a\x97\xCDV[P\x90a\t\x9A\x93\x94\x97a\t\x8C\x92a\x98ca\x98Ra\x98\x80\x9A`\x01`\x01`@\x1B\x03\x16\x90V[\x95T`@\x1C`\x01`\x01`@\x1B\x03\x16\x90V[\x92`@Q\x98\x89\x96c \xA8{9`\xE2\x1B` \x89\x01R`$\x88\x01a\x92\xB2V[_\x80\x80\x80\x80a\x97{V[PPP\x80a\x98\x99`\x01\x92a\"\xE3V[\x14\x80a\x98\xC2W[\x15a|\xF7W`\x02\x86\x01T`\x03\x87\x01Ta\x80\x94\x91`\x01`\x01`\xA0\x1B\x03\x16\x87a\xB4\x8CV[P`\x03\x86\x01T\x15\x15a\x98\xA0V[P`\x03\x8A\x01T\x15\x15a\x97<V[`\x01`\x01`@\x1B\x03\x80`\x04T`\x80\x1C\x16\x91\x16\x90\x81\x10\x15a\x99\x04W_R`\x10` R`@_ \x90V[cdQE\xDB`\xE1\x1B_R`\x04R`$_\xFD[a\x0B\xE6\x91`\x01`\x01`\xA0\x1B\x03\x16\x90a\xBA\x1BV[`\x01`\x01`@\x1B\x03\x90\x81\x16_\x81\x81R`\x15` R`@\x90 T\x83\x83\x16\x94\x93\x92\x16\x84\x10\x15a\x99wWa\x0B\xE6\x92\x93P_R`\x16` R`@_ \x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[\x83\x90c%\xB1\xBA\xFF`\xE2\x1B_R`\x04R`$R`D_\xFD[\x91\x90`\x01`\x01`@\x1B\x03\x83\x16\x91\x82_R`\x10` R`@_ \x92_R`\x12` Ra\x99\xBB`@_ a\xBB3V[a\x99\xC5\x81Qah\xCAV[\x91_\x93_\x94[\x83Q\x86\x10\x15a\x9AGWa\x9A?`\x01\x91a\x9A/a\x9A%a]Aa\x99\xFE\x8D`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[a\x9A\x08\x8C\x8Bai2V[\x87\x80`\xA0\x1B\x03\x90Q\x16`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[a]S\x8A\x8Aai2V[aP\xADa\x1CCa]l\x8A\x8Aai2V[\x95\x01\x94a\x99\xCBV[\x94P\x90\x95a\x9A_a\x05\xD1\x96T`\x01`\x01`@\x1B\x03\x16\x90V[\x90a\xB5VV[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x16_\x81\x81R\x7F\xB7\xDB-\xD0\x8F\xCBb\xD0\xC9\xE0\x8CQ\x94\x1C\xAES\xC2gxj\x0Bu\x80?\xB7\x96\t\x02\xFC\x8E\xF9}` R`@\x81 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91\x90_\x80Q` a\xC8\x87\x839\x81Q\x91R\x81\x80\xA4`\x01\x90V[P_\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xB1n\x88\xC4/\xD4\xE4\x8D\xF2\xDDj.\xAB\xD6\xBC\x9A\xECeN\xC1p\x05kG\x08\x19\xF8\x89,\xC6C\x1C` R`@\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x90`\x01`\x01`\xA0\x1B\x03\x16\x7F\xA4\x98\x07 \\\xE4\xD3U\t.\xF5\xA8\xA1\x8FV\xE8\x91<\xF4\xA2\x01\xFB\xE2\x87\x82[\tV\x93\xC2\x17u_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7FuD+\n\x96\x08\x8BTV\xBCN\xD0\x13\x94\xC9jO\xEE\xC0\xF8\x83\xC9IBW\xD7k\x96\xAB\x1C\x9Bk` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7FuD+\n\x96\x08\x8BTV\xBCN\xD0\x13\x94\xC9jO\xEE\xC0\xF8\x83\xC9IBW\xD7k\x96\xAB\x1C\x9Bk` R`@\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x90`\x01`\x01`\xA0\x1B\x03\x16\x7Fe\xD7\xA2\x8E2e\xB3zdt\x92\x9F3e!\xB32\xC1h\x1B\x93?l\xB9\xF37fsD\r\x86*_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xABq\xE3\xF3&ftM$n\xDF\xF3\xF9nK\xDA\xFE\xE2\xE9\x86p\x98\xCD\xD1\x18\xA9y\xA7FG\x86\xA8` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R\x7F\xABq\xE3\xF3&ftM$n\xDF\xF3\xF9nK\xDA\xFE\xE2\xE9\x86p\x98\xCD\xD1\x18\xA9y\xA7FG\x86\xA8` R`@\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x90`\x01`\x01`\xA0\x1B\x03\x16\x7F\x18\x9A\xB7\xA9$M\xF0\x84\x81\"\x15C\x15\xAFq\xFE\x14\x0F=\xB0\xFE\x01@1x;\tF\xB8\xC9\xD2\xE3_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_\x80Q` a\xC9G\x839\x81Q\x91R` R`@\x90 T`\xFF\x16a\x9A\xFCW`\x01`\x01`\xA0\x1B\x03\x81\x16_\x90\x81R_\x80Q` a\xC9G\x839\x81Q\x91R` R`@\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x90`\x01`\x01`\xA0\x1B\x03\x16\x7FLpp\xC6\xC1\x9C\xC9\xB4'\xB9O\xE5\x97\x9E\xE0\xC5s\xF8\xED\xD0\r%Y\x1A\xFEL\x95\x10\xDE\x94y\xBA_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\xFF\x16a\x8E\xDFW_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16`\x01\x17\x90U3\x91`\x01`\x01`\xA0\x1B\x03\x16\x90_\x80Q` a\xC8\x87\x839\x81Q\x91R_\x80\xA4`\x01\x90V[\x91\x90\x91\x82Q`\x01`\x01`@\x1B\x03\x81\x11a&\xA9Wa\x9E\x8F\x81aq\x01\x84Tam\xD5V[` `\x1F\x82\x11`\x01\x14a\x9E\xC9W\x81\x90ap\x8F\x93\x94\x95_\x92a\x9E\xBEWPP\x81`\x01\x1B\x91_\x19\x90`\x03\x1B\x1C\x19\x16\x17\x90V[\x01Q\x90P_\x80aq\"V[`\x1F\x19\x82\x16\x90a\x9E\xDC\x84_R` _ \x90V[\x91_[\x81\x81\x10a\x9F\x15WP\x95\x83`\x01\x95\x96\x97\x10a\x9E\xFDWPPP\x81\x1B\x01\x90UV[\x01Q_\x19`\xF8\x84`\x03\x1B\x16\x1C\x19\x16\x90U_\x80\x80aqkV[\x91\x92` `\x01\x81\x92\x86\x8B\x01Q\x81U\x01\x94\x01\x92\x01a\x9E\xDFV[`\x06a\x01 a\x05\xD1\x93a\x9Fga\x9FJ\x82Q`\x01`\x01`@\x1B\x03\x16\x90V[\x85Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16`\x01`\x01`@\x1B\x03\x90\x91\x16\x17\x85UV[` \x81\x01Qa\x9F\x7F\x90`\x01`\x01`\xA0\x1B\x03\x16\x85a\x83\xBAV[`@\x81\x01Q`\x01\x85\x01\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x91\x90\x91\x17\x90U``\x81\x01Q`\x02\x85\x01U`\x80\x81\x01Q`\x03\x85\x01U`\xA0\x81\x01Q`\x04\x85\x01Ua\xA0\r`\x05\x85\x01a\x9F\xE1a\x84S`\xC0\x85\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x9F\xF8a\x84\xBE`\xE0\x85\x01Q`\x01`\x01`@\x1B\x03\x16\x90V[a\x01\0\x83\x01Q\x90a\xA0\x08\x82ac\xA3V[a\x86UV[\x01Q\x91\x01a\x9EnV[\x95\x94\x90\x92\x80\x15a\xA1\xBAW`\x01`\x01`\xA0\x1B\x03\x84\x16\x94\x85\x15a=\xB6Wa\xA0;\x90\x82a\xBA~V[\x96\x87\x15a\xA1\xBAWa\xA1\xB5`\x01`\x01`@\x1B\x03\x92\x7F)a[E\x7F\"\xE1c\xCCE@2}p\xF3\\\x19\x90\xA8\xEF\0\x03\xE9\x15\xAD\x17\n\xCB\x81z\xCE=\x94\x84B\x16\x9Aa\xA0\x8Fa\xA0\x89`\x1CT`\x01`\x01`@\x1B\x03\x16\x90V[\x8Dao\xA3V[\x92a\xA1ta\xA0\xA5`\x1BT`\x01`\x01`@\x1B\x03\x16\x90V[\x9Aa\xA0\xCFa\xA0\xB2\x8Dah\xADV[`\x1B\x90`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x19\x82T\x16\x17\x90UV[a\xA1/\x8C\x9Fa\xA0\xFCa\xA0\xDFa'\xA3V[`\x01`\x01`@\x1B\x03\x8C\x16\x81R\x93`\x01`\x01`\xA0\x1B\x03\x16` \x85\x01RV[`\x01`\x01`\xA0\x1B\x03\x8D\x16`@\x84\x01R\x84``\x84\x01R\x85`\x80\x84\x01R\x86`\xA0\x84\x01R`\xC0\x83\x01\x90`\x01`\x01`@\x1B\x03\x16\x90RV[`\x01`\x01`@\x1B\x03\x86\x16`\xE0\x82\x01R_a\x01\0\x82\x01Ra\xA1MaKWV[a\x01 \x82\x01Ra\xA1o\x8C`\x1D\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[a\x9F-V[`@\x80Q`\x01`\x01`\xA0\x1B\x03\x90\x9A\x16\x8AR` \x8A\x01\x91\x90\x91R\x88\x01R``\x87\x01R`\x01`\x01`@\x1B\x03\x16`\x80\x86\x01R\x90\x82\x16\x94\x90\x91\x16\x92\x90\x81\x90`\xA0\x82\x01\x90V[\x03\x90\xA4V[c\xC5\x8DY5`\xE0\x1B_R`\x04_\xFD[\x80\x15a\xA1\xEFW\x80\x82\x10a\xA1\xDAWPPV[c\xB9\x9E*\xB7`\xE0\x1B_R`\x04R`$R`D_\xFD[PPV[\x81\x15a\xA2NW`\x01`\x01`\xA0\x1B\x03\x16\x80a\xA2\x13WP\x80\x82\x10a\xA1\xDAWPPV[a\x05\xD1\x92P`@Q\x91c#\xB8r\xDD`\xE0\x1B` \x84\x01R3`$\x84\x01R0`D\x84\x01R`d\x83\x01R`d\x82Ra\xA2I`\x84\x83a'6V[a\xC2\x8FV[PPPV[\x90_\x80\x91` \x81Q\x91\x01\x82\x85Z\xF1a\xA2ia\x86\xB3V[\x90\x15a\xA2sWPPV[\x80Qa\xA2\x9AWPc8\xE6\x07M`\xE1\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[`@\x80Qc\x03\xD4'a`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x90\x93\x16`\x04\x84\x01R`$\x83\x01R\x81\x90aV]\x90`D\x83\x01\x90aKkV[_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 T`\xFF\x16\x15a\x8E\xDFW_\x81\x81R_\x80Q` a\xC8\xE7\x839\x81Q\x91R` \x90\x81R`@\x80\x83 `\x01`\x01`\xA0\x1B\x03\x86\x16\x84R\x90\x91R\x90 \x80T`\xFF\x19\x16\x90U3\x91`\x01`\x01`\xA0\x1B\x03\x16\x90\x7F\xF69\x1F\\2\xD9\xC6\x9D*G\xEAg\x0BD)t\xB595\xD1\xED\xC7\xFDd\xEB!\xE0G\xA89\x17\x1B_\x80\xA4`\x01\x90V[\x90`\x01\x80`\xA0\x1B\x03\x82\x16\x91\x82_R`\x19` R`@_ _\x80R` R`@_ T\x92\x83\x15a\xA3\xB9W_a\x05\xD1\x92\x85\x92\x82R`\x19` R`@\x82 \x82\x80R` R\x81`@\x81 Ua\xA7<V[P_\x92PPV[`\x01`\x01`\xA0\x1B\x03\x81\x81\x16_\x81\x81R`\x19` \x90\x81R`@\x80\x83 \x94\x87\x16\x83R\x93\x90R\x91\x90\x91 T\x93\x92\x91\x90\x84\x15a\xA4$W\x91\x84\x91a\x05\xD1\x93_R`\x19` R_a\xA4\x1E\x83`@\x83 \x90`\x01\x80`\xA0\x1B\x03\x16_R` R`@_ \x90V[Ua\xA7<V[P_\x93PPPV[\x91\x90\x81\x15\x80\x15a\xA4DW[a\xA2NWa\x05\xD1\x92a\xA7<V[P`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\xA47V[\x91\x90a\xA4s\x83`\x1D\x90`\x01`\x01`@\x1B\x03\x16_R` R`@_ \x90V[\x80T`@\x1C`\x01`\x01`\xA0\x1B\x03\x16\x15a\xA5^W`\x05\x81\x01\x80T`\x80\x81\x90\x1C`\xFF\x16a\xA4\x9D\x81ac\xA3V[a\xA5BWa\xA4\xB6\x90`@\x1C`\x01`\x01`@\x1B\x03\x16a!\xCCV[B\x10\x15a\xA5&W\x80T`\xFF`\x80\x1B\x19\x16`\x01`\x80\x1B\x17\x90U\x7F\rD\x18\xCC\x07\xB1\xC8\x1FV\xE2\xD1'\x7F]\x11\xC1\xB2~\xBA\xC6\xCD\xAC\xAF\xCC\xEC\xD4\xAD\xD6t+K\x0F\x91`\x01`\x01`@\x1B\x03\x91a\xA5\x07\x90\x85\x90`\x06\x01a\x9EnV[a\xA5!`@Q\x92\x83\x92`\x01\x80`\xA0\x1B\x03\x16\x96\x16\x94\x82aK\x8FV[\x03\x90\xA3V[c3|,\x01`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x85\x16`\x04R`$_\xFD[c\x07\x97i\xAD`\xE1\x1B_R`\x01`\x01`@\x1B\x03\x86\x16`\x04R`$_\xFD[c\x16.?\xAB`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x84\x16`\x04R`$_\xFD[a\xA5\x95\x90`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[`\x02\x81\x01T`\x01`p\x82\x90\x1C`\xFF\x16a\xA5\xAD\x81a\"\xE3V[\x03a\x8E\xDFW`\x01\x90`h\x1C`\xFF\x16a\xA5\xC4\x81a\"\xE3V[\x03a\x9A\xFCW`\x01\x81\x01T\x90`\x01`\x01`@\x1B\x03`@\x83\x90\x1C\x16\x80\x15\x15\x90\x81a\xA6:W[Pa\x8E\xDFWa\xA6+\x91a\xA6%`\x02a\xA6\x16a\xA6\x0Fa!Ga!\xCC\x96T`\x01`\x01`@\x1B\x03\x16\x90V[\x93`\xC0\x1C\x90V[\x92\x01T`\x01`\x01`@\x1B\x03\x16\x90V[\x90ao\xA3V[B\x10a\xA66W`\x01\x90V[_\x90V[a\xA6R\x91Pa!\xCC\x90`\x01`\x01`@\x1B\x03\x85\x16ao\xA3V[B\x11_a\xA5\xE7V[\x92\x90\x91\x92\x83\x15a\x92[W\x83`\x02\x82\x01\x93\x84T\x15_\x14a\xA6\xB8W\x82T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x82\x16\x17\x83U`\x01\x93a\xA6\x9A\x92\x90\x91a\xA1\xF3V[\x01\x80T\x90\x83\x82\x01\x80\x92\x11aP\xD8WU\x80T\x91\x82\x01\x80\x92\x11aP\xD8WUV[\x82T\x90\x91P`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x90\x82\x16\x03a\xA6\xDDW`\x01\x92\x85a\xA6\x9A\x92a\xA1\xF3V[cV\xE7\xEC_`\xE0\x1B_R`\x04_\xFD[\x81\x15\x80\x15a\xA7+W[a\xA1\xEFW_\x91\x82\x91\x82\x91\x82\x91`\x01`\x01`\xA0\x1B\x03\x16Z\xF1a\xA7\x14a\x86\xB3V[P\x15a\xA7\x1CWV[c\x07\xA4\xCE\xD1`\xE5\x1B_R`\x04_\xFD[P`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\xA6\xF5V[\x90\x82\x15\x80\x15a\xA7\xADW[a\xA2NW`\x01`\x01`\xA0\x1B\x03\x16\x80a\xA7tWP_\x91\x82\x91\x82\x91\x82\x91`\x01`\x01`\xA0\x1B\x03\x16Z\xF1a\xA7\x14a\x86\xB3V[`@Qc\xA9\x05\x9C\xBB`\xE0\x1B` \x82\x01R`\x01`\x01`\xA0\x1B\x03\x90\x92\x16`$\x83\x01R`D\x82\x01\x92\x90\x92Ra\x05\xD1\x91a\xA2I\x82`d\x81\x01a\t\x8CV[P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a\xA7FV[\x91\x90`\x01`\x01`@\x1B\x03\x83\x16_R`\x1D` R`@_ \x92\x83`\x01\x80`\xA0\x1B\x03\x81T`@\x1C\x16\x15a\xA8\x7FWa\xA7\xF5a\x15\x8A\x82a\x8E\x9BV[a\xA8cW`\x05\x81\x01\x80T`\xFF`\x80\x1B\x19\x16`\x01`\x81\x1B\x17\x90UT\x91\x7FJ\x81n\x13'\x12\xDB\xDF\xE6\xA3c\x96^[\xC6\x8F\x8E(;\x99\x9A\xE1\x1A\xFE)J1b\x97<8U`\x01`\x01`@\x1B\x03a\xA8D\x81\x86\x16a\x1B\x1BV[`@Q\x93\x84R`\x01`\x01`\xA0\x1B\x03\x16\x94\x81\x16\x93\x16\x91\x80` \x81\x01a\xA1\xB5V[c\xB4\x8B\tY`\xE0\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R`$_\xFD[c\x16.?\xAB`\xE2\x1B_R`\x01`\x01`@\x1B\x03\x82\x16`\x04R`$_\xFD[\x91\x90\x91a\xA8\xA6a\xBB{V[`\x01`\x01`\xA0\x1B\x03\x81\x16\x15\x80\x15a\xA9\xDBW[\x80\x15a\xA9\xCAW[a=\xB6Wa\xA9Z\x92a\xA9\x1Ba\xA9=\x92a\xA8\xD6a\xBB{V[a\xA8\xDEa\xBB\xA6V[a\xA8\xE6a\xBB\xDAV[a\xA8\xEEa\xBB{V[a\xA8\xF7\x81a\x9AeV[Pa\xA9\x01\x81a\x9B\x01V[Pa\xA9\x0B\x81a\x9B\xC2V[Pa\xA9\x15\x81a\x9C\x83V[Pa\x9DDV[P_\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16\x91\x90\x91\x17\x90UV[`\x01\x80`\xA0\x1B\x03\x16`\x01`\x01``\x1B\x03`\xA0\x1B`\x01T\x16\x17`\x01UV[a\xA9\x9Fa\xA9ea'WV[a\x13\x88\x81Ra\x03\xE8` \x82\x01Ra\x07\xD0`@\x82\x01\x81\x90R``\x90\x91\x01R`\x02\x80Tg\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16g\x07\xD0\x07\xD0\x03\xE8\x13\x88\x17\x90UV[a\xA9\xC2a\xA9\xBDa\xA9\xADa\xA9\xECV[0\x90a\xA9\xB7a\xAA\x15V[\x90a\xBB\xEAV[`\x03UV[a\x05\xD1a\xBC[V[P`\x01`\x01`\xA0\x1B\x03\x82\x16\x15a\xA8\xBFV[P`\x01`\x01`\xA0\x1B\x03\x83\x16\x15a\xA8\xB8V[`@Q\x90a\xA9\xFB`@\x83a'6V[`\x0B\x82RjTangleQuote`\xA8\x1B` \x83\x01RV[`@Q\x90a\xAA$`@\x83a'6V[`\x01\x82R`1`\xF8\x1B` \x83\x01RV[\x93\x92\x91a\xAAb`\x02a\xAAW\x87`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[\x01Tc\xFF\xFF\xFF\xFF\x16\x90V[\x91a\xAA\x81a\\\xC8\x87`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[\x93_\x94_\x94_\x94_[\x83Q\x81\x10\x15a\xAB<Wa\xAA\xBEa\xAA\xA3a] \x83\x87ai2V[a\x08\xCA\x8D`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[T`\xFF`\x90\x82\x90\x1C\x16\x15a\xAB3W`\xFF\x86\x16`\x01\x03a\xAB&Wa\xAA\xE8a\x1CCa\xAA\xEF\x92a\xFF\xFF\x16\x90V[\x80\x99au\xC0V[\x97`\x01\x80\x88\x84\x1C\x16\x14a\xAB\x08W[P`\x01\x90[\x01a\xAA\x8AV[a\xAB\x1F\x90a\xAB\x19`\x01\x93\x99\x9Bat\xFEV[\x9Aau\xC0V[\x96\x90a\xAA\xFDV[Pa\xAA\xEF`\x01\x80\x99au\xC0V[P`\x01\x90a\xAB\x02V[P\x97\x96\x95\x94\x93P\x97PP`\xFF\x16\x15_\x14a\xAB\x94WPPa\xABka\xFF\xFFc\xFF\xFF\xFF\xFFa\xABs\x93\x96\x16\x94\x16\x84aoQV[a'\x10\x90\x04\x90V[\x91\x82\x15\x90\x81a\xAB\x8AW[Pa\xAB\x84WV[`\x01\x91PV[\x90P\x15\x15_a\xAB}V[\x94P\x92a\xABs\x91Pa\xABk\x90a\xFF\xFF\x16\x84aoQV[a\xAB\xB6a\x15\x8A\x82a\xA5zV[a\x9A\xFCWa\xAB\xD5\x81`\x01`\x01`@\x1B\x03\x16_R`\x10` R`@_ \x90V[\x90a\xAB\xEAa!G\x83T`\x01`\x01`@\x1B\x03\x16\x90V[\x90a\xAC\x06\x81`\x01`\x01`@\x1B\x03\x16_R`\x14` R`@_ \x90V[\x90`\x01\x83\x01T\x91\x82`\x01\x82\x01T\x10a\xAD7W\x82a\xAC\"\x91a\xBE\nV[`\x01\x85\x01\x80T`\x01`\x01`\xC0\x1B\x03\x16B`\xC0\x1B`\x01`\x01`\xC0\x1B\x03\x19\x16\x17\x90U\x94a\xACaa\\\xC8\x83`\x01`\x01`@\x1B\x03\x16_R`\x12` R`@_ \x90V[\x92a\xACl\x84Qah\xCAV[\x94_\x97_\x98[\x86Q\x8A\x10\x15a\xAC\xCCWa\xAC\xC4`\x01\x91aP\xADa\x1CCa]l\x8Ea\x98$\x8Ea]S\x8F\x8Fa]A\x86\x92a]-a] \x85a]\x1Aa\xAC\xBE\x96`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[\x92ai2V[\x99\x01\x98a\xACrV[a\xAD/\x94\x99Pa\xAD!\x90\x7F$\xDCH[\xEF\x04\xB4\xD7\x90\xD9z\xC1\x03\x81\xD8\xD9\xE6lV\xDDo\xBA\x991\xB7\x03\xCA\x16\x95\x11w\x8A\x98`\x01`\x01`@\x1B\x03\x98\x86`\x02\x96\x95a\xAD\x1Ba]\xC7\x99\x9ET`\x01`\x01`@\x1B\x03\x16\x90V[\x8Ba\xB7\xC8V[\x01T`\x01`\x01`@\x1B\x03\x16\x90V[\x03\x90\xA2`\x01\x90V[PPPPP_\x90V[\x93\x92\x90\x91\x93\x82Q\x15a\xAE\xF2Wa\xADV\x83Qah\xCAV[\x90_\x93_\x94[\x81Q\x86\x10\x15a\xAE\xE8Wa\xADo\x86\x83ai2V[Q`@\x81\x01_[\x88\x81\x10a\xAE\xA2WP\x81QQ`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x8B\x16`\x01`\x01`@\x1B\x03\x82\x16\x03a\xAEsWP\x81Q` \x01Q`\x01`\x01`@\x1B\x03\x16`\x01`\x01`@\x1B\x03\x88\x16`\x01`\x01`@\x1B\x03\x82\x16\x03a\xAEDWP\x81Q`\x80\x01Q`\x01`\x01`@\x1B\x03\x16B\x81\x10a\xAE\x1BWP\x91`@\x82a\xAE\na\xAE\0`\x01\x96a] a\xAE\x13\x97\x8B`\x1Ea\xBEYV[a\x7F}\x8C\x8Bai2V[Q\x01Q\x90au\xC0V[\x95\x01\x94a\xAD\\V[\x90Qc{\xBEW\xE9`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`\x01`\x01`@\x1B\x03\x16`$R`D_\xFD[\x90Qc\xAD!\xCDe`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`\x01`\x01`@\x1B\x03\x80\x88\x16`$R\x16`DR`d_\xFD[\x90QcV\xFEa\xA3`\xE1\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`\x01`\x01`@\x1B\x03\x80\x8B\x16`$R\x16`DR`d_\xFD[a\xAE\xAFa] \x82\x89ai2V[\x82Q`\x01`\x01`\xA0\x1B\x03\x90\x81\x16\x91\x16\x81\x14a\xAE\xCDWP`\x01\x01a\xADvV[c\x02xy\x17`\xE1\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`$_\xFD[\x96PPP\x92\x91PPV[c?l'\xF9`\xE0\x1B_R`\x04_\xFD[\x91\x90\x81\x10\x15ai\x1DW`\x05\x1B\x81\x015\x90`^\x19\x816\x03\x01\x82\x12\x15a\x05\xAFW\x01\x90V[\x905\x90`\xBE\x19\x816\x03\x01\x82\x12\x15a\x05\xAFW\x01\x90V[\x905\x90`\x1E\x19\x816\x03\x01\x82\x12\x15a\x05\xAFW\x01\x805\x90`\x01`\x01`@\x1B\x03\x82\x11a\x05\xAFW` \x01\x91``\x82\x026\x03\x83\x13a\x05\xAFWV[\x90\x92\x91\x94\x93_\x90_\x96`\x01`\x01`@\x1B\x03B\x16\x92[\x85Q\x89\x10\x15a\xB0\x91Wa\xB0:`\x01\x91a\xFF\xFF\x8B\x8A\x8A\x8A\x8A\x8A\x8Aa'\x10\x95a\xAF\xC0a\xAF\xB6a\xAF\xB0\x8A\x85\x85a\xAF\x01V[\x80a\xAF#V[`\xA0\x81\x01\x90a\xAF8V[\x90Pa\xB0BW[PP\x94a]\x1Aa\x80:\x93a\x95\xB0a] \x94a\xAF\xEA\x89a]S\x87a\x95\xC7\x9C\x9Dai2V[a\xB0\x02a\xAF\xF5a'WV[a\xFF\xFF\x8C\x16\x81R\x91aY\xA0V[_`@\x82\x01R`\x01``\x82\x01Ra\x10\xD9a\xB0-\x84`\x01`\x01`@\x1B\x03\x16_R`\x11` R`@_ \x90V[a]-a] \x88\x8Cai2V[\x98\x01\x97a\xAF\x82V[a\x95\xC7\x96P\x93a\x95\xB0a] \x94a\xAF\xEA\x8A\x95a]Sa\xB0}`@aj\xF8a\xB0wa\xAF\xB6a\xAF\xB0a\x80:\x9Fa]\x1A\x9D\x8F\x91a\xAF\x01V[\x90al9V[\x9BPP\x95PP\x94PP\x93PP\x8F\x8B\x90a\xAF\xC7V[\x97PPPPPPPV[\x91\x90\x82`@\x91\x03\x12a\x05\xAFW` \x82Qa\xB0\xB4\x81a9\xB7V[\x92\x01Qa\x0B\xE6\x81a\x05\xB3V[\x91\x90\x82`@\x91\x03\x12a\x05\xAFW` \x82Qav\xC0\x81a9\xB7V[` T`\x01`\x01`\xA0\x1B\x03\x16\x92\x90\x91\x90\x83\x15a\x92[W_\x93\x84\x92`\x01`\x01`\xA0\x1B\x03\x16\x80a\xB29W[Pa\xB1\x15\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x80;\x15a\x05\xAFW`@QbWxU`\xE4\x1B\x81R`\x01`\x01`@\x1B\x03\x85\x16`\x04\x82\x01R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16`$\x83\x01R_\x90\x82\x90`D\x90\x82\x90\x84\x90Z\xF1a\xB2%W[P`\x01`\x01`@\x1B\x03\x83\x16\x15\x80\x15\x81a\xB2\x19W[a\xB1xWPPPPV[a\xB2\x0FW[`\xFF\x81\x16\x15a\xB2\x07W[` Ta\xB1\x9E\x90a\x0F\xF0\x90`\x01`\x01`\xA0\x1B\x03\x16\x81V[\x80;\x15a\x05\xAFW`@Qc\xB9\x9FgY`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x93\x84\x16`\x04\x82\x01R\x93\x90\x92\x16`$\x84\x01R`\xFF\x16`D\x83\x01R_\x90\x82\x90`d\x90\x82\x90\x84\x90Z\xF1a\xB1\xEDW[\x80\x80\x80a\x92[V[\x80a\xB1\xFB_a\xB2\x01\x93a'6V[\x80a\x07\xC0V[_a\xB1\xE5V[P`\x03a\xB1\x87V[a\x01,\x92Pa\xB1}V[P`\xFF\x82\x16\x15\x15a\xB1nV[\x80a\xB1\xFB_a\xB23\x93a'6V[_a\xB1ZV[`@\x80Qbh\x08\x0B`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x87\x16`\x04\x82\x01R\x90\x81`$\x81\x85Z\xFA\x90\x81_\x91_\x93a\xB3nW[Pa\xB3BW[PP`@\x80QcIe\xDB\xC7`\xE1\x1B\x81R`\x01`\x01`@\x1B\x03\x87\x16`\x04\x82\x01R\x91\x82\x90`$\x90\x82\x90Z\xFA\x90\x81_\x91_\x93a\xB3\x0FW[Pa\xB2\xAEW[Pa\xB1\x02V[\x15\x80a\xB3\x03W[a\xB2\xC0W[\x80a\xB2\xA8V[\x90\x92P`\xFF\x16`P\x81\x11\x15a\xB2\xE1WPa\xB1\x15a\x0F\xF0`\x01[\x93\x91Pa\xB2\xBAV[`2\x10\x15a\xB2\xF6Wa\xB1\x15a\x0F\xF0`\x02a\xB2\xD9V[a\xB1\x15a\x0F\xF0`\x03a\xB2\xD9V[P`\xFF\x81\x16\x15\x15a\xB2\xB5V[\x90\x92Pa\xB34\x91P`@=`@\x11a\xB3;W[a\xB3,\x81\x83a'6V[\x81\x01\x90a\xB0\xC0V[\x91_a\xB2\xA2V[P=a\xB3\"V[\x15\x80a\xB3\\W[a\xB3TW[\x80a\xB2nV[\x95P_a\xB3NV[P`\x01`\x01`@\x1B\x03\x81\x16\x15\x15a\xB3IV[\x90\x92Pa\xB3\x93\x91P`@=`@\x11a\xB3\x9AW[a\xB3\x8B\x81\x83a'6V[\x81\x01\x90a\xB0\x9BV[\x91_a\xB2hV[P=a\xB3\x81V[\x80T\x80\x15a\xB3\xC8W_\x19\x01\x90a\xB3\xB7\x82\x82al$V[\x81T\x90_\x19\x90`\x03\x1B\x1B\x19\x16\x90UUV[cNH{q`\xE0\x1B_R`1`\x04R`$_\xFD[`\x01\x81\x01\x91\x80_R\x82` R`@_ T\x92\x83\x15\x15_\x14a\xB4\x84W_\x19\x84\x01\x84\x81\x11aP\xD8W\x83T_\x19\x81\x01\x94\x90\x85\x11aP\xD8W_\x95\x85\x83a\xB47\x97a\xB4*\x95\x03a\xB4=W[PPPa\xB3\xA1V[\x90_R` R`@_ \x90V[U`\x01\x90V[a\xB4ma\xB4g\x91a\xB4^a\xB4Ta\xB4{\x95\x88al$V[\x90T\x90`\x03\x1B\x1C\x90V[\x92\x83\x91\x87al$V[\x90apvV[\x85\x90_R` R`@_ \x90V[U_\x80\x80a\xB4\"V[PPPP_\x90V[`\x01`\x01`@\x1B\x03\x16_\x81\x81R`\x14` R`@\x90 \x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x17\x81U\x90\x91\x90`\x01\x81\x01\x90\x81T\x85\x81\x01\x80\x91\x11aP\xD8W`\x02\x92U\x01\x80T\x91\x84\x83\x01\x80\x93\x11aP\xD8W\x91\x90U`@Q\x92\x83R`\x01`\x01`\xA0\x1B\x03\x16\x91\x7F\xD2\x8D\xE7\xC5\x18\xC3\x12\xFA8\x8E\x03\xF8\xD1 =\x8FLu\x16\x1E5\x8F\xFB\x08'\xB6\xCA\xA2\xE9\xAC\x8A1\x90` \x90\xA3V[`@Q\x90a\xB5)\x82a&\xAEV[\x81``a\xFF\xFF`\x02T\x81\x81\x16\x84R\x81\x81`\x10\x1C\x16` \x85\x01R\x81\x81` \x1C\x16`@\x85\x01R`0\x1C\x16\x91\x01RV[\x93\x91\x95\x94\x92\x90\x86\x15a\xB7\xBFWa\xB5\x92a\xB5\x83a\xB5\xC5\x92`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[\x97a\xB5\x8Ca\xB5\x1CV[\x90a\xBF\xE0V[\x87T\x90\x97\x90a\xB5\xAC\x90`\x01\x90`\x01`\x01`\xA0\x1B\x03\x16aj\xFEV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\xB7>W[P_\x88Q\x91a\xA7<V[`\x01T` \x87\x01Qa\xB5\xE1\x91_\x90`\x01`\x01`\xA0\x1B\x03\x16a\xA7<V[\x82a\xB5\xEFW[PPPP\x90PV[\x85```@a\xB6\x04\x96\x98\x01Q\x91\x01Q\x90a\xC1\x0FV[_[\x81Q\x81\x10\x15a\xB70Wa\xB6Ca\xB6-a\xB6\x1F\x83\x85ai2V[QQ`\x01`\x01`\xA0\x1B\x03\x16\x90V[_` a\xB6:\x85\x87ai2V[Q\x01Q\x91a\xC2SV[`@a\xB6O\x82\x84ai2V[Q\x01Qa\xB6_W[`\x01\x01a\xB6\x06V[_Ta\xB6\x8D\x90a\xB6w\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[_`@a\xB6\x84\x85\x87ai2V[Q\x01Q\x91a\xA7<V[_Ta\xB6\xA1\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x90a\xB6\xAFa\xB6\x1F\x82\x85ai2V[`@a\xB6\xBB\x83\x86ai2V[Q\x01Q\x83;\x15a\x05\xAFW`@QcQ\xDC\xE2\xE1`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16`\x04\x83\x01R`\x01`\x01`@\x1B\x03\x87\x16`$\x83\x01R`D\x82\x01R\x91_\x90\x83\x90`d\x90\x82\x90\x84\x90Z\xF1\x91\x82\x15a\x13cW`\x01\x92a\xB7\x1CW[P\x90Pa\xB6WV[\x80a\xB1\xFB_a\xB7*\x93a'6V[_a\xB7\x14V[PP\x90P\x80_\x80\x80\x80a\xB5\xE7V[a\xB7P\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\x08\x17\x9F5`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x88\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA_\x91\x81a\xB7\x9EW[P\x15a\xB5\xBBW`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\xB5\xBBW\x90P_a\xB5\xBBV[a\xB7\xB8\x91\x92P` =` \x11a\x1D\xE0Wa\x1D\xD1\x81\x83a'6V[\x90_a\xB7\x81V[PPPPP\x90PV[\x94\x91\x93\x90\x96\x95\x92\x96\x87\x15a\xBA\x11Wa\xB8\0a\xB7\xF7a\xB83\x92`\x01`\x01`@\x1B\x03\x16_R`\x05` R`@_ \x90V[\x98a\xB5\x8Ca\xB5\x1CV[\x88T\x90\x98\x90a\xB8\x1A\x90`\x01\x90`\x01`\x01`\xA0\x1B\x03\x16aj\xFEV[`\x01`\x01`\xA0\x1B\x03\x81\x16a\xB9\x90W[P\x85\x89Q\x91a\xA7<V[`\x01T` \x88\x01Qa\xB8O\x91\x86\x90`\x01`\x01`\xA0\x1B\x03\x16a\xA7<V[\x82a\xB8]WPPPPP\x90PV[\x86```@a\xB8s\x96\x97\x99\x01Q\x91\x01Q\x90a\xC1\x0FV[\x90_[\x82Q\x81\x10\x15a\xB9\x80Wa\xB8\x9Ca\xB8\x8Fa\xB6\x1F\x83\x86ai2V[\x83` a\xB6:\x85\x88ai2V[`@a\xB8\xA8\x82\x85ai2V[Q\x01Qa\xB8\xB8W[`\x01\x01a\xB8vV[_Ta\xB8\xDD\x90a\xB8\xD0\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x83`@a\xB6\x84\x85\x88ai2V[_Ta\xB8\xF1\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[\x90a\xB8\xFFa\xB6\x1F\x82\x86ai2V[`@a\xB9\x0B\x83\x87ai2V[Q\x01Q\x83;\x15a\x05\xAFW`@QcQ\xDC\xE2\xE1`\xE1\x1B\x81R`\x01`\x01`\xA0\x1B\x03\x92\x90\x92\x16`\x04\x83\x01R`\x01`\x01`@\x1B\x03\x88\x16`$\x83\x01R`D\x82\x01R\x91_\x90\x83\x90`d\x90\x82\x90\x84\x90Z\xF1\x91\x82\x15a\x13cW`\x01\x92a\xB9lW[P\x90Pa\xB8\xB0V[\x80a\xB1\xFB_a\xB9z\x93a'6V[_a\xB9dV[PPP\x90P\x80_\x80\x80\x80\x80a\xB7\xBFV[a\xB9\xA2\x90`\x01`\x01`\xA0\x1B\x03\x16a\x0F\xF0V[`@Qc\x08\x17\x9F5`\xE0\x1B\x81R`\x01`\x01`@\x1B\x03\x89\x16`\x04\x82\x01R\x90` \x90\x82\x90`$\x90\x82\x90Z\xFA_\x91\x81a\xB9\xF0W[P\x15a\xB8)W`\x01`\x01`\xA0\x1B\x03\x16\x80\x15a\xB8)W\x90P_a\xB8)V[a\xBA\n\x91\x92P` =` \x11a\x1D\xE0Wa\x1D\xD1\x81\x83a'6V[\x90_a\xB9\xD3V[PPPPPP\x90PV[_\x82\x81R`\x01\x82\x01` R`@\x90 Ta\x8E\xDFW\x80T\x90`\x01`@\x1B\x82\x10\x15a&\xA9W\x82a\xBAia\xBAS\x84`\x01\x80\x96\x01\x85U\x84al$V[\x81\x93\x91T\x90`\x03\x1B\x91\x82\x1B\x91_\x19\x90\x1B\x19\x16\x17\x90V[\x90U\x80T\x92_R\x01` R`@_ U`\x01\x90V[a\xBA\x90\x90a\xFF\xFFa'\x10\x93\x16\x90aoQV[\x04\x90V[\x90\x81;\x15a\xBB\x12W_\x80Q` a\xC8\xC7\x839\x81Q\x91R\x80T`\x01`\x01`\xA0\x1B\x03\x19\x16`\x01`\x01`\xA0\x1B\x03\x84\x16\x90\x81\x17\x90\x91U\x7F\xBC|\xD7Z \xEE'\xFD\x9A\xDE\xBA\xB3 A\xF7U!M\xBCk\xFF\xA9\x0C\xC0\"[9\xDA.\\-;_\x80\xA2\x80Q\x15a\xBA\xFAWa\x86\xF9\x91a\xC2\xE7V[PP4a\xBB\x03WV[c\xB3\x98\x97\x9F`\xE0\x1B_R`\x04_\xFD[PcL\x9C\x8C\xE3`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[\x90`@Q\x91\x82\x81T\x91\x82\x82R` \x82\x01\x90_R` _ \x92_[\x81\x81\x10a\xBBbWPPa\x05\xD1\x92P\x03\x83a'6V[\x84T\x83R`\x01\x94\x85\x01\x94\x87\x94P` \x90\x93\x01\x92\x01a\xBBMV[`\xFF_\x80Q` a\xC9g\x839\x81Q\x91RT`@\x1C\x16\x15a\xBB\x97WV[c\x1A\xFC\xD7\x9F`\xE3\x1B_R`\x04_\xFD[a\xBB\xAEa\xBB{V[a\xBB\xB6a\xBB{V[`\xFF\x19_\x80Q` a\xC9\x07\x839\x81Q\x91RT\x16_\x80Q` a\xC9\x07\x839\x81Q\x91RUV[a\xBB\xE2a\xBB{V[a\x87na\xBB{V[\x91\x90\x91` \x81Q\x91\x01 \x91` \x81Q\x91\x01 \x90`@Q\x91` \x83\x01\x93\x7F\x8Bs\xC3\xC6\x9B\xB8\xFE=Q.\xCCL\xF7Y\xCCy#\x9F{\x17\x9B\x0F\xFA\xCA\xA9\xA7]R+9@\x0F\x85R`@\x84\x01R``\x83\x01RF`\x80\x83\x01R`\x01\x80`\xA0\x1B\x03\x16`\xA0\x82\x01R`\xA0\x81Ra\xBCU`\xC0\x82a'6V[Q\x90 \x90V[a'\x10`@\x80Qa\xBCk\x81a'\x1BV[b\t:\x80\x81R_` \x82\x01R\x01R`\x1C\x80Tj\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x19\x16j'\x10\0\0\0\0\0\0\t:\x80\x17\x90UV[a\xBC\xA8\x90\x93\x92\x93a\xC3\x1CV[\x92`@Q\x90a\xBC\xB6\x82a'\0V[\x7F\x19\x8E\x93\x93\x92\rH:r`\xBF\xB71\xFB]%\xF1\xAAI35\xA9\xE7\x12\x97\xE4\x85\xB7\xAE\xF3\x12\xC2\x82R\x7F\x18\0\xDE\xEF\x12\x1F\x1EvBj\0f^\\DygC\"\xD4\xF7^\xDA\xDDF\xDE\xBD\\\xD9\x92\xF6\xED` \x83\x01R`@Qa\xBD\x0B\x81a'\0V[\x7F\t\x06\x89\xD0X_\xF0u\xEC\x9E\x99\xADi\x0C3\x95\xBCK13p\xB3\x8E\xF3U\xAC\xDA\xDC\xD1\"\x97[\x81R\x7F\x12\xC8^\xA5\xDB\x8Cm\xEBJ\xABq\x80\x8D\xCB@\x8F\xE3\xD1\xE7i\x0CC\xD3{L\xE6\xCC\x01f\xFA}\xAA` \x82\x01R`@Q\x92a\xBDa\x84a'\0V[\x83R` \x83\x01R`@Q\x91a\xBDw``\x84a'6V[`\x02\x83R`@_[\x81\x81\x10a\xBD\xF3WPPa\xBD\xB2a\x0B\xE6\x95\x96a\xBD\x98a\xC3\xE7V[\x95a\xBD\xA2\x86ai\x10V[Ra\xBD\xAC\x85ai\x10V[Pa\xC56V[a\xBD\xBB\x84ai\"V[Ra\xBD\xC5\x83ai\"V[Pa\xBD\xCF\x84ai\x10V[Ra\xBD\xD9\x83ai\x10V[Pa\xBD\xE3\x83ai\"V[Ra\xBD\xED\x82ai\"V[Pa\xC5\xF9V[` \x90a\xBD\xFEa\xC3\x04V[\x82\x82\x88\x01\x01R\x01a\xBD\x7FV[\x90`\x01\x82\x01\x80T\x90\x82\x82\x10a\xBEBW\x82\x82\x03\x91\x82\x11aP\xD8WU`\x03\x82\x01\x80T\x91\x82\x01\x80\x92\x11aP\xD8WUT`\x01`\x01`\xA0\x1B\x03\x16\x90V[P\x90c\x03\x9F\xF3\xB1`\xE4\x1B_R`\x04R`$R`D_\xFD[\x91\x90aT\xD5a\xBF\x18\x83Q`\x01`\x01`@\x1B\x03\x81Q\x16\x90`\x01`\x01`@\x1B\x03` \x82\x01Q\x16\x90`@\x81\x01Q\x90`\x01`\x01`@\x1B\x03`\x80\x81``\x84\x01Q\x16\x92\x01Q\x16\x91`@Q\x93` \x85\x01\x95\x7F#\xDB6\xA6X\xFD\x8D\xD6\x1C\x92\x8C|\xBE\xC6\xA1\x84\x0E3\x9E6>\xFD\x87\\\xDA\xF8:\x1D`\xC8JC\x87R`@\x86\x01R``\x85\x01R`\x80\x84\x01R`\xA0\x83\x01R`\xC0\x82\x01R`\xC0\x81Ra\xBE\xEE`\xE0\x82a'6V[Q\x90 `@Q\x92\x83\x91` \x83\x01\x95\x86\x90\x91`B\x92a\x19\x01`\xF0\x1B\x83R`\x02\x83\x01R`\"\x82\x01R\x01\x90V[Q\x90 \x91a\xBF1a\x15\xE2\x84\x83\x90_R` R`@_ \x90V[a\xBF\xC0W`@a\xBFE` \x84\x01Q\x85a\xC4\\V[\x92\x01\x80Q\x90\x92`\x01`\x01`\xA0\x1B\x03\x91\x82\x16\x91\x16\x81\x90\x03a\xBF\xA5WPa\x16%\x83a\xBFu\x92\x90_R` R`@_ \x90V[Q`\x01`\x01`\xA0\x1B\x03\x16\x7F\x89\xA9\xFC\xF5/\xCD\xC4\x8F\x0Ef\x9F\xB3\xB7\x12R\x91\xDA\x85\x012Y/]\xD5\x80\xFF\xB5\x81f\xC8\xE9\xE8_\x80\xA3V[c\x08\xB1\xC5G`\xE1\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`$_\xFD[`@\x82\x01Qc\x08\xD1\x82q`\xE0\x1B_R`\x01`\x01`\xA0\x1B\x03\x16`\x04R`$_\xFD[\x91\x90\x91a\xBF\xEBar\xD3V[\x92a'\x10a\xBF\xFEa\xFF\xFF\x83Q\x16\x84aoQV[\x04\x84Ra'\x10a\xC01a\xFF\xFF\x80`@\x84a\xC0\x1E\x83` \x89\x01Q\x16\x89aoQV[\x04\x95` \x8A\x01\x96\x87R\x01Q\x16\x16\x84aoQV[\x04\x90`@\x85\x01\x91\x82R\x84Q\x83\x03\x92\x83\x11aP\xD8Wa\xC0\\\x92a\xC0T\x91Q\x90au\x1AV[\x90Q\x90au\x1AV[``\x83\x01RV[`@Q\x90a\xC0r` \x83a'6V[_\x80\x83R\x82\x81[\x82\x81\x10a\xC0\x85WPPPV[` \x90`@Qa\xC0\x94\x81a'\x1BV[_\x81R_\x83\x82\x01R_`@\x82\x01R\x82\x82\x85\x01\x01R\x01a\xC0yV[\x90a\xC0\xB8\x82ah\x96V[a\xC0\xC5`@Q\x91\x82a'6V[\x82\x81R\x80\x92a\xC0\xD6`\x1F\x19\x91ah\x96V[\x01\x90_[\x82\x81\x10a\xC0\xE6WPPPV[` \x90`@Qa\xC0\xF5\x81a'\x1BV[_\x81R_\x83\x82\x01R_`@\x82\x01R\x82\x82\x85\x01\x01R\x01a\xC0\xDAV[\x91\x94\x93\x80\x15a\xC2EWa\xC1\"\x86Qa\xC0\xAEV[\x95_\x91_\x95_[\x83Q\x81\x10\x15a\xC2;W\x89a\xC1Ca\x1CCa]l\x84\x86ai2V[a\xC1M\x86Qau\x0CV[\x83\x03a\xC1\xBBWPP\x80a\xC1ea] `\x01\x93\x87ai2V[a\xC1o\x87\x8Aau\x1AV[a\xC1y\x8B\x8Aau\x1AV[\x90a\xC1\x94a\xC1\x85a'\x94V[`\x01`\x01`\xA0\x1B\x03\x90\x94\x16\x84RV[` \x83\x01R`@\x82\x01Ra\xC1\xA8\x82\x8Dai2V[Ra\xC1\xB3\x81\x8Cai2V[P[\x01a\xC1)V[a\xC2/\x88\x84\x9B\x98aM_\x86a\xC25\x96a\xC1\xF9\x8F`\x01\x9Aa\xC1\xF3\x8F\x9A\x8F\x90\x80a\xC1\xED\x83a\x1C>a\x1C>\x94a] \x99aoQV[\x9BaoQV[\x99ai2V[a\xC2\x13a\xC2\x04a'\x94V[`\x01`\x01`\xA0\x1B\x03\x90\x92\x16\x82RV[\x85` \x82\x01R\x87`@\x82\x01Ra\xC2)\x83\x83ai2V[Rai2V[\x96au\xC0V[\x97a\xC1\xB5V[PPPPPPPPV[PPPP\x90Pa\x0B\xE6a\xC0cV[\x90\x82\x15a\xA2NW`\x01`\x01`\xA0\x1B\x03\x91\x82\x16_\x90\x81R`\x19` \x90\x81R`@\x80\x83 \x93\x90\x94\x16\x82R\x91\x90\x91R \x80T\x91\x82\x01\x80\x92\x11aP\xD8WUV[\x90_` \x91\x82\x81Q\x91\x01\x82\x85Z\xF1\x15am\x96W_Q=a\xC2\xDEWP`\x01`\x01`\xA0\x1B\x03\x81\x16;\x15[a\xC2\xBEWPV[cRt\xAF\xE7`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[`\x01\x14\x15a\xC2\xB7V[_\x80a\x0B\xE6\x93` \x81Q\x91\x01\x84Z\xF4a\xC2\xFEa\x86\xB3V[\x91a\xC4rV[`@Q\x90a\xC3\x11\x82a'\0V[_` \x83\x82\x81R\x01RV[a\xC3C\x90a\xC3(a\xC3\x04V[P` \x81Q\x91\x01 _\x80Q` a\xC8\xA7\x839\x81Q\x91R\x90\x06\x90V[\x90_\x90_[a\x01\0\x83\x10a\xC3`Wc\xDBJ\\\xD9`\xE0\x1B_R`\x04_\xFD[aonW_\x80Q` a\xC8\xA7\x839\x81Q\x91R`\x03\x81\x85\x81\x81\x80\t\t\x08a\xC3\x85\x81a\xC4\xD0V[\x90_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x82\x80\t\x14a\xC3\xBAWP`\x01_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x81_\x95\x08\x92\x01\x91\x92a\xC3HV[\x90\x92\x91Pa\xC3\xC6a'\xB3V[\x91\x82R` \x82\x01R\x90V[`@Q\x90a\xC3\xE0` \x83a'6V[` 6\x837V[`@Q\x90a\xC3\xF6``\x83a'6V[`\x02\x82R\x81`\x1F\x19a\xC4\x08`\x02ah\x96V[\x01\x90`@\x90_[\x83\x81\x10a\xC4\x1CWPPPPV[` \x90\x83Qa\xC4*\x81a'\0V[\x84Qa\xC46\x86\x82a'6V[\x856\x827\x81R\x84Qa\xC4H\x86\x82a'6V[\x856\x827\x83\x82\x01R\x82\x82\x85\x01\x01R\x01a\xC4\x0FV[a\x0B\xE6\x91a\xC4i\x91a\xC7NV[\x90\x92\x91\x92a\xC7\x88V[\x90a\xC4\x96WP\x80Q\x15a\xC4\x87W\x80Q\x90` \x01\xFD[c\xD6\xBD\xA2u`\xE0\x1B_R`\x04_\xFD[\x81Q\x15\x80a\xC4\xC7W[a\xC4\xA7WP\x90V[c\x99\x96\xB3\x15`\xE0\x1B_\x90\x81R`\x01`\x01`\xA0\x1B\x03\x91\x90\x91\x16`\x04R`$\x90\xFD[P\x80;\x15a\xC4\x9FV[_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x90\x81\x80`\x01\x92\x06\x90[a\xC4\xF1WP\x90P\x90V[`\x01\x80\x84\x16\x14a\xC5\x1DW[_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x91\x92`\x01\x1C\x91\x81\x83\x92\t\x91\x92\x91\x90a\xC4\xE7V[_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x81\x81\x93\t\x91Pa\xC4\xFCV[a\xC5>a\xC3\x04V[P\x80Q\x90\x81\x15\x80a\xC5\xA1W[a\xC5\x9CW` _\x80Q` a\xC8\xA7\x839\x81Q\x91R\x91\x01Q\x06_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x03_\x80Q` a\xC8\xA7\x839\x81Q\x91R\x81\x11aP\xD8W`@Q\x91a\xC5\x92\x83a'\0V[\x82R` \x82\x01R\x90V[\x90P\x90V[P` \x81\x01Q\x15a\xC5JV[\x15a\xC5\xB4WV[`@QbF\x1B\xCD`\xE5\x1B\x81R` `\x04\x82\x01R`\x1E`$\x82\x01R\x7FBN254: pairing length mismatch\0\0`D\x82\x01R`d\x90\xFD[a\xC6\x06\x81Q\x83Q\x14a\xC5\xADV[\x80Qa\xC6\x11\x81ao;V[\x92a\xC6\x1B\x84ah\xCAV[\x92_[\x83\x81\x10a\xC6hWPPPP` \x80\x92a\xC6N\x92a\xC69a\xC3\xD1V[\x94\x85\x92`\x05\x1B\x91\x01`\x08a\x07\xCF\x19Z\x01\xFA\x15\x90V[a\xC6YWQ`\x01\x14\x90V[cM\xF4^/`\xE0\x1B_R`\x04_\xFD[\x80a\xC6u`\x01\x92\x84ai2V[QQa\xC6\x83a\x7F\xF8\x83ao;V[R` a\xC6\x90\x82\x85ai2V[Q\x01Qa\xC6\xA7a\x7F\xF8a\xC6\xA2\x84ao;V[auzV[Ra\xC6\xBDa\xC6\xB5\x82\x86ai2V[QQ` \x01\x90V[Qa\xC6\xD2a\x7F\xF8a\xC6\xCD\x84ao;V[au\x88V[Ra\xC6\xDD\x81\x85ai2V[QQQa\xC6\xF4a\x7F\xF8a\xC6\xEF\x84ao;V[au\x96V[Ra\xC7\r` a\xC7\x04\x83\x87ai2V[Q\x01Q` \x01\x90V[Qa\xC7\"a\x7F\xF8a\xC7\x1D\x84ao;V[au\xA4V[R` a\xC7/\x82\x86ai2V[Q\x01QQa\xC7Ga\x7F\xF8a\xC7B\x84ao;V[au\xB2V[R\x01a\xC6\x1EV[\x81Q\x91\x90`A\x83\x03a\xC7~Wa\xC7w\x92P` \x82\x01Q\x90```@\x84\x01Q\x93\x01Q_\x1A\x90a\xC8\x04V[\x91\x92\x90\x91\x90V[PP_\x91`\x02\x91\x90V[a\xC7\x91\x81ac\xA3V[\x80a\xC7\x9AWPPV[a\xC7\xA3\x81ac\xA3V[`\x01\x81\x03a\xC7\xBAWc\xF6E\xEE\xDF`\xE0\x1B_R`\x04_\xFD[a\xC7\xC3\x81ac\xA3V[`\x02\x81\x03a\xC7\xDEWPc\xFC\xE6\x98\xF7`\xE0\x1B_R`\x04R`$_\xFD[\x80a\xC7\xEA`\x03\x92ac\xA3V[\x14a\xC7\xF2WPV[c5\xE2\xF3\x83`\xE2\x1B_R`\x04R`$_\xFD[\x91\x90\x7F\x7F\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF]WnsW\xA4P\x1D\xDF\xE9/Fh\x1B \xA0\x84\x11a\xC8{W\x91` \x93`\x80\x92`\xFF_\x95`@Q\x94\x85R\x16\x86\x84\x01R`@\x83\x01R``\x82\x01R\x82\x80R`\x01Z\xFA\x15a\x13cW_Q`\x01`\x01`\xA0\x1B\x03\x81\x16\x15a\xC8qW\x90_\x90_\x90V[P_\x90`\x01\x90_\x90V[PPP_\x91`\x03\x91\x90V\xFE/\x87\x88\x11~~\xFF\x1D\x82\xE9&\xECyI\x01\xD1|x\x02JP'\t@0E@\xA73eo\r0dNr\xE11\xA0)\xB8PE\xB6\x81\x81X]\x97\x81j\x91hq\xCA\x8D< \x8C\x16\xD8|\xFDG6\x08\x94\xA1;\xA1\xA3!\x06g\xC8(I-\xB9\x8D\xCA> v\xCC75\xA9 \xA3\xCAP]8+\xBC\x02\xDD{\xC7\xDE\xC4\xDC\xEE\xDD\xA7u\xE5\x8D\xD5A\xE0\x8A\x11llS\x81\\\x0B\xD0(\x19/{bh\0\xCD^\xD1\\n\x18~w\xE9\xAE\xE8\x81\x84\xC2\x1FO!\x82\xABX'\xCB;~\x07\xFB\xED\xCDc\xF03\0\x9Bw\x9B\x17B-\r\xF9\"#\x01\x8B2\xB4\xD1\xFAF\xE0qr=h\x17\xE2Hm\0;\xEC\xC5_\0o$\xB3\xAC\xD9\x14O\xE9\x86\xC6\xFCF\x8F\xF9\x93\x84\x0C\x17\x93\xF5\x85\xF3\x9E\x15\xB5\xD2\x07(\xBD-\xDAA\xF0\xC5~\x16\x84\r\xF0@\xF1P\x88\xDC/\x81\xFE9\x1C9#\xBE\xC7>#\xA9f.\xFC\x9C\"\x9Cj\0\xA1dsolcC\0\x08\x1A\0\n",
    );
    /**Custom error with signature `AccessControlBadConfirmation()` and selector `0x6697b232`.
```solidity
error AccessControlBadConfirmation();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlBadConfirmation {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlBadConfirmation>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlBadConfirmation) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlBadConfirmation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlBadConfirmation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlBadConfirmation()";
            const SELECTOR: [u8; 4] = [102u8, 151u8, 178u8, 50u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `AccessControlUnauthorizedAccount(address,bytes32)` and selector `0xe2517d3f`.
```solidity
error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AccessControlUnauthorizedAccount {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub neededRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::FixedBytes<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::FixedBytes<32>,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AccessControlUnauthorizedAccount>
        for UnderlyingRustTuple<'_> {
            fn from(value: AccessControlUnauthorizedAccount) -> Self {
                (value.account, value.neededRole)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AccessControlUnauthorizedAccount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    account: tuple.0,
                    neededRole: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AccessControlUnauthorizedAccount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AccessControlUnauthorizedAccount(address,bytes32)";
            const SELECTOR: [u8; 4] = [226u8, 81u8, 125u8, 63u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.neededRole),
                )
            }
        }
    };
    /**Custom error with signature `AddressEmptyCode(address)` and selector `0x9996b315`.
```solidity
error AddressEmptyCode(address target);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AddressEmptyCode {
        #[allow(missing_docs)]
        pub target: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AddressEmptyCode> for UnderlyingRustTuple<'_> {
            fn from(value: AddressEmptyCode) -> Self {
                (value.target,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AddressEmptyCode {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { target: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AddressEmptyCode {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AddressEmptyCode(address)";
            const SELECTOR: [u8; 4] = [153u8, 150u8, 179u8, 21u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.target,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `AggregationNotRequired(uint64,uint8)` and selector `0x4f3b66ea`.
```solidity
error AggregationNotRequired(uint64 serviceId, uint8 jobIndex);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AggregationNotRequired {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub jobIndex: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u8);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AggregationNotRequired> for UnderlyingRustTuple<'_> {
            fn from(value: AggregationNotRequired) -> Self {
                (value.serviceId, value.jobIndex)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AggregationNotRequired {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    jobIndex: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AggregationNotRequired {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AggregationNotRequired(uint64,uint8)";
            const SELECTOR: [u8; 4] = [79u8, 59u8, 102u8, 234u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.jobIndex),
                )
            }
        }
    };
    /**Custom error with signature `AggregationRequired(uint64,uint8)` and selector `0x77164cdc`.
```solidity
error AggregationRequired(uint64 serviceId, uint8 jobIndex);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AggregationRequired {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub jobIndex: u8,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<8>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u8);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AggregationRequired> for UnderlyingRustTuple<'_> {
            fn from(value: AggregationRequired) -> Self {
                (value.serviceId, value.jobIndex)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AggregationRequired {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    jobIndex: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AggregationRequired {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AggregationRequired(uint64,uint8)";
            const SELECTOR: [u8; 4] = [119u8, 22u8, 76u8, 220u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.jobIndex),
                )
            }
        }
    };
    /**Custom error with signature `AggregationThresholdNotMet(uint64,uint64,uint256,uint256)` and selector `0x15cb246a`.
```solidity
error AggregationThresholdNotMet(uint64 serviceId, uint64 callId, uint256 achieved, uint256 required);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AggregationThresholdNotMet {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
        #[allow(missing_docs)]
        pub achieved: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub required: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            u64,
            u64,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AggregationThresholdNotMet>
        for UnderlyingRustTuple<'_> {
            fn from(value: AggregationThresholdNotMet) -> Self {
                (value.serviceId, value.callId, value.achieved, value.required)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for AggregationThresholdNotMet {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    callId: tuple.1,
                    achieved: tuple.2,
                    required: tuple.3,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AggregationThresholdNotMet {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AggregationThresholdNotMet(uint64,uint64,uint256,uint256)";
            const SELECTOR: [u8; 4] = [21u8, 203u8, 36u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.callId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.achieved),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                )
            }
        }
    };
    /**Custom error with signature `AlreadyApproved(uint64,address)` and selector `0xf2bb0f10`.
```solidity
error AlreadyApproved(uint64 requestId, address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct AlreadyApproved {
        #[allow(missing_docs)]
        pub requestId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<AlreadyApproved> for UnderlyingRustTuple<'_> {
            fn from(value: AlreadyApproved) -> Self {
                (value.requestId, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for AlreadyApproved {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    requestId: tuple.0,
                    operator: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for AlreadyApproved {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "AlreadyApproved(uint64,address)";
            const SELECTOR: [u8; 4] = [242u8, 187u8, 15u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `BlueprintNotActive(uint64)` and selector `0x421d69da`.
```solidity
error BlueprintNotActive(uint64 blueprintId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlueprintNotActive {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlueprintNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: BlueprintNotActive) -> Self {
                (value.blueprintId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlueprintNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { blueprintId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BlueprintNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BlueprintNotActive(uint64)";
            const SELECTOR: [u8; 4] = [66u8, 29u8, 105u8, 218u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
        }
    };
    /**Custom error with signature `BlueprintNotFound(uint64)` and selector `0x5fd248ec`.
```solidity
error BlueprintNotFound(uint64 blueprintId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct BlueprintNotFound {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<BlueprintNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: BlueprintNotFound) -> Self {
                (value.blueprintId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for BlueprintNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { blueprintId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for BlueprintNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "BlueprintNotFound(uint64)";
            const SELECTOR: [u8; 4] = [95u8, 210u8, 72u8, 236u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
        }
    };
    /**Custom error with signature `CommitmentAboveMaximum(address,uint16,uint16)` and selector `0x6d1000b7`.
```solidity
error CommitmentAboveMaximum(address asset, uint16 committed, uint16 maximum);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CommitmentAboveMaximum {
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub committed: u16,
        #[allow(missing_docs)]
        pub maximum: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<16>,
            alloy::sol_types::sol_data::Uint<16>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u16, u16);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CommitmentAboveMaximum> for UnderlyingRustTuple<'_> {
            fn from(value: CommitmentAboveMaximum) -> Self {
                (value.asset, value.committed, value.maximum)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CommitmentAboveMaximum {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    asset: tuple.0,
                    committed: tuple.1,
                    maximum: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CommitmentAboveMaximum {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CommitmentAboveMaximum(address,uint16,uint16)";
            const SELECTOR: [u8; 4] = [109u8, 16u8, 0u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.committed),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.maximum),
                )
            }
        }
    };
    /**Custom error with signature `CommitmentBelowMinimum(address,uint16,uint16)` and selector `0x94f47ccb`.
```solidity
error CommitmentBelowMinimum(address asset, uint16 committed, uint16 minimum);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct CommitmentBelowMinimum {
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub committed: u16,
        #[allow(missing_docs)]
        pub minimum: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<16>,
            alloy::sol_types::sol_data::Uint<16>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u16, u16);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<CommitmentBelowMinimum> for UnderlyingRustTuple<'_> {
            fn from(value: CommitmentBelowMinimum) -> Self {
                (value.asset, value.committed, value.minimum)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for CommitmentBelowMinimum {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    asset: tuple.0,
                    committed: tuple.1,
                    minimum: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for CommitmentBelowMinimum {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "CommitmentBelowMinimum(address,uint16,uint16)";
            const SELECTOR: [u8; 4] = [148u8, 244u8, 124u8, 203u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.committed),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.minimum),
                )
            }
        }
    };
    /**Custom error with signature `DeadlineExpired()` and selector `0x1ab7da6b`.
```solidity
error DeadlineExpired();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DeadlineExpired {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DeadlineExpired> for UnderlyingRustTuple<'_> {
            fn from(value: DeadlineExpired) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DeadlineExpired {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DeadlineExpired {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DeadlineExpired()";
            const SELECTOR: [u8; 4] = [26u8, 183u8, 218u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `DisputeWindowPassed(uint64)` and selector `0x337c2c01`.
```solidity
error DisputeWindowPassed(uint64 slashId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DisputeWindowPassed {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DisputeWindowPassed> for UnderlyingRustTuple<'_> {
            fn from(value: DisputeWindowPassed) -> Self {
                (value.slashId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DisputeWindowPassed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slashId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DisputeWindowPassed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DisputeWindowPassed(uint64)";
            const SELECTOR: [u8; 4] = [51u8, 124u8, 44u8, 1u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
        }
    };
    /**Custom error with signature `DuplicateOperatorQuote(address)` and selector `0x04f0f22e`.
```solidity
error DuplicateOperatorQuote(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DuplicateOperatorQuote {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<DuplicateOperatorQuote> for UnderlyingRustTuple<'_> {
            fn from(value: DuplicateOperatorQuote) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for DuplicateOperatorQuote {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for DuplicateOperatorQuote {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DuplicateOperatorQuote(address)";
            const SELECTOR: [u8; 4] = [4u8, 240u8, 242u8, 46u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignature()` and selector `0xf645eedf`.
```solidity
error ECDSAInvalidSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignature> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignature()";
            const SELECTOR: [u8; 4] = [246u8, 69u8, 238u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureLength(uint256)` and selector `0xfce698f7`.
```solidity
error ECDSAInvalidSignatureLength(uint256 length);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureLength {
        #[allow(missing_docs)]
        pub length: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureLength>
        for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureLength) -> Self {
                (value.length,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ECDSAInvalidSignatureLength {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { length: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureLength {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureLength(uint256)";
            const SELECTOR: [u8; 4] = [252u8, 230u8, 152u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.length),
                )
            }
        }
    };
    /**Custom error with signature `ECDSAInvalidSignatureS(bytes32)` and selector `0xd78bce0c`.
```solidity
error ECDSAInvalidSignatureS(bytes32 s);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ECDSAInvalidSignatureS {
        #[allow(missing_docs)]
        pub s: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ECDSAInvalidSignatureS> for UnderlyingRustTuple<'_> {
            fn from(value: ECDSAInvalidSignatureS) -> Self {
                (value.s,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ECDSAInvalidSignatureS {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { s: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ECDSAInvalidSignatureS {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ECDSAInvalidSignatureS(bytes32)";
            const SELECTOR: [u8; 4] = [215u8, 139u8, 206u8, 12u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.s),
                )
            }
        }
    };
    /**Custom error with signature `ERC1967InvalidImplementation(address)` and selector `0x4c9c8ce3`.
```solidity
error ERC1967InvalidImplementation(address implementation);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967InvalidImplementation {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967InvalidImplementation>
        for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967InvalidImplementation) -> Self {
                (value.implementation,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ERC1967InvalidImplementation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { implementation: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967InvalidImplementation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967InvalidImplementation(address)";
            const SELECTOR: [u8; 4] = [76u8, 156u8, 140u8, 227u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.implementation,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ERC1967NonPayable()` and selector `0xb398979f`.
```solidity
error ERC1967NonPayable();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ERC1967NonPayable {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ERC1967NonPayable> for UnderlyingRustTuple<'_> {
            fn from(value: ERC1967NonPayable) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ERC1967NonPayable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ERC1967NonPayable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ERC1967NonPayable()";
            const SELECTOR: [u8; 4] = [179u8, 152u8, 151u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `EnforcedPause()` and selector `0xd93c0665`.
```solidity
error EnforcedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct EnforcedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<EnforcedPause> for UnderlyingRustTuple<'_> {
            fn from(value: EnforcedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for EnforcedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for EnforcedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "EnforcedPause()";
            const SELECTOR: [u8; 4] = [217u8, 60u8, 6u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ExpectedPause()` and selector `0x8dfc202b`.
```solidity
error ExpectedPause();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ExpectedPause {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ExpectedPause> for UnderlyingRustTuple<'_> {
            fn from(value: ExpectedPause) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ExpectedPause {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ExpectedPause {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ExpectedPause()";
            const SELECTOR: [u8; 4] = [141u8, 252u8, 32u8, 43u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `FailedCall()` and selector `0xd6bda275`.
```solidity
error FailedCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct FailedCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<FailedCall> for UnderlyingRustTuple<'_> {
            fn from(value: FailedCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for FailedCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for FailedCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "FailedCall()";
            const SELECTOR: [u8; 4] = [214u8, 189u8, 162u8, 117u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `HashToPointFailed()` and selector `0xdb4a5cd9`.
```solidity
error HashToPointFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct HashToPointFailed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<HashToPointFailed> for UnderlyingRustTuple<'_> {
            fn from(value: HashToPointFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for HashToPointFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for HashToPointFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "HashToPointFailed()";
            const SELECTOR: [u8; 4] = [219u8, 74u8, 92u8, 217u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InstantSlashNotEnabled()` and selector `0x5724e9d5`.
```solidity
error InstantSlashNotEnabled();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InstantSlashNotEnabled {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InstantSlashNotEnabled> for UnderlyingRustTuple<'_> {
            fn from(value: InstantSlashNotEnabled) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InstantSlashNotEnabled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InstantSlashNotEnabled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InstantSlashNotEnabled()";
            const SELECTOR: [u8; 4] = [87u8, 36u8, 233u8, 213u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InsufficientEscrowBalance(uint256,uint256)` and selector `0x39ff3b10`.
```solidity
error InsufficientEscrowBalance(uint256 required, uint256 available);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientEscrowBalance {
        #[allow(missing_docs)]
        pub required: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub available: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientEscrowBalance>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientEscrowBalance) -> Self {
                (value.required, value.available)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientEscrowBalance {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    required: tuple.0,
                    available: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientEscrowBalance {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientEscrowBalance(uint256,uint256)";
            const SELECTOR: [u8; 4] = [57u8, 255u8, 59u8, 16u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.available),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientOperators(uint32,uint32)` and selector `0xeb8e175d`.
```solidity
error InsufficientOperators(uint32 required, uint32 provided);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientOperators {
        #[allow(missing_docs)]
        pub required: u32,
        #[allow(missing_docs)]
        pub provided: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u32, u32);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientOperators> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientOperators) -> Self {
                (value.required, value.provided)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientOperators {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    required: tuple.0,
                    provided: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientOperators {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientOperators(uint32,uint32)";
            const SELECTOR: [u8; 4] = [235u8, 142u8, 23u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.provided),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientPayment(uint256,uint256)` and selector `0xb99e2ab7`.
```solidity
error InsufficientPayment(uint256 required, uint256 sent);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientPayment {
        #[allow(missing_docs)]
        pub required: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub sent: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientPayment> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientPayment) -> Self {
                (value.required, value.sent)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientPayment {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    required: tuple.0,
                    sent: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientPayment {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientPayment(uint256,uint256)";
            const SELECTOR: [u8; 4] = [185u8, 158u8, 42u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.sent),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientPaymentForQuotes(uint256,uint256)` and selector `0x9a6ae60d`.
```solidity
error InsufficientPaymentForQuotes(uint256 totalCost, uint256 payment);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientPaymentForQuotes {
        #[allow(missing_docs)]
        pub totalCost: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub payment: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientPaymentForQuotes>
        for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientPaymentForQuotes) -> Self {
                (value.totalCost, value.payment)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InsufficientPaymentForQuotes {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    totalCost: tuple.0,
                    payment: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientPaymentForQuotes {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientPaymentForQuotes(uint256,uint256)";
            const SELECTOR: [u8; 4] = [154u8, 106u8, 230u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.totalCost),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.payment),
                )
            }
        }
    };
    /**Custom error with signature `InsufficientStake(address,uint256,uint256)` and selector `0x936d426d`.
```solidity
error InsufficientStake(address operator, uint256 required, uint256 actual);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InsufficientStake {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub required: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub actual: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<256>,
            alloy::sol_types::sol_data::Uint<256>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::primitives::aliases::U256,
            alloy::sol_types::private::primitives::aliases::U256,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InsufficientStake> for UnderlyingRustTuple<'_> {
            fn from(value: InsufficientStake) -> Self {
                (value.operator, value.required, value.actual)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InsufficientStake {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    required: tuple.1,
                    actual: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InsufficientStake {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InsufficientStake(address,uint256,uint256)";
            const SELECTOR: [u8; 4] = [147u8, 109u8, 66u8, 109u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.required),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actual),
                )
            }
        }
    };
    /**Custom error with signature `InvalidBLSSignature()` and selector `0xab1b236b`.
```solidity
error InvalidBLSSignature();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidBLSSignature {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidBLSSignature> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidBLSSignature) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidBLSSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidBLSSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidBLSSignature()";
            const SELECTOR: [u8; 4] = [171u8, 27u8, 35u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidInitialization()` and selector `0xf92ee8a9`.
```solidity
error InvalidInitialization();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidInitialization {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidInitialization> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidInitialization) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidInitialization {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidInitialization {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidInitialization()";
            const SELECTOR: [u8; 4] = [249u8, 46u8, 232u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidPaymentSplit()` and selector `0x43744f71`.
```solidity
error InvalidPaymentSplit();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidPaymentSplit {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidPaymentSplit> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidPaymentSplit) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidPaymentSplit {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidPaymentSplit {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidPaymentSplit()";
            const SELECTOR: [u8; 4] = [67u8, 116u8, 79u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidPaymentToken()` and selector `0x56e7ec5f`.
```solidity
error InvalidPaymentToken();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidPaymentToken {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidPaymentToken> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidPaymentToken) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidPaymentToken {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidPaymentToken {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidPaymentToken()";
            const SELECTOR: [u8; 4] = [86u8, 231u8, 236u8, 95u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidQuoteSignature(address)` and selector `0x11638a8e`.
```solidity
error InvalidQuoteSignature(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidQuoteSignature {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidQuoteSignature> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidQuoteSignature) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidQuoteSignature {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidQuoteSignature {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidQuoteSignature(address)";
            const SELECTOR: [u8; 4] = [17u8, 99u8, 138u8, 142u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `InvalidSecurityRequirement()` and selector `0x6923afcf`.
```solidity
error InvalidSecurityRequirement();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSecurityRequirement {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSecurityRequirement>
        for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSecurityRequirement) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for InvalidSecurityRequirement {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSecurityRequirement {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSecurityRequirement()";
            const SELECTOR: [u8; 4] = [105u8, 35u8, 175u8, 207u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidSlashAmount()` and selector `0xc58d5935`.
```solidity
error InvalidSlashAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSlashAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSlashAmount> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSlashAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSlashAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSlashAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSlashAmount()";
            const SELECTOR: [u8; 4] = [197u8, 141u8, 89u8, 53u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidSlashConfig()` and selector `0xd8f2727d`.
```solidity
error InvalidSlashConfig();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidSlashConfig {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidSlashConfig> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidSlashConfig) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidSlashConfig {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidSlashConfig {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidSlashConfig()";
            const SELECTOR: [u8; 4] = [216u8, 242u8, 114u8, 125u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `InvalidState()` and selector `0xbaf3f0f7`.
```solidity
error InvalidState();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct InvalidState {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<InvalidState> for UnderlyingRustTuple<'_> {
            fn from(value: InvalidState) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for InvalidState {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for InvalidState {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "InvalidState()";
            const SELECTOR: [u8; 4] = [186u8, 243u8, 240u8, 247u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `JobAlreadyCompleted(uint64,uint64)` and selector `0x0a55512f`.
```solidity
error JobAlreadyCompleted(uint64 serviceId, uint64 callId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct JobAlreadyCompleted {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<JobAlreadyCompleted> for UnderlyingRustTuple<'_> {
            fn from(value: JobAlreadyCompleted) -> Self {
                (value.serviceId, value.callId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for JobAlreadyCompleted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    callId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for JobAlreadyCompleted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "JobAlreadyCompleted(uint64,uint64)";
            const SELECTOR: [u8; 4] = [10u8, 85u8, 81u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.callId),
                )
            }
        }
    };
    /**Custom error with signature `JobCallNotFound(uint64,uint64)` and selector `0x96c6ebfc`.
```solidity
error JobCallNotFound(uint64 serviceId, uint64 callId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct JobCallNotFound {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<JobCallNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: JobCallNotFound) -> Self {
                (value.serviceId, value.callId)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for JobCallNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    callId: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for JobCallNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "JobCallNotFound(uint64,uint64)";
            const SELECTOR: [u8; 4] = [150u8, 198u8, 235u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.callId),
                )
            }
        }
    };
    /**Custom error with signature `LengthMismatch()` and selector `0xff633a38`.
```solidity
error LengthMismatch();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct LengthMismatch {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<LengthMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: LengthMismatch) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for LengthMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for LengthMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "LengthMismatch()";
            const SELECTOR: [u8; 4] = [255u8, 99u8, 58u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ManagerRejected(address)` and selector `0x71cc0e9a`.
```solidity
error ManagerRejected(address manager);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ManagerRejected {
        #[allow(missing_docs)]
        pub manager: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ManagerRejected> for UnderlyingRustTuple<'_> {
            fn from(value: ManagerRejected) -> Self {
                (value.manager,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ManagerRejected {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { manager: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ManagerRejected {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ManagerRejected(address)";
            const SELECTOR: [u8; 4] = [113u8, 204u8, 14u8, 154u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.manager,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ManagerReverted(address,bytes)` and selector `0x07a84ec2`.
```solidity
error ManagerReverted(address manager, bytes reason);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ManagerReverted {
        #[allow(missing_docs)]
        pub manager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Bytes,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (
            alloy::sol_types::private::Address,
            alloy::sol_types::private::Bytes,
        );
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ManagerReverted> for UnderlyingRustTuple<'_> {
            fn from(value: ManagerReverted) -> Self {
                (value.manager, value.reason)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ManagerReverted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    manager: tuple.0,
                    reason: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ManagerReverted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ManagerReverted(address,bytes)";
            const SELECTOR: [u8; 4] = [7u8, 168u8, 78u8, 194u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.manager,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `MissingAssetCommitment(address)` and selector `0x86475908`.
```solidity
error MissingAssetCommitment(address asset);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct MissingAssetCommitment {
        #[allow(missing_docs)]
        pub asset: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<MissingAssetCommitment> for UnderlyingRustTuple<'_> {
            fn from(value: MissingAssetCommitment) -> Self {
                (value.asset,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for MissingAssetCommitment {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { asset: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for MissingAssetCommitment {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "MissingAssetCommitment(address)";
            const SELECTOR: [u8; 4] = [134u8, 71u8, 89u8, 8u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.asset,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NoOperators()` and selector `0xddf9d245`.
```solidity
error NoOperators();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoOperators {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoOperators> for UnderlyingRustTuple<'_> {
            fn from(value: NoOperators) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoOperators {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoOperators {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoOperators()";
            const SELECTOR: [u8; 4] = [221u8, 249u8, 210u8, 69u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NoQuotes()` and selector `0x3f6c27f9`.
```solidity
error NoQuotes();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoQuotes {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoQuotes> for UnderlyingRustTuple<'_> {
            fn from(value: NoQuotes) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoQuotes {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoQuotes {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoQuotes()";
            const SELECTOR: [u8; 4] = [63u8, 108u8, 39u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NoSecurityRequirements()` and selector `0x81d6fd6a`.
```solidity
error NoSecurityRequirements();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NoSecurityRequirements {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NoSecurityRequirements> for UnderlyingRustTuple<'_> {
            fn from(value: NoSecurityRequirements) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NoSecurityRequirements {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NoSecurityRequirements {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NoSecurityRequirements()";
            const SELECTOR: [u8; 4] = [129u8, 214u8, 253u8, 106u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotBlueprintOwner(uint64,address)` and selector `0x234e071d`.
```solidity
error NotBlueprintOwner(uint64 blueprintId, address caller);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotBlueprintOwner {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotBlueprintOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotBlueprintOwner) -> Self {
                (value.blueprintId, value.caller)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotBlueprintOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blueprintId: tuple.0,
                    caller: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotBlueprintOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotBlueprintOwner(uint64,address)";
            const SELECTOR: [u8; 4] = [35u8, 78u8, 7u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotInitializing()` and selector `0xd7e6bcf8`.
```solidity
error NotInitializing();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotInitializing {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotInitializing> for UnderlyingRustTuple<'_> {
            fn from(value: NotInitializing) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotInitializing {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotInitializing {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotInitializing()";
            const SELECTOR: [u8; 4] = [215u8, 230u8, 188u8, 248u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `NotPermittedCaller(uint64,address)` and selector `0xd5dd5b44`.
```solidity
error NotPermittedCaller(uint64 serviceId, address caller);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotPermittedCaller {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotPermittedCaller> for UnderlyingRustTuple<'_> {
            fn from(value: NotPermittedCaller) -> Self {
                (value.serviceId, value.caller)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotPermittedCaller {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    caller: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotPermittedCaller {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotPermittedCaller(uint64,address)";
            const SELECTOR: [u8; 4] = [213u8, 221u8, 91u8, 68u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotServiceOwner(uint64,address)` and selector `0x19aacf9e`.
```solidity
error NotServiceOwner(uint64 serviceId, address caller);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotServiceOwner {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotServiceOwner> for UnderlyingRustTuple<'_> {
            fn from(value: NotServiceOwner) -> Self {
                (value.serviceId, value.caller)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotServiceOwner {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    caller: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotServiceOwner {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotServiceOwner(uint64,address)";
            const SELECTOR: [u8; 4] = [25u8, 170u8, 207u8, 158u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotSlashCanceller(uint64,address)` and selector `0x1c9cbce8`.
```solidity
error NotSlashCanceller(uint64 slashId, address caller);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotSlashCanceller {
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotSlashCanceller> for UnderlyingRustTuple<'_> {
            fn from(value: NotSlashCanceller) -> Self {
                (value.slashId, value.caller)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotSlashCanceller {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    slashId: tuple.0,
                    caller: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotSlashCanceller {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotSlashCanceller(uint64,address)";
            const SELECTOR: [u8; 4] = [28u8, 156u8, 188u8, 232u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `NotSlashDisputer(uint64,address)` and selector `0xdd2c7fb7`.
```solidity
error NotSlashDisputer(uint64 slashId, address caller);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct NotSlashDisputer {
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<NotSlashDisputer> for UnderlyingRustTuple<'_> {
            fn from(value: NotSlashDisputer) -> Self {
                (value.slashId, value.caller)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for NotSlashDisputer {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    slashId: tuple.0,
                    caller: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for NotSlashDisputer {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "NotSlashDisputer(uint64,address)";
            const SELECTOR: [u8; 4] = [221u8, 44u8, 127u8, 183u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OperatorAlreadyRegistered(uint64,address)` and selector `0x9ec4e30d`.
```solidity
error OperatorAlreadyRegistered(uint64 blueprintId, address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorAlreadyRegistered {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorAlreadyRegistered>
        for UnderlyingRustTuple<'_> {
            fn from(value: OperatorAlreadyRegistered) -> Self {
                (value.blueprintId, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for OperatorAlreadyRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blueprintId: tuple.0,
                    operator: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorAlreadyRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorAlreadyRegistered(uint64,address)";
            const SELECTOR: [u8; 4] = [158u8, 196u8, 227u8, 13u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OperatorNotActive(address)` and selector `0xe356d5aa`.
```solidity
error OperatorNotActive(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorNotActive {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorNotActive) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorNotActive(address)";
            const SELECTOR: [u8; 4] = [227u8, 86u8, 213u8, 170u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OperatorNotInService(uint64,address)` and selector `0x783482e9`.
```solidity
error OperatorNotInService(uint64 serviceId, address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorNotInService {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorNotInService> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorNotInService) -> Self {
                (value.serviceId, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorNotInService {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    operator: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorNotInService {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorNotInService(uint64,address)";
            const SELECTOR: [u8; 4] = [120u8, 52u8, 130u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `OperatorNotRegistered(uint64,address)` and selector `0x9bcccbfd`.
```solidity
error OperatorNotRegistered(uint64 blueprintId, address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct OperatorNotRegistered {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<OperatorNotRegistered> for UnderlyingRustTuple<'_> {
            fn from(value: OperatorNotRegistered) -> Self {
                (value.blueprintId, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for OperatorNotRegistered {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    blueprintId: tuple.0,
                    operator: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for OperatorNotRegistered {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "OperatorNotRegistered(uint64,address)";
            const SELECTOR: [u8; 4] = [155u8, 204u8, 203u8, 253u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `PairingFailed()` and selector `0x4df45e2f`.
```solidity
error PairingFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PairingFailed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PairingFailed> for UnderlyingRustTuple<'_> {
            fn from(value: PairingFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PairingFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PairingFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PairingFailed()";
            const SELECTOR: [u8; 4] = [77u8, 244u8, 94u8, 47u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `PaymentFailed()` and selector `0xf499da20`.
```solidity
error PaymentFailed();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PaymentFailed {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<PaymentFailed> for UnderlyingRustTuple<'_> {
            fn from(value: PaymentFailed) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for PaymentFailed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for PaymentFailed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PaymentFailed()";
            const SELECTOR: [u8; 4] = [244u8, 153u8, 218u8, 32u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `QuoteAlreadyUsed(address)` and selector `0x08d18271`.
```solidity
error QuoteAlreadyUsed(address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QuoteAlreadyUsed {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QuoteAlreadyUsed> for UnderlyingRustTuple<'_> {
            fn from(value: QuoteAlreadyUsed) -> Self {
                (value.operator,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QuoteAlreadyUsed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { operator: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for QuoteAlreadyUsed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "QuoteAlreadyUsed(address)";
            const SELECTOR: [u8; 4] = [8u8, 209u8, 130u8, 113u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `QuoteBlueprintMismatch(address,uint64,uint64)` and selector `0xadfcc346`.
```solidity
error QuoteBlueprintMismatch(address operator, uint64 expectedBlueprint, uint64 quotedBlueprint);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QuoteBlueprintMismatch {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub expectedBlueprint: u64,
        #[allow(missing_docs)]
        pub quotedBlueprint: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QuoteBlueprintMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: QuoteBlueprintMismatch) -> Self {
                (value.operator, value.expectedBlueprint, value.quotedBlueprint)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QuoteBlueprintMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    expectedBlueprint: tuple.1,
                    quotedBlueprint: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for QuoteBlueprintMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "QuoteBlueprintMismatch(address,uint64,uint64)";
            const SELECTOR: [u8; 4] = [173u8, 252u8, 195u8, 70u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedBlueprint),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.quotedBlueprint),
                )
            }
        }
    };
    /**Custom error with signature `QuoteExpired(address,uint64)` and selector `0x7bbe57e9`.
```solidity
error QuoteExpired(address operator, uint64 expiry);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QuoteExpired {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub expiry: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QuoteExpired> for UnderlyingRustTuple<'_> {
            fn from(value: QuoteExpired) -> Self {
                (value.operator, value.expiry)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QuoteExpired {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    expiry: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for QuoteExpired {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "QuoteExpired(address,uint64)";
            const SELECTOR: [u8; 4] = [123u8, 190u8, 87u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.expiry),
                )
            }
        }
    };
    /**Custom error with signature `QuoteTTLMismatch(address,uint64,uint64)` and selector `0xad21cd65`.
```solidity
error QuoteTTLMismatch(address operator, uint64 expectedTTL, uint64 quotedTTL);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct QuoteTTLMismatch {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub expectedTTL: u64,
        #[allow(missing_docs)]
        pub quotedTTL: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Address,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address, u64, u64);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<QuoteTTLMismatch> for UnderlyingRustTuple<'_> {
            fn from(value: QuoteTTLMismatch) -> Self {
                (value.operator, value.expectedTTL, value.quotedTTL)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for QuoteTTLMismatch {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    operator: tuple.0,
                    expectedTTL: tuple.1,
                    quotedTTL: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for QuoteTTLMismatch {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "QuoteTTLMismatch(address,uint64,uint64)";
            const SELECTOR: [u8; 4] = [173u8, 33u8, 205u8, 101u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.expectedTTL),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.quotedTTL),
                )
            }
        }
    };
    /**Custom error with signature `ReentrancyGuardReentrantCall()` and selector `0x3ee5aeb5`.
```solidity
error ReentrancyGuardReentrantCall();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ReentrancyGuardReentrantCall {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ReentrancyGuardReentrantCall>
        for UnderlyingRustTuple<'_> {
            fn from(value: ReentrancyGuardReentrantCall) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ReentrancyGuardReentrantCall {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ReentrancyGuardReentrantCall {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ReentrancyGuardReentrantCall()";
            const SELECTOR: [u8; 4] = [62u8, 229u8, 174u8, 181u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ResultAlreadySubmitted(uint64,uint64,address)` and selector `0xb7e7fcee`.
```solidity
error ResultAlreadySubmitted(uint64 serviceId, uint64 callId, address operator);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ResultAlreadySubmitted {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Uint<64>,
            alloy::sol_types::sol_data::Address,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64, u64, alloy::sol_types::private::Address);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ResultAlreadySubmitted> for UnderlyingRustTuple<'_> {
            fn from(value: ResultAlreadySubmitted) -> Self {
                (value.serviceId, value.callId, value.operator)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ResultAlreadySubmitted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    serviceId: tuple.0,
                    callId: tuple.1,
                    operator: tuple.2,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ResultAlreadySubmitted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ResultAlreadySubmitted(uint64,uint64,address)";
            const SELECTOR: [u8; 4] = [183u8, 231u8, 252u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.callId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `SafeERC20FailedOperation(address)` and selector `0x5274afe7`.
```solidity
error SafeERC20FailedOperation(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SafeERC20FailedOperation {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SafeERC20FailedOperation>
        for UnderlyingRustTuple<'_> {
            fn from(value: SafeERC20FailedOperation) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for SafeERC20FailedOperation {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SafeERC20FailedOperation {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SafeERC20FailedOperation(address)";
            const SELECTOR: [u8; 4] = [82u8, 116u8, 175u8, 231u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `ServiceExpired(uint64)` and selector `0x7c3e621b`.
```solidity
error ServiceExpired(uint64 serviceId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceExpired {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ServiceExpired> for UnderlyingRustTuple<'_> {
            fn from(value: ServiceExpired) -> Self {
                (value.serviceId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ServiceExpired {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { serviceId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ServiceExpired {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ServiceExpired(uint64)";
            const SELECTOR: [u8; 4] = [124u8, 62u8, 98u8, 27u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
        }
    };
    /**Custom error with signature `ServiceNotActive(uint64)` and selector `0x4c5fe2d8`.
```solidity
error ServiceNotActive(uint64 serviceId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceNotActive {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ServiceNotActive> for UnderlyingRustTuple<'_> {
            fn from(value: ServiceNotActive) -> Self {
                (value.serviceId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ServiceNotActive {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { serviceId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ServiceNotActive {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ServiceNotActive(uint64)";
            const SELECTOR: [u8; 4] = [76u8, 95u8, 226u8, 216u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
        }
    };
    /**Custom error with signature `ServiceNotFound(uint64)` and selector `0xc8a28bb6`.
```solidity
error ServiceNotFound(uint64 serviceId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceNotFound {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ServiceNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: ServiceNotFound) -> Self {
                (value.serviceId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ServiceNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { serviceId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ServiceNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ServiceNotFound(uint64)";
            const SELECTOR: [u8; 4] = [200u8, 162u8, 139u8, 182u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
        }
    };
    /**Custom error with signature `ServiceRequestAlreadyProcessed(uint64)` and selector `0x9481228c`.
```solidity
error ServiceRequestAlreadyProcessed(uint64 requestId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceRequestAlreadyProcessed {
        #[allow(missing_docs)]
        pub requestId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ServiceRequestAlreadyProcessed>
        for UnderlyingRustTuple<'_> {
            fn from(value: ServiceRequestAlreadyProcessed) -> Self {
                (value.requestId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for ServiceRequestAlreadyProcessed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { requestId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ServiceRequestAlreadyProcessed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ServiceRequestAlreadyProcessed(uint64)";
            const SELECTOR: [u8; 4] = [148u8, 129u8, 34u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                )
            }
        }
    };
    /**Custom error with signature `ServiceRequestNotFound(uint64)` and selector `0x246c2d66`.
```solidity
error ServiceRequestNotFound(uint64 requestId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ServiceRequestNotFound {
        #[allow(missing_docs)]
        pub requestId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ServiceRequestNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: ServiceRequestNotFound) -> Self {
                (value.requestId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ServiceRequestNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { requestId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ServiceRequestNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ServiceRequestNotFound(uint64)";
            const SELECTOR: [u8; 4] = [36u8, 108u8, 45u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                )
            }
        }
    };
    /**Custom error with signature `SlashAlreadyCancelled(uint64)` and selector `0x7705ccd0`.
```solidity
error SlashAlreadyCancelled(uint64 slashId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SlashAlreadyCancelled {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SlashAlreadyCancelled> for UnderlyingRustTuple<'_> {
            fn from(value: SlashAlreadyCancelled) -> Self {
                (value.slashId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SlashAlreadyCancelled {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slashId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SlashAlreadyCancelled {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SlashAlreadyCancelled(uint64)";
            const SELECTOR: [u8; 4] = [119u8, 5u8, 204u8, 208u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
        }
    };
    /**Custom error with signature `SlashAlreadyExecuted(uint64)` and selector `0x532af369`.
```solidity
error SlashAlreadyExecuted(uint64 slashId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SlashAlreadyExecuted {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SlashAlreadyExecuted> for UnderlyingRustTuple<'_> {
            fn from(value: SlashAlreadyExecuted) -> Self {
                (value.slashId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SlashAlreadyExecuted {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slashId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SlashAlreadyExecuted {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SlashAlreadyExecuted(uint64)";
            const SELECTOR: [u8; 4] = [83u8, 42u8, 243u8, 105u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
        }
    };
    /**Custom error with signature `SlashNotExecutable(uint64)` and selector `0xb48b0959`.
```solidity
error SlashNotExecutable(uint64 slashId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SlashNotExecutable {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SlashNotExecutable> for UnderlyingRustTuple<'_> {
            fn from(value: SlashNotExecutable) -> Self {
                (value.slashId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SlashNotExecutable {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slashId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SlashNotExecutable {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SlashNotExecutable(uint64)";
            const SELECTOR: [u8; 4] = [180u8, 139u8, 9u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
        }
    };
    /**Custom error with signature `SlashNotFound(uint64)` and selector `0x58b8feac`.
```solidity
error SlashNotFound(uint64 slashId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SlashNotFound {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SlashNotFound> for UnderlyingRustTuple<'_> {
            fn from(value: SlashNotFound) -> Self {
                (value.slashId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SlashNotFound {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slashId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SlashNotFound {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SlashNotFound(uint64)";
            const SELECTOR: [u8; 4] = [88u8, 184u8, 254u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
        }
    };
    /**Custom error with signature `SlashNotPending(uint64)` and selector `0x0f2ed35a`.
```solidity
error SlashNotPending(uint64 slashId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SlashNotPending {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u64,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<SlashNotPending> for UnderlyingRustTuple<'_> {
            fn from(value: SlashNotPending) -> Self {
                (value.slashId,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for SlashNotPending {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slashId: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for SlashNotPending {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SlashNotPending(uint64)";
            const SELECTOR: [u8; 4] = [15u8, 46u8, 211u8, 90u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
        }
    };
    /**Custom error with signature `TokenNotAllowed(address)` and selector `0x94403b70`.
```solidity
error TokenNotAllowed(address token);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TokenNotAllowed {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TokenNotAllowed> for UnderlyingRustTuple<'_> {
            fn from(value: TokenNotAllowed) -> Self {
                (value.token,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TokenNotAllowed {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { token: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TokenNotAllowed {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TokenNotAllowed(address)";
            const SELECTOR: [u8; 4] = [148u8, 64u8, 59u8, 112u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
        }
    };
    /**Custom error with signature `TooManyOperators(uint32,uint32)` and selector `0x7e33e8e4`.
```solidity
error TooManyOperators(uint32 maximum, uint32 provided);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct TooManyOperators {
        #[allow(missing_docs)]
        pub maximum: u32,
        #[allow(missing_docs)]
        pub provided: u32,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (
            alloy::sol_types::sol_data::Uint<32>,
            alloy::sol_types::sol_data::Uint<32>,
        );
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (u32, u32);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<TooManyOperators> for UnderlyingRustTuple<'_> {
            fn from(value: TooManyOperators) -> Self {
                (value.maximum, value.provided)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for TooManyOperators {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {
                    maximum: tuple.0,
                    provided: tuple.1,
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for TooManyOperators {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "TooManyOperators(uint32,uint32)";
            const SELECTOR: [u8; 4] = [126u8, 51u8, 232u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.maximum),
                    <alloy::sol_types::sol_data::Uint<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.provided),
                )
            }
        }
    };
    /**Custom error with signature `UUPSUnauthorizedCallContext()` and selector `0xe07c8dba`.
```solidity
error UUPSUnauthorizedCallContext();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnauthorizedCallContext {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnauthorizedCallContext>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnauthorizedCallContext) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnauthorizedCallContext {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnauthorizedCallContext {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnauthorizedCallContext()";
            const SELECTOR: [u8; 4] = [224u8, 124u8, 141u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `UUPSUnsupportedProxiableUUID(bytes32)` and selector `0xaa1d49a4`.
```solidity
error UUPSUnsupportedProxiableUUID(bytes32 slot);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UUPSUnsupportedProxiableUUID {
        #[allow(missing_docs)]
        pub slot: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UUPSUnsupportedProxiableUUID>
        for UnderlyingRustTuple<'_> {
            fn from(value: UUPSUnsupportedProxiableUUID) -> Self {
                (value.slot,)
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>>
        for UUPSUnsupportedProxiableUUID {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self { slot: tuple.0 }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for UUPSUnsupportedProxiableUUID {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UUPSUnsupportedProxiableUUID(bytes32)";
            const SELECTOR: [u8; 4] = [170u8, 29u8, 73u8, 164u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.slot),
                )
            }
        }
    };
    /**Custom error with signature `Unauthorized()` and selector `0x82b42900`.
```solidity
error Unauthorized();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct Unauthorized {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<Unauthorized> for UnderlyingRustTuple<'_> {
            fn from(value: Unauthorized) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for Unauthorized {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for Unauthorized {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "Unauthorized()";
            const SELECTOR: [u8; 4] = [130u8, 180u8, 41u8, 0u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAddress()` and selector `0xd92e233d`.
```solidity
error ZeroAddress();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAddress {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAddress> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAddress) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAddress {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAddress {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAddress()";
            const SELECTOR: [u8; 4] = [217u8, 46u8, 35u8, 61u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Custom error with signature `ZeroAmount()` and selector `0x1f2a2005`.
```solidity
error ZeroAmount();
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ZeroAmount {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[doc(hidden)]
        type UnderlyingSolTuple<'a> = ();
        #[doc(hidden)]
        type UnderlyingRustTuple<'a> = ();
        #[cfg(test)]
        #[allow(dead_code, unreachable_patterns)]
        fn _type_assertion(
            _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
        ) {
            match _t {
                alloy_sol_types::private::AssertTypeEq::<
                    <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                >(_) => {}
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<ZeroAmount> for UnderlyingRustTuple<'_> {
            fn from(value: ZeroAmount) -> Self {
                ()
            }
        }
        #[automatically_derived]
        #[doc(hidden)]
        impl ::core::convert::From<UnderlyingRustTuple<'_>> for ZeroAmount {
            fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                Self {}
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolError for ZeroAmount {
            type Parameters<'a> = UnderlyingSolTuple<'a>;
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ZeroAmount()";
            const SELECTOR: [u8; 4] = [31u8, 42u8, 32u8, 5u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
        }
    };
    /**Event with signature `AggregatedResultSubmitted(uint64,uint64,uint256,bytes)` and selector `0xe6fcb3342abe43c21acc6a04e3d7912476836976e07ed47d0b15a374e200e2f0`.
```solidity
event AggregatedResultSubmitted(uint64 indexed serviceId, uint64 indexed callId, uint256 signerBitmap, bytes output);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct AggregatedResultSubmitted {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
        #[allow(missing_docs)]
        pub signerBitmap: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub output: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for AggregatedResultSubmitted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "AggregatedResultSubmitted(uint64,uint64,uint256,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                230u8,
                252u8,
                179u8,
                52u8,
                42u8,
                190u8,
                67u8,
                194u8,
                26u8,
                204u8,
                106u8,
                4u8,
                227u8,
                215u8,
                145u8,
                36u8,
                118u8,
                131u8,
                105u8,
                118u8,
                224u8,
                126u8,
                212u8,
                125u8,
                11u8,
                21u8,
                163u8,
                116u8,
                226u8,
                0u8,
                226u8,
                240u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    callId: topics.2,
                    signerBitmap: data.0,
                    output: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.signerBitmap),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.output,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.serviceId.clone(),
                    self.callId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.callId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for AggregatedResultSubmitted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&AggregatedResultSubmitted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &AggregatedResultSubmitted,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BlueprintCreated(uint64,address,address)` and selector `0x2b0f6a7b1f5afd7832e49972f40b9fcd16998930b24f36469c91003502d0d998`.
```solidity
event BlueprintCreated(uint64 indexed blueprintId, address indexed owner, address manager);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlueprintCreated {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub owner: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub manager: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlueprintCreated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BlueprintCreated(uint64,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                43u8,
                15u8,
                106u8,
                123u8,
                31u8,
                90u8,
                253u8,
                120u8,
                50u8,
                228u8,
                153u8,
                114u8,
                244u8,
                11u8,
                159u8,
                205u8,
                22u8,
                153u8,
                137u8,
                48u8,
                178u8,
                79u8,
                54u8,
                70u8,
                156u8,
                145u8,
                0u8,
                53u8,
                2u8,
                208u8,
                217u8,
                152u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blueprintId: topics.1,
                    owner: topics.2,
                    manager: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.manager,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blueprintId.clone(),
                    self.owner.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.owner,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlueprintCreated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlueprintCreated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BlueprintCreated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BlueprintDeactivated(uint64)` and selector `0xe14286f3ad49ada6d0911adda8ef90616999045bde2a33e391a7b5ae6589e789`.
```solidity
event BlueprintDeactivated(uint64 indexed blueprintId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlueprintDeactivated {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlueprintDeactivated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "BlueprintDeactivated(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                225u8,
                66u8,
                134u8,
                243u8,
                173u8,
                73u8,
                173u8,
                166u8,
                208u8,
                145u8,
                26u8,
                221u8,
                168u8,
                239u8,
                144u8,
                97u8,
                105u8,
                153u8,
                4u8,
                91u8,
                222u8,
                42u8,
                51u8,
                227u8,
                145u8,
                167u8,
                181u8,
                174u8,
                101u8,
                137u8,
                231u8,
                137u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { blueprintId: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.blueprintId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlueprintDeactivated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlueprintDeactivated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BlueprintDeactivated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BlueprintTransferred(uint64,address,address)` and selector `0xd2b958a1b0b978ceded4986b4f49c8b25fbd6e812cb8925e13efc731ea4aa24d`.
```solidity
event BlueprintTransferred(uint64 indexed blueprintId, address indexed from, address indexed to);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlueprintTransferred {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub from: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub to: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlueprintTransferred {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "BlueprintTransferred(uint64,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                210u8,
                185u8,
                88u8,
                161u8,
                176u8,
                185u8,
                120u8,
                206u8,
                222u8,
                212u8,
                152u8,
                107u8,
                79u8,
                73u8,
                200u8,
                178u8,
                95u8,
                189u8,
                110u8,
                129u8,
                44u8,
                184u8,
                146u8,
                94u8,
                19u8,
                239u8,
                199u8,
                49u8,
                234u8,
                74u8,
                162u8,
                77u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blueprintId: topics.1,
                    from: topics.2,
                    to: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blueprintId.clone(),
                    self.from.clone(),
                    self.to.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.from,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.to,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlueprintTransferred {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlueprintTransferred> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BlueprintTransferred) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `BlueprintUpdated(uint64,string)` and selector `0x30fc45e05a33fd9068cf6ae1a8f3db2b9d15372dd6494eccc8cd5d305fdf38b3`.
```solidity
event BlueprintUpdated(uint64 indexed blueprintId, string metadataUri);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct BlueprintUpdated {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub metadataUri: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for BlueprintUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "BlueprintUpdated(uint64,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                48u8,
                252u8,
                69u8,
                224u8,
                90u8,
                51u8,
                253u8,
                144u8,
                104u8,
                207u8,
                106u8,
                225u8,
                168u8,
                243u8,
                219u8,
                43u8,
                157u8,
                21u8,
                55u8,
                45u8,
                214u8,
                73u8,
                78u8,
                204u8,
                200u8,
                205u8,
                93u8,
                48u8,
                95u8,
                223u8,
                56u8,
                179u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blueprintId: topics.1,
                    metadataUri: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.metadataUri,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.blueprintId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for BlueprintUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&BlueprintUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &BlueprintUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `EscrowFunded(uint64,address,uint256)` and selector `0xd28de7c518c312fa388e03f8d1203d8f4c75161e358ffb0827b6caa2e9ac8a31`.
```solidity
event EscrowFunded(uint64 indexed serviceId, address indexed token, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct EscrowFunded {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for EscrowFunded {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "EscrowFunded(uint64,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                210u8,
                141u8,
                231u8,
                197u8,
                24u8,
                195u8,
                18u8,
                250u8,
                56u8,
                142u8,
                3u8,
                248u8,
                209u8,
                32u8,
                61u8,
                143u8,
                76u8,
                117u8,
                22u8,
                30u8,
                53u8,
                143u8,
                251u8,
                8u8,
                39u8,
                182u8,
                202u8,
                162u8,
                233u8,
                172u8,
                138u8,
                49u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    token: topics.2,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.serviceId.clone(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for EscrowFunded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&EscrowFunded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &EscrowFunded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Initialized(uint64)` and selector `0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2`.
```solidity
event Initialized(uint64 version);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Initialized {
        #[allow(missing_docs)]
        pub version: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Initialized {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Initialized(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                199u8,
                245u8,
                5u8,
                178u8,
                243u8,
                113u8,
                174u8,
                33u8,
                117u8,
                238u8,
                73u8,
                19u8,
                244u8,
                73u8,
                158u8,
                31u8,
                38u8,
                51u8,
                167u8,
                181u8,
                147u8,
                99u8,
                33u8,
                238u8,
                209u8,
                205u8,
                174u8,
                182u8,
                17u8,
                81u8,
                129u8,
                210u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { version: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.version),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Initialized {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Initialized> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Initialized) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `JobCompleted(uint64,uint64)` and selector `0x60a7649f6e93e7a3ce1dc9729c20e3d95dce28c6a6bd957cde09d8a1cb37c19f`.
```solidity
event JobCompleted(uint64 indexed serviceId, uint64 indexed callId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct JobCompleted {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for JobCompleted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "JobCompleted(uint64,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                96u8,
                167u8,
                100u8,
                159u8,
                110u8,
                147u8,
                231u8,
                163u8,
                206u8,
                29u8,
                201u8,
                114u8,
                156u8,
                32u8,
                227u8,
                217u8,
                93u8,
                206u8,
                40u8,
                198u8,
                166u8,
                189u8,
                149u8,
                124u8,
                222u8,
                9u8,
                216u8,
                161u8,
                203u8,
                55u8,
                193u8,
                159u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    callId: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.serviceId.clone(),
                    self.callId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.callId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for JobCompleted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&JobCompleted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &JobCompleted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `JobResultSubmitted(uint64,uint64,address,bytes)` and selector `0x8a04f99fe23284e874e8dd017345248279cc59701695e73bcdbeb6241bcd2ac6`.
```solidity
event JobResultSubmitted(uint64 indexed serviceId, uint64 indexed callId, address indexed operator, bytes output);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct JobResultSubmitted {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub output: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for JobResultSubmitted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "JobResultSubmitted(uint64,uint64,address,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                138u8,
                4u8,
                249u8,
                159u8,
                226u8,
                50u8,
                132u8,
                232u8,
                116u8,
                232u8,
                221u8,
                1u8,
                115u8,
                69u8,
                36u8,
                130u8,
                121u8,
                204u8,
                89u8,
                112u8,
                22u8,
                149u8,
                231u8,
                59u8,
                205u8,
                190u8,
                182u8,
                36u8,
                27u8,
                205u8,
                42u8,
                198u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    callId: topics.2,
                    operator: topics.3,
                    output: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.output,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.serviceId.clone(),
                    self.callId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.callId);
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for JobResultSubmitted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&JobResultSubmitted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &JobResultSubmitted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `JobSubmitted(uint64,uint64,uint8,address,bytes)` and selector `0xde37cc48d21778e1c9a075c4e41c5aff6918c3ea6151221f0af3ce8121a29db5`.
```solidity
event JobSubmitted(uint64 indexed serviceId, uint64 indexed callId, uint8 jobIndex, address caller, bytes inputs);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct JobSubmitted {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
        #[allow(missing_docs)]
        pub jobIndex: u8,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub inputs: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for JobSubmitted {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "JobSubmitted(uint64,uint64,uint8,address,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                222u8,
                55u8,
                204u8,
                72u8,
                210u8,
                23u8,
                120u8,
                225u8,
                201u8,
                160u8,
                117u8,
                196u8,
                228u8,
                28u8,
                90u8,
                255u8,
                105u8,
                24u8,
                195u8,
                234u8,
                97u8,
                81u8,
                34u8,
                31u8,
                10u8,
                243u8,
                206u8,
                129u8,
                33u8,
                162u8,
                157u8,
                181u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    callId: topics.2,
                    jobIndex: data.0,
                    caller: data.1,
                    inputs: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.jobIndex),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.inputs,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.serviceId.clone(),
                    self.callId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.callId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for JobSubmitted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&JobSubmitted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &JobSubmitted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorJoinedService(uint64,address,uint16)` and selector `0x2457918796078440068385e73e422539c84f2f9045dd442e123d4284258ae24a`.
```solidity
event OperatorJoinedService(uint64 indexed serviceId, address indexed operator, uint16 exposureBps);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorJoinedService {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub exposureBps: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorJoinedService {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<16>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorJoinedService(uint64,address,uint16)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                36u8,
                87u8,
                145u8,
                135u8,
                150u8,
                7u8,
                132u8,
                64u8,
                6u8,
                131u8,
                133u8,
                231u8,
                62u8,
                66u8,
                37u8,
                57u8,
                200u8,
                79u8,
                47u8,
                144u8,
                69u8,
                221u8,
                68u8,
                46u8,
                18u8,
                61u8,
                66u8,
                132u8,
                37u8,
                138u8,
                226u8,
                74u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    operator: topics.2,
                    exposureBps: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.exposureBps),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.serviceId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorJoinedService {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorJoinedService> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorJoinedService) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorLeftService(uint64,address)` and selector `0x8ce53e4b6002ff090e641ddecdaf7edd2813a98e19139fa7d1c79fccc3c4dead`.
```solidity
event OperatorLeftService(uint64 indexed serviceId, address indexed operator);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorLeftService {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorLeftService {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorLeftService(uint64,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                140u8,
                229u8,
                62u8,
                75u8,
                96u8,
                2u8,
                255u8,
                9u8,
                14u8,
                100u8,
                29u8,
                222u8,
                205u8,
                175u8,
                126u8,
                221u8,
                40u8,
                19u8,
                169u8,
                142u8,
                25u8,
                19u8,
                159u8,
                167u8,
                209u8,
                199u8,
                159u8,
                204u8,
                195u8,
                196u8,
                222u8,
                173u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    operator: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.serviceId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorLeftService {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorLeftService> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorLeftService) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorPreRegistered(uint64,address)` and selector `0xd39ff75a15c31a272891c52e42995acfa27459ba1c12239cbac23cdb76f53084`.
```solidity
event OperatorPreRegistered(uint64 indexed blueprintId, address indexed operator);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorPreRegistered {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorPreRegistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorPreRegistered(uint64,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                211u8,
                159u8,
                247u8,
                90u8,
                21u8,
                195u8,
                26u8,
                39u8,
                40u8,
                145u8,
                197u8,
                46u8,
                66u8,
                153u8,
                90u8,
                207u8,
                162u8,
                116u8,
                89u8,
                186u8,
                28u8,
                18u8,
                35u8,
                156u8,
                186u8,
                194u8,
                60u8,
                219u8,
                118u8,
                245u8,
                48u8,
                132u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blueprintId: topics.1,
                    operator: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blueprintId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorPreRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorPreRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorPreRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorPreferencesUpdated(uint64,address,bytes)` and selector `0x8547e94bd95ca7d3c7a3be9b66a29e6f36151be54a2563e35098438861a4c871`.
```solidity
event OperatorPreferencesUpdated(uint64 indexed blueprintId, address indexed operator, bytes preferences);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorPreferencesUpdated {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub preferences: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorPreferencesUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorPreferencesUpdated(uint64,address,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                133u8,
                71u8,
                233u8,
                75u8,
                217u8,
                92u8,
                167u8,
                211u8,
                199u8,
                163u8,
                190u8,
                155u8,
                102u8,
                162u8,
                158u8,
                111u8,
                54u8,
                21u8,
                27u8,
                229u8,
                74u8,
                37u8,
                99u8,
                227u8,
                80u8,
                152u8,
                67u8,
                136u8,
                97u8,
                164u8,
                200u8,
                113u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blueprintId: topics.1,
                    operator: topics.2,
                    preferences: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.preferences,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blueprintId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorPreferencesUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorPreferencesUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OperatorPreferencesUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorRegistered(uint64,address,bytes)` and selector `0xa9cf99c4c75bf0874576e6ee70b00b920e9c36551e4d6c17694ecaa684624d2b`.
```solidity
event OperatorRegistered(uint64 indexed blueprintId, address indexed operator, bytes preferences);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorRegistered {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub preferences: alloy::sol_types::private::Bytes,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorRegistered {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Bytes,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorRegistered(uint64,address,bytes)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                169u8,
                207u8,
                153u8,
                196u8,
                199u8,
                91u8,
                240u8,
                135u8,
                69u8,
                118u8,
                230u8,
                238u8,
                112u8,
                176u8,
                11u8,
                146u8,
                14u8,
                156u8,
                54u8,
                85u8,
                30u8,
                77u8,
                108u8,
                23u8,
                105u8,
                78u8,
                202u8,
                166u8,
                132u8,
                98u8,
                77u8,
                43u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blueprintId: topics.1,
                    operator: topics.2,
                    preferences: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.preferences,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blueprintId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorRegistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorRegistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorRegistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorRpcAddressUpdated(uint64,address,string)` and selector `0x2d0e8c75ccfc606463bd5f7556ccf358b1c409ec6059cee6e51935a29bd0fdc1`.
```solidity
event OperatorRpcAddressUpdated(uint64 indexed blueprintId, address indexed operator, string rpcAddress);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorRpcAddressUpdated {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub rpcAddress: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorRpcAddressUpdated {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorRpcAddressUpdated(uint64,address,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                45u8,
                14u8,
                140u8,
                117u8,
                204u8,
                252u8,
                96u8,
                100u8,
                99u8,
                189u8,
                95u8,
                117u8,
                86u8,
                204u8,
                243u8,
                88u8,
                177u8,
                196u8,
                9u8,
                236u8,
                96u8,
                89u8,
                206u8,
                230u8,
                229u8,
                25u8,
                53u8,
                162u8,
                155u8,
                208u8,
                253u8,
                193u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blueprintId: topics.1,
                    operator: topics.2,
                    rpcAddress: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.rpcAddress,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blueprintId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorRpcAddressUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorRpcAddressUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &OperatorRpcAddressUpdated,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `OperatorUnregistered(uint64,address)` and selector `0x88e46e95bcdf1020c0caf9f3dd5fde69c41d2151dbbca0a77c03c4e28b4d3ec1`.
```solidity
event OperatorUnregistered(uint64 indexed blueprintId, address indexed operator);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct OperatorUnregistered {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for OperatorUnregistered {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "OperatorUnregistered(uint64,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                136u8,
                228u8,
                110u8,
                149u8,
                188u8,
                223u8,
                16u8,
                32u8,
                192u8,
                202u8,
                249u8,
                243u8,
                221u8,
                95u8,
                222u8,
                105u8,
                196u8,
                29u8,
                33u8,
                81u8,
                219u8,
                188u8,
                160u8,
                167u8,
                124u8,
                3u8,
                196u8,
                226u8,
                139u8,
                77u8,
                62u8,
                193u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    blueprintId: topics.1,
                    operator: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.blueprintId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for OperatorUnregistered {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&OperatorUnregistered> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &OperatorUnregistered) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Paused(address)` and selector `0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258`.
```solidity
event Paused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Paused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Paused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Paused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Paused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Paused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Paused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `QuoteUsed(address,bytes32)` and selector `0x89a9fcf52fcdc48f0e669fb3b7125291da850132592f5dd580ffb58166c8e9e8`.
```solidity
event QuoteUsed(address indexed operator, bytes32 indexed quoteHash);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct QuoteUsed {
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub quoteHash: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for QuoteUsed {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "QuoteUsed(address,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                137u8,
                169u8,
                252u8,
                245u8,
                47u8,
                205u8,
                196u8,
                143u8,
                14u8,
                102u8,
                159u8,
                179u8,
                183u8,
                18u8,
                82u8,
                145u8,
                218u8,
                133u8,
                1u8,
                50u8,
                89u8,
                47u8,
                93u8,
                213u8,
                128u8,
                255u8,
                181u8,
                129u8,
                102u8,
                200u8,
                233u8,
                232u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    operator: topics.1,
                    quoteHash: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.operator.clone(),
                    self.quoteHash.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.quoteHash);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for QuoteUsed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&QuoteUsed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &QuoteUsed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RewardsClaimed(address,address,uint256)` and selector `0x9310ccfcb8de723f578a9e4282ea9f521f05ae40dc08f3068dfad528a65ee3c7`.
```solidity
event RewardsClaimed(address indexed account, address indexed token, uint256 amount);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RewardsClaimed {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RewardsClaimed {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RewardsClaimed(address,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                147u8,
                16u8,
                204u8,
                252u8,
                184u8,
                222u8,
                114u8,
                63u8,
                87u8,
                138u8,
                158u8,
                66u8,
                130u8,
                234u8,
                159u8,
                82u8,
                31u8,
                5u8,
                174u8,
                64u8,
                220u8,
                8u8,
                243u8,
                6u8,
                141u8,
                250u8,
                213u8,
                40u8,
                166u8,
                94u8,
                227u8,
                199u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    account: topics.1,
                    token: topics.2,
                    amount: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.account.clone(), self.token.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.token,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RewardsClaimed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RewardsClaimed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RewardsClaimed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleAdminChanged(bytes32,bytes32,bytes32)` and selector `0xbd79b86ffe0ab8e8776151514217cd7cacd52c909f66475c3af44e129f0b00ff`.
```solidity
event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleAdminChanged {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub previousAdminRole: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub newAdminRole: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleAdminChanged {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            const SIGNATURE: &'static str = "RoleAdminChanged(bytes32,bytes32,bytes32)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    previousAdminRole: topics.2,
                    newAdminRole: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.previousAdminRole.clone(),
                    self.newAdminRole.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.previousAdminRole);
                out[3usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.newAdminRole);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleAdminChanged {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleAdminChanged> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleAdminChanged) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleGranted(bytes32,address,address)` and selector `0x2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d`.
```solidity
event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleGranted {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleGranted {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleGranted(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleGranted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleGranted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleGranted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `RoleRevoked(bytes32,address,address)` and selector `0xf6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b`.
```solidity
event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct RoleRevoked {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub sender: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for RoleRevoked {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "RoleRevoked(bytes32,address,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    role: topics.1,
                    account: topics.2,
                    sender: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.role.clone(),
                    self.account.clone(),
                    self.sender.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::FixedBytes<
                    32,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.role);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.account,
                );
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.sender,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for RoleRevoked {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&RoleRevoked> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &RoleRevoked) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ServiceActivated(uint64,uint64,uint64)` and selector `0x741e97ee1ff887c4d882f4c49ad280ea7d61d035e4e8a471e531951550275023`.
```solidity
event ServiceActivated(uint64 indexed serviceId, uint64 indexed requestId, uint64 indexed blueprintId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ServiceActivated {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub requestId: u64,
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ServiceActivated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "ServiceActivated(uint64,uint64,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                116u8,
                30u8,
                151u8,
                238u8,
                31u8,
                248u8,
                135u8,
                196u8,
                216u8,
                130u8,
                244u8,
                196u8,
                154u8,
                210u8,
                128u8,
                234u8,
                125u8,
                97u8,
                208u8,
                53u8,
                228u8,
                232u8,
                164u8,
                113u8,
                229u8,
                49u8,
                149u8,
                21u8,
                80u8,
                39u8,
                80u8,
                35u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    requestId: topics.2,
                    blueprintId: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.serviceId.clone(),
                    self.requestId.clone(),
                    self.blueprintId.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.requestId);
                out[3usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ServiceActivated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ServiceActivated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ServiceActivated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ServiceApproved(uint64,address)` and selector `0xceda1a44ead4da3d3abaaa941afa6d9530fd84dd8e99385c9183d986dcab980f`.
```solidity
event ServiceApproved(uint64 indexed requestId, address indexed operator);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ServiceApproved {
        #[allow(missing_docs)]
        pub requestId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ServiceApproved {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ServiceApproved(uint64,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                206u8,
                218u8,
                26u8,
                68u8,
                234u8,
                212u8,
                218u8,
                61u8,
                58u8,
                186u8,
                170u8,
                148u8,
                26u8,
                250u8,
                109u8,
                149u8,
                48u8,
                253u8,
                132u8,
                221u8,
                142u8,
                153u8,
                56u8,
                92u8,
                145u8,
                131u8,
                217u8,
                134u8,
                220u8,
                171u8,
                152u8,
                15u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    requestId: topics.1,
                    operator: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.requestId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.requestId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ServiceApproved {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ServiceApproved> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ServiceApproved) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ServiceRejected(uint64,address)` and selector `0xc63050b963ec6e2cf36df90ecacaa43212c0e74b8c3a58a0f8cce3bd5a2a7675`.
```solidity
event ServiceRejected(uint64 indexed requestId, address indexed operator);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ServiceRejected {
        #[allow(missing_docs)]
        pub requestId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ServiceRejected {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ServiceRejected(uint64,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                198u8,
                48u8,
                80u8,
                185u8,
                99u8,
                236u8,
                110u8,
                44u8,
                243u8,
                109u8,
                249u8,
                14u8,
                202u8,
                202u8,
                164u8,
                50u8,
                18u8,
                192u8,
                231u8,
                75u8,
                140u8,
                58u8,
                88u8,
                160u8,
                248u8,
                204u8,
                227u8,
                189u8,
                90u8,
                42u8,
                118u8,
                117u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    requestId: topics.1,
                    operator: topics.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.requestId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.requestId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ServiceRejected {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ServiceRejected> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ServiceRejected) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ServiceRequested(uint64,uint64,address)` and selector `0xbd1fdda393b679e6c4f873e233b34e2c4ea8283a3f76345dbc143b86ea047679`.
```solidity
event ServiceRequested(uint64 indexed requestId, uint64 indexed blueprintId, address indexed requester);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ServiceRequested {
        #[allow(missing_docs)]
        pub requestId: u64,
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub requester: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ServiceRequested {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ServiceRequested(uint64,uint64,address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                189u8,
                31u8,
                221u8,
                163u8,
                147u8,
                182u8,
                121u8,
                230u8,
                196u8,
                248u8,
                115u8,
                226u8,
                51u8,
                179u8,
                78u8,
                44u8,
                78u8,
                168u8,
                40u8,
                58u8,
                63u8,
                118u8,
                52u8,
                93u8,
                188u8,
                20u8,
                59u8,
                134u8,
                234u8,
                4u8,
                118u8,
                121u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    requestId: topics.1,
                    blueprintId: topics.2,
                    requester: topics.3,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.requestId.clone(),
                    self.blueprintId.clone(),
                    self.requester.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.requestId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.requester,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ServiceRequested {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ServiceRequested> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ServiceRequested) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ServiceRequestedWithSecurity(uint64,uint64,address,address[],((uint8,address),uint16,uint16)[])` and selector `0xe9b9d941d31762ebeb7a00008b4cf95e9a19255cb6695c9d35215c914a7e8486`.
```solidity
event ServiceRequestedWithSecurity(uint64 indexed requestId, uint64 indexed blueprintId, address indexed requester, address[] operators, Types.AssetSecurityRequirement[] securityRequirements);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ServiceRequestedWithSecurity {
        #[allow(missing_docs)]
        pub requestId: u64,
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub requester: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub operators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub securityRequirements: alloy::sol_types::private::Vec<
            <Types::AssetSecurityRequirement as alloy::sol_types::SolType>::RustType,
        >,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ServiceRequestedWithSecurity {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<Types::AssetSecurityRequirement>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "ServiceRequestedWithSecurity(uint64,uint64,address,address[],((uint8,address),uint16,uint16)[])";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                233u8,
                185u8,
                217u8,
                65u8,
                211u8,
                23u8,
                98u8,
                235u8,
                235u8,
                122u8,
                0u8,
                0u8,
                139u8,
                76u8,
                249u8,
                94u8,
                154u8,
                25u8,
                37u8,
                92u8,
                182u8,
                105u8,
                92u8,
                157u8,
                53u8,
                33u8,
                92u8,
                145u8,
                74u8,
                126u8,
                132u8,
                134u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    requestId: topics.1,
                    blueprintId: topics.2,
                    requester: topics.3,
                    operators: data.0,
                    securityRequirements: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.operators),
                    <alloy::sol_types::sol_data::Array<
                        Types::AssetSecurityRequirement,
                    > as alloy_sol_types::SolType>::tokenize(&self.securityRequirements),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.requestId.clone(),
                    self.blueprintId.clone(),
                    self.requester.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.requestId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.blueprintId);
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.requester,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ServiceRequestedWithSecurity {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ServiceRequestedWithSecurity> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(
                this: &ServiceRequestedWithSecurity,
            ) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `ServiceTerminated(uint64)` and selector `0x3fd558a59bbce1d996d17eab7fde314bcd201ec3f17375a7f873b3162927e881`.
```solidity
event ServiceTerminated(uint64 indexed serviceId);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct ServiceTerminated {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for ServiceTerminated {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "ServiceTerminated(uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                63u8,
                213u8,
                88u8,
                165u8,
                155u8,
                188u8,
                225u8,
                217u8,
                150u8,
                209u8,
                126u8,
                171u8,
                127u8,
                222u8,
                49u8,
                75u8,
                205u8,
                32u8,
                30u8,
                195u8,
                241u8,
                115u8,
                117u8,
                167u8,
                248u8,
                115u8,
                179u8,
                22u8,
                41u8,
                39u8,
                232u8,
                129u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { serviceId: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.serviceId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for ServiceTerminated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&ServiceTerminated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &ServiceTerminated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SlashCancelled(uint64,address,string)` and selector `0xe80d1a183af30916f79b15a6c85e82470d0b88065dfdd2505d106adf0e8b7796`.
```solidity
event SlashCancelled(uint64 indexed slashId, address indexed canceller, string reason);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SlashCancelled {
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub canceller: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SlashCancelled {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SlashCancelled(uint64,address,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                232u8,
                13u8,
                26u8,
                24u8,
                58u8,
                243u8,
                9u8,
                22u8,
                247u8,
                155u8,
                21u8,
                166u8,
                200u8,
                94u8,
                130u8,
                71u8,
                13u8,
                11u8,
                136u8,
                6u8,
                93u8,
                253u8,
                210u8,
                80u8,
                93u8,
                16u8,
                106u8,
                223u8,
                14u8,
                139u8,
                119u8,
                150u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    slashId: topics.1,
                    canceller: topics.2,
                    reason: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.slashId.clone(),
                    self.canceller.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.slashId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.canceller,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SlashCancelled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SlashCancelled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SlashCancelled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SlashConfigUpdated(uint64,bool,uint16)` and selector `0x33e0411431005a063470b554094e62f6973aa35fce230eaf5d5a0079be4e339c`.
```solidity
event SlashConfigUpdated(uint64 disputeWindow, bool instantSlashEnabled, uint16 maxSlashBps);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SlashConfigUpdated {
        #[allow(missing_docs)]
        pub disputeWindow: u64,
        #[allow(missing_docs)]
        pub instantSlashEnabled: bool,
        #[allow(missing_docs)]
        pub maxSlashBps: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SlashConfigUpdated {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<16>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "SlashConfigUpdated(uint64,bool,uint16)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                51u8,
                224u8,
                65u8,
                20u8,
                49u8,
                0u8,
                90u8,
                6u8,
                52u8,
                112u8,
                181u8,
                84u8,
                9u8,
                78u8,
                98u8,
                246u8,
                151u8,
                58u8,
                163u8,
                95u8,
                206u8,
                35u8,
                14u8,
                175u8,
                93u8,
                90u8,
                0u8,
                121u8,
                190u8,
                78u8,
                51u8,
                156u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    disputeWindow: data.0,
                    instantSlashEnabled: data.1,
                    maxSlashBps: data.2,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.disputeWindow),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.instantSlashEnabled,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSlashBps),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SlashConfigUpdated {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SlashConfigUpdated> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SlashConfigUpdated) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SlashDisputed(uint64,address,string)` and selector `0x0d4418cc07b1c81f56e2d1277f5d11c1b27ebac6cdacafccecd4add6742b4b0f`.
```solidity
event SlashDisputed(uint64 indexed slashId, address indexed disputer, string reason);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SlashDisputed {
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub disputer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SlashDisputed {
            type DataTuple<'a> = (alloy::sol_types::sol_data::String,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SlashDisputed(uint64,address,string)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                13u8,
                68u8,
                24u8,
                204u8,
                7u8,
                177u8,
                200u8,
                31u8,
                86u8,
                226u8,
                209u8,
                39u8,
                127u8,
                93u8,
                17u8,
                193u8,
                178u8,
                126u8,
                186u8,
                198u8,
                205u8,
                172u8,
                175u8,
                204u8,
                236u8,
                212u8,
                173u8,
                214u8,
                116u8,
                43u8,
                75u8,
                15u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    slashId: topics.1,
                    disputer: topics.2,
                    reason: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.slashId.clone(),
                    self.disputer.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.slashId);
                out[2usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.disputer,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SlashDisputed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SlashDisputed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SlashDisputed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SlashExecuted(uint64,uint64,address,uint256)` and selector `0x4a816e132712dbdfe6a363965e5bc68f8e283b999ae11afe294a3162973c3855`.
```solidity
event SlashExecuted(uint64 indexed slashId, uint64 indexed serviceId, address indexed operator, uint256 actualSlashed);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SlashExecuted {
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub actualSlashed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SlashExecuted {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SlashExecuted(uint64,uint64,address,uint256)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                74u8,
                129u8,
                110u8,
                19u8,
                39u8,
                18u8,
                219u8,
                223u8,
                230u8,
                163u8,
                99u8,
                150u8,
                94u8,
                91u8,
                198u8,
                143u8,
                142u8,
                40u8,
                59u8,
                153u8,
                154u8,
                225u8,
                26u8,
                254u8,
                41u8,
                74u8,
                49u8,
                98u8,
                151u8,
                60u8,
                56u8,
                85u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    slashId: topics.1,
                    serviceId: topics.2,
                    operator: topics.3,
                    actualSlashed: data.0,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.actualSlashed),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.slashId.clone(),
                    self.serviceId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.slashId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SlashExecuted {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SlashExecuted> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SlashExecuted) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SlashProposed(uint64,uint64,address,address,uint256,uint256,bytes32,uint64)` and selector `0x29615b457f22e163cc4540327d70f35c1990a8ef0003e915ad170acb817ace3d`.
```solidity
event SlashProposed(uint64 indexed slashId, uint64 indexed serviceId, address indexed operator, address proposer, uint256 amount, uint256 effectiveAmount, bytes32 evidence, uint64 executeAfter);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SlashProposed {
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub proposer: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub effectiveAmount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub executeAfter: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SlashProposed {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "SlashProposed(uint64,uint64,address,address,uint256,uint256,bytes32,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                41u8,
                97u8,
                91u8,
                69u8,
                127u8,
                34u8,
                225u8,
                99u8,
                204u8,
                69u8,
                64u8,
                50u8,
                125u8,
                112u8,
                243u8,
                92u8,
                25u8,
                144u8,
                168u8,
                239u8,
                0u8,
                3u8,
                233u8,
                21u8,
                173u8,
                23u8,
                10u8,
                203u8,
                129u8,
                122u8,
                206u8,
                61u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    slashId: topics.1,
                    serviceId: topics.2,
                    operator: topics.3,
                    proposer: data.0,
                    amount: data.1,
                    effectiveAmount: data.2,
                    evidence: data.3,
                    executeAfter: data.4,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.proposer,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.effectiveAmount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.executeAfter),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (
                    Self::SIGNATURE_HASH.into(),
                    self.slashId.clone(),
                    self.serviceId.clone(),
                    self.operator.clone(),
                )
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.slashId);
                out[2usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                out[3usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.operator,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SlashProposed {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SlashProposed> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SlashProposed) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `SubscriptionBilled(uint64,uint256,uint64)` and selector `0x24dc485bef04b4d790d97ac10381d8d9e66c56dd6fba9931b703ca169511778a`.
```solidity
event SubscriptionBilled(uint64 indexed serviceId, uint256 amount, uint64 period);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct SubscriptionBilled {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub period: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for SubscriptionBilled {
            type DataTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            const SIGNATURE: &'static str = "SubscriptionBilled(uint64,uint256,uint64)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                36u8,
                220u8,
                72u8,
                91u8,
                239u8,
                4u8,
                180u8,
                215u8,
                144u8,
                217u8,
                122u8,
                193u8,
                3u8,
                129u8,
                216u8,
                217u8,
                230u8,
                108u8,
                86u8,
                221u8,
                111u8,
                186u8,
                153u8,
                49u8,
                183u8,
                3u8,
                202u8,
                22u8,
                149u8,
                17u8,
                119u8,
                138u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self {
                    serviceId: topics.1,
                    amount: data.0,
                    period: data.1,
                }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.period),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.serviceId.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Uint<
                    64,
                > as alloy_sol_types::EventTopic>::encode_topic(&self.serviceId);
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for SubscriptionBilled {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&SubscriptionBilled> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &SubscriptionBilled) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Unpaused(address)` and selector `0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa`.
```solidity
event Unpaused(address account);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Unpaused {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Unpaused {
            type DataTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (alloy_sol_types::sol_data::FixedBytes<32>,);
            const SIGNATURE: &'static str = "Unpaused(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { account: data.0 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(),)
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Unpaused {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Unpaused> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Unpaused) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Event with signature `Upgraded(address)` and selector `0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b`.
```solidity
event Upgraded(address indexed implementation);
```*/
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    #[derive(Clone)]
    pub struct Upgraded {
        #[allow(missing_docs)]
        pub implementation: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        #[automatically_derived]
        impl alloy_sol_types::SolEvent for Upgraded {
            type DataTuple<'a> = ();
            type DataToken<'a> = <Self::DataTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type TopicList = (
                alloy_sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            const SIGNATURE: &'static str = "Upgraded(address)";
            const SIGNATURE_HASH: alloy_sol_types::private::B256 = alloy_sol_types::private::B256::new([
                188u8,
                124u8,
                215u8,
                90u8,
                32u8,
                238u8,
                39u8,
                253u8,
                154u8,
                222u8,
                186u8,
                179u8,
                32u8,
                65u8,
                247u8,
                85u8,
                33u8,
                77u8,
                188u8,
                107u8,
                255u8,
                169u8,
                12u8,
                192u8,
                34u8,
                91u8,
                57u8,
                218u8,
                46u8,
                92u8,
                45u8,
                59u8,
            ]);
            const ANONYMOUS: bool = false;
            #[allow(unused_variables)]
            #[inline]
            fn new(
                topics: <Self::TopicList as alloy_sol_types::SolType>::RustType,
                data: <Self::DataTuple<'_> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                Self { implementation: topics.1 }
            }
            #[inline]
            fn check_signature(
                topics: &<Self::TopicList as alloy_sol_types::SolType>::RustType,
            ) -> alloy_sol_types::Result<()> {
                if topics.0 != Self::SIGNATURE_HASH {
                    return Err(
                        alloy_sol_types::Error::invalid_event_signature_hash(
                            Self::SIGNATURE,
                            topics.0,
                            Self::SIGNATURE_HASH,
                        ),
                    );
                }
                Ok(())
            }
            #[inline]
            fn tokenize_body(&self) -> Self::DataToken<'_> {
                ()
            }
            #[inline]
            fn topics(&self) -> <Self::TopicList as alloy_sol_types::SolType>::RustType {
                (Self::SIGNATURE_HASH.into(), self.implementation.clone())
            }
            #[inline]
            fn encode_topics_raw(
                &self,
                out: &mut [alloy_sol_types::abi::token::WordToken],
            ) -> alloy_sol_types::Result<()> {
                if out.len() < <Self::TopicList as alloy_sol_types::TopicList>::COUNT {
                    return Err(alloy_sol_types::Error::Overrun);
                }
                out[0usize] = alloy_sol_types::abi::token::WordToken(
                    Self::SIGNATURE_HASH,
                );
                out[1usize] = <alloy::sol_types::sol_data::Address as alloy_sol_types::EventTopic>::encode_topic(
                    &self.implementation,
                );
                Ok(())
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::private::IntoLogData for Upgraded {
            fn to_log_data(&self) -> alloy_sol_types::private::LogData {
                From::from(self)
            }
            fn into_log_data(self) -> alloy_sol_types::private::LogData {
                From::from(&self)
            }
        }
        #[automatically_derived]
        impl From<&Upgraded> for alloy_sol_types::private::LogData {
            #[inline]
            fn from(this: &Upgraded) -> alloy_sol_types::private::LogData {
                alloy_sol_types::SolEvent::encode_log_data(this)
            }
        }
    };
    /**Function with signature `ADMIN_ROLE()` and selector `0x75b238fc`.
```solidity
function ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`ADMIN_ROLE()`](ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ADMIN_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<ADMIN_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [117u8, 178u8, 56u8, 252u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `DEFAULT_ADMIN_ROLE()` and selector `0xa217fddf`.
```solidity
function DEFAULT_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`DEFAULT_ADMIN_ROLE()`](DEFAULT_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct DEFAULT_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<DEFAULT_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: DEFAULT_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for DEFAULT_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for DEFAULT_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = DEFAULT_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "DEFAULT_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [162u8, 23u8, 253u8, 223u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `PAUSER_ROLE()` and selector `0xe63ab1e9`.
```solidity
function PAUSER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLECall {}
    ///Container type for the return parameters of the [`PAUSER_ROLE()`](PAUSER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct PAUSER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<PAUSER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: PAUSER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for PAUSER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for PAUSER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = PAUSER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "PAUSER_ROLE()";
            const SELECTOR: [u8; 4] = [230u8, 58u8, 177u8, 233u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `SLASH_ADMIN_ROLE()` and selector `0x8c9a281d`.
```solidity
function SLASH_ADMIN_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SLASH_ADMIN_ROLECall {}
    ///Container type for the return parameters of the [`SLASH_ADMIN_ROLE()`](SLASH_ADMIN_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct SLASH_ADMIN_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SLASH_ADMIN_ROLECall>
            for UnderlyingRustTuple<'_> {
                fn from(value: SLASH_ADMIN_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SLASH_ADMIN_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<SLASH_ADMIN_ROLEReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: SLASH_ADMIN_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for SLASH_ADMIN_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for SLASH_ADMIN_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = SLASH_ADMIN_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "SLASH_ADMIN_ROLE()";
            const SELECTOR: [u8; 4] = [140u8, 154u8, 40u8, 29u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `UPGRADER_ROLE()` and selector `0xf72c0d8b`.
```solidity
function UPGRADER_ROLE() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADER_ROLECall {}
    ///Container type for the return parameters of the [`UPGRADER_ROLE()`](UPGRADER_ROLECall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADER_ROLEReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADER_ROLECall> for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADER_ROLECall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for UPGRADER_ROLECall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADER_ROLEReturn> for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADER_ROLEReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for UPGRADER_ROLEReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADER_ROLECall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UPGRADER_ROLEReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADER_ROLE()";
            const SELECTOR: [u8; 4] = [247u8, 44u8, 13u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `UPGRADE_INTERFACE_VERSION()` and selector `0xad3cb1cc`.
```solidity
function UPGRADE_INTERFACE_VERSION() external view returns (string memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONCall {}
    ///Container type for the return parameters of the [`UPGRADE_INTERFACE_VERSION()`](UPGRADE_INTERFACE_VERSIONCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct UPGRADE_INTERFACE_VERSIONReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::String,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::String,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::String,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UPGRADE_INTERFACE_VERSIONReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: UPGRADE_INTERFACE_VERSIONReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for UPGRADE_INTERFACE_VERSIONReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for UPGRADE_INTERFACE_VERSIONCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = UPGRADE_INTERFACE_VERSIONReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::String,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "UPGRADE_INTERFACE_VERSION()";
            const SELECTOR: [u8; 4] = [173u8, 60u8, 177u8, 204u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `addPermittedCaller(uint64,address)` and selector `0x815d6a26`.
```solidity
function addPermittedCaller(uint64 serviceId, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addPermittedCallerCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`addPermittedCaller(uint64,address)`](addPermittedCallerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct addPermittedCallerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addPermittedCallerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: addPermittedCallerCall) -> Self {
                    (value.serviceId, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addPermittedCallerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        caller: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<addPermittedCallerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: addPermittedCallerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for addPermittedCallerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for addPermittedCallerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = addPermittedCallerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "addPermittedCaller(uint64,address)";
            const SELECTOR: [u8; 4] = [129u8, 93u8, 106u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approveService(uint64,uint8)` and selector `0x614823b2`.
```solidity
function approveService(uint64 requestId, uint8 restakingPercent) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveServiceCall {
        #[allow(missing_docs)]
        pub requestId: u64,
        #[allow(missing_docs)]
        pub restakingPercent: u8,
    }
    ///Container type for the return parameters of the [`approveService(uint64,uint8)`](approveServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveServiceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u8);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveServiceCall> for UnderlyingRustTuple<'_> {
                fn from(value: approveServiceCall) -> Self {
                    (value.requestId, value.restakingPercent)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for approveServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        requestId: tuple.0,
                        restakingPercent: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveServiceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: approveServiceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for approveServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveServiceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<8>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveServiceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approveService(uint64,uint8)";
            const SELECTOR: [u8; 4] = [97u8, 72u8, 35u8, 178u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.restakingPercent),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `approveServiceWithCommitments(uint64,((uint8,address),uint16)[])` and selector `0x23d7b3e1`.
```solidity
function approveServiceWithCommitments(uint64 requestId, Types.AssetSecurityCommitment[] memory commitments) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveServiceWithCommitmentsCall {
        #[allow(missing_docs)]
        pub requestId: u64,
        #[allow(missing_docs)]
        pub commitments: alloy::sol_types::private::Vec<
            <Types::AssetSecurityCommitment as alloy::sol_types::SolType>::RustType,
        >,
    }
    ///Container type for the return parameters of the [`approveServiceWithCommitments(uint64,((uint8,address),uint16)[])`](approveServiceWithCommitmentsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct approveServiceWithCommitmentsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<Types::AssetSecurityCommitment>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Vec<
                    <Types::AssetSecurityCommitment as alloy::sol_types::SolType>::RustType,
                >,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveServiceWithCommitmentsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: approveServiceWithCommitmentsCall) -> Self {
                    (value.requestId, value.commitments)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for approveServiceWithCommitmentsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        requestId: tuple.0,
                        commitments: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<approveServiceWithCommitmentsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: approveServiceWithCommitmentsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for approveServiceWithCommitmentsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for approveServiceWithCommitmentsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<Types::AssetSecurityCommitment>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = approveServiceWithCommitmentsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "approveServiceWithCommitments(uint64,((uint8,address),uint16)[])";
            const SELECTOR: [u8; 4] = [35u8, 215u8, 179u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                    <alloy::sol_types::sol_data::Array<
                        Types::AssetSecurityCommitment,
                    > as alloy_sol_types::SolType>::tokenize(&self.commitments),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `billSubscription(uint64)` and selector `0xcf3806c6`.
```solidity
function billSubscription(uint64 serviceId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct billSubscriptionCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    ///Container type for the return parameters of the [`billSubscription(uint64)`](billSubscriptionCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct billSubscriptionReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<billSubscriptionCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: billSubscriptionCall) -> Self {
                    (value.serviceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for billSubscriptionCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<billSubscriptionReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: billSubscriptionReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for billSubscriptionReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for billSubscriptionCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = billSubscriptionReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "billSubscription(uint64)";
            const SELECTOR: [u8; 4] = [207u8, 56u8, 6u8, 198u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `billSubscriptionBatch(uint64[])` and selector `0xda232ded`.
```solidity
function billSubscriptionBatch(uint64[] memory serviceIds) external returns (uint256 totalBilled, uint256 billedCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct billSubscriptionBatchCall {
        #[allow(missing_docs)]
        pub serviceIds: alloy::sol_types::private::Vec<u64>,
    }
    ///Container type for the return parameters of the [`billSubscriptionBatch(uint64[])`](billSubscriptionBatchCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct billSubscriptionBatchReturn {
        #[allow(missing_docs)]
        pub totalBilled: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub billedCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<u64>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<billSubscriptionBatchCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: billSubscriptionBatchCall) -> Self {
                    (value.serviceIds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for billSubscriptionBatchCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceIds: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<billSubscriptionBatchReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: billSubscriptionBatchReturn) -> Self {
                    (value.totalBilled, value.billedCount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for billSubscriptionBatchReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        totalBilled: tuple.0,
                        billedCount: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for billSubscriptionBatchCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = billSubscriptionBatchReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "billSubscriptionBatch(uint64[])";
            const SELECTOR: [u8; 4] = [218u8, 35u8, 45u8, 237u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<64>,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceIds),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `blueprintCount()` and selector `0xc602d4fa`.
```solidity
function blueprintCount() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blueprintCountCall {}
    ///Container type for the return parameters of the [`blueprintCount()`](blueprintCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blueprintCountReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blueprintCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: blueprintCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for blueprintCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blueprintCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: blueprintCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blueprintCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blueprintCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = blueprintCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blueprintCount()";
            const SELECTOR: [u8; 4] = [198u8, 2u8, 212u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `blueprintOperatorCount(uint64)` and selector `0x8d3f65be`.
```solidity
function blueprintOperatorCount(uint64 blueprintId) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blueprintOperatorCountCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    ///Container type for the return parameters of the [`blueprintOperatorCount(uint64)`](blueprintOperatorCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct blueprintOperatorCountReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blueprintOperatorCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: blueprintOperatorCountCall) -> Self {
                    (value.blueprintId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blueprintOperatorCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blueprintId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<blueprintOperatorCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: blueprintOperatorCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for blueprintOperatorCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for blueprintOperatorCountCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = blueprintOperatorCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "blueprintOperatorCount(uint64)";
            const SELECTOR: [u8; 4] = [141u8, 63u8, 101u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `cancelSlash(uint64,string)` and selector `0x06079dc5`.
```solidity
function cancelSlash(uint64 slashId, string memory reason) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cancelSlashCall {
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`cancelSlash(uint64,string)`](cancelSlashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct cancelSlashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cancelSlashCall> for UnderlyingRustTuple<'_> {
                fn from(value: cancelSlashCall) -> Self {
                    (value.slashId, value.reason)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for cancelSlashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        slashId: tuple.0,
                        reason: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<cancelSlashReturn> for UnderlyingRustTuple<'_> {
                fn from(value: cancelSlashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for cancelSlashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for cancelSlashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = cancelSlashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "cancelSlash(uint64,string)";
            const SELECTOR: [u8; 4] = [6u8, 7u8, 157u8, 197u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimRewards()` and selector `0x372500ab`.
```solidity
function claimRewards() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimRewards_0Call {}
    ///Container type for the return parameters of the [`claimRewards()`](claimRewards_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimRewards_0Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimRewards_0Call> for UnderlyingRustTuple<'_> {
                fn from(value: claimRewards_0Call) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimRewards_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimRewards_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimRewards_0Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimRewards_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimRewards_0Call {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimRewards_0Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimRewards()";
            const SELECTOR: [u8; 4] = [55u8, 37u8, 0u8, 171u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `claimRewards(address)` and selector `0xef5cfb8c`.
```solidity
function claimRewards(address token) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimRewards_1Call {
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`claimRewards(address)`](claimRewards_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct claimRewards_1Return {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimRewards_1Call> for UnderlyingRustTuple<'_> {
                fn from(value: claimRewards_1Call) -> Self {
                    (value.token,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for claimRewards_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { token: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<claimRewards_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: claimRewards_1Return) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for claimRewards_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for claimRewards_1Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = claimRewards_1Return;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "claimRewards(address)";
            const SELECTOR: [u8; 4] = [239u8, 92u8, 251u8, 140u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createBlueprint(string,address)` and selector `0xe72146a9`.
```solidity
function createBlueprint(string memory metadataUri, address manager) external returns (uint64 blueprintId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createBlueprintCall {
        #[allow(missing_docs)]
        pub metadataUri: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub manager: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`createBlueprint(string,address)`](createBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createBlueprintReturn {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createBlueprintCall> for UnderlyingRustTuple<'_> {
                fn from(value: createBlueprintCall) -> Self {
                    (value.metadataUri, value.manager)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for createBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        metadataUri: tuple.0,
                        manager: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createBlueprintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createBlueprintReturn) -> Self {
                    (value.blueprintId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blueprintId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createBlueprintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createBlueprintReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createBlueprint(string,address)";
            const SELECTOR: [u8; 4] = [231u8, 33u8, 70u8, 169u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.metadataUri,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.manager,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createBlueprintWithConfig(string,address,(uint8,uint8,uint32,uint32,uint256,uint64,uint256))` and selector `0x78448637`.
```solidity
function createBlueprintWithConfig(string memory metadataUri, address manager, Types.BlueprintConfig memory config) external returns (uint64 blueprintId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createBlueprintWithConfigCall {
        #[allow(missing_docs)]
        pub metadataUri: alloy::sol_types::private::String,
        #[allow(missing_docs)]
        pub manager: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub config: <Types::BlueprintConfig as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`createBlueprintWithConfig(string,address,(uint8,uint8,uint32,uint32,uint256,uint64,uint256))`](createBlueprintWithConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createBlueprintWithConfigReturn {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Address,
                Types::BlueprintConfig,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::String,
                alloy::sol_types::private::Address,
                <Types::BlueprintConfig as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createBlueprintWithConfigCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createBlueprintWithConfigCall) -> Self {
                    (value.metadataUri, value.manager, value.config)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createBlueprintWithConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        metadataUri: tuple.0,
                        manager: tuple.1,
                        config: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createBlueprintWithConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createBlueprintWithConfigReturn) -> Self {
                    (value.blueprintId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createBlueprintWithConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blueprintId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createBlueprintWithConfigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::String,
                alloy::sol_types::sol_data::Address,
                Types::BlueprintConfig,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createBlueprintWithConfigReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createBlueprintWithConfig(string,address,(uint8,uint8,uint32,uint32,uint256,uint64,uint256))";
            const SELECTOR: [u8; 4] = [120u8, 68u8, 134u8, 55u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.metadataUri,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.manager,
                    ),
                    <Types::BlueprintConfig as alloy_sol_types::SolType>::tokenize(
                        &self.config,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `createServiceFromQuotes(uint64,((uint64,uint64,uint256,uint64,uint64,((uint8,address),uint16)[]),bytes,address)[],bytes,address[],uint64)` and selector `0xf0411af3`.
```solidity
function createServiceFromQuotes(uint64 blueprintId, Types.SignedQuote[] memory quotes, bytes memory config, address[] memory permittedCallers, uint64 ttl) external payable returns (uint64 serviceId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createServiceFromQuotesCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub quotes: alloy::sol_types::private::Vec<
            <Types::SignedQuote as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub config: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub permittedCallers: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub ttl: u64,
    }
    ///Container type for the return parameters of the [`createServiceFromQuotes(uint64,((uint64,uint64,uint256,uint64,uint64,((uint8,address),uint16)[]),bytes,address)[],bytes,address[],uint64)`](createServiceFromQuotesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct createServiceFromQuotesReturn {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<Types::SignedQuote>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Vec<
                    <Types::SignedQuote as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                u64,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createServiceFromQuotesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: createServiceFromQuotesCall) -> Self {
                    (
                        value.blueprintId,
                        value.quotes,
                        value.config,
                        value.permittedCallers,
                        value.ttl,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createServiceFromQuotesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        quotes: tuple.1,
                        config: tuple.2,
                        permittedCallers: tuple.3,
                        ttl: tuple.4,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<createServiceFromQuotesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: createServiceFromQuotesReturn) -> Self {
                    (value.serviceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for createServiceFromQuotesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for createServiceFromQuotesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<Types::SignedQuote>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = createServiceFromQuotesReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "createServiceFromQuotes(uint64,((uint64,uint64,uint256,uint64,uint64,((uint8,address),uint16)[]),bytes,address)[],bytes,address[],uint64)";
            const SELECTOR: [u8; 4] = [240u8, 65u8, 26u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Array<
                        Types::SignedQuote,
                    > as alloy_sol_types::SolType>::tokenize(&self.quotes),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.config,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.permittedCallers),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.ttl),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `deactivateBlueprint(uint64)` and selector `0x449bb849`.
```solidity
function deactivateBlueprint(uint64 blueprintId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deactivateBlueprintCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    ///Container type for the return parameters of the [`deactivateBlueprint(uint64)`](deactivateBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct deactivateBlueprintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deactivateBlueprintCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: deactivateBlueprintCall) -> Self {
                    (value.blueprintId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for deactivateBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blueprintId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<deactivateBlueprintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: deactivateBlueprintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for deactivateBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for deactivateBlueprintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = deactivateBlueprintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "deactivateBlueprint(uint64)";
            const SELECTOR: [u8; 4] = [68u8, 155u8, 184u8, 73u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `disputeSlash(uint64,string)` and selector `0x77380c74`.
```solidity
function disputeSlash(uint64 slashId, string memory reason) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disputeSlashCall {
        #[allow(missing_docs)]
        pub slashId: u64,
        #[allow(missing_docs)]
        pub reason: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`disputeSlash(uint64,string)`](disputeSlashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct disputeSlashReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disputeSlashCall> for UnderlyingRustTuple<'_> {
                fn from(value: disputeSlashCall) -> Self {
                    (value.slashId, value.reason)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for disputeSlashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        slashId: tuple.0,
                        reason: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<disputeSlashReturn> for UnderlyingRustTuple<'_> {
                fn from(value: disputeSlashReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for disputeSlashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for disputeSlashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = disputeSlashReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "disputeSlash(uint64,string)";
            const SELECTOR: [u8; 4] = [119u8, 56u8, 12u8, 116u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.reason,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `executeSlash(uint64)` and selector `0xa5bfbae4`.
```solidity
function executeSlash(uint64 slashId) external returns (uint256 actualSlashed);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeSlashCall {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    ///Container type for the return parameters of the [`executeSlash(uint64)`](executeSlashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeSlashReturn {
        #[allow(missing_docs)]
        pub actualSlashed: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeSlashCall> for UnderlyingRustTuple<'_> {
                fn from(value: executeSlashCall) -> Self {
                    (value.slashId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for executeSlashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slashId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeSlashReturn> for UnderlyingRustTuple<'_> {
                fn from(value: executeSlashReturn) -> Self {
                    (value.actualSlashed,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for executeSlashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { actualSlashed: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for executeSlashCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = executeSlashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "executeSlash(uint64)";
            const SELECTOR: [u8; 4] = [165u8, 191u8, 186u8, 228u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `executeSlashBatch(uint64[])` and selector `0xb055449b`.
```solidity
function executeSlashBatch(uint64[] memory slashIds) external returns (uint256 totalSlashed, uint256 executedCount);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeSlashBatchCall {
        #[allow(missing_docs)]
        pub slashIds: alloy::sol_types::private::Vec<u64>,
    }
    ///Container type for the return parameters of the [`executeSlashBatch(uint64[])`](executeSlashBatchCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct executeSlashBatchReturn {
        #[allow(missing_docs)]
        pub totalSlashed: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub executedCount: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<u64>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeSlashBatchCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeSlashBatchCall) -> Self {
                    (value.slashIds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeSlashBatchCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slashIds: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<executeSlashBatchReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: executeSlashBatchReturn) -> Self {
                    (value.totalSlashed, value.executedCount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for executeSlashBatchReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        totalSlashed: tuple.0,
                        executedCount: tuple.1,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for executeSlashBatchCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = executeSlashBatchReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "executeSlashBatch(uint64[])";
            const SELECTOR: [u8; 4] = [176u8, 85u8, 68u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<64>,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashIds),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `fundService(uint64,uint256)` and selector `0x970e08fe`.
```solidity
function fundService(uint64 serviceId, uint256 amount) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fundServiceCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`fundService(uint64,uint256)`](fundServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct fundServiceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fundServiceCall> for UnderlyingRustTuple<'_> {
                fn from(value: fundServiceCall) -> Self {
                    (value.serviceId, value.amount)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fundServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        amount: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<fundServiceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: fundServiceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for fundServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for fundServiceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = fundServiceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "fundService(uint64,uint256)";
            const SELECTOR: [u8; 4] = [151u8, 14u8, 8u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBillableServices(uint64[])` and selector `0x93f3ddaf`.
```solidity
function getBillableServices(uint64[] memory serviceIds) external view returns (uint64[] memory billable);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBillableServicesCall {
        #[allow(missing_docs)]
        pub serviceIds: alloy::sol_types::private::Vec<u64>,
    }
    ///Container type for the return parameters of the [`getBillableServices(uint64[])`](getBillableServicesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBillableServicesReturn {
        #[allow(missing_docs)]
        pub billable: alloy::sol_types::private::Vec<u64>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<u64>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBillableServicesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBillableServicesCall) -> Self {
                    (value.serviceIds,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBillableServicesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceIds: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<u64>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBillableServicesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBillableServicesReturn) -> Self {
                    (value.billable,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBillableServicesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { billable: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBillableServicesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBillableServicesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBillableServices(uint64[])";
            const SELECTOR: [u8; 4] = [147u8, 243u8, 221u8, 175u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<64>,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceIds),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBlueprint(uint64)` and selector `0xb7696dbb`.
```solidity
function getBlueprint(uint64 id) external view returns (Types.Blueprint memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlueprintCall {
        #[allow(missing_docs)]
        pub id: u64,
    }
    ///Container type for the return parameters of the [`getBlueprint(uint64)`](getBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlueprintReturn {
        #[allow(missing_docs)]
        pub _0: <Types::Blueprint as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlueprintCall> for UnderlyingRustTuple<'_> {
                fn from(value: getBlueprintCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Types::Blueprint,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::Blueprint as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlueprintReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getBlueprintReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlueprintCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBlueprintReturn;
            type ReturnTuple<'a> = (Types::Blueprint,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlueprint(uint64)";
            const SELECTOR: [u8; 4] = [183u8, 105u8, 109u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getBlueprintConfig(uint64)` and selector `0x563a89f9`.
```solidity
function getBlueprintConfig(uint64 id) external view returns (Types.BlueprintConfig memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlueprintConfigCall {
        #[allow(missing_docs)]
        pub id: u64,
    }
    ///Container type for the return parameters of the [`getBlueprintConfig(uint64)`](getBlueprintConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getBlueprintConfigReturn {
        #[allow(missing_docs)]
        pub _0: <Types::BlueprintConfig as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlueprintConfigCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlueprintConfigCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlueprintConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Types::BlueprintConfig,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::BlueprintConfig as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getBlueprintConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getBlueprintConfigReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getBlueprintConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getBlueprintConfigCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getBlueprintConfigReturn;
            type ReturnTuple<'a> = (Types::BlueprintConfig,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getBlueprintConfig(uint64)";
            const SELECTOR: [u8; 4] = [86u8, 58u8, 137u8, 249u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getExecutableSlashes(uint64,uint64)` and selector `0x110f829b`.
```solidity
function getExecutableSlashes(uint64 fromId, uint64 toId) external view returns (uint64[] memory ids);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getExecutableSlashesCall {
        #[allow(missing_docs)]
        pub fromId: u64,
        #[allow(missing_docs)]
        pub toId: u64,
    }
    ///Container type for the return parameters of the [`getExecutableSlashes(uint64,uint64)`](getExecutableSlashesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getExecutableSlashesReturn {
        #[allow(missing_docs)]
        pub ids: alloy::sol_types::private::Vec<u64>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getExecutableSlashesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getExecutableSlashesCall) -> Self {
                    (value.fromId, value.toId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getExecutableSlashesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        fromId: tuple.0,
                        toId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Vec<u64>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getExecutableSlashesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getExecutableSlashesReturn) -> Self {
                    (value.ids,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getExecutableSlashesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { ids: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getExecutableSlashesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getExecutableSlashesReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getExecutableSlashes(uint64,uint64)";
            const SELECTOR: [u8; 4] = [17u8, 15u8, 130u8, 155u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.fromId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.toId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getJobCall(uint64,uint64)` and selector `0xa672bc0a`.
```solidity
function getJobCall(uint64 serviceId, uint64 callId) external view returns (Types.JobCall memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getJobCallCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
    }
    ///Container type for the return parameters of the [`getJobCall(uint64,uint64)`](getJobCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getJobCallReturn {
        #[allow(missing_docs)]
        pub _0: <Types::JobCall as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u64);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getJobCallCall> for UnderlyingRustTuple<'_> {
                fn from(value: getJobCallCall) -> Self {
                    (value.serviceId, value.callId)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getJobCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        callId: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Types::JobCall,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::JobCall as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getJobCallReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getJobCallReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getJobCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getJobCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getJobCallReturn;
            type ReturnTuple<'a> = (Types::JobCall,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getJobCall(uint64,uint64)";
            const SELECTOR: [u8; 4] = [166u8, 114u8, 188u8, 10u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.callId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getOperatorRegistration(uint64,address)` and selector `0x6bda42f3`.
```solidity
function getOperatorRegistration(uint64 blueprintId, address op) external view returns (Types.OperatorRegistration memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorRegistrationCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub op: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getOperatorRegistration(uint64,address)`](getOperatorRegistrationCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getOperatorRegistrationReturn {
        #[allow(missing_docs)]
        pub _0: <Types::OperatorRegistration as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorRegistrationCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorRegistrationCall) -> Self {
                    (value.blueprintId, value.op)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorRegistrationCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        op: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Types::OperatorRegistration,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::OperatorRegistration as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getOperatorRegistrationReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getOperatorRegistrationReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getOperatorRegistrationReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getOperatorRegistrationCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getOperatorRegistrationReturn;
            type ReturnTuple<'a> = (Types::OperatorRegistration,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getOperatorRegistration(uint64,address)";
            const SELECTOR: [u8; 4] = [107u8, 218u8, 66u8, 243u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.op,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getRoleAdmin(bytes32)` and selector `0x248a9ca3`.
```solidity
function getRoleAdmin(bytes32 role) external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`getRoleAdmin(bytes32)`](getRoleAdminCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getRoleAdminReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminCall> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminCall) -> Self {
                    (value.role,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { role: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getRoleAdminReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getRoleAdminReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getRoleAdminReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getRoleAdminCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getRoleAdminReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getRoleAdmin(bytes32)";
            const SELECTOR: [u8; 4] = [36u8, 138u8, 156u8, 163u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getService(uint64)` and selector `0x3dc0d5fe`.
```solidity
function getService(uint64 id) external view returns (Types.Service memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceCall {
        #[allow(missing_docs)]
        pub id: u64,
    }
    ///Container type for the return parameters of the [`getService(uint64)`](getServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceReturn {
        #[allow(missing_docs)]
        pub _0: <Types::Service as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceCall> for UnderlyingRustTuple<'_> {
                fn from(value: getServiceCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Types::Service,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::Service as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: getServiceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for getServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getServiceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getServiceReturn;
            type ReturnTuple<'a> = (Types::Service,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getService(uint64)";
            const SELECTOR: [u8; 4] = [61u8, 192u8, 213u8, 254u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getServiceEscrow(uint64)` and selector `0xeb8c3bcd`.
```solidity
function getServiceEscrow(uint64 serviceId) external view returns (PaymentLib.ServiceEscrow memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceEscrowCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    ///Container type for the return parameters of the [`getServiceEscrow(uint64)`](getServiceEscrowCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceEscrowReturn {
        #[allow(missing_docs)]
        pub _0: <PaymentLib::ServiceEscrow as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceEscrowCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getServiceEscrowCall) -> Self {
                    (value.serviceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getServiceEscrowCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (PaymentLib::ServiceEscrow,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <PaymentLib::ServiceEscrow as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceEscrowReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getServiceEscrowReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getServiceEscrowReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getServiceEscrowCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getServiceEscrowReturn;
            type ReturnTuple<'a> = (PaymentLib::ServiceEscrow,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getServiceEscrow(uint64)";
            const SELECTOR: [u8; 4] = [235u8, 140u8, 59u8, 205u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getServiceOperator(uint64,address)` and selector `0x842524bb`.
```solidity
function getServiceOperator(uint64 serviceId, address op) external view returns (Types.ServiceOperator memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceOperatorCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub op: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`getServiceOperator(uint64,address)`](getServiceOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceOperatorReturn {
        #[allow(missing_docs)]
        pub _0: <Types::ServiceOperator as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceOperatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getServiceOperatorCall) -> Self {
                    (value.serviceId, value.op)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getServiceOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        op: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Types::ServiceOperator,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::ServiceOperator as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceOperatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getServiceOperatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getServiceOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getServiceOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getServiceOperatorReturn;
            type ReturnTuple<'a> = (Types::ServiceOperator,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getServiceOperator(uint64,address)";
            const SELECTOR: [u8; 4] = [132u8, 37u8, 36u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.op,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getServiceOperators(uint64)` and selector `0xbb207f1f`.
```solidity
function getServiceOperators(uint64 serviceId) external view returns (address[] memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceOperatorsCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    ///Container type for the return parameters of the [`getServiceOperators(uint64)`](getServiceOperatorsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceOperatorsReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceOperatorsCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getServiceOperatorsCall) -> Self {
                    (value.serviceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getServiceOperatorsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceOperatorsReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getServiceOperatorsReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getServiceOperatorsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getServiceOperatorsCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getServiceOperatorsReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getServiceOperators(uint64)";
            const SELECTOR: [u8; 4] = [187u8, 32u8, 127u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getServiceRequest(uint64)` and selector `0x5f9b4dfa`.
```solidity
function getServiceRequest(uint64 id) external view returns (Types.ServiceRequest memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceRequestCall {
        #[allow(missing_docs)]
        pub id: u64,
    }
    ///Container type for the return parameters of the [`getServiceRequest(uint64)`](getServiceRequestCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getServiceRequestReturn {
        #[allow(missing_docs)]
        pub _0: <Types::ServiceRequest as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceRequestCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getServiceRequestCall) -> Self {
                    (value.id,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getServiceRequestCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { id: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Types::ServiceRequest,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::ServiceRequest as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getServiceRequestReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getServiceRequestReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getServiceRequestReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getServiceRequestCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getServiceRequestReturn;
            type ReturnTuple<'a> = (Types::ServiceRequest,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getServiceRequest(uint64)";
            const SELECTOR: [u8; 4] = [95u8, 155u8, 77u8, 250u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.id),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `getSlashProposal(uint64)` and selector `0xef1b42a2`.
```solidity
function getSlashProposal(uint64 slashId) external view returns (SlashingLib.SlashProposal memory);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashProposalCall {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    ///Container type for the return parameters of the [`getSlashProposal(uint64)`](getSlashProposalCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct getSlashProposalReturn {
        #[allow(missing_docs)]
        pub _0: <SlashingLib::SlashProposal as alloy::sol_types::SolType>::RustType,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashProposalCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSlashProposalCall) -> Self {
                    (value.slashId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSlashProposalCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slashId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (SlashingLib::SlashProposal,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <SlashingLib::SlashProposal as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<getSlashProposalReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: getSlashProposalReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for getSlashProposalReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for getSlashProposalCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = getSlashProposalReturn;
            type ReturnTuple<'a> = (SlashingLib::SlashProposal,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "getSlashProposal(uint64)";
            const SELECTOR: [u8; 4] = [239u8, 27u8, 66u8, 162u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.slashId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `grantRole(bytes32,address)` and selector `0x2f2ff15d`.
```solidity
function grantRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`grantRole(bytes32,address)`](grantRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct grantRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<grantRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: grantRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for grantRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for grantRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = grantRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "grantRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [47u8, 47u8, 241u8, 93u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `hasRole(bytes32,address)` and selector `0x91d14854`.
```solidity
function hasRole(bytes32 role, address account) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`hasRole(bytes32,address)`](hasRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct hasRoleReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<hasRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: hasRoleReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for hasRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for hasRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = hasRoleReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "hasRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [145u8, 209u8, 72u8, 84u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `initialize(address,address,address)` and selector `0xc0c53b8b`.
```solidity
function initialize(address admin, address restaking_, address treasury_) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeCall {
        #[allow(missing_docs)]
        pub admin: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub restaking_: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub treasury_: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`initialize(address,address,address)`](initializeCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct initializeReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeCall> for UnderlyingRustTuple<'_> {
                fn from(value: initializeCall) -> Self {
                    (value.admin, value.restaking_, value.treasury_)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        admin: tuple.0,
                        restaking_: tuple.1,
                        treasury_: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<initializeReturn> for UnderlyingRustTuple<'_> {
                fn from(value: initializeReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for initializeReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for initializeCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = initializeReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "initialize(address,address,address)";
            const SELECTOR: [u8; 4] = [192u8, 197u8, 59u8, 139u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.admin,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.restaking_,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.treasury_,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isOperatorRegistered(uint64,address)` and selector `0x64462595`.
```solidity
function isOperatorRegistered(uint64 blueprintId, address op) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOperatorRegisteredCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub op: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isOperatorRegistered(uint64,address)`](isOperatorRegisteredCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isOperatorRegisteredReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorRegisteredCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorRegisteredCall) -> Self {
                    (value.blueprintId, value.op)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isOperatorRegisteredCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        op: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isOperatorRegisteredReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isOperatorRegisteredReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isOperatorRegisteredReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isOperatorRegisteredCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isOperatorRegisteredReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isOperatorRegistered(uint64,address)";
            const SELECTOR: [u8; 4] = [100u8, 70u8, 37u8, 149u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.op,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isPermittedCaller(uint64,address)` and selector `0x2ec2bd03`.
```solidity
function isPermittedCaller(uint64 serviceId, address caller) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isPermittedCallerCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isPermittedCaller(uint64,address)`](isPermittedCallerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isPermittedCallerReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isPermittedCallerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isPermittedCallerCall) -> Self {
                    (value.serviceId, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isPermittedCallerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        caller: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isPermittedCallerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isPermittedCallerReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isPermittedCallerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isPermittedCallerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isPermittedCallerReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isPermittedCaller(uint64,address)";
            const SELECTOR: [u8; 4] = [46u8, 194u8, 189u8, 3u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isServiceActive(uint64)` and selector `0x2f46279f`.
```solidity
function isServiceActive(uint64 serviceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isServiceActiveCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    ///Container type for the return parameters of the [`isServiceActive(uint64)`](isServiceActiveCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isServiceActiveReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isServiceActiveCall> for UnderlyingRustTuple<'_> {
                fn from(value: isServiceActiveCall) -> Self {
                    (value.serviceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for isServiceActiveCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isServiceActiveReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isServiceActiveReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isServiceActiveReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isServiceActiveCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isServiceActiveReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isServiceActive(uint64)";
            const SELECTOR: [u8; 4] = [47u8, 70u8, 39u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `isServiceOperator(uint64,address)` and selector `0xa595b21e`.
```solidity
function isServiceOperator(uint64 serviceId, address op) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isServiceOperatorCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub op: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`isServiceOperator(uint64,address)`](isServiceOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct isServiceOperatorReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isServiceOperatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: isServiceOperatorCall) -> Self {
                    (value.serviceId, value.op)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isServiceOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        op: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<isServiceOperatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: isServiceOperatorReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for isServiceOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for isServiceOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = isServiceOperatorReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "isServiceOperator(uint64,address)";
            const SELECTOR: [u8; 4] = [165u8, 149u8, 178u8, 30u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.op,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `joinService(uint64,uint16)` and selector `0x2b9da71a`.
```solidity
function joinService(uint64 serviceId, uint16 exposureBps) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct joinServiceCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub exposureBps: u16,
    }
    ///Container type for the return parameters of the [`joinService(uint64,uint16)`](joinServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct joinServiceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u16);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<joinServiceCall> for UnderlyingRustTuple<'_> {
                fn from(value: joinServiceCall) -> Self {
                    (value.serviceId, value.exposureBps)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for joinServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        exposureBps: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<joinServiceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: joinServiceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for joinServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for joinServiceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = joinServiceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "joinService(uint64,uint16)";
            const SELECTOR: [u8; 4] = [43u8, 157u8, 167u8, 26u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.exposureBps),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `leaveService(uint64)` and selector `0x6778afbc`.
```solidity
function leaveService(uint64 serviceId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaveServiceCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    ///Container type for the return parameters of the [`leaveService(uint64)`](leaveServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct leaveServiceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaveServiceCall> for UnderlyingRustTuple<'_> {
                fn from(value: leaveServiceCall) -> Self {
                    (value.serviceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leaveServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<leaveServiceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: leaveServiceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for leaveServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for leaveServiceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = leaveServiceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "leaveService(uint64)";
            const SELECTOR: [u8; 4] = [103u8, 120u8, 175u8, 188u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `metricsRecorder()` and selector `0x2dae1885`.
```solidity
function metricsRecorder() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct metricsRecorderCall {}
    ///Container type for the return parameters of the [`metricsRecorder()`](metricsRecorderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct metricsRecorderReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<metricsRecorderCall> for UnderlyingRustTuple<'_> {
                fn from(value: metricsRecorderCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for metricsRecorderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<metricsRecorderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: metricsRecorderReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for metricsRecorderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for metricsRecorderCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = metricsRecorderReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "metricsRecorder()";
            const SELECTOR: [u8; 4] = [45u8, 174u8, 24u8, 133u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `operatorStatusRegistry()` and selector `0xd390bbbb`.
```solidity
function operatorStatusRegistry() external view returns (address);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorStatusRegistryCall {}
    ///Container type for the return parameters of the [`operatorStatusRegistry()`](operatorStatusRegistryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct operatorStatusRegistryReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::Address,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorStatusRegistryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: operatorStatusRegistryCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for operatorStatusRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<operatorStatusRegistryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: operatorStatusRegistryReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for operatorStatusRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for operatorStatusRegistryCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = operatorStatusRegistryReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Address,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "operatorStatusRegistry()";
            const SELECTOR: [u8; 4] = [211u8, 144u8, 187u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pause()` and selector `0x8456cb59`.
```solidity
function pause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseCall {}
    ///Container type for the return parameters of the [`pause()`](pauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: pauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pause()";
            const SELECTOR: [u8; 4] = [132u8, 86u8, 203u8, 89u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paused()` and selector `0x5c975abb`.
```solidity
function paused() external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedCall {}
    ///Container type for the return parameters of the [`paused()`](pausedCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pausedReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedCall> for UnderlyingRustTuple<'_> {
                fn from(value: pausedCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pausedReturn> for UnderlyingRustTuple<'_> {
                fn from(value: pausedReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for pausedReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pausedCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pausedReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paused()";
            const SELECTOR: [u8; 4] = [92u8, 151u8, 90u8, 187u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `paymentSplit()` and selector `0xaac7416b`.
```solidity
function paymentSplit() external view returns (uint16, uint16, uint16, uint16);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct paymentSplitCall {}
    ///Container type for the return parameters of the [`paymentSplit()`](paymentSplitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct paymentSplitReturn {
        #[allow(missing_docs)]
        pub _0: u16,
        #[allow(missing_docs)]
        pub _1: u16,
        #[allow(missing_docs)]
        pub _2: u16,
        #[allow(missing_docs)]
        pub _3: u16,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paymentSplitCall> for UnderlyingRustTuple<'_> {
                fn from(value: paymentSplitCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paymentSplitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u16, u16, u16, u16);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<paymentSplitReturn> for UnderlyingRustTuple<'_> {
                fn from(value: paymentSplitReturn) -> Self {
                    (value._0, value._1, value._2, value._3)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for paymentSplitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        _0: tuple.0,
                        _1: tuple.1,
                        _2: tuple.2,
                        _3: tuple.3,
                    }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for paymentSplitCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = paymentSplitReturn;
            type ReturnTuple<'a> = (
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<16>,
                alloy::sol_types::sol_data::Uint<16>,
            );
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "paymentSplit()";
            const SELECTOR: [u8; 4] = [170u8, 199u8, 65u8, 107u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingRewards(address)` and selector `0x31d7a262`.
```solidity
function pendingRewards(address account) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingRewards_0Call {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`pendingRewards(address)`](pendingRewards_0Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingRewards_0Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingRewards_0Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingRewards_0Call) -> Self {
                    (value.account,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingRewards_0Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { account: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingRewards_0Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingRewards_0Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingRewards_0Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingRewards_0Call {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingRewards_0Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingRewards(address)";
            const SELECTOR: [u8; 4] = [49u8, 215u8, 162u8, 98u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `pendingRewards(address,address)` and selector `0x80ac8228`.
```solidity
function pendingRewards(address account, address token) external view returns (uint256);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingRewards_1Call {
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub token: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`pendingRewards(address,address)`](pendingRewards_1Call) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct pendingRewards_1Return {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::primitives::aliases::U256,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingRewards_1Call>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingRewards_1Call) -> Self {
                    (value.account, value.token)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingRewards_1Call {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        account: tuple.0,
                        token: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<pendingRewards_1Return>
            for UnderlyingRustTuple<'_> {
                fn from(value: pendingRewards_1Return) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for pendingRewards_1Return {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for pendingRewards_1Call {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = pendingRewards_1Return;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<256>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "pendingRewards(address,address)";
            const SELECTOR: [u8; 4] = [128u8, 172u8, 130u8, 40u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.token,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `preRegister(uint64)` and selector `0x18c68017`.
```solidity
function preRegister(uint64 blueprintId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct preRegisterCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    ///Container type for the return parameters of the [`preRegister(uint64)`](preRegisterCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct preRegisterReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<preRegisterCall> for UnderlyingRustTuple<'_> {
                fn from(value: preRegisterCall) -> Self {
                    (value.blueprintId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for preRegisterCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blueprintId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<preRegisterReturn> for UnderlyingRustTuple<'_> {
                fn from(value: preRegisterReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for preRegisterReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for preRegisterCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = preRegisterReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "preRegister(uint64)";
            const SELECTOR: [u8; 4] = [24u8, 198u8, 128u8, 23u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `proposeSlash(uint64,address,uint256,bytes32)` and selector `0x30ae289c`.
```solidity
function proposeSlash(uint64 serviceId, address operator, uint256 amount, bytes32 evidence) external returns (uint64 slashId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proposeSlashCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub operator: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub amount: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub evidence: alloy::sol_types::private::FixedBytes<32>,
    }
    ///Container type for the return parameters of the [`proposeSlash(uint64,address,uint256,bytes32)`](proposeSlashCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proposeSlashReturn {
        #[allow(missing_docs)]
        pub slashId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
                alloy::sol_types::private::FixedBytes<32>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proposeSlashCall> for UnderlyingRustTuple<'_> {
                fn from(value: proposeSlashCall) -> Self {
                    (value.serviceId, value.operator, value.amount, value.evidence)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proposeSlashCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        operator: tuple.1,
                        amount: tuple.2,
                        evidence: tuple.3,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proposeSlashReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proposeSlashReturn) -> Self {
                    (value.slashId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proposeSlashReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { slashId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proposeSlashCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedBytes<32>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proposeSlashReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proposeSlash(uint64,address,uint256,bytes32)";
            const SELECTOR: [u8; 4] = [48u8, 174u8, 40u8, 156u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.operator,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.amount),
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.evidence),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `proxiableUUID()` and selector `0x52d1902d`.
```solidity
function proxiableUUID() external view returns (bytes32);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDCall {}
    ///Container type for the return parameters of the [`proxiableUUID()`](proxiableUUIDCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct proxiableUUIDReturn {
        #[allow(missing_docs)]
        pub _0: alloy::sol_types::private::FixedBytes<32>,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDCall> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<32>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<proxiableUUIDReturn> for UnderlyingRustTuple<'_> {
                fn from(value: proxiableUUIDReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for proxiableUUIDReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for proxiableUUIDCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = proxiableUUIDReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<32>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "proxiableUUID()";
            const SELECTOR: [u8; 4] = [82u8, 209u8, 144u8, 45u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `registerOperator(uint64,bytes)` and selector `0xcc3d19c3`.
```solidity
function registerOperator(uint64 blueprintId, bytes memory preferences) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerOperatorCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub preferences: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`registerOperator(uint64,bytes)`](registerOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct registerOperatorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorCall) -> Self {
                    (value.blueprintId, value.preferences)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        preferences: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<registerOperatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: registerOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for registerOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for registerOperatorCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = registerOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "registerOperator(uint64,bytes)";
            const SELECTOR: [u8; 4] = [204u8, 61u8, 25u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.preferences,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `rejectService(uint64)` and selector `0x6d8b88c3`.
```solidity
function rejectService(uint64 requestId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rejectServiceCall {
        #[allow(missing_docs)]
        pub requestId: u64,
    }
    ///Container type for the return parameters of the [`rejectService(uint64)`](rejectServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct rejectServiceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rejectServiceCall> for UnderlyingRustTuple<'_> {
                fn from(value: rejectServiceCall) -> Self {
                    (value.requestId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rejectServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { requestId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<rejectServiceReturn> for UnderlyingRustTuple<'_> {
                fn from(value: rejectServiceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for rejectServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for rejectServiceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = rejectServiceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "rejectService(uint64)";
            const SELECTOR: [u8; 4] = [109u8, 139u8, 136u8, 195u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.requestId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `removePermittedCaller(uint64,address)` and selector `0x5f359924`.
```solidity
function removePermittedCaller(uint64 serviceId, address caller) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removePermittedCallerCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub caller: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`removePermittedCaller(uint64,address)`](removePermittedCallerCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct removePermittedCallerReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removePermittedCallerCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: removePermittedCallerCall) -> Self {
                    (value.serviceId, value.caller)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removePermittedCallerCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        caller: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<removePermittedCallerReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: removePermittedCallerReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for removePermittedCallerReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for removePermittedCallerCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = removePermittedCallerReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "removePermittedCaller(uint64,address)";
            const SELECTOR: [u8; 4] = [95u8, 53u8, 153u8, 36u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.caller,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `renounceRole(bytes32,address)` and selector `0x36568abe`.
```solidity
function renounceRole(bytes32 role, address callerConfirmation) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub callerConfirmation: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`renounceRole(bytes32,address)`](renounceRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct renounceRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleCall) -> Self {
                    (value.role, value.callerConfirmation)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        callerConfirmation: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<renounceRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: renounceRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for renounceRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for renounceRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = renounceRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "renounceRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [54u8, 86u8, 138u8, 190u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.callerConfirmation,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `requestService(uint64,address[],bytes,address[],uint64,address,uint256)` and selector `0xa37b9286`.
```solidity
function requestService(uint64 blueprintId, address[] memory operators, bytes memory config, address[] memory permittedCallers, uint64 ttl, address paymentToken, uint256 paymentAmount) external payable returns (uint64 requestId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestServiceCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub config: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub permittedCallers: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub ttl: u64,
        #[allow(missing_docs)]
        pub paymentToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub paymentAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`requestService(uint64,address[],bytes,address[],uint64,address,uint256)`](requestServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestServiceReturn {
        #[allow(missing_docs)]
        pub requestId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestServiceCall> for UnderlyingRustTuple<'_> {
                fn from(value: requestServiceCall) -> Self {
                    (
                        value.blueprintId,
                        value.operators,
                        value.config,
                        value.permittedCallers,
                        value.ttl,
                        value.paymentToken,
                        value.paymentAmount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for requestServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        operators: tuple.1,
                        config: tuple.2,
                        permittedCallers: tuple.3,
                        ttl: tuple.4,
                        paymentToken: tuple.5,
                        paymentAmount: tuple.6,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestServiceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestServiceReturn) -> Self {
                    (value.requestId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { requestId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requestServiceCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = requestServiceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requestService(uint64,address[],bytes,address[],uint64,address,uint256)";
            const SELECTOR: [u8; 4] = [163u8, 123u8, 146u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.operators),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.config,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.permittedCallers),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.ttl),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.paymentToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.paymentAmount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `requestServiceWithExposure(uint64,address[],uint16[],bytes,address[],uint64,address,uint256)` and selector `0x108a7d63`.
```solidity
function requestServiceWithExposure(uint64 blueprintId, address[] memory operators, uint16[] memory exposures, bytes memory config, address[] memory permittedCallers, uint64 ttl, address paymentToken, uint256 paymentAmount) external payable returns (uint64 requestId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestServiceWithExposureCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub exposures: alloy::sol_types::private::Vec<u16>,
        #[allow(missing_docs)]
        pub config: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub permittedCallers: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub ttl: u64,
        #[allow(missing_docs)]
        pub paymentToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub paymentAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`requestServiceWithExposure(uint64,address[],uint16[],bytes,address[],uint64,address,uint256)`](requestServiceWithExposureCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestServiceWithExposureReturn {
        #[allow(missing_docs)]
        pub requestId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<16>>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<u16>,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestServiceWithExposureCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestServiceWithExposureCall) -> Self {
                    (
                        value.blueprintId,
                        value.operators,
                        value.exposures,
                        value.config,
                        value.permittedCallers,
                        value.ttl,
                        value.paymentToken,
                        value.paymentAmount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestServiceWithExposureCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        operators: tuple.1,
                        exposures: tuple.2,
                        config: tuple.3,
                        permittedCallers: tuple.4,
                        ttl: tuple.5,
                        paymentToken: tuple.6,
                        paymentAmount: tuple.7,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestServiceWithExposureReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestServiceWithExposureReturn) -> Self {
                    (value.requestId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestServiceWithExposureReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { requestId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requestServiceWithExposureCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<16>>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = requestServiceWithExposureReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requestServiceWithExposure(uint64,address[],uint16[],bytes,address[],uint64,address,uint256)";
            const SELECTOR: [u8; 4] = [16u8, 138u8, 125u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.operators),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<16>,
                    > as alloy_sol_types::SolType>::tokenize(&self.exposures),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.config,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.permittedCallers),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.ttl),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.paymentToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.paymentAmount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `requestServiceWithSecurity(uint64,address[],((uint8,address),uint16,uint16)[],bytes,address[],uint64,address,uint256)` and selector `0xec9f0fdd`.
```solidity
function requestServiceWithSecurity(uint64 blueprintId, address[] memory operators, Types.AssetSecurityRequirement[] memory securityRequirements, bytes memory config, address[] memory permittedCallers, uint64 ttl, address paymentToken, uint256 paymentAmount) external payable returns (uint64 requestId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestServiceWithSecurityCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub operators: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub securityRequirements: alloy::sol_types::private::Vec<
            <Types::AssetSecurityRequirement as alloy::sol_types::SolType>::RustType,
        >,
        #[allow(missing_docs)]
        pub config: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub permittedCallers: alloy::sol_types::private::Vec<
            alloy::sol_types::private::Address,
        >,
        #[allow(missing_docs)]
        pub ttl: u64,
        #[allow(missing_docs)]
        pub paymentToken: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub paymentAmount: alloy::sol_types::private::primitives::aliases::U256,
    }
    ///Container type for the return parameters of the [`requestServiceWithSecurity(uint64,address[],((uint8,address),uint16,uint16)[],bytes,address[],uint64,address,uint256)`](requestServiceWithSecurityCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct requestServiceWithSecurityReturn {
        #[allow(missing_docs)]
        pub requestId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<Types::AssetSecurityRequirement>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                alloy::sol_types::private::Vec<
                    <Types::AssetSecurityRequirement as alloy::sol_types::SolType>::RustType,
                >,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Address>,
                u64,
                alloy::sol_types::private::Address,
                alloy::sol_types::private::primitives::aliases::U256,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestServiceWithSecurityCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestServiceWithSecurityCall) -> Self {
                    (
                        value.blueprintId,
                        value.operators,
                        value.securityRequirements,
                        value.config,
                        value.permittedCallers,
                        value.ttl,
                        value.paymentToken,
                        value.paymentAmount,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestServiceWithSecurityCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        operators: tuple.1,
                        securityRequirements: tuple.2,
                        config: tuple.3,
                        permittedCallers: tuple.4,
                        ttl: tuple.5,
                        paymentToken: tuple.6,
                        paymentAmount: tuple.7,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<requestServiceWithSecurityReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: requestServiceWithSecurityReturn) -> Self {
                    (value.requestId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for requestServiceWithSecurityReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { requestId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for requestServiceWithSecurityCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Array<Types::AssetSecurityRequirement>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Address>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Uint<256>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = requestServiceWithSecurityReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "requestServiceWithSecurity(uint64,address[],((uint8,address),uint16,uint16)[],bytes,address[],uint64,address,uint256)";
            const SELECTOR: [u8; 4] = [236u8, 159u8, 15u8, 221u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.operators),
                    <alloy::sol_types::sol_data::Array<
                        Types::AssetSecurityRequirement,
                    > as alloy_sol_types::SolType>::tokenize(&self.securityRequirements),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.config,
                    ),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Address,
                    > as alloy_sol_types::SolType>::tokenize(&self.permittedCallers),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.ttl),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.paymentToken,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.paymentAmount),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `revokeRole(bytes32,address)` and selector `0xd547741f`.
```solidity
function revokeRole(bytes32 role, address account) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleCall {
        #[allow(missing_docs)]
        pub role: alloy::sol_types::private::FixedBytes<32>,
        #[allow(missing_docs)]
        pub account: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`revokeRole(bytes32,address)`](revokeRoleCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct revokeRoleReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::FixedBytes<32>,
                alloy::sol_types::private::Address,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleCall> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleCall) -> Self {
                    (value.role, value.account)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        role: tuple.0,
                        account: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<revokeRoleReturn> for UnderlyingRustTuple<'_> {
                fn from(value: revokeRoleReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for revokeRoleReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for revokeRoleCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::FixedBytes<32>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = revokeRoleReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "revokeRole(bytes32,address)";
            const SELECTOR: [u8; 4] = [213u8, 71u8, 116u8, 31u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        32,
                    > as alloy_sol_types::SolType>::tokenize(&self.role),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.account,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `serviceCount()` and selector `0x06237526`.
```solidity
function serviceCount() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serviceCountCall {}
    ///Container type for the return parameters of the [`serviceCount()`](serviceCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serviceCountReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceCountCall> for UnderlyingRustTuple<'_> {
                fn from(value: serviceCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serviceCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceCountReturn> for UnderlyingRustTuple<'_> {
                fn from(value: serviceCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for serviceCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serviceCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = serviceCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serviceCount()";
            const SELECTOR: [u8; 4] = [6u8, 35u8, 117u8, 38u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `serviceRequestCount()` and selector `0x07e60129`.
```solidity
function serviceRequestCount() external view returns (uint64);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serviceRequestCountCall {}
    ///Container type for the return parameters of the [`serviceRequestCount()`](serviceRequestCountCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct serviceRequestCountReturn {
        #[allow(missing_docs)]
        pub _0: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceRequestCountCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: serviceRequestCountCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for serviceRequestCountCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<serviceRequestCountReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: serviceRequestCountReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for serviceRequestCountReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for serviceRequestCountCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = serviceRequestCountReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "serviceRequestCount()";
            const SELECTOR: [u8; 4] = [7u8, 230u8, 1u8, 41u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setMetricsRecorder(address)` and selector `0x20812956`.
```solidity
function setMetricsRecorder(address recorder) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMetricsRecorderCall {
        #[allow(missing_docs)]
        pub recorder: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setMetricsRecorder(address)`](setMetricsRecorderCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setMetricsRecorderReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMetricsRecorderCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMetricsRecorderCall) -> Self {
                    (value.recorder,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMetricsRecorderCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { recorder: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setMetricsRecorderReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setMetricsRecorderReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setMetricsRecorderReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setMetricsRecorderCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setMetricsRecorderReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setMetricsRecorder(address)";
            const SELECTOR: [u8; 4] = [32u8, 129u8, 41u8, 86u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.recorder,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setOperatorStatusRegistry(address)` and selector `0x6a64a27e`.
```solidity
function setOperatorStatusRegistry(address registry) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOperatorStatusRegistryCall {
        #[allow(missing_docs)]
        pub registry: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setOperatorStatusRegistry(address)`](setOperatorStatusRegistryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setOperatorStatusRegistryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorStatusRegistryCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorStatusRegistryCall) -> Self {
                    (value.registry,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setOperatorStatusRegistryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { registry: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setOperatorStatusRegistryReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setOperatorStatusRegistryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setOperatorStatusRegistryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setOperatorStatusRegistryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setOperatorStatusRegistryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setOperatorStatusRegistry(address)";
            const SELECTOR: [u8; 4] = [106u8, 100u8, 162u8, 126u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.registry,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setPaymentSplit((uint16,uint16,uint16,uint16))` and selector `0xb81741ac`.
```solidity
function setPaymentSplit(Types.PaymentSplit memory split) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setPaymentSplitCall {
        #[allow(missing_docs)]
        pub split: <Types::PaymentSplit as alloy::sol_types::SolType>::RustType,
    }
    ///Container type for the return parameters of the [`setPaymentSplit((uint16,uint16,uint16,uint16))`](setPaymentSplitCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setPaymentSplitReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (Types::PaymentSplit,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                <Types::PaymentSplit as alloy::sol_types::SolType>::RustType,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPaymentSplitCall> for UnderlyingRustTuple<'_> {
                fn from(value: setPaymentSplitCall) -> Self {
                    (value.split,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setPaymentSplitCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { split: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setPaymentSplitReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setPaymentSplitReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setPaymentSplitReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setPaymentSplitCall {
            type Parameters<'a> = (Types::PaymentSplit,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setPaymentSplitReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setPaymentSplit((uint16,uint16,uint16,uint16))";
            const SELECTOR: [u8; 4] = [184u8, 23u8, 65u8, 172u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <Types::PaymentSplit as alloy_sol_types::SolType>::tokenize(
                        &self.split,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setSlashConfig(uint64,bool,uint16)` and selector `0x78867a16`.
```solidity
function setSlashConfig(uint64 disputeWindow, bool instantSlashEnabled, uint16 maxSlashBps) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSlashConfigCall {
        #[allow(missing_docs)]
        pub disputeWindow: u64,
        #[allow(missing_docs)]
        pub instantSlashEnabled: bool,
        #[allow(missing_docs)]
        pub maxSlashBps: u16,
    }
    ///Container type for the return parameters of the [`setSlashConfig(uint64,bool,uint16)`](setSlashConfigCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setSlashConfigReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<16>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, bool, u16);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSlashConfigCall> for UnderlyingRustTuple<'_> {
                fn from(value: setSlashConfigCall) -> Self {
                    (value.disputeWindow, value.instantSlashEnabled, value.maxSlashBps)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setSlashConfigCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        disputeWindow: tuple.0,
                        instantSlashEnabled: tuple.1,
                        maxSlashBps: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setSlashConfigReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: setSlashConfigReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for setSlashConfigReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setSlashConfigCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bool,
                alloy::sol_types::sol_data::Uint<16>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setSlashConfigReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setSlashConfig(uint64,bool,uint16)";
            const SELECTOR: [u8; 4] = [120u8, 134u8, 122u8, 22u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.disputeWindow),
                    <alloy::sol_types::sol_data::Bool as alloy_sol_types::SolType>::tokenize(
                        &self.instantSlashEnabled,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        16,
                    > as alloy_sol_types::SolType>::tokenize(&self.maxSlashBps),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `setTreasury(address)` and selector `0xf0f44260`.
```solidity
function setTreasury(address treasury_) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setTreasuryCall {
        #[allow(missing_docs)]
        pub treasury_: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`setTreasury(address)`](setTreasuryCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct setTreasuryReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Address,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::Address,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setTreasuryCall> for UnderlyingRustTuple<'_> {
                fn from(value: setTreasuryCall) -> Self {
                    (value.treasury_,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setTreasuryCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { treasury_: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<setTreasuryReturn> for UnderlyingRustTuple<'_> {
                fn from(value: setTreasuryReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for setTreasuryReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for setTreasuryCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Address,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = setTreasuryReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "setTreasury(address)";
            const SELECTOR: [u8; 4] = [240u8, 244u8, 66u8, 96u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.treasury_,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitAggregatedResult(uint64,uint64,bytes,uint256,uint256[2],uint256[4])` and selector `0xc325ae12`.
```solidity
function submitAggregatedResult(uint64 serviceId, uint64 callId, bytes memory output, uint256 signerBitmap, uint256[2] memory aggregatedSignature, uint256[4] memory aggregatedPubkey) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAggregatedResultCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
        #[allow(missing_docs)]
        pub output: alloy::sol_types::private::Bytes,
        #[allow(missing_docs)]
        pub signerBitmap: alloy::sol_types::private::primitives::aliases::U256,
        #[allow(missing_docs)]
        pub aggregatedSignature: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
        #[allow(missing_docs)]
        pub aggregatedPubkey: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
    }
    ///Container type for the return parameters of the [`submitAggregatedResult(uint64,uint64,bytes,uint256,uint256[2],uint256[4])`](submitAggregatedResultCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitAggregatedResultReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                u64,
                alloy::sol_types::private::Bytes,
                alloy::sol_types::private::primitives::aliases::U256,
                [alloy::sol_types::private::primitives::aliases::U256; 2usize],
                [alloy::sol_types::private::primitives::aliases::U256; 4usize],
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAggregatedResultCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitAggregatedResultCall) -> Self {
                    (
                        value.serviceId,
                        value.callId,
                        value.output,
                        value.signerBitmap,
                        value.aggregatedSignature,
                        value.aggregatedPubkey,
                    )
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitAggregatedResultCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        callId: tuple.1,
                        output: tuple.2,
                        signerBitmap: tuple.3,
                        aggregatedSignature: tuple.4,
                        aggregatedPubkey: tuple.5,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitAggregatedResultReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: submitAggregatedResultReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for submitAggregatedResultReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitAggregatedResultCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bytes,
                alloy::sol_types::sol_data::Uint<256>,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    2usize,
                >,
                alloy::sol_types::sol_data::FixedArray<
                    alloy::sol_types::sol_data::Uint<256>,
                    4usize,
                >,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitAggregatedResultReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitAggregatedResult(uint64,uint64,bytes,uint256,uint256[2],uint256[4])";
            const SELECTOR: [u8; 4] = [195u8, 37u8, 174u8, 18u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.callId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.output,
                    ),
                    <alloy::sol_types::sol_data::Uint<
                        256,
                    > as alloy_sol_types::SolType>::tokenize(&self.signerBitmap),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        2usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.aggregatedSignature),
                    <alloy::sol_types::sol_data::FixedArray<
                        alloy::sol_types::sol_data::Uint<256>,
                        4usize,
                    > as alloy_sol_types::SolType>::tokenize(&self.aggregatedPubkey),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitJob(uint64,uint8,bytes)` and selector `0x3413e8ee`.
```solidity
function submitJob(uint64 serviceId, uint8 jobIndex, bytes memory inputs) external payable returns (uint64 callId);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitJobCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub jobIndex: u8,
        #[allow(missing_docs)]
        pub inputs: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`submitJob(uint64,uint8,bytes)`](submitJobCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitJobReturn {
        #[allow(missing_docs)]
        pub callId: u64,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u8, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitJobCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitJobCall) -> Self {
                    (value.serviceId, value.jobIndex, value.inputs)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitJobCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        jobIndex: tuple.1,
                        inputs: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitJobReturn> for UnderlyingRustTuple<'_> {
                fn from(value: submitJobReturn) -> Self {
                    (value.callId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitJobReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { callId: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitJobCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<8>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitJobReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitJob(uint64,uint8,bytes)";
            const SELECTOR: [u8; 4] = [52u8, 19u8, 232u8, 238u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        8,
                    > as alloy_sol_types::SolType>::tokenize(&self.jobIndex),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.inputs,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitResult(uint64,uint64,bytes)` and selector `0x2d07e655`.
```solidity
function submitResult(uint64 serviceId, uint64 callId, bytes memory output) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitResultCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callId: u64,
        #[allow(missing_docs)]
        pub output: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`submitResult(uint64,uint64,bytes)`](submitResultCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitResultReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, u64, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitResultCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitResultCall) -> Self {
                    (value.serviceId, value.callId, value.output)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitResultCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        callId: tuple.1,
                        output: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitResultReturn> for UnderlyingRustTuple<'_> {
                fn from(value: submitResultReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitResultReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitResultCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitResultReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitResult(uint64,uint64,bytes)";
            const SELECTOR: [u8; 4] = [45u8, 7u8, 230u8, 85u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.callId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.output,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `submitResults(uint64,uint64[],bytes[])` and selector `0xaacdba9f`.
```solidity
function submitResults(uint64 serviceId, uint64[] memory callIds, bytes[] memory outputs) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitResultsCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
        #[allow(missing_docs)]
        pub callIds: alloy::sol_types::private::Vec<u64>,
        #[allow(missing_docs)]
        pub outputs: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
    }
    ///Container type for the return parameters of the [`submitResults(uint64,uint64[],bytes[])`](submitResultsCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct submitResultsReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                u64,
                alloy::sol_types::private::Vec<u64>,
                alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitResultsCall> for UnderlyingRustTuple<'_> {
                fn from(value: submitResultsCall) -> Self {
                    (value.serviceId, value.callIds, value.outputs)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitResultsCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        serviceId: tuple.0,
                        callIds: tuple.1,
                        outputs: tuple.2,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<submitResultsReturn> for UnderlyingRustTuple<'_> {
                fn from(value: submitResultsReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for submitResultsReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for submitResultsCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Uint<64>>,
                alloy::sol_types::sol_data::Array<alloy::sol_types::sol_data::Bytes>,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = submitResultsReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "submitResults(uint64,uint64[],bytes[])";
            const SELECTOR: [u8; 4] = [170u8, 205u8, 186u8, 159u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Uint<64>,
                    > as alloy_sol_types::SolType>::tokenize(&self.callIds),
                    <alloy::sol_types::sol_data::Array<
                        alloy::sol_types::sol_data::Bytes,
                    > as alloy_sol_types::SolType>::tokenize(&self.outputs),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `supportsInterface(bytes4)` and selector `0x01ffc9a7`.
```solidity
function supportsInterface(bytes4 interfaceId) external view returns (bool);
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceCall {
        #[allow(missing_docs)]
        pub interfaceId: alloy::sol_types::private::FixedBytes<4>,
    }
    ///Container type for the return parameters of the [`supportsInterface(bytes4)`](supportsInterfaceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct supportsInterfaceReturn {
        #[allow(missing_docs)]
        pub _0: bool,
    }
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (alloy::sol_types::private::FixedBytes<4>,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceCall) -> Self {
                    (value.interfaceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { interfaceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (bool,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<supportsInterfaceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: supportsInterfaceReturn) -> Self {
                    (value._0,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for supportsInterfaceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { _0: tuple.0 }
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for supportsInterfaceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::FixedBytes<4>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = supportsInterfaceReturn;
            type ReturnTuple<'a> = (alloy::sol_types::sol_data::Bool,);
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "supportsInterface(bytes4)";
            const SELECTOR: [u8; 4] = [1u8, 255u8, 201u8, 167u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::FixedBytes<
                        4,
                    > as alloy_sol_types::SolType>::tokenize(&self.interfaceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `terminateService(uint64)` and selector `0x5b71c934`.
```solidity
function terminateService(uint64 serviceId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct terminateServiceCall {
        #[allow(missing_docs)]
        pub serviceId: u64,
    }
    ///Container type for the return parameters of the [`terminateService(uint64)`](terminateServiceCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct terminateServiceReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<terminateServiceCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: terminateServiceCall) -> Self {
                    (value.serviceId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for terminateServiceCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { serviceId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<terminateServiceReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: terminateServiceReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for terminateServiceReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for terminateServiceCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = terminateServiceReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "terminateService(uint64)";
            const SELECTOR: [u8; 4] = [91u8, 113u8, 201u8, 52u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.serviceId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `transferBlueprint(uint64,address)` and selector `0x8a4cf763`.
```solidity
function transferBlueprint(uint64 blueprintId, address newOwner) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferBlueprintCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub newOwner: alloy::sol_types::private::Address,
    }
    ///Container type for the return parameters of the [`transferBlueprint(uint64,address)`](transferBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct transferBlueprintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Address);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferBlueprintCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferBlueprintCall) -> Self {
                    (value.blueprintId, value.newOwner)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        newOwner: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<transferBlueprintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: transferBlueprintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for transferBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for transferBlueprintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Address,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = transferBlueprintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "transferBlueprint(uint64,address)";
            const SELECTOR: [u8; 4] = [138u8, 76u8, 247u8, 99u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newOwner,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unpause()` and selector `0x3f4ba83a`.
```solidity
function unpause() external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseCall {}
    ///Container type for the return parameters of the [`unpause()`](unpauseCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unpauseReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseCall> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseCall) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unpauseReturn> for UnderlyingRustTuple<'_> {
                fn from(value: unpauseReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for unpauseReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unpauseCall {
            type Parameters<'a> = ();
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unpauseReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unpause()";
            const SELECTOR: [u8; 4] = [63u8, 75u8, 168u8, 58u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                ()
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `unregisterOperator(uint64)` and selector `0x0afd3738`.
```solidity
function unregisterOperator(uint64 blueprintId) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unregisterOperatorCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
    }
    ///Container type for the return parameters of the [`unregisterOperator(uint64)`](unregisterOperatorCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct unregisterOperatorReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64,);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unregisterOperatorCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: unregisterOperatorCall) -> Self {
                    (value.blueprintId,)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for unregisterOperatorCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self { blueprintId: tuple.0 }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<unregisterOperatorReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: unregisterOperatorReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for unregisterOperatorReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for unregisterOperatorCall {
            type Parameters<'a> = (alloy::sol_types::sol_data::Uint<64>,);
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = unregisterOperatorReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "unregisterOperator(uint64)";
            const SELECTOR: [u8; 4] = [10u8, 253u8, 55u8, 56u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateBlueprint(uint64,string)` and selector `0xe538da66`.
```solidity
function updateBlueprint(uint64 blueprintId, string memory metadataUri) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateBlueprintCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub metadataUri: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`updateBlueprint(uint64,string)`](updateBlueprintCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateBlueprintReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateBlueprintCall> for UnderlyingRustTuple<'_> {
                fn from(value: updateBlueprintCall) -> Self {
                    (value.blueprintId, value.metadataUri)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>> for updateBlueprintCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        metadataUri: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateBlueprintReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateBlueprintReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateBlueprintReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateBlueprintCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateBlueprintReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateBlueprint(uint64,string)";
            const SELECTOR: [u8; 4] = [229u8, 56u8, 218u8, 102u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.metadataUri,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateOperatorPreferences(uint64,bytes)` and selector `0xdfe62aba`.
```solidity
function updateOperatorPreferences(uint64 blueprintId, bytes memory preferences) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateOperatorPreferencesCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub preferences: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`updateOperatorPreferences(uint64,bytes)`](updateOperatorPreferencesCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateOperatorPreferencesReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::Bytes);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorPreferencesCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorPreferencesCall) -> Self {
                    (value.blueprintId, value.preferences)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateOperatorPreferencesCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        preferences: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateOperatorPreferencesReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateOperatorPreferencesReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateOperatorPreferencesReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateOperatorPreferencesCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateOperatorPreferencesReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateOperatorPreferences(uint64,bytes)";
            const SELECTOR: [u8; 4] = [223u8, 230u8, 42u8, 186u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.preferences,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `updateRpcAddress(uint64,string)` and selector `0x0f33e8e1`.
```solidity
function updateRpcAddress(uint64 blueprintId, string memory rpcAddress) external;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateRpcAddressCall {
        #[allow(missing_docs)]
        pub blueprintId: u64,
        #[allow(missing_docs)]
        pub rpcAddress: alloy::sol_types::private::String,
    }
    ///Container type for the return parameters of the [`updateRpcAddress(uint64,string)`](updateRpcAddressCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct updateRpcAddressReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::String,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (u64, alloy::sol_types::private::String);
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateRpcAddressCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateRpcAddressCall) -> Self {
                    (value.blueprintId, value.rpcAddress)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateRpcAddressCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        blueprintId: tuple.0,
                        rpcAddress: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<updateRpcAddressReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: updateRpcAddressReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for updateRpcAddressReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for updateRpcAddressCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Uint<64>,
                alloy::sol_types::sol_data::String,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = updateRpcAddressReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "updateRpcAddress(uint64,string)";
            const SELECTOR: [u8; 4] = [15u8, 51u8, 232u8, 225u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Uint<
                        64,
                    > as alloy_sol_types::SolType>::tokenize(&self.blueprintId),
                    <alloy::sol_types::sol_data::String as alloy_sol_types::SolType>::tokenize(
                        &self.rpcAddress,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    /**Function with signature `upgradeToAndCall(address,bytes)` and selector `0x4f1ef286`.
```solidity
function upgradeToAndCall(address newImplementation, bytes memory data) external payable;
```*/
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallCall {
        #[allow(missing_docs)]
        pub newImplementation: alloy::sol_types::private::Address,
        #[allow(missing_docs)]
        pub data: alloy::sol_types::private::Bytes,
    }
    ///Container type for the return parameters of the [`upgradeToAndCall(address,bytes)`](upgradeToAndCallCall) function.
    #[allow(non_camel_case_types, non_snake_case, clippy::pub_underscore_fields)]
    #[derive(Clone)]
    pub struct upgradeToAndCallReturn {}
    #[allow(
        non_camel_case_types,
        non_snake_case,
        clippy::pub_underscore_fields,
        clippy::style
    )]
    const _: () = {
        use alloy::sol_types as alloy_sol_types;
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = (
                alloy::sol_types::private::Address,
                alloy::sol_types::private::Bytes,
            );
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallCall>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallCall) -> Self {
                    (value.newImplementation, value.data)
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallCall {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {
                        newImplementation: tuple.0,
                        data: tuple.1,
                    }
                }
            }
        }
        {
            #[doc(hidden)]
            type UnderlyingSolTuple<'a> = ();
            #[doc(hidden)]
            type UnderlyingRustTuple<'a> = ();
            #[cfg(test)]
            #[allow(dead_code, unreachable_patterns)]
            fn _type_assertion(
                _t: alloy_sol_types::private::AssertTypeEq<UnderlyingRustTuple>,
            ) {
                match _t {
                    alloy_sol_types::private::AssertTypeEq::<
                        <UnderlyingSolTuple as alloy_sol_types::SolType>::RustType,
                    >(_) => {}
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<upgradeToAndCallReturn>
            for UnderlyingRustTuple<'_> {
                fn from(value: upgradeToAndCallReturn) -> Self {
                    ()
                }
            }
            #[automatically_derived]
            #[doc(hidden)]
            impl ::core::convert::From<UnderlyingRustTuple<'_>>
            for upgradeToAndCallReturn {
                fn from(tuple: UnderlyingRustTuple<'_>) -> Self {
                    Self {}
                }
            }
        }
        #[automatically_derived]
        impl alloy_sol_types::SolCall for upgradeToAndCallCall {
            type Parameters<'a> = (
                alloy::sol_types::sol_data::Address,
                alloy::sol_types::sol_data::Bytes,
            );
            type Token<'a> = <Self::Parameters<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            type Return = upgradeToAndCallReturn;
            type ReturnTuple<'a> = ();
            type ReturnToken<'a> = <Self::ReturnTuple<
                'a,
            > as alloy_sol_types::SolType>::Token<'a>;
            const SIGNATURE: &'static str = "upgradeToAndCall(address,bytes)";
            const SELECTOR: [u8; 4] = [79u8, 30u8, 242u8, 134u8];
            #[inline]
            fn new<'a>(
                tuple: <Self::Parameters<'a> as alloy_sol_types::SolType>::RustType,
            ) -> Self {
                tuple.into()
            }
            #[inline]
            fn tokenize(&self) -> Self::Token<'_> {
                (
                    <alloy::sol_types::sol_data::Address as alloy_sol_types::SolType>::tokenize(
                        &self.newImplementation,
                    ),
                    <alloy::sol_types::sol_data::Bytes as alloy_sol_types::SolType>::tokenize(
                        &self.data,
                    ),
                )
            }
            #[inline]
            fn abi_decode_returns(
                data: &[u8],
                validate: bool,
            ) -> alloy_sol_types::Result<Self::Return> {
                <Self::ReturnTuple<
                    '_,
                > as alloy_sol_types::SolType>::abi_decode_sequence(data, validate)
                    .map(Into::into)
            }
        }
    };
    ///Container for all the [`Tangle`](self) function calls.
    pub enum TangleCalls {
        #[allow(missing_docs)]
        ADMIN_ROLE(ADMIN_ROLECall),
        #[allow(missing_docs)]
        DEFAULT_ADMIN_ROLE(DEFAULT_ADMIN_ROLECall),
        #[allow(missing_docs)]
        PAUSER_ROLE(PAUSER_ROLECall),
        #[allow(missing_docs)]
        SLASH_ADMIN_ROLE(SLASH_ADMIN_ROLECall),
        #[allow(missing_docs)]
        UPGRADER_ROLE(UPGRADER_ROLECall),
        #[allow(missing_docs)]
        UPGRADE_INTERFACE_VERSION(UPGRADE_INTERFACE_VERSIONCall),
        #[allow(missing_docs)]
        addPermittedCaller(addPermittedCallerCall),
        #[allow(missing_docs)]
        approveService(approveServiceCall),
        #[allow(missing_docs)]
        approveServiceWithCommitments(approveServiceWithCommitmentsCall),
        #[allow(missing_docs)]
        billSubscription(billSubscriptionCall),
        #[allow(missing_docs)]
        billSubscriptionBatch(billSubscriptionBatchCall),
        #[allow(missing_docs)]
        blueprintCount(blueprintCountCall),
        #[allow(missing_docs)]
        blueprintOperatorCount(blueprintOperatorCountCall),
        #[allow(missing_docs)]
        cancelSlash(cancelSlashCall),
        #[allow(missing_docs)]
        claimRewards_0(claimRewards_0Call),
        #[allow(missing_docs)]
        claimRewards_1(claimRewards_1Call),
        #[allow(missing_docs)]
        createBlueprint(createBlueprintCall),
        #[allow(missing_docs)]
        createBlueprintWithConfig(createBlueprintWithConfigCall),
        #[allow(missing_docs)]
        createServiceFromQuotes(createServiceFromQuotesCall),
        #[allow(missing_docs)]
        deactivateBlueprint(deactivateBlueprintCall),
        #[allow(missing_docs)]
        disputeSlash(disputeSlashCall),
        #[allow(missing_docs)]
        executeSlash(executeSlashCall),
        #[allow(missing_docs)]
        executeSlashBatch(executeSlashBatchCall),
        #[allow(missing_docs)]
        fundService(fundServiceCall),
        #[allow(missing_docs)]
        getBillableServices(getBillableServicesCall),
        #[allow(missing_docs)]
        getBlueprint(getBlueprintCall),
        #[allow(missing_docs)]
        getBlueprintConfig(getBlueprintConfigCall),
        #[allow(missing_docs)]
        getExecutableSlashes(getExecutableSlashesCall),
        #[allow(missing_docs)]
        getJobCall(getJobCallCall),
        #[allow(missing_docs)]
        getOperatorRegistration(getOperatorRegistrationCall),
        #[allow(missing_docs)]
        getRoleAdmin(getRoleAdminCall),
        #[allow(missing_docs)]
        getService(getServiceCall),
        #[allow(missing_docs)]
        getServiceEscrow(getServiceEscrowCall),
        #[allow(missing_docs)]
        getServiceOperator(getServiceOperatorCall),
        #[allow(missing_docs)]
        getServiceOperators(getServiceOperatorsCall),
        #[allow(missing_docs)]
        getServiceRequest(getServiceRequestCall),
        #[allow(missing_docs)]
        getSlashProposal(getSlashProposalCall),
        #[allow(missing_docs)]
        grantRole(grantRoleCall),
        #[allow(missing_docs)]
        hasRole(hasRoleCall),
        #[allow(missing_docs)]
        initialize(initializeCall),
        #[allow(missing_docs)]
        isOperatorRegistered(isOperatorRegisteredCall),
        #[allow(missing_docs)]
        isPermittedCaller(isPermittedCallerCall),
        #[allow(missing_docs)]
        isServiceActive(isServiceActiveCall),
        #[allow(missing_docs)]
        isServiceOperator(isServiceOperatorCall),
        #[allow(missing_docs)]
        joinService(joinServiceCall),
        #[allow(missing_docs)]
        leaveService(leaveServiceCall),
        #[allow(missing_docs)]
        metricsRecorder(metricsRecorderCall),
        #[allow(missing_docs)]
        operatorStatusRegistry(operatorStatusRegistryCall),
        #[allow(missing_docs)]
        pause(pauseCall),
        #[allow(missing_docs)]
        paused(pausedCall),
        #[allow(missing_docs)]
        paymentSplit(paymentSplitCall),
        #[allow(missing_docs)]
        pendingRewards_0(pendingRewards_0Call),
        #[allow(missing_docs)]
        pendingRewards_1(pendingRewards_1Call),
        #[allow(missing_docs)]
        preRegister(preRegisterCall),
        #[allow(missing_docs)]
        proposeSlash(proposeSlashCall),
        #[allow(missing_docs)]
        proxiableUUID(proxiableUUIDCall),
        #[allow(missing_docs)]
        registerOperator(registerOperatorCall),
        #[allow(missing_docs)]
        rejectService(rejectServiceCall),
        #[allow(missing_docs)]
        removePermittedCaller(removePermittedCallerCall),
        #[allow(missing_docs)]
        renounceRole(renounceRoleCall),
        #[allow(missing_docs)]
        requestService(requestServiceCall),
        #[allow(missing_docs)]
        requestServiceWithExposure(requestServiceWithExposureCall),
        #[allow(missing_docs)]
        requestServiceWithSecurity(requestServiceWithSecurityCall),
        #[allow(missing_docs)]
        revokeRole(revokeRoleCall),
        #[allow(missing_docs)]
        serviceCount(serviceCountCall),
        #[allow(missing_docs)]
        serviceRequestCount(serviceRequestCountCall),
        #[allow(missing_docs)]
        setMetricsRecorder(setMetricsRecorderCall),
        #[allow(missing_docs)]
        setOperatorStatusRegistry(setOperatorStatusRegistryCall),
        #[allow(missing_docs)]
        setPaymentSplit(setPaymentSplitCall),
        #[allow(missing_docs)]
        setSlashConfig(setSlashConfigCall),
        #[allow(missing_docs)]
        setTreasury(setTreasuryCall),
        #[allow(missing_docs)]
        submitAggregatedResult(submitAggregatedResultCall),
        #[allow(missing_docs)]
        submitJob(submitJobCall),
        #[allow(missing_docs)]
        submitResult(submitResultCall),
        #[allow(missing_docs)]
        submitResults(submitResultsCall),
        #[allow(missing_docs)]
        supportsInterface(supportsInterfaceCall),
        #[allow(missing_docs)]
        terminateService(terminateServiceCall),
        #[allow(missing_docs)]
        transferBlueprint(transferBlueprintCall),
        #[allow(missing_docs)]
        unpause(unpauseCall),
        #[allow(missing_docs)]
        unregisterOperator(unregisterOperatorCall),
        #[allow(missing_docs)]
        updateBlueprint(updateBlueprintCall),
        #[allow(missing_docs)]
        updateOperatorPreferences(updateOperatorPreferencesCall),
        #[allow(missing_docs)]
        updateRpcAddress(updateRpcAddressCall),
        #[allow(missing_docs)]
        upgradeToAndCall(upgradeToAndCallCall),
    }
    #[automatically_derived]
    impl TangleCalls {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [1u8, 255u8, 201u8, 167u8],
            [6u8, 7u8, 157u8, 197u8],
            [6u8, 35u8, 117u8, 38u8],
            [7u8, 230u8, 1u8, 41u8],
            [10u8, 253u8, 55u8, 56u8],
            [15u8, 51u8, 232u8, 225u8],
            [16u8, 138u8, 125u8, 99u8],
            [17u8, 15u8, 130u8, 155u8],
            [24u8, 198u8, 128u8, 23u8],
            [32u8, 129u8, 41u8, 86u8],
            [35u8, 215u8, 179u8, 225u8],
            [36u8, 138u8, 156u8, 163u8],
            [43u8, 157u8, 167u8, 26u8],
            [45u8, 7u8, 230u8, 85u8],
            [45u8, 174u8, 24u8, 133u8],
            [46u8, 194u8, 189u8, 3u8],
            [47u8, 47u8, 241u8, 93u8],
            [47u8, 70u8, 39u8, 159u8],
            [48u8, 174u8, 40u8, 156u8],
            [49u8, 215u8, 162u8, 98u8],
            [52u8, 19u8, 232u8, 238u8],
            [54u8, 86u8, 138u8, 190u8],
            [55u8, 37u8, 0u8, 171u8],
            [61u8, 192u8, 213u8, 254u8],
            [63u8, 75u8, 168u8, 58u8],
            [68u8, 155u8, 184u8, 73u8],
            [79u8, 30u8, 242u8, 134u8],
            [82u8, 209u8, 144u8, 45u8],
            [86u8, 58u8, 137u8, 249u8],
            [91u8, 113u8, 201u8, 52u8],
            [92u8, 151u8, 90u8, 187u8],
            [95u8, 53u8, 153u8, 36u8],
            [95u8, 155u8, 77u8, 250u8],
            [97u8, 72u8, 35u8, 178u8],
            [100u8, 70u8, 37u8, 149u8],
            [103u8, 120u8, 175u8, 188u8],
            [106u8, 100u8, 162u8, 126u8],
            [107u8, 218u8, 66u8, 243u8],
            [109u8, 139u8, 136u8, 195u8],
            [117u8, 178u8, 56u8, 252u8],
            [119u8, 56u8, 12u8, 116u8],
            [120u8, 68u8, 134u8, 55u8],
            [120u8, 134u8, 122u8, 22u8],
            [128u8, 172u8, 130u8, 40u8],
            [129u8, 93u8, 106u8, 38u8],
            [132u8, 37u8, 36u8, 187u8],
            [132u8, 86u8, 203u8, 89u8],
            [138u8, 76u8, 247u8, 99u8],
            [140u8, 154u8, 40u8, 29u8],
            [141u8, 63u8, 101u8, 190u8],
            [145u8, 209u8, 72u8, 84u8],
            [147u8, 243u8, 221u8, 175u8],
            [151u8, 14u8, 8u8, 254u8],
            [162u8, 23u8, 253u8, 223u8],
            [163u8, 123u8, 146u8, 134u8],
            [165u8, 149u8, 178u8, 30u8],
            [165u8, 191u8, 186u8, 228u8],
            [166u8, 114u8, 188u8, 10u8],
            [170u8, 199u8, 65u8, 107u8],
            [170u8, 205u8, 186u8, 159u8],
            [173u8, 60u8, 177u8, 204u8],
            [176u8, 85u8, 68u8, 155u8],
            [183u8, 105u8, 109u8, 187u8],
            [184u8, 23u8, 65u8, 172u8],
            [187u8, 32u8, 127u8, 31u8],
            [192u8, 197u8, 59u8, 139u8],
            [195u8, 37u8, 174u8, 18u8],
            [198u8, 2u8, 212u8, 250u8],
            [204u8, 61u8, 25u8, 195u8],
            [207u8, 56u8, 6u8, 198u8],
            [211u8, 144u8, 187u8, 187u8],
            [213u8, 71u8, 116u8, 31u8],
            [218u8, 35u8, 45u8, 237u8],
            [223u8, 230u8, 42u8, 186u8],
            [229u8, 56u8, 218u8, 102u8],
            [230u8, 58u8, 177u8, 233u8],
            [231u8, 33u8, 70u8, 169u8],
            [235u8, 140u8, 59u8, 205u8],
            [236u8, 159u8, 15u8, 221u8],
            [239u8, 27u8, 66u8, 162u8],
            [239u8, 92u8, 251u8, 140u8],
            [240u8, 65u8, 26u8, 243u8],
            [240u8, 244u8, 66u8, 96u8],
            [247u8, 44u8, 13u8, 139u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TangleCalls {
        const NAME: &'static str = "TangleCalls";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 84usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::ADMIN_ROLE(_) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::DEFAULT_ADMIN_ROLE(_) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::PAUSER_ROLE(_) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::SLASH_ADMIN_ROLE(_) => {
                    <SLASH_ADMIN_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::UPGRADER_ROLE(_) => {
                    <UPGRADER_ROLECall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::UPGRADE_INTERFACE_VERSION(_) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::addPermittedCaller(_) => {
                    <addPermittedCallerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approveService(_) => {
                    <approveServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::approveServiceWithCommitments(_) => {
                    <approveServiceWithCommitmentsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::billSubscription(_) => {
                    <billSubscriptionCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::billSubscriptionBatch(_) => {
                    <billSubscriptionBatchCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::blueprintCount(_) => {
                    <blueprintCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::blueprintOperatorCount(_) => {
                    <blueprintOperatorCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::cancelSlash(_) => {
                    <cancelSlashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimRewards_0(_) => {
                    <claimRewards_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::claimRewards_1(_) => {
                    <claimRewards_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createBlueprint(_) => {
                    <createBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createBlueprintWithConfig(_) => {
                    <createBlueprintWithConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::createServiceFromQuotes(_) => {
                    <createServiceFromQuotesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::deactivateBlueprint(_) => {
                    <deactivateBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::disputeSlash(_) => {
                    <disputeSlashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::executeSlash(_) => {
                    <executeSlashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::executeSlashBatch(_) => {
                    <executeSlashBatchCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::fundService(_) => {
                    <fundServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBillableServices(_) => {
                    <getBillableServicesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlueprint(_) => {
                    <getBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getBlueprintConfig(_) => {
                    <getBlueprintConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getExecutableSlashes(_) => {
                    <getExecutableSlashesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getJobCall(_) => {
                    <getJobCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getOperatorRegistration(_) => {
                    <getOperatorRegistrationCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getRoleAdmin(_) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getService(_) => {
                    <getServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getServiceEscrow(_) => {
                    <getServiceEscrowCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getServiceOperator(_) => {
                    <getServiceOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getServiceOperators(_) => {
                    <getServiceOperatorsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getServiceRequest(_) => {
                    <getServiceRequestCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::getSlashProposal(_) => {
                    <getSlashProposalCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::grantRole(_) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::hasRole(_) => <hasRoleCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::initialize(_) => {
                    <initializeCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isOperatorRegistered(_) => {
                    <isOperatorRegisteredCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isPermittedCaller(_) => {
                    <isPermittedCallerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isServiceActive(_) => {
                    <isServiceActiveCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::isServiceOperator(_) => {
                    <isServiceOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::joinService(_) => {
                    <joinServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::leaveService(_) => {
                    <leaveServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::metricsRecorder(_) => {
                    <metricsRecorderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::operatorStatusRegistry(_) => {
                    <operatorStatusRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pause(_) => <pauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paused(_) => <pausedCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::paymentSplit(_) => {
                    <paymentSplitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pendingRewards_0(_) => {
                    <pendingRewards_0Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::pendingRewards_1(_) => {
                    <pendingRewards_1Call as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::preRegister(_) => {
                    <preRegisterCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proposeSlash(_) => {
                    <proposeSlashCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::proxiableUUID(_) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::registerOperator(_) => {
                    <registerOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::rejectService(_) => {
                    <rejectServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::removePermittedCaller(_) => {
                    <removePermittedCallerCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::renounceRole(_) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requestService(_) => {
                    <requestServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requestServiceWithExposure(_) => {
                    <requestServiceWithExposureCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::requestServiceWithSecurity(_) => {
                    <requestServiceWithSecurityCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::revokeRole(_) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serviceCount(_) => {
                    <serviceCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::serviceRequestCount(_) => {
                    <serviceRequestCountCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setMetricsRecorder(_) => {
                    <setMetricsRecorderCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setOperatorStatusRegistry(_) => {
                    <setOperatorStatusRegistryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setPaymentSplit(_) => {
                    <setPaymentSplitCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setSlashConfig(_) => {
                    <setSlashConfigCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::setTreasury(_) => {
                    <setTreasuryCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitAggregatedResult(_) => {
                    <submitAggregatedResultCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitJob(_) => {
                    <submitJobCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitResult(_) => {
                    <submitResultCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::submitResults(_) => {
                    <submitResultsCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::supportsInterface(_) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::terminateService(_) => {
                    <terminateServiceCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::transferBlueprint(_) => {
                    <transferBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::unpause(_) => <unpauseCall as alloy_sol_types::SolCall>::SELECTOR,
                Self::unregisterOperator(_) => {
                    <unregisterOperatorCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateBlueprint(_) => {
                    <updateBlueprintCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateOperatorPreferences(_) => {
                    <updateOperatorPreferencesCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::updateRpcAddress(_) => {
                    <updateRpcAddressCall as alloy_sol_types::SolCall>::SELECTOR
                }
                Self::upgradeToAndCall(_) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TangleCalls>] = &[
                {
                    fn supportsInterface(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::supportsInterface)
                    }
                    supportsInterface
                },
                {
                    fn cancelSlash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <cancelSlashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::cancelSlash)
                    }
                    cancelSlash
                },
                {
                    fn serviceCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <serviceCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::serviceCount)
                    }
                    serviceCount
                },
                {
                    fn serviceRequestCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <serviceRequestCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::serviceRequestCount)
                    }
                    serviceRequestCount
                },
                {
                    fn unregisterOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <unregisterOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::unregisterOperator)
                    }
                    unregisterOperator
                },
                {
                    fn updateRpcAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <updateRpcAddressCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::updateRpcAddress)
                    }
                    updateRpcAddress
                },
                {
                    fn requestServiceWithExposure(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <requestServiceWithExposureCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::requestServiceWithExposure)
                    }
                    requestServiceWithExposure
                },
                {
                    fn getExecutableSlashes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getExecutableSlashesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getExecutableSlashes)
                    }
                    getExecutableSlashes
                },
                {
                    fn preRegister(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <preRegisterCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::preRegister)
                    }
                    preRegister
                },
                {
                    fn setMetricsRecorder(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <setMetricsRecorderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::setMetricsRecorder)
                    }
                    setMetricsRecorder
                },
                {
                    fn approveServiceWithCommitments(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <approveServiceWithCommitmentsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::approveServiceWithCommitments)
                    }
                    approveServiceWithCommitments
                },
                {
                    fn getRoleAdmin(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getRoleAdminCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getRoleAdmin)
                    }
                    getRoleAdmin
                },
                {
                    fn joinService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <joinServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::joinService)
                    }
                    joinService
                },
                {
                    fn submitResult(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <submitResultCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::submitResult)
                    }
                    submitResult
                },
                {
                    fn metricsRecorder(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <metricsRecorderCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::metricsRecorder)
                    }
                    metricsRecorder
                },
                {
                    fn isPermittedCaller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <isPermittedCallerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::isPermittedCaller)
                    }
                    isPermittedCaller
                },
                {
                    fn grantRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <grantRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::grantRole)
                    }
                    grantRole
                },
                {
                    fn isServiceActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <isServiceActiveCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::isServiceActive)
                    }
                    isServiceActive
                },
                {
                    fn proposeSlash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <proposeSlashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::proposeSlash)
                    }
                    proposeSlash
                },
                {
                    fn pendingRewards_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <pendingRewards_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::pendingRewards_0)
                    }
                    pendingRewards_0
                },
                {
                    fn submitJob(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <submitJobCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::submitJob)
                    }
                    submitJob
                },
                {
                    fn renounceRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <renounceRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::renounceRole)
                    }
                    renounceRole
                },
                {
                    fn claimRewards_0(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <claimRewards_0Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::claimRewards_0)
                    }
                    claimRewards_0
                },
                {
                    fn getService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getService)
                    }
                    getService
                },
                {
                    fn unpause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <unpauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::unpause)
                    }
                    unpause
                },
                {
                    fn deactivateBlueprint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <deactivateBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::deactivateBlueprint)
                    }
                    deactivateBlueprint
                },
                {
                    fn upgradeToAndCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::upgradeToAndCall)
                    }
                    upgradeToAndCall
                },
                {
                    fn proxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::proxiableUUID)
                    }
                    proxiableUUID
                },
                {
                    fn getBlueprintConfig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getBlueprintConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getBlueprintConfig)
                    }
                    getBlueprintConfig
                },
                {
                    fn terminateService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <terminateServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::terminateService)
                    }
                    terminateService
                },
                {
                    fn paused(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <pausedCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::paused)
                    }
                    paused
                },
                {
                    fn removePermittedCaller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <removePermittedCallerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::removePermittedCaller)
                    }
                    removePermittedCaller
                },
                {
                    fn getServiceRequest(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getServiceRequestCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getServiceRequest)
                    }
                    getServiceRequest
                },
                {
                    fn approveService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <approveServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::approveService)
                    }
                    approveService
                },
                {
                    fn isOperatorRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <isOperatorRegisteredCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::isOperatorRegistered)
                    }
                    isOperatorRegistered
                },
                {
                    fn leaveService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <leaveServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::leaveService)
                    }
                    leaveService
                },
                {
                    fn setOperatorStatusRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <setOperatorStatusRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::setOperatorStatusRegistry)
                    }
                    setOperatorStatusRegistry
                },
                {
                    fn getOperatorRegistration(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getOperatorRegistrationCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getOperatorRegistration)
                    }
                    getOperatorRegistration
                },
                {
                    fn rejectService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <rejectServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::rejectService)
                    }
                    rejectService
                },
                {
                    fn ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::ADMIN_ROLE)
                    }
                    ADMIN_ROLE
                },
                {
                    fn disputeSlash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <disputeSlashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::disputeSlash)
                    }
                    disputeSlash
                },
                {
                    fn createBlueprintWithConfig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <createBlueprintWithConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::createBlueprintWithConfig)
                    }
                    createBlueprintWithConfig
                },
                {
                    fn setSlashConfig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <setSlashConfigCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::setSlashConfig)
                    }
                    setSlashConfig
                },
                {
                    fn pendingRewards_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <pendingRewards_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::pendingRewards_1)
                    }
                    pendingRewards_1
                },
                {
                    fn addPermittedCaller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <addPermittedCallerCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::addPermittedCaller)
                    }
                    addPermittedCaller
                },
                {
                    fn getServiceOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getServiceOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getServiceOperator)
                    }
                    getServiceOperator
                },
                {
                    fn pause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <pauseCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::pause)
                    }
                    pause
                },
                {
                    fn transferBlueprint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <transferBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::transferBlueprint)
                    }
                    transferBlueprint
                },
                {
                    fn SLASH_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <SLASH_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::SLASH_ADMIN_ROLE)
                    }
                    SLASH_ADMIN_ROLE
                },
                {
                    fn blueprintOperatorCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <blueprintOperatorCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::blueprintOperatorCount)
                    }
                    blueprintOperatorCount
                },
                {
                    fn hasRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <hasRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::hasRole)
                    }
                    hasRole
                },
                {
                    fn getBillableServices(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getBillableServicesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getBillableServices)
                    }
                    getBillableServices
                },
                {
                    fn fundService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <fundServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::fundService)
                    }
                    fundService
                },
                {
                    fn DEFAULT_ADMIN_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::DEFAULT_ADMIN_ROLE)
                    }
                    DEFAULT_ADMIN_ROLE
                },
                {
                    fn requestService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <requestServiceCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::requestService)
                    }
                    requestService
                },
                {
                    fn isServiceOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <isServiceOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::isServiceOperator)
                    }
                    isServiceOperator
                },
                {
                    fn executeSlash(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <executeSlashCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::executeSlash)
                    }
                    executeSlash
                },
                {
                    fn getJobCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getJobCallCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getJobCall)
                    }
                    getJobCall
                },
                {
                    fn paymentSplit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <paymentSplitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::paymentSplit)
                    }
                    paymentSplit
                },
                {
                    fn submitResults(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <submitResultsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::submitResults)
                    }
                    submitResults
                },
                {
                    fn UPGRADE_INTERFACE_VERSION(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::UPGRADE_INTERFACE_VERSION)
                    }
                    UPGRADE_INTERFACE_VERSION
                },
                {
                    fn executeSlashBatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <executeSlashBatchCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::executeSlashBatch)
                    }
                    executeSlashBatch
                },
                {
                    fn getBlueprint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getBlueprint)
                    }
                    getBlueprint
                },
                {
                    fn setPaymentSplit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <setPaymentSplitCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::setPaymentSplit)
                    }
                    setPaymentSplit
                },
                {
                    fn getServiceOperators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getServiceOperatorsCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getServiceOperators)
                    }
                    getServiceOperators
                },
                {
                    fn initialize(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <initializeCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::initialize)
                    }
                    initialize
                },
                {
                    fn submitAggregatedResult(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <submitAggregatedResultCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::submitAggregatedResult)
                    }
                    submitAggregatedResult
                },
                {
                    fn blueprintCount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <blueprintCountCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::blueprintCount)
                    }
                    blueprintCount
                },
                {
                    fn registerOperator(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <registerOperatorCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::registerOperator)
                    }
                    registerOperator
                },
                {
                    fn billSubscription(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <billSubscriptionCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::billSubscription)
                    }
                    billSubscription
                },
                {
                    fn operatorStatusRegistry(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <operatorStatusRegistryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::operatorStatusRegistry)
                    }
                    operatorStatusRegistry
                },
                {
                    fn revokeRole(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <revokeRoleCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::revokeRole)
                    }
                    revokeRole
                },
                {
                    fn billSubscriptionBatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <billSubscriptionBatchCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::billSubscriptionBatch)
                    }
                    billSubscriptionBatch
                },
                {
                    fn updateOperatorPreferences(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <updateOperatorPreferencesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::updateOperatorPreferences)
                    }
                    updateOperatorPreferences
                },
                {
                    fn updateBlueprint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <updateBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::updateBlueprint)
                    }
                    updateBlueprint
                },
                {
                    fn PAUSER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::PAUSER_ROLE)
                    }
                    PAUSER_ROLE
                },
                {
                    fn createBlueprint(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <createBlueprintCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::createBlueprint)
                    }
                    createBlueprint
                },
                {
                    fn getServiceEscrow(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getServiceEscrowCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getServiceEscrow)
                    }
                    getServiceEscrow
                },
                {
                    fn requestServiceWithSecurity(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <requestServiceWithSecurityCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::requestServiceWithSecurity)
                    }
                    requestServiceWithSecurity
                },
                {
                    fn getSlashProposal(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <getSlashProposalCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::getSlashProposal)
                    }
                    getSlashProposal
                },
                {
                    fn claimRewards_1(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <claimRewards_1Call as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::claimRewards_1)
                    }
                    claimRewards_1
                },
                {
                    fn createServiceFromQuotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <createServiceFromQuotesCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::createServiceFromQuotes)
                    }
                    createServiceFromQuotes
                },
                {
                    fn setTreasury(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <setTreasuryCall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::setTreasury)
                    }
                    setTreasury
                },
                {
                    fn UPGRADER_ROLE(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleCalls> {
                        <UPGRADER_ROLECall as alloy_sol_types::SolCall>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleCalls::UPGRADER_ROLE)
                    }
                    UPGRADER_ROLE
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::ADMIN_ROLE(inner) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SLASH_ADMIN_ROLE(inner) => {
                    <SLASH_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UPGRADER_ROLE(inner) => {
                    <UPGRADER_ROLECall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::addPermittedCaller(inner) => {
                    <addPermittedCallerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::approveService(inner) => {
                    <approveServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::approveServiceWithCommitments(inner) => {
                    <approveServiceWithCommitmentsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::billSubscription(inner) => {
                    <billSubscriptionCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::billSubscriptionBatch(inner) => {
                    <billSubscriptionBatchCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::blueprintCount(inner) => {
                    <blueprintCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::blueprintOperatorCount(inner) => {
                    <blueprintOperatorCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::cancelSlash(inner) => {
                    <cancelSlashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimRewards_0(inner) => {
                    <claimRewards_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::claimRewards_1(inner) => {
                    <claimRewards_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createBlueprint(inner) => {
                    <createBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createBlueprintWithConfig(inner) => {
                    <createBlueprintWithConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::createServiceFromQuotes(inner) => {
                    <createServiceFromQuotesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::deactivateBlueprint(inner) => {
                    <deactivateBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::disputeSlash(inner) => {
                    <disputeSlashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::executeSlash(inner) => {
                    <executeSlashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::executeSlashBatch(inner) => {
                    <executeSlashBatchCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::fundService(inner) => {
                    <fundServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBillableServices(inner) => {
                    <getBillableServicesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlueprint(inner) => {
                    <getBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getBlueprintConfig(inner) => {
                    <getBlueprintConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getExecutableSlashes(inner) => {
                    <getExecutableSlashesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getJobCall(inner) => {
                    <getJobCallCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getOperatorRegistration(inner) => {
                    <getOperatorRegistrationCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getService(inner) => {
                    <getServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::getServiceEscrow(inner) => {
                    <getServiceEscrowCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getServiceOperator(inner) => {
                    <getServiceOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getServiceOperators(inner) => {
                    <getServiceOperatorsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getServiceRequest(inner) => {
                    <getServiceRequestCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::getSlashProposal(inner) => {
                    <getSlashProposalCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::isOperatorRegistered(inner) => {
                    <isOperatorRegisteredCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isPermittedCaller(inner) => {
                    <isPermittedCallerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isServiceActive(inner) => {
                    <isServiceActiveCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::isServiceOperator(inner) => {
                    <isServiceOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::joinService(inner) => {
                    <joinServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::leaveService(inner) => {
                    <leaveServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::metricsRecorder(inner) => {
                    <metricsRecorderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::operatorStatusRegistry(inner) => {
                    <operatorStatusRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::paymentSplit(inner) => {
                    <paymentSplitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pendingRewards_0(inner) => {
                    <pendingRewards_0Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::pendingRewards_1(inner) => {
                    <pendingRewards_1Call as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::preRegister(inner) => {
                    <preRegisterCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proposeSlash(inner) => {
                    <proposeSlashCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::registerOperator(inner) => {
                    <registerOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::rejectService(inner) => {
                    <rejectServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::removePermittedCaller(inner) => {
                    <removePermittedCallerCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requestService(inner) => {
                    <requestServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requestServiceWithExposure(inner) => {
                    <requestServiceWithExposureCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::requestServiceWithSecurity(inner) => {
                    <requestServiceWithSecurityCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::serviceCount(inner) => {
                    <serviceCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::serviceRequestCount(inner) => {
                    <serviceRequestCountCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setMetricsRecorder(inner) => {
                    <setMetricsRecorderCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setOperatorStatusRegistry(inner) => {
                    <setOperatorStatusRegistryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setPaymentSplit(inner) => {
                    <setPaymentSplitCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setSlashConfig(inner) => {
                    <setSlashConfigCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::setTreasury(inner) => {
                    <setTreasuryCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitAggregatedResult(inner) => {
                    <submitAggregatedResultCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitJob(inner) => {
                    <submitJobCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::submitResult(inner) => {
                    <submitResultCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::submitResults(inner) => {
                    <submitResultsCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::terminateService(inner) => {
                    <terminateServiceCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::transferBlueprint(inner) => {
                    <transferBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encoded_size(inner)
                }
                Self::unregisterOperator(inner) => {
                    <unregisterOperatorCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateBlueprint(inner) => {
                    <updateBlueprintCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateOperatorPreferences(inner) => {
                    <updateOperatorPreferencesCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::updateRpcAddress(inner) => {
                    <updateRpcAddressCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encoded_size(
                        inner,
                    )
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::ADMIN_ROLE(inner) => {
                    <ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DEFAULT_ADMIN_ROLE(inner) => {
                    <DEFAULT_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PAUSER_ROLE(inner) => {
                    <PAUSER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SLASH_ADMIN_ROLE(inner) => {
                    <SLASH_ADMIN_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UPGRADER_ROLE(inner) => {
                    <UPGRADER_ROLECall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UPGRADE_INTERFACE_VERSION(inner) => {
                    <UPGRADE_INTERFACE_VERSIONCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::addPermittedCaller(inner) => {
                    <addPermittedCallerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approveService(inner) => {
                    <approveServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::approveServiceWithCommitments(inner) => {
                    <approveServiceWithCommitmentsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::billSubscription(inner) => {
                    <billSubscriptionCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::billSubscriptionBatch(inner) => {
                    <billSubscriptionBatchCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::blueprintCount(inner) => {
                    <blueprintCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::blueprintOperatorCount(inner) => {
                    <blueprintOperatorCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::cancelSlash(inner) => {
                    <cancelSlashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimRewards_0(inner) => {
                    <claimRewards_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::claimRewards_1(inner) => {
                    <claimRewards_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createBlueprint(inner) => {
                    <createBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createBlueprintWithConfig(inner) => {
                    <createBlueprintWithConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::createServiceFromQuotes(inner) => {
                    <createServiceFromQuotesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::deactivateBlueprint(inner) => {
                    <deactivateBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::disputeSlash(inner) => {
                    <disputeSlashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::executeSlash(inner) => {
                    <executeSlashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::executeSlashBatch(inner) => {
                    <executeSlashBatchCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::fundService(inner) => {
                    <fundServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBillableServices(inner) => {
                    <getBillableServicesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlueprint(inner) => {
                    <getBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getBlueprintConfig(inner) => {
                    <getBlueprintConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getExecutableSlashes(inner) => {
                    <getExecutableSlashesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getJobCall(inner) => {
                    <getJobCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getOperatorRegistration(inner) => {
                    <getOperatorRegistrationCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getRoleAdmin(inner) => {
                    <getRoleAdminCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getService(inner) => {
                    <getServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getServiceEscrow(inner) => {
                    <getServiceEscrowCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getServiceOperator(inner) => {
                    <getServiceOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getServiceOperators(inner) => {
                    <getServiceOperatorsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getServiceRequest(inner) => {
                    <getServiceRequestCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::getSlashProposal(inner) => {
                    <getSlashProposalCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::grantRole(inner) => {
                    <grantRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::hasRole(inner) => {
                    <hasRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::initialize(inner) => {
                    <initializeCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isOperatorRegistered(inner) => {
                    <isOperatorRegisteredCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isPermittedCaller(inner) => {
                    <isPermittedCallerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isServiceActive(inner) => {
                    <isServiceActiveCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::isServiceOperator(inner) => {
                    <isServiceOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::joinService(inner) => {
                    <joinServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::leaveService(inner) => {
                    <leaveServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::metricsRecorder(inner) => {
                    <metricsRecorderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::operatorStatusRegistry(inner) => {
                    <operatorStatusRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pause(inner) => {
                    <pauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paused(inner) => {
                    <pausedCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::paymentSplit(inner) => {
                    <paymentSplitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pendingRewards_0(inner) => {
                    <pendingRewards_0Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::pendingRewards_1(inner) => {
                    <pendingRewards_1Call as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::preRegister(inner) => {
                    <preRegisterCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proposeSlash(inner) => {
                    <proposeSlashCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::proxiableUUID(inner) => {
                    <proxiableUUIDCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::registerOperator(inner) => {
                    <registerOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::rejectService(inner) => {
                    <rejectServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::removePermittedCaller(inner) => {
                    <removePermittedCallerCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::renounceRole(inner) => {
                    <renounceRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requestService(inner) => {
                    <requestServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requestServiceWithExposure(inner) => {
                    <requestServiceWithExposureCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::requestServiceWithSecurity(inner) => {
                    <requestServiceWithSecurityCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::revokeRole(inner) => {
                    <revokeRoleCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serviceCount(inner) => {
                    <serviceCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::serviceRequestCount(inner) => {
                    <serviceRequestCountCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setMetricsRecorder(inner) => {
                    <setMetricsRecorderCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setOperatorStatusRegistry(inner) => {
                    <setOperatorStatusRegistryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setPaymentSplit(inner) => {
                    <setPaymentSplitCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setSlashConfig(inner) => {
                    <setSlashConfigCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::setTreasury(inner) => {
                    <setTreasuryCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitAggregatedResult(inner) => {
                    <submitAggregatedResultCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitJob(inner) => {
                    <submitJobCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitResult(inner) => {
                    <submitResultCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::submitResults(inner) => {
                    <submitResultsCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::supportsInterface(inner) => {
                    <supportsInterfaceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::terminateService(inner) => {
                    <terminateServiceCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::transferBlueprint(inner) => {
                    <transferBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::unpause(inner) => {
                    <unpauseCall as alloy_sol_types::SolCall>::abi_encode_raw(inner, out)
                }
                Self::unregisterOperator(inner) => {
                    <unregisterOperatorCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateBlueprint(inner) => {
                    <updateBlueprintCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateOperatorPreferences(inner) => {
                    <updateOperatorPreferencesCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::updateRpcAddress(inner) => {
                    <updateRpcAddressCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::upgradeToAndCall(inner) => {
                    <upgradeToAndCallCall as alloy_sol_types::SolCall>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
            }
        }
    }
    ///Container for all the [`Tangle`](self) custom errors.
    pub enum TangleErrors {
        #[allow(missing_docs)]
        AccessControlBadConfirmation(AccessControlBadConfirmation),
        #[allow(missing_docs)]
        AccessControlUnauthorizedAccount(AccessControlUnauthorizedAccount),
        #[allow(missing_docs)]
        AddressEmptyCode(AddressEmptyCode),
        #[allow(missing_docs)]
        AggregationNotRequired(AggregationNotRequired),
        #[allow(missing_docs)]
        AggregationRequired(AggregationRequired),
        #[allow(missing_docs)]
        AggregationThresholdNotMet(AggregationThresholdNotMet),
        #[allow(missing_docs)]
        AlreadyApproved(AlreadyApproved),
        #[allow(missing_docs)]
        BlueprintNotActive(BlueprintNotActive),
        #[allow(missing_docs)]
        BlueprintNotFound(BlueprintNotFound),
        #[allow(missing_docs)]
        CommitmentAboveMaximum(CommitmentAboveMaximum),
        #[allow(missing_docs)]
        CommitmentBelowMinimum(CommitmentBelowMinimum),
        #[allow(missing_docs)]
        DeadlineExpired(DeadlineExpired),
        #[allow(missing_docs)]
        DisputeWindowPassed(DisputeWindowPassed),
        #[allow(missing_docs)]
        DuplicateOperatorQuote(DuplicateOperatorQuote),
        #[allow(missing_docs)]
        ECDSAInvalidSignature(ECDSAInvalidSignature),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureLength(ECDSAInvalidSignatureLength),
        #[allow(missing_docs)]
        ECDSAInvalidSignatureS(ECDSAInvalidSignatureS),
        #[allow(missing_docs)]
        ERC1967InvalidImplementation(ERC1967InvalidImplementation),
        #[allow(missing_docs)]
        ERC1967NonPayable(ERC1967NonPayable),
        #[allow(missing_docs)]
        EnforcedPause(EnforcedPause),
        #[allow(missing_docs)]
        ExpectedPause(ExpectedPause),
        #[allow(missing_docs)]
        FailedCall(FailedCall),
        #[allow(missing_docs)]
        HashToPointFailed(HashToPointFailed),
        #[allow(missing_docs)]
        InstantSlashNotEnabled(InstantSlashNotEnabled),
        #[allow(missing_docs)]
        InsufficientEscrowBalance(InsufficientEscrowBalance),
        #[allow(missing_docs)]
        InsufficientOperators(InsufficientOperators),
        #[allow(missing_docs)]
        InsufficientPayment(InsufficientPayment),
        #[allow(missing_docs)]
        InsufficientPaymentForQuotes(InsufficientPaymentForQuotes),
        #[allow(missing_docs)]
        InsufficientStake(InsufficientStake),
        #[allow(missing_docs)]
        InvalidBLSSignature(InvalidBLSSignature),
        #[allow(missing_docs)]
        InvalidInitialization(InvalidInitialization),
        #[allow(missing_docs)]
        InvalidPaymentSplit(InvalidPaymentSplit),
        #[allow(missing_docs)]
        InvalidPaymentToken(InvalidPaymentToken),
        #[allow(missing_docs)]
        InvalidQuoteSignature(InvalidQuoteSignature),
        #[allow(missing_docs)]
        InvalidSecurityRequirement(InvalidSecurityRequirement),
        #[allow(missing_docs)]
        InvalidSlashAmount(InvalidSlashAmount),
        #[allow(missing_docs)]
        InvalidSlashConfig(InvalidSlashConfig),
        #[allow(missing_docs)]
        InvalidState(InvalidState),
        #[allow(missing_docs)]
        JobAlreadyCompleted(JobAlreadyCompleted),
        #[allow(missing_docs)]
        JobCallNotFound(JobCallNotFound),
        #[allow(missing_docs)]
        LengthMismatch(LengthMismatch),
        #[allow(missing_docs)]
        ManagerRejected(ManagerRejected),
        #[allow(missing_docs)]
        ManagerReverted(ManagerReverted),
        #[allow(missing_docs)]
        MissingAssetCommitment(MissingAssetCommitment),
        #[allow(missing_docs)]
        NoOperators(NoOperators),
        #[allow(missing_docs)]
        NoQuotes(NoQuotes),
        #[allow(missing_docs)]
        NoSecurityRequirements(NoSecurityRequirements),
        #[allow(missing_docs)]
        NotBlueprintOwner(NotBlueprintOwner),
        #[allow(missing_docs)]
        NotInitializing(NotInitializing),
        #[allow(missing_docs)]
        NotPermittedCaller(NotPermittedCaller),
        #[allow(missing_docs)]
        NotServiceOwner(NotServiceOwner),
        #[allow(missing_docs)]
        NotSlashCanceller(NotSlashCanceller),
        #[allow(missing_docs)]
        NotSlashDisputer(NotSlashDisputer),
        #[allow(missing_docs)]
        OperatorAlreadyRegistered(OperatorAlreadyRegistered),
        #[allow(missing_docs)]
        OperatorNotActive(OperatorNotActive),
        #[allow(missing_docs)]
        OperatorNotInService(OperatorNotInService),
        #[allow(missing_docs)]
        OperatorNotRegistered(OperatorNotRegistered),
        #[allow(missing_docs)]
        PairingFailed(PairingFailed),
        #[allow(missing_docs)]
        PaymentFailed(PaymentFailed),
        #[allow(missing_docs)]
        QuoteAlreadyUsed(QuoteAlreadyUsed),
        #[allow(missing_docs)]
        QuoteBlueprintMismatch(QuoteBlueprintMismatch),
        #[allow(missing_docs)]
        QuoteExpired(QuoteExpired),
        #[allow(missing_docs)]
        QuoteTTLMismatch(QuoteTTLMismatch),
        #[allow(missing_docs)]
        ReentrancyGuardReentrantCall(ReentrancyGuardReentrantCall),
        #[allow(missing_docs)]
        ResultAlreadySubmitted(ResultAlreadySubmitted),
        #[allow(missing_docs)]
        SafeERC20FailedOperation(SafeERC20FailedOperation),
        #[allow(missing_docs)]
        ServiceExpired(ServiceExpired),
        #[allow(missing_docs)]
        ServiceNotActive(ServiceNotActive),
        #[allow(missing_docs)]
        ServiceNotFound(ServiceNotFound),
        #[allow(missing_docs)]
        ServiceRequestAlreadyProcessed(ServiceRequestAlreadyProcessed),
        #[allow(missing_docs)]
        ServiceRequestNotFound(ServiceRequestNotFound),
        #[allow(missing_docs)]
        SlashAlreadyCancelled(SlashAlreadyCancelled),
        #[allow(missing_docs)]
        SlashAlreadyExecuted(SlashAlreadyExecuted),
        #[allow(missing_docs)]
        SlashNotExecutable(SlashNotExecutable),
        #[allow(missing_docs)]
        SlashNotFound(SlashNotFound),
        #[allow(missing_docs)]
        SlashNotPending(SlashNotPending),
        #[allow(missing_docs)]
        TokenNotAllowed(TokenNotAllowed),
        #[allow(missing_docs)]
        TooManyOperators(TooManyOperators),
        #[allow(missing_docs)]
        UUPSUnauthorizedCallContext(UUPSUnauthorizedCallContext),
        #[allow(missing_docs)]
        UUPSUnsupportedProxiableUUID(UUPSUnsupportedProxiableUUID),
        #[allow(missing_docs)]
        Unauthorized(Unauthorized),
        #[allow(missing_docs)]
        ZeroAddress(ZeroAddress),
        #[allow(missing_docs)]
        ZeroAmount(ZeroAmount),
    }
    #[automatically_derived]
    impl TangleErrors {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 4usize]] = &[
            [4u8, 240u8, 242u8, 46u8],
            [7u8, 168u8, 78u8, 194u8],
            [8u8, 209u8, 130u8, 113u8],
            [10u8, 85u8, 81u8, 47u8],
            [15u8, 46u8, 211u8, 90u8],
            [17u8, 99u8, 138u8, 142u8],
            [21u8, 203u8, 36u8, 106u8],
            [25u8, 170u8, 207u8, 158u8],
            [26u8, 183u8, 218u8, 107u8],
            [28u8, 156u8, 188u8, 232u8],
            [31u8, 42u8, 32u8, 5u8],
            [35u8, 78u8, 7u8, 29u8],
            [36u8, 108u8, 45u8, 102u8],
            [51u8, 124u8, 44u8, 1u8],
            [57u8, 255u8, 59u8, 16u8],
            [62u8, 229u8, 174u8, 181u8],
            [63u8, 108u8, 39u8, 249u8],
            [66u8, 29u8, 105u8, 218u8],
            [67u8, 116u8, 79u8, 113u8],
            [76u8, 95u8, 226u8, 216u8],
            [76u8, 156u8, 140u8, 227u8],
            [77u8, 244u8, 94u8, 47u8],
            [79u8, 59u8, 102u8, 234u8],
            [82u8, 116u8, 175u8, 231u8],
            [83u8, 42u8, 243u8, 105u8],
            [86u8, 231u8, 236u8, 95u8],
            [87u8, 36u8, 233u8, 213u8],
            [88u8, 184u8, 254u8, 172u8],
            [95u8, 210u8, 72u8, 236u8],
            [102u8, 151u8, 178u8, 50u8],
            [105u8, 35u8, 175u8, 207u8],
            [109u8, 16u8, 0u8, 183u8],
            [113u8, 204u8, 14u8, 154u8],
            [119u8, 5u8, 204u8, 208u8],
            [119u8, 22u8, 76u8, 220u8],
            [120u8, 52u8, 130u8, 233u8],
            [123u8, 190u8, 87u8, 233u8],
            [124u8, 62u8, 98u8, 27u8],
            [126u8, 51u8, 232u8, 228u8],
            [129u8, 214u8, 253u8, 106u8],
            [130u8, 180u8, 41u8, 0u8],
            [134u8, 71u8, 89u8, 8u8],
            [141u8, 252u8, 32u8, 43u8],
            [147u8, 109u8, 66u8, 109u8],
            [148u8, 64u8, 59u8, 112u8],
            [148u8, 129u8, 34u8, 140u8],
            [148u8, 244u8, 124u8, 203u8],
            [150u8, 198u8, 235u8, 252u8],
            [153u8, 150u8, 179u8, 21u8],
            [154u8, 106u8, 230u8, 13u8],
            [155u8, 204u8, 203u8, 253u8],
            [158u8, 196u8, 227u8, 13u8],
            [170u8, 29u8, 73u8, 164u8],
            [171u8, 27u8, 35u8, 107u8],
            [173u8, 33u8, 205u8, 101u8],
            [173u8, 252u8, 195u8, 70u8],
            [179u8, 152u8, 151u8, 159u8],
            [180u8, 139u8, 9u8, 89u8],
            [183u8, 231u8, 252u8, 238u8],
            [185u8, 158u8, 42u8, 183u8],
            [186u8, 243u8, 240u8, 247u8],
            [197u8, 141u8, 89u8, 53u8],
            [200u8, 162u8, 139u8, 182u8],
            [213u8, 221u8, 91u8, 68u8],
            [214u8, 189u8, 162u8, 117u8],
            [215u8, 139u8, 206u8, 12u8],
            [215u8, 230u8, 188u8, 248u8],
            [216u8, 242u8, 114u8, 125u8],
            [217u8, 46u8, 35u8, 61u8],
            [217u8, 60u8, 6u8, 101u8],
            [219u8, 74u8, 92u8, 217u8],
            [221u8, 44u8, 127u8, 183u8],
            [221u8, 249u8, 210u8, 69u8],
            [224u8, 124u8, 141u8, 186u8],
            [226u8, 81u8, 125u8, 63u8],
            [227u8, 86u8, 213u8, 170u8],
            [235u8, 142u8, 23u8, 93u8],
            [242u8, 187u8, 15u8, 16u8],
            [244u8, 153u8, 218u8, 32u8],
            [246u8, 69u8, 238u8, 223u8],
            [249u8, 46u8, 232u8, 169u8],
            [252u8, 230u8, 152u8, 247u8],
            [255u8, 99u8, 58u8, 56u8],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolInterface for TangleErrors {
        const NAME: &'static str = "TangleErrors";
        const MIN_DATA_LENGTH: usize = 0usize;
        const COUNT: usize = 83usize;
        #[inline]
        fn selector(&self) -> [u8; 4] {
            match self {
                Self::AccessControlBadConfirmation(_) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AccessControlUnauthorizedAccount(_) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AddressEmptyCode(_) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AggregationNotRequired(_) => {
                    <AggregationNotRequired as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AggregationRequired(_) => {
                    <AggregationRequired as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AggregationThresholdNotMet(_) => {
                    <AggregationThresholdNotMet as alloy_sol_types::SolError>::SELECTOR
                }
                Self::AlreadyApproved(_) => {
                    <AlreadyApproved as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BlueprintNotActive(_) => {
                    <BlueprintNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::BlueprintNotFound(_) => {
                    <BlueprintNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CommitmentAboveMaximum(_) => {
                    <CommitmentAboveMaximum as alloy_sol_types::SolError>::SELECTOR
                }
                Self::CommitmentBelowMinimum(_) => {
                    <CommitmentBelowMinimum as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DeadlineExpired(_) => {
                    <DeadlineExpired as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DisputeWindowPassed(_) => {
                    <DisputeWindowPassed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::DuplicateOperatorQuote(_) => {
                    <DuplicateOperatorQuote as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignature(_) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureLength(_) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ECDSAInvalidSignatureS(_) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967InvalidImplementation(_) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ERC1967NonPayable(_) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::EnforcedPause(_) => {
                    <EnforcedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ExpectedPause(_) => {
                    <ExpectedPause as alloy_sol_types::SolError>::SELECTOR
                }
                Self::FailedCall(_) => {
                    <FailedCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::HashToPointFailed(_) => {
                    <HashToPointFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InstantSlashNotEnabled(_) => {
                    <InstantSlashNotEnabled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientEscrowBalance(_) => {
                    <InsufficientEscrowBalance as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientOperators(_) => {
                    <InsufficientOperators as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientPayment(_) => {
                    <InsufficientPayment as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientPaymentForQuotes(_) => {
                    <InsufficientPaymentForQuotes as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InsufficientStake(_) => {
                    <InsufficientStake as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidBLSSignature(_) => {
                    <InvalidBLSSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidInitialization(_) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidPaymentSplit(_) => {
                    <InvalidPaymentSplit as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidPaymentToken(_) => {
                    <InvalidPaymentToken as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidQuoteSignature(_) => {
                    <InvalidQuoteSignature as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSecurityRequirement(_) => {
                    <InvalidSecurityRequirement as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSlashAmount(_) => {
                    <InvalidSlashAmount as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidSlashConfig(_) => {
                    <InvalidSlashConfig as alloy_sol_types::SolError>::SELECTOR
                }
                Self::InvalidState(_) => {
                    <InvalidState as alloy_sol_types::SolError>::SELECTOR
                }
                Self::JobAlreadyCompleted(_) => {
                    <JobAlreadyCompleted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::JobCallNotFound(_) => {
                    <JobCallNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::LengthMismatch(_) => {
                    <LengthMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ManagerRejected(_) => {
                    <ManagerRejected as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ManagerReverted(_) => {
                    <ManagerReverted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::MissingAssetCommitment(_) => {
                    <MissingAssetCommitment as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoOperators(_) => {
                    <NoOperators as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NoQuotes(_) => <NoQuotes as alloy_sol_types::SolError>::SELECTOR,
                Self::NoSecurityRequirements(_) => {
                    <NoSecurityRequirements as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotBlueprintOwner(_) => {
                    <NotBlueprintOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotInitializing(_) => {
                    <NotInitializing as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotPermittedCaller(_) => {
                    <NotPermittedCaller as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotServiceOwner(_) => {
                    <NotServiceOwner as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotSlashCanceller(_) => {
                    <NotSlashCanceller as alloy_sol_types::SolError>::SELECTOR
                }
                Self::NotSlashDisputer(_) => {
                    <NotSlashDisputer as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorAlreadyRegistered(_) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorNotActive(_) => {
                    <OperatorNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorNotInService(_) => {
                    <OperatorNotInService as alloy_sol_types::SolError>::SELECTOR
                }
                Self::OperatorNotRegistered(_) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PairingFailed(_) => {
                    <PairingFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::PaymentFailed(_) => {
                    <PaymentFailed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::QuoteAlreadyUsed(_) => {
                    <QuoteAlreadyUsed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::QuoteBlueprintMismatch(_) => {
                    <QuoteBlueprintMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::QuoteExpired(_) => {
                    <QuoteExpired as alloy_sol_types::SolError>::SELECTOR
                }
                Self::QuoteTTLMismatch(_) => {
                    <QuoteTTLMismatch as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ReentrancyGuardReentrantCall(_) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ResultAlreadySubmitted(_) => {
                    <ResultAlreadySubmitted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SafeERC20FailedOperation(_) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ServiceExpired(_) => {
                    <ServiceExpired as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ServiceNotActive(_) => {
                    <ServiceNotActive as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ServiceNotFound(_) => {
                    <ServiceNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ServiceRequestAlreadyProcessed(_) => {
                    <ServiceRequestAlreadyProcessed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ServiceRequestNotFound(_) => {
                    <ServiceRequestNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SlashAlreadyCancelled(_) => {
                    <SlashAlreadyCancelled as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SlashAlreadyExecuted(_) => {
                    <SlashAlreadyExecuted as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SlashNotExecutable(_) => {
                    <SlashNotExecutable as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SlashNotFound(_) => {
                    <SlashNotFound as alloy_sol_types::SolError>::SELECTOR
                }
                Self::SlashNotPending(_) => {
                    <SlashNotPending as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TokenNotAllowed(_) => {
                    <TokenNotAllowed as alloy_sol_types::SolError>::SELECTOR
                }
                Self::TooManyOperators(_) => {
                    <TooManyOperators as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnauthorizedCallContext(_) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::SELECTOR
                }
                Self::UUPSUnsupportedProxiableUUID(_) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::SELECTOR
                }
                Self::Unauthorized(_) => {
                    <Unauthorized as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAddress(_) => {
                    <ZeroAddress as alloy_sol_types::SolError>::SELECTOR
                }
                Self::ZeroAmount(_) => {
                    <ZeroAmount as alloy_sol_types::SolError>::SELECTOR
                }
            }
        }
        #[inline]
        fn selector_at(i: usize) -> ::core::option::Option<[u8; 4]> {
            Self::SELECTORS.get(i).copied()
        }
        #[inline]
        fn valid_selector(selector: [u8; 4]) -> bool {
            Self::SELECTORS.binary_search(&selector).is_ok()
        }
        #[inline]
        #[allow(non_snake_case)]
        fn abi_decode_raw(
            selector: [u8; 4],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            static DECODE_SHIMS: &[fn(
                &[u8],
                bool,
            ) -> alloy_sol_types::Result<TangleErrors>] = &[
                {
                    fn DuplicateOperatorQuote(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <DuplicateOperatorQuote as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::DuplicateOperatorQuote)
                    }
                    DuplicateOperatorQuote
                },
                {
                    fn ManagerReverted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ManagerReverted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ManagerReverted)
                    }
                    ManagerReverted
                },
                {
                    fn QuoteAlreadyUsed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <QuoteAlreadyUsed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::QuoteAlreadyUsed)
                    }
                    QuoteAlreadyUsed
                },
                {
                    fn JobAlreadyCompleted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <JobAlreadyCompleted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::JobAlreadyCompleted)
                    }
                    JobAlreadyCompleted
                },
                {
                    fn SlashNotPending(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <SlashNotPending as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::SlashNotPending)
                    }
                    SlashNotPending
                },
                {
                    fn InvalidQuoteSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidQuoteSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidQuoteSignature)
                    }
                    InvalidQuoteSignature
                },
                {
                    fn AggregationThresholdNotMet(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <AggregationThresholdNotMet as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::AggregationThresholdNotMet)
                    }
                    AggregationThresholdNotMet
                },
                {
                    fn NotServiceOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NotServiceOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NotServiceOwner)
                    }
                    NotServiceOwner
                },
                {
                    fn DeadlineExpired(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <DeadlineExpired as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::DeadlineExpired)
                    }
                    DeadlineExpired
                },
                {
                    fn NotSlashCanceller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NotSlashCanceller as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NotSlashCanceller)
                    }
                    NotSlashCanceller
                },
                {
                    fn ZeroAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ZeroAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ZeroAmount)
                    }
                    ZeroAmount
                },
                {
                    fn NotBlueprintOwner(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NotBlueprintOwner as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NotBlueprintOwner)
                    }
                    NotBlueprintOwner
                },
                {
                    fn ServiceRequestNotFound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ServiceRequestNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ServiceRequestNotFound)
                    }
                    ServiceRequestNotFound
                },
                {
                    fn DisputeWindowPassed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <DisputeWindowPassed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::DisputeWindowPassed)
                    }
                    DisputeWindowPassed
                },
                {
                    fn InsufficientEscrowBalance(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InsufficientEscrowBalance as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InsufficientEscrowBalance)
                    }
                    InsufficientEscrowBalance
                },
                {
                    fn ReentrancyGuardReentrantCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ReentrancyGuardReentrantCall)
                    }
                    ReentrancyGuardReentrantCall
                },
                {
                    fn NoQuotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NoQuotes as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NoQuotes)
                    }
                    NoQuotes
                },
                {
                    fn BlueprintNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <BlueprintNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::BlueprintNotActive)
                    }
                    BlueprintNotActive
                },
                {
                    fn InvalidPaymentSplit(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidPaymentSplit as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidPaymentSplit)
                    }
                    InvalidPaymentSplit
                },
                {
                    fn ServiceNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ServiceNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ServiceNotActive)
                    }
                    ServiceNotActive
                },
                {
                    fn ERC1967InvalidImplementation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ERC1967InvalidImplementation)
                    }
                    ERC1967InvalidImplementation
                },
                {
                    fn PairingFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <PairingFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::PairingFailed)
                    }
                    PairingFailed
                },
                {
                    fn AggregationNotRequired(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <AggregationNotRequired as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::AggregationNotRequired)
                    }
                    AggregationNotRequired
                },
                {
                    fn SafeERC20FailedOperation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::SafeERC20FailedOperation)
                    }
                    SafeERC20FailedOperation
                },
                {
                    fn SlashAlreadyExecuted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <SlashAlreadyExecuted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::SlashAlreadyExecuted)
                    }
                    SlashAlreadyExecuted
                },
                {
                    fn InvalidPaymentToken(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidPaymentToken as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidPaymentToken)
                    }
                    InvalidPaymentToken
                },
                {
                    fn InstantSlashNotEnabled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InstantSlashNotEnabled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InstantSlashNotEnabled)
                    }
                    InstantSlashNotEnabled
                },
                {
                    fn SlashNotFound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <SlashNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::SlashNotFound)
                    }
                    SlashNotFound
                },
                {
                    fn BlueprintNotFound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <BlueprintNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::BlueprintNotFound)
                    }
                    BlueprintNotFound
                },
                {
                    fn AccessControlBadConfirmation(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::AccessControlBadConfirmation)
                    }
                    AccessControlBadConfirmation
                },
                {
                    fn InvalidSecurityRequirement(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidSecurityRequirement as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidSecurityRequirement)
                    }
                    InvalidSecurityRequirement
                },
                {
                    fn CommitmentAboveMaximum(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <CommitmentAboveMaximum as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::CommitmentAboveMaximum)
                    }
                    CommitmentAboveMaximum
                },
                {
                    fn ManagerRejected(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ManagerRejected as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ManagerRejected)
                    }
                    ManagerRejected
                },
                {
                    fn SlashAlreadyCancelled(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <SlashAlreadyCancelled as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::SlashAlreadyCancelled)
                    }
                    SlashAlreadyCancelled
                },
                {
                    fn AggregationRequired(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <AggregationRequired as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::AggregationRequired)
                    }
                    AggregationRequired
                },
                {
                    fn OperatorNotInService(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <OperatorNotInService as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::OperatorNotInService)
                    }
                    OperatorNotInService
                },
                {
                    fn QuoteExpired(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <QuoteExpired as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::QuoteExpired)
                    }
                    QuoteExpired
                },
                {
                    fn ServiceExpired(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ServiceExpired as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ServiceExpired)
                    }
                    ServiceExpired
                },
                {
                    fn TooManyOperators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <TooManyOperators as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::TooManyOperators)
                    }
                    TooManyOperators
                },
                {
                    fn NoSecurityRequirements(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NoSecurityRequirements as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NoSecurityRequirements)
                    }
                    NoSecurityRequirements
                },
                {
                    fn Unauthorized(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <Unauthorized as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::Unauthorized)
                    }
                    Unauthorized
                },
                {
                    fn MissingAssetCommitment(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <MissingAssetCommitment as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::MissingAssetCommitment)
                    }
                    MissingAssetCommitment
                },
                {
                    fn ExpectedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ExpectedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ExpectedPause)
                    }
                    ExpectedPause
                },
                {
                    fn InsufficientStake(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InsufficientStake as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InsufficientStake)
                    }
                    InsufficientStake
                },
                {
                    fn TokenNotAllowed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <TokenNotAllowed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::TokenNotAllowed)
                    }
                    TokenNotAllowed
                },
                {
                    fn ServiceRequestAlreadyProcessed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ServiceRequestAlreadyProcessed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ServiceRequestAlreadyProcessed)
                    }
                    ServiceRequestAlreadyProcessed
                },
                {
                    fn CommitmentBelowMinimum(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <CommitmentBelowMinimum as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::CommitmentBelowMinimum)
                    }
                    CommitmentBelowMinimum
                },
                {
                    fn JobCallNotFound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <JobCallNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::JobCallNotFound)
                    }
                    JobCallNotFound
                },
                {
                    fn AddressEmptyCode(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <AddressEmptyCode as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::AddressEmptyCode)
                    }
                    AddressEmptyCode
                },
                {
                    fn InsufficientPaymentForQuotes(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InsufficientPaymentForQuotes as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InsufficientPaymentForQuotes)
                    }
                    InsufficientPaymentForQuotes
                },
                {
                    fn OperatorNotRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <OperatorNotRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::OperatorNotRegistered)
                    }
                    OperatorNotRegistered
                },
                {
                    fn OperatorAlreadyRegistered(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::OperatorAlreadyRegistered)
                    }
                    OperatorAlreadyRegistered
                },
                {
                    fn UUPSUnsupportedProxiableUUID(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::UUPSUnsupportedProxiableUUID)
                    }
                    UUPSUnsupportedProxiableUUID
                },
                {
                    fn InvalidBLSSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidBLSSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidBLSSignature)
                    }
                    InvalidBLSSignature
                },
                {
                    fn QuoteTTLMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <QuoteTTLMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::QuoteTTLMismatch)
                    }
                    QuoteTTLMismatch
                },
                {
                    fn QuoteBlueprintMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <QuoteBlueprintMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::QuoteBlueprintMismatch)
                    }
                    QuoteBlueprintMismatch
                },
                {
                    fn ERC1967NonPayable(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ERC1967NonPayable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ERC1967NonPayable)
                    }
                    ERC1967NonPayable
                },
                {
                    fn SlashNotExecutable(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <SlashNotExecutable as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::SlashNotExecutable)
                    }
                    SlashNotExecutable
                },
                {
                    fn ResultAlreadySubmitted(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ResultAlreadySubmitted as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ResultAlreadySubmitted)
                    }
                    ResultAlreadySubmitted
                },
                {
                    fn InsufficientPayment(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InsufficientPayment as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InsufficientPayment)
                    }
                    InsufficientPayment
                },
                {
                    fn InvalidState(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidState as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidState)
                    }
                    InvalidState
                },
                {
                    fn InvalidSlashAmount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidSlashAmount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidSlashAmount)
                    }
                    InvalidSlashAmount
                },
                {
                    fn ServiceNotFound(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ServiceNotFound as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ServiceNotFound)
                    }
                    ServiceNotFound
                },
                {
                    fn NotPermittedCaller(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NotPermittedCaller as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NotPermittedCaller)
                    }
                    NotPermittedCaller
                },
                {
                    fn FailedCall(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <FailedCall as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::FailedCall)
                    }
                    FailedCall
                },
                {
                    fn ECDSAInvalidSignatureS(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ECDSAInvalidSignatureS)
                    }
                    ECDSAInvalidSignatureS
                },
                {
                    fn NotInitializing(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NotInitializing as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NotInitializing)
                    }
                    NotInitializing
                },
                {
                    fn InvalidSlashConfig(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidSlashConfig as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidSlashConfig)
                    }
                    InvalidSlashConfig
                },
                {
                    fn ZeroAddress(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ZeroAddress as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ZeroAddress)
                    }
                    ZeroAddress
                },
                {
                    fn EnforcedPause(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <EnforcedPause as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::EnforcedPause)
                    }
                    EnforcedPause
                },
                {
                    fn HashToPointFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <HashToPointFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::HashToPointFailed)
                    }
                    HashToPointFailed
                },
                {
                    fn NotSlashDisputer(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NotSlashDisputer as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NotSlashDisputer)
                    }
                    NotSlashDisputer
                },
                {
                    fn NoOperators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <NoOperators as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::NoOperators)
                    }
                    NoOperators
                },
                {
                    fn UUPSUnauthorizedCallContext(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::UUPSUnauthorizedCallContext)
                    }
                    UUPSUnauthorizedCallContext
                },
                {
                    fn AccessControlUnauthorizedAccount(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::AccessControlUnauthorizedAccount)
                    }
                    AccessControlUnauthorizedAccount
                },
                {
                    fn OperatorNotActive(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <OperatorNotActive as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::OperatorNotActive)
                    }
                    OperatorNotActive
                },
                {
                    fn InsufficientOperators(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InsufficientOperators as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InsufficientOperators)
                    }
                    InsufficientOperators
                },
                {
                    fn AlreadyApproved(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <AlreadyApproved as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::AlreadyApproved)
                    }
                    AlreadyApproved
                },
                {
                    fn PaymentFailed(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <PaymentFailed as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::PaymentFailed)
                    }
                    PaymentFailed
                },
                {
                    fn ECDSAInvalidSignature(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ECDSAInvalidSignature)
                    }
                    ECDSAInvalidSignature
                },
                {
                    fn InvalidInitialization(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <InvalidInitialization as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::InvalidInitialization)
                    }
                    InvalidInitialization
                },
                {
                    fn ECDSAInvalidSignatureLength(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::ECDSAInvalidSignatureLength)
                    }
                    ECDSAInvalidSignatureLength
                },
                {
                    fn LengthMismatch(
                        data: &[u8],
                        validate: bool,
                    ) -> alloy_sol_types::Result<TangleErrors> {
                        <LengthMismatch as alloy_sol_types::SolError>::abi_decode_raw(
                                data,
                                validate,
                            )
                            .map(TangleErrors::LengthMismatch)
                    }
                    LengthMismatch
                },
            ];
            let Ok(idx) = Self::SELECTORS.binary_search(&selector) else {
                return Err(
                    alloy_sol_types::Error::unknown_selector(
                        <Self as alloy_sol_types::SolInterface>::NAME,
                        selector,
                    ),
                );
            };
            DECODE_SHIMS[idx](data, validate)
        }
        #[inline]
        fn abi_encoded_size(&self) -> usize {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AggregationNotRequired(inner) => {
                    <AggregationNotRequired as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AggregationRequired(inner) => {
                    <AggregationRequired as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AggregationThresholdNotMet(inner) => {
                    <AggregationThresholdNotMet as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::AlreadyApproved(inner) => {
                    <AlreadyApproved as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BlueprintNotActive(inner) => {
                    <BlueprintNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::BlueprintNotFound(inner) => {
                    <BlueprintNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CommitmentAboveMaximum(inner) => {
                    <CommitmentAboveMaximum as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::CommitmentBelowMinimum(inner) => {
                    <CommitmentBelowMinimum as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DeadlineExpired(inner) => {
                    <DeadlineExpired as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DisputeWindowPassed(inner) => {
                    <DisputeWindowPassed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::DuplicateOperatorQuote(inner) => {
                    <DuplicateOperatorQuote as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::HashToPointFailed(inner) => {
                    <HashToPointFailed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InstantSlashNotEnabled(inner) => {
                    <InstantSlashNotEnabled as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientEscrowBalance(inner) => {
                    <InsufficientEscrowBalance as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientOperators(inner) => {
                    <InsufficientOperators as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientPayment(inner) => {
                    <InsufficientPayment as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientPaymentForQuotes(inner) => {
                    <InsufficientPaymentForQuotes as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidBLSSignature(inner) => {
                    <InvalidBLSSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidPaymentSplit(inner) => {
                    <InvalidPaymentSplit as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidPaymentToken(inner) => {
                    <InvalidPaymentToken as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidQuoteSignature(inner) => {
                    <InvalidQuoteSignature as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSecurityRequirement(inner) => {
                    <InvalidSecurityRequirement as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSlashAmount(inner) => {
                    <InvalidSlashAmount as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidSlashConfig(inner) => {
                    <InvalidSlashConfig as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::InvalidState(inner) => {
                    <InvalidState as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::JobAlreadyCompleted(inner) => {
                    <JobAlreadyCompleted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::JobCallNotFound(inner) => {
                    <JobCallNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::LengthMismatch(inner) => {
                    <LengthMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ManagerRejected(inner) => {
                    <ManagerRejected as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ManagerReverted(inner) => {
                    <ManagerReverted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::MissingAssetCommitment(inner) => {
                    <MissingAssetCommitment as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NoOperators(inner) => {
                    <NoOperators as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NoQuotes(inner) => {
                    <NoQuotes as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::NoSecurityRequirements(inner) => {
                    <NoSecurityRequirements as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotBlueprintOwner(inner) => {
                    <NotBlueprintOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotPermittedCaller(inner) => {
                    <NotPermittedCaller as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotServiceOwner(inner) => {
                    <NotServiceOwner as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotSlashCanceller(inner) => {
                    <NotSlashCanceller as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::NotSlashDisputer(inner) => {
                    <NotSlashDisputer as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorAlreadyRegistered(inner) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorNotActive(inner) => {
                    <OperatorNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorNotInService(inner) => {
                    <OperatorNotInService as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::OperatorNotRegistered(inner) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::PairingFailed(inner) => {
                    <PairingFailed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::PaymentFailed(inner) => {
                    <PaymentFailed as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::QuoteAlreadyUsed(inner) => {
                    <QuoteAlreadyUsed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::QuoteBlueprintMismatch(inner) => {
                    <QuoteBlueprintMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::QuoteExpired(inner) => {
                    <QuoteExpired as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::QuoteTTLMismatch(inner) => {
                    <QuoteTTLMismatch as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ResultAlreadySubmitted(inner) => {
                    <ResultAlreadySubmitted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ServiceExpired(inner) => {
                    <ServiceExpired as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ServiceNotActive(inner) => {
                    <ServiceNotActive as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ServiceNotFound(inner) => {
                    <ServiceNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ServiceRequestAlreadyProcessed(inner) => {
                    <ServiceRequestAlreadyProcessed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::ServiceRequestNotFound(inner) => {
                    <ServiceRequestNotFound as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SlashAlreadyCancelled(inner) => {
                    <SlashAlreadyCancelled as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SlashAlreadyExecuted(inner) => {
                    <SlashAlreadyExecuted as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SlashNotExecutable(inner) => {
                    <SlashNotExecutable as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::SlashNotFound(inner) => {
                    <SlashNotFound as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::SlashNotPending(inner) => {
                    <SlashNotPending as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TokenNotAllowed(inner) => {
                    <TokenNotAllowed as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::TooManyOperators(inner) => {
                    <TooManyOperators as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encoded_size(
                        inner,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encoded_size(inner)
                }
            }
        }
        #[inline]
        fn abi_encode_raw(&self, out: &mut alloy_sol_types::private::Vec<u8>) {
            match self {
                Self::AccessControlBadConfirmation(inner) => {
                    <AccessControlBadConfirmation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AccessControlUnauthorizedAccount(inner) => {
                    <AccessControlUnauthorizedAccount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AddressEmptyCode(inner) => {
                    <AddressEmptyCode as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AggregationNotRequired(inner) => {
                    <AggregationNotRequired as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AggregationRequired(inner) => {
                    <AggregationRequired as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AggregationThresholdNotMet(inner) => {
                    <AggregationThresholdNotMet as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::AlreadyApproved(inner) => {
                    <AlreadyApproved as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BlueprintNotActive(inner) => {
                    <BlueprintNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::BlueprintNotFound(inner) => {
                    <BlueprintNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CommitmentAboveMaximum(inner) => {
                    <CommitmentAboveMaximum as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::CommitmentBelowMinimum(inner) => {
                    <CommitmentBelowMinimum as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DeadlineExpired(inner) => {
                    <DeadlineExpired as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DisputeWindowPassed(inner) => {
                    <DisputeWindowPassed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::DuplicateOperatorQuote(inner) => {
                    <DuplicateOperatorQuote as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignature(inner) => {
                    <ECDSAInvalidSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureLength(inner) => {
                    <ECDSAInvalidSignatureLength as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ECDSAInvalidSignatureS(inner) => {
                    <ECDSAInvalidSignatureS as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967InvalidImplementation(inner) => {
                    <ERC1967InvalidImplementation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ERC1967NonPayable(inner) => {
                    <ERC1967NonPayable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::EnforcedPause(inner) => {
                    <EnforcedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ExpectedPause(inner) => {
                    <ExpectedPause as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::FailedCall(inner) => {
                    <FailedCall as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::HashToPointFailed(inner) => {
                    <HashToPointFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InstantSlashNotEnabled(inner) => {
                    <InstantSlashNotEnabled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientEscrowBalance(inner) => {
                    <InsufficientEscrowBalance as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientOperators(inner) => {
                    <InsufficientOperators as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientPayment(inner) => {
                    <InsufficientPayment as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientPaymentForQuotes(inner) => {
                    <InsufficientPaymentForQuotes as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InsufficientStake(inner) => {
                    <InsufficientStake as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidBLSSignature(inner) => {
                    <InvalidBLSSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidInitialization(inner) => {
                    <InvalidInitialization as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidPaymentSplit(inner) => {
                    <InvalidPaymentSplit as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidPaymentToken(inner) => {
                    <InvalidPaymentToken as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidQuoteSignature(inner) => {
                    <InvalidQuoteSignature as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSecurityRequirement(inner) => {
                    <InvalidSecurityRequirement as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSlashAmount(inner) => {
                    <InvalidSlashAmount as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidSlashConfig(inner) => {
                    <InvalidSlashConfig as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::InvalidState(inner) => {
                    <InvalidState as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::JobAlreadyCompleted(inner) => {
                    <JobAlreadyCompleted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::JobCallNotFound(inner) => {
                    <JobCallNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::LengthMismatch(inner) => {
                    <LengthMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ManagerRejected(inner) => {
                    <ManagerRejected as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ManagerReverted(inner) => {
                    <ManagerReverted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::MissingAssetCommitment(inner) => {
                    <MissingAssetCommitment as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoOperators(inner) => {
                    <NoOperators as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NoQuotes(inner) => {
                    <NoQuotes as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
                Self::NoSecurityRequirements(inner) => {
                    <NoSecurityRequirements as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotBlueprintOwner(inner) => {
                    <NotBlueprintOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotInitializing(inner) => {
                    <NotInitializing as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotPermittedCaller(inner) => {
                    <NotPermittedCaller as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotServiceOwner(inner) => {
                    <NotServiceOwner as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotSlashCanceller(inner) => {
                    <NotSlashCanceller as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::NotSlashDisputer(inner) => {
                    <NotSlashDisputer as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OperatorAlreadyRegistered(inner) => {
                    <OperatorAlreadyRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OperatorNotActive(inner) => {
                    <OperatorNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OperatorNotInService(inner) => {
                    <OperatorNotInService as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::OperatorNotRegistered(inner) => {
                    <OperatorNotRegistered as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PairingFailed(inner) => {
                    <PairingFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::PaymentFailed(inner) => {
                    <PaymentFailed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::QuoteAlreadyUsed(inner) => {
                    <QuoteAlreadyUsed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::QuoteBlueprintMismatch(inner) => {
                    <QuoteBlueprintMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::QuoteExpired(inner) => {
                    <QuoteExpired as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::QuoteTTLMismatch(inner) => {
                    <QuoteTTLMismatch as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ReentrancyGuardReentrantCall(inner) => {
                    <ReentrancyGuardReentrantCall as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ResultAlreadySubmitted(inner) => {
                    <ResultAlreadySubmitted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SafeERC20FailedOperation(inner) => {
                    <SafeERC20FailedOperation as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ServiceExpired(inner) => {
                    <ServiceExpired as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ServiceNotActive(inner) => {
                    <ServiceNotActive as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ServiceNotFound(inner) => {
                    <ServiceNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ServiceRequestAlreadyProcessed(inner) => {
                    <ServiceRequestAlreadyProcessed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ServiceRequestNotFound(inner) => {
                    <ServiceRequestNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SlashAlreadyCancelled(inner) => {
                    <SlashAlreadyCancelled as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SlashAlreadyExecuted(inner) => {
                    <SlashAlreadyExecuted as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SlashNotExecutable(inner) => {
                    <SlashNotExecutable as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SlashNotFound(inner) => {
                    <SlashNotFound as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::SlashNotPending(inner) => {
                    <SlashNotPending as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TokenNotAllowed(inner) => {
                    <TokenNotAllowed as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::TooManyOperators(inner) => {
                    <TooManyOperators as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnauthorizedCallContext(inner) => {
                    <UUPSUnauthorizedCallContext as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::UUPSUnsupportedProxiableUUID(inner) => {
                    <UUPSUnsupportedProxiableUUID as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::Unauthorized(inner) => {
                    <Unauthorized as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAddress(inner) => {
                    <ZeroAddress as alloy_sol_types::SolError>::abi_encode_raw(
                        inner,
                        out,
                    )
                }
                Self::ZeroAmount(inner) => {
                    <ZeroAmount as alloy_sol_types::SolError>::abi_encode_raw(inner, out)
                }
            }
        }
    }
    ///Container for all the [`Tangle`](self) events.
    pub enum TangleEvents {
        #[allow(missing_docs)]
        AggregatedResultSubmitted(AggregatedResultSubmitted),
        #[allow(missing_docs)]
        BlueprintCreated(BlueprintCreated),
        #[allow(missing_docs)]
        BlueprintDeactivated(BlueprintDeactivated),
        #[allow(missing_docs)]
        BlueprintTransferred(BlueprintTransferred),
        #[allow(missing_docs)]
        BlueprintUpdated(BlueprintUpdated),
        #[allow(missing_docs)]
        EscrowFunded(EscrowFunded),
        #[allow(missing_docs)]
        Initialized(Initialized),
        #[allow(missing_docs)]
        JobCompleted(JobCompleted),
        #[allow(missing_docs)]
        JobResultSubmitted(JobResultSubmitted),
        #[allow(missing_docs)]
        JobSubmitted(JobSubmitted),
        #[allow(missing_docs)]
        OperatorJoinedService(OperatorJoinedService),
        #[allow(missing_docs)]
        OperatorLeftService(OperatorLeftService),
        #[allow(missing_docs)]
        OperatorPreRegistered(OperatorPreRegistered),
        #[allow(missing_docs)]
        OperatorPreferencesUpdated(OperatorPreferencesUpdated),
        #[allow(missing_docs)]
        OperatorRegistered(OperatorRegistered),
        #[allow(missing_docs)]
        OperatorRpcAddressUpdated(OperatorRpcAddressUpdated),
        #[allow(missing_docs)]
        OperatorUnregistered(OperatorUnregistered),
        #[allow(missing_docs)]
        Paused(Paused),
        #[allow(missing_docs)]
        QuoteUsed(QuoteUsed),
        #[allow(missing_docs)]
        RewardsClaimed(RewardsClaimed),
        #[allow(missing_docs)]
        RoleAdminChanged(RoleAdminChanged),
        #[allow(missing_docs)]
        RoleGranted(RoleGranted),
        #[allow(missing_docs)]
        RoleRevoked(RoleRevoked),
        #[allow(missing_docs)]
        ServiceActivated(ServiceActivated),
        #[allow(missing_docs)]
        ServiceApproved(ServiceApproved),
        #[allow(missing_docs)]
        ServiceRejected(ServiceRejected),
        #[allow(missing_docs)]
        ServiceRequested(ServiceRequested),
        #[allow(missing_docs)]
        ServiceRequestedWithSecurity(ServiceRequestedWithSecurity),
        #[allow(missing_docs)]
        ServiceTerminated(ServiceTerminated),
        #[allow(missing_docs)]
        SlashCancelled(SlashCancelled),
        #[allow(missing_docs)]
        SlashConfigUpdated(SlashConfigUpdated),
        #[allow(missing_docs)]
        SlashDisputed(SlashDisputed),
        #[allow(missing_docs)]
        SlashExecuted(SlashExecuted),
        #[allow(missing_docs)]
        SlashProposed(SlashProposed),
        #[allow(missing_docs)]
        SubscriptionBilled(SubscriptionBilled),
        #[allow(missing_docs)]
        Unpaused(Unpaused),
        #[allow(missing_docs)]
        Upgraded(Upgraded),
    }
    #[automatically_derived]
    impl TangleEvents {
        /// All the selectors of this enum.
        ///
        /// Note that the selectors might not be in the same order as the variants.
        /// No guarantees are made about the order of the selectors.
        ///
        /// Prefer using `SolInterface` methods instead.
        pub const SELECTORS: &'static [[u8; 32usize]] = &[
            [
                13u8,
                68u8,
                24u8,
                204u8,
                7u8,
                177u8,
                200u8,
                31u8,
                86u8,
                226u8,
                209u8,
                39u8,
                127u8,
                93u8,
                17u8,
                193u8,
                178u8,
                126u8,
                186u8,
                198u8,
                205u8,
                172u8,
                175u8,
                204u8,
                236u8,
                212u8,
                173u8,
                214u8,
                116u8,
                43u8,
                75u8,
                15u8,
            ],
            [
                36u8,
                87u8,
                145u8,
                135u8,
                150u8,
                7u8,
                132u8,
                64u8,
                6u8,
                131u8,
                133u8,
                231u8,
                62u8,
                66u8,
                37u8,
                57u8,
                200u8,
                79u8,
                47u8,
                144u8,
                69u8,
                221u8,
                68u8,
                46u8,
                18u8,
                61u8,
                66u8,
                132u8,
                37u8,
                138u8,
                226u8,
                74u8,
            ],
            [
                36u8,
                220u8,
                72u8,
                91u8,
                239u8,
                4u8,
                180u8,
                215u8,
                144u8,
                217u8,
                122u8,
                193u8,
                3u8,
                129u8,
                216u8,
                217u8,
                230u8,
                108u8,
                86u8,
                221u8,
                111u8,
                186u8,
                153u8,
                49u8,
                183u8,
                3u8,
                202u8,
                22u8,
                149u8,
                17u8,
                119u8,
                138u8,
            ],
            [
                41u8,
                97u8,
                91u8,
                69u8,
                127u8,
                34u8,
                225u8,
                99u8,
                204u8,
                69u8,
                64u8,
                50u8,
                125u8,
                112u8,
                243u8,
                92u8,
                25u8,
                144u8,
                168u8,
                239u8,
                0u8,
                3u8,
                233u8,
                21u8,
                173u8,
                23u8,
                10u8,
                203u8,
                129u8,
                122u8,
                206u8,
                61u8,
            ],
            [
                43u8,
                15u8,
                106u8,
                123u8,
                31u8,
                90u8,
                253u8,
                120u8,
                50u8,
                228u8,
                153u8,
                114u8,
                244u8,
                11u8,
                159u8,
                205u8,
                22u8,
                153u8,
                137u8,
                48u8,
                178u8,
                79u8,
                54u8,
                70u8,
                156u8,
                145u8,
                0u8,
                53u8,
                2u8,
                208u8,
                217u8,
                152u8,
            ],
            [
                45u8,
                14u8,
                140u8,
                117u8,
                204u8,
                252u8,
                96u8,
                100u8,
                99u8,
                189u8,
                95u8,
                117u8,
                86u8,
                204u8,
                243u8,
                88u8,
                177u8,
                196u8,
                9u8,
                236u8,
                96u8,
                89u8,
                206u8,
                230u8,
                229u8,
                25u8,
                53u8,
                162u8,
                155u8,
                208u8,
                253u8,
                193u8,
            ],
            [
                47u8,
                135u8,
                136u8,
                17u8,
                126u8,
                126u8,
                255u8,
                29u8,
                130u8,
                233u8,
                38u8,
                236u8,
                121u8,
                73u8,
                1u8,
                209u8,
                124u8,
                120u8,
                2u8,
                74u8,
                80u8,
                39u8,
                9u8,
                64u8,
                48u8,
                69u8,
                64u8,
                167u8,
                51u8,
                101u8,
                111u8,
                13u8,
            ],
            [
                48u8,
                252u8,
                69u8,
                224u8,
                90u8,
                51u8,
                253u8,
                144u8,
                104u8,
                207u8,
                106u8,
                225u8,
                168u8,
                243u8,
                219u8,
                43u8,
                157u8,
                21u8,
                55u8,
                45u8,
                214u8,
                73u8,
                78u8,
                204u8,
                200u8,
                205u8,
                93u8,
                48u8,
                95u8,
                223u8,
                56u8,
                179u8,
            ],
            [
                51u8,
                224u8,
                65u8,
                20u8,
                49u8,
                0u8,
                90u8,
                6u8,
                52u8,
                112u8,
                181u8,
                84u8,
                9u8,
                78u8,
                98u8,
                246u8,
                151u8,
                58u8,
                163u8,
                95u8,
                206u8,
                35u8,
                14u8,
                175u8,
                93u8,
                90u8,
                0u8,
                121u8,
                190u8,
                78u8,
                51u8,
                156u8,
            ],
            [
                63u8,
                213u8,
                88u8,
                165u8,
                155u8,
                188u8,
                225u8,
                217u8,
                150u8,
                209u8,
                126u8,
                171u8,
                127u8,
                222u8,
                49u8,
                75u8,
                205u8,
                32u8,
                30u8,
                195u8,
                241u8,
                115u8,
                117u8,
                167u8,
                248u8,
                115u8,
                179u8,
                22u8,
                41u8,
                39u8,
                232u8,
                129u8,
            ],
            [
                74u8,
                129u8,
                110u8,
                19u8,
                39u8,
                18u8,
                219u8,
                223u8,
                230u8,
                163u8,
                99u8,
                150u8,
                94u8,
                91u8,
                198u8,
                143u8,
                142u8,
                40u8,
                59u8,
                153u8,
                154u8,
                225u8,
                26u8,
                254u8,
                41u8,
                74u8,
                49u8,
                98u8,
                151u8,
                60u8,
                56u8,
                85u8,
            ],
            [
                93u8,
                185u8,
                238u8,
                10u8,
                73u8,
                91u8,
                242u8,
                230u8,
                255u8,
                156u8,
                145u8,
                167u8,
                131u8,
                76u8,
                27u8,
                164u8,
                253u8,
                210u8,
                68u8,
                165u8,
                232u8,
                170u8,
                78u8,
                83u8,
                123u8,
                211u8,
                138u8,
                234u8,
                228u8,
                176u8,
                115u8,
                170u8,
            ],
            [
                96u8,
                167u8,
                100u8,
                159u8,
                110u8,
                147u8,
                231u8,
                163u8,
                206u8,
                29u8,
                201u8,
                114u8,
                156u8,
                32u8,
                227u8,
                217u8,
                93u8,
                206u8,
                40u8,
                198u8,
                166u8,
                189u8,
                149u8,
                124u8,
                222u8,
                9u8,
                216u8,
                161u8,
                203u8,
                55u8,
                193u8,
                159u8,
            ],
            [
                98u8,
                231u8,
                140u8,
                234u8,
                1u8,
                190u8,
                227u8,
                32u8,
                205u8,
                78u8,
                66u8,
                2u8,
                112u8,
                181u8,
                234u8,
                116u8,
                0u8,
                13u8,
                17u8,
                176u8,
                201u8,
                247u8,
                71u8,
                84u8,
                235u8,
                219u8,
                252u8,
                84u8,
                75u8,
                5u8,
                162u8,
                88u8,
            ],
            [
                116u8,
                30u8,
                151u8,
                238u8,
                31u8,
                248u8,
                135u8,
                196u8,
                216u8,
                130u8,
                244u8,
                196u8,
                154u8,
                210u8,
                128u8,
                234u8,
                125u8,
                97u8,
                208u8,
                53u8,
                228u8,
                232u8,
                164u8,
                113u8,
                229u8,
                49u8,
                149u8,
                21u8,
                80u8,
                39u8,
                80u8,
                35u8,
            ],
            [
                133u8,
                71u8,
                233u8,
                75u8,
                217u8,
                92u8,
                167u8,
                211u8,
                199u8,
                163u8,
                190u8,
                155u8,
                102u8,
                162u8,
                158u8,
                111u8,
                54u8,
                21u8,
                27u8,
                229u8,
                74u8,
                37u8,
                99u8,
                227u8,
                80u8,
                152u8,
                67u8,
                136u8,
                97u8,
                164u8,
                200u8,
                113u8,
            ],
            [
                136u8,
                228u8,
                110u8,
                149u8,
                188u8,
                223u8,
                16u8,
                32u8,
                192u8,
                202u8,
                249u8,
                243u8,
                221u8,
                95u8,
                222u8,
                105u8,
                196u8,
                29u8,
                33u8,
                81u8,
                219u8,
                188u8,
                160u8,
                167u8,
                124u8,
                3u8,
                196u8,
                226u8,
                139u8,
                77u8,
                62u8,
                193u8,
            ],
            [
                137u8,
                169u8,
                252u8,
                245u8,
                47u8,
                205u8,
                196u8,
                143u8,
                14u8,
                102u8,
                159u8,
                179u8,
                183u8,
                18u8,
                82u8,
                145u8,
                218u8,
                133u8,
                1u8,
                50u8,
                89u8,
                47u8,
                93u8,
                213u8,
                128u8,
                255u8,
                181u8,
                129u8,
                102u8,
                200u8,
                233u8,
                232u8,
            ],
            [
                138u8,
                4u8,
                249u8,
                159u8,
                226u8,
                50u8,
                132u8,
                232u8,
                116u8,
                232u8,
                221u8,
                1u8,
                115u8,
                69u8,
                36u8,
                130u8,
                121u8,
                204u8,
                89u8,
                112u8,
                22u8,
                149u8,
                231u8,
                59u8,
                205u8,
                190u8,
                182u8,
                36u8,
                27u8,
                205u8,
                42u8,
                198u8,
            ],
            [
                140u8,
                229u8,
                62u8,
                75u8,
                96u8,
                2u8,
                255u8,
                9u8,
                14u8,
                100u8,
                29u8,
                222u8,
                205u8,
                175u8,
                126u8,
                221u8,
                40u8,
                19u8,
                169u8,
                142u8,
                25u8,
                19u8,
                159u8,
                167u8,
                209u8,
                199u8,
                159u8,
                204u8,
                195u8,
                196u8,
                222u8,
                173u8,
            ],
            [
                147u8,
                16u8,
                204u8,
                252u8,
                184u8,
                222u8,
                114u8,
                63u8,
                87u8,
                138u8,
                158u8,
                66u8,
                130u8,
                234u8,
                159u8,
                82u8,
                31u8,
                5u8,
                174u8,
                64u8,
                220u8,
                8u8,
                243u8,
                6u8,
                141u8,
                250u8,
                213u8,
                40u8,
                166u8,
                94u8,
                227u8,
                199u8,
            ],
            [
                169u8,
                207u8,
                153u8,
                196u8,
                199u8,
                91u8,
                240u8,
                135u8,
                69u8,
                118u8,
                230u8,
                238u8,
                112u8,
                176u8,
                11u8,
                146u8,
                14u8,
                156u8,
                54u8,
                85u8,
                30u8,
                77u8,
                108u8,
                23u8,
                105u8,
                78u8,
                202u8,
                166u8,
                132u8,
                98u8,
                77u8,
                43u8,
            ],
            [
                188u8,
                124u8,
                215u8,
                90u8,
                32u8,
                238u8,
                39u8,
                253u8,
                154u8,
                222u8,
                186u8,
                179u8,
                32u8,
                65u8,
                247u8,
                85u8,
                33u8,
                77u8,
                188u8,
                107u8,
                255u8,
                169u8,
                12u8,
                192u8,
                34u8,
                91u8,
                57u8,
                218u8,
                46u8,
                92u8,
                45u8,
                59u8,
            ],
            [
                189u8,
                31u8,
                221u8,
                163u8,
                147u8,
                182u8,
                121u8,
                230u8,
                196u8,
                248u8,
                115u8,
                226u8,
                51u8,
                179u8,
                78u8,
                44u8,
                78u8,
                168u8,
                40u8,
                58u8,
                63u8,
                118u8,
                52u8,
                93u8,
                188u8,
                20u8,
                59u8,
                134u8,
                234u8,
                4u8,
                118u8,
                121u8,
            ],
            [
                189u8,
                121u8,
                184u8,
                111u8,
                254u8,
                10u8,
                184u8,
                232u8,
                119u8,
                97u8,
                81u8,
                81u8,
                66u8,
                23u8,
                205u8,
                124u8,
                172u8,
                213u8,
                44u8,
                144u8,
                159u8,
                102u8,
                71u8,
                92u8,
                58u8,
                244u8,
                78u8,
                18u8,
                159u8,
                11u8,
                0u8,
                255u8,
            ],
            [
                198u8,
                48u8,
                80u8,
                185u8,
                99u8,
                236u8,
                110u8,
                44u8,
                243u8,
                109u8,
                249u8,
                14u8,
                202u8,
                202u8,
                164u8,
                50u8,
                18u8,
                192u8,
                231u8,
                75u8,
                140u8,
                58u8,
                88u8,
                160u8,
                248u8,
                204u8,
                227u8,
                189u8,
                90u8,
                42u8,
                118u8,
                117u8,
            ],
            [
                199u8,
                245u8,
                5u8,
                178u8,
                243u8,
                113u8,
                174u8,
                33u8,
                117u8,
                238u8,
                73u8,
                19u8,
                244u8,
                73u8,
                158u8,
                31u8,
                38u8,
                51u8,
                167u8,
                181u8,
                147u8,
                99u8,
                33u8,
                238u8,
                209u8,
                205u8,
                174u8,
                182u8,
                17u8,
                81u8,
                129u8,
                210u8,
            ],
            [
                206u8,
                218u8,
                26u8,
                68u8,
                234u8,
                212u8,
                218u8,
                61u8,
                58u8,
                186u8,
                170u8,
                148u8,
                26u8,
                250u8,
                109u8,
                149u8,
                48u8,
                253u8,
                132u8,
                221u8,
                142u8,
                153u8,
                56u8,
                92u8,
                145u8,
                131u8,
                217u8,
                134u8,
                220u8,
                171u8,
                152u8,
                15u8,
            ],
            [
                210u8,
                141u8,
                231u8,
                197u8,
                24u8,
                195u8,
                18u8,
                250u8,
                56u8,
                142u8,
                3u8,
                248u8,
                209u8,
                32u8,
                61u8,
                143u8,
                76u8,
                117u8,
                22u8,
                30u8,
                53u8,
                143u8,
                251u8,
                8u8,
                39u8,
                182u8,
                202u8,
                162u8,
                233u8,
                172u8,
                138u8,
                49u8,
            ],
            [
                210u8,
                185u8,
                88u8,
                161u8,
                176u8,
                185u8,
                120u8,
                206u8,
                222u8,
                212u8,
                152u8,
                107u8,
                79u8,
                73u8,
                200u8,
                178u8,
                95u8,
                189u8,
                110u8,
                129u8,
                44u8,
                184u8,
                146u8,
                94u8,
                19u8,
                239u8,
                199u8,
                49u8,
                234u8,
                74u8,
                162u8,
                77u8,
            ],
            [
                211u8,
                159u8,
                247u8,
                90u8,
                21u8,
                195u8,
                26u8,
                39u8,
                40u8,
                145u8,
                197u8,
                46u8,
                66u8,
                153u8,
                90u8,
                207u8,
                162u8,
                116u8,
                89u8,
                186u8,
                28u8,
                18u8,
                35u8,
                156u8,
                186u8,
                194u8,
                60u8,
                219u8,
                118u8,
                245u8,
                48u8,
                132u8,
            ],
            [
                222u8,
                55u8,
                204u8,
                72u8,
                210u8,
                23u8,
                120u8,
                225u8,
                201u8,
                160u8,
                117u8,
                196u8,
                228u8,
                28u8,
                90u8,
                255u8,
                105u8,
                24u8,
                195u8,
                234u8,
                97u8,
                81u8,
                34u8,
                31u8,
                10u8,
                243u8,
                206u8,
                129u8,
                33u8,
                162u8,
                157u8,
                181u8,
            ],
            [
                225u8,
                66u8,
                134u8,
                243u8,
                173u8,
                73u8,
                173u8,
                166u8,
                208u8,
                145u8,
                26u8,
                221u8,
                168u8,
                239u8,
                144u8,
                97u8,
                105u8,
                153u8,
                4u8,
                91u8,
                222u8,
                42u8,
                51u8,
                227u8,
                145u8,
                167u8,
                181u8,
                174u8,
                101u8,
                137u8,
                231u8,
                137u8,
            ],
            [
                230u8,
                252u8,
                179u8,
                52u8,
                42u8,
                190u8,
                67u8,
                194u8,
                26u8,
                204u8,
                106u8,
                4u8,
                227u8,
                215u8,
                145u8,
                36u8,
                118u8,
                131u8,
                105u8,
                118u8,
                224u8,
                126u8,
                212u8,
                125u8,
                11u8,
                21u8,
                163u8,
                116u8,
                226u8,
                0u8,
                226u8,
                240u8,
            ],
            [
                232u8,
                13u8,
                26u8,
                24u8,
                58u8,
                243u8,
                9u8,
                22u8,
                247u8,
                155u8,
                21u8,
                166u8,
                200u8,
                94u8,
                130u8,
                71u8,
                13u8,
                11u8,
                136u8,
                6u8,
                93u8,
                253u8,
                210u8,
                80u8,
                93u8,
                16u8,
                106u8,
                223u8,
                14u8,
                139u8,
                119u8,
                150u8,
            ],
            [
                233u8,
                185u8,
                217u8,
                65u8,
                211u8,
                23u8,
                98u8,
                235u8,
                235u8,
                122u8,
                0u8,
                0u8,
                139u8,
                76u8,
                249u8,
                94u8,
                154u8,
                25u8,
                37u8,
                92u8,
                182u8,
                105u8,
                92u8,
                157u8,
                53u8,
                33u8,
                92u8,
                145u8,
                74u8,
                126u8,
                132u8,
                134u8,
            ],
            [
                246u8,
                57u8,
                31u8,
                92u8,
                50u8,
                217u8,
                198u8,
                157u8,
                42u8,
                71u8,
                234u8,
                103u8,
                11u8,
                68u8,
                41u8,
                116u8,
                181u8,
                57u8,
                53u8,
                209u8,
                237u8,
                199u8,
                253u8,
                100u8,
                235u8,
                33u8,
                224u8,
                71u8,
                168u8,
                57u8,
                23u8,
                27u8,
            ],
        ];
    }
    #[automatically_derived]
    impl alloy_sol_types::SolEventInterface for TangleEvents {
        const NAME: &'static str = "TangleEvents";
        const COUNT: usize = 37usize;
        fn decode_raw_log(
            topics: &[alloy_sol_types::Word],
            data: &[u8],
            validate: bool,
        ) -> alloy_sol_types::Result<Self> {
            match topics.first().copied() {
                Some(
                    <AggregatedResultSubmitted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <AggregatedResultSubmitted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::AggregatedResultSubmitted)
                }
                Some(<BlueprintCreated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BlueprintCreated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BlueprintCreated)
                }
                Some(
                    <BlueprintDeactivated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlueprintDeactivated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BlueprintDeactivated)
                }
                Some(
                    <BlueprintTransferred as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <BlueprintTransferred as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BlueprintTransferred)
                }
                Some(<BlueprintUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <BlueprintUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::BlueprintUpdated)
                }
                Some(<EscrowFunded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <EscrowFunded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::EscrowFunded)
                }
                Some(<Initialized as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Initialized as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Initialized)
                }
                Some(<JobCompleted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <JobCompleted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::JobCompleted)
                }
                Some(
                    <JobResultSubmitted as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <JobResultSubmitted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::JobResultSubmitted)
                }
                Some(<JobSubmitted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <JobSubmitted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::JobSubmitted)
                }
                Some(
                    <OperatorJoinedService as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorJoinedService as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorJoinedService)
                }
                Some(
                    <OperatorLeftService as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorLeftService as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorLeftService)
                }
                Some(
                    <OperatorPreRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorPreRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorPreRegistered)
                }
                Some(
                    <OperatorPreferencesUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorPreferencesUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorPreferencesUpdated)
                }
                Some(
                    <OperatorRegistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorRegistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorRegistered)
                }
                Some(
                    <OperatorRpcAddressUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorRpcAddressUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorRpcAddressUpdated)
                }
                Some(
                    <OperatorUnregistered as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <OperatorUnregistered as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::OperatorUnregistered)
                }
                Some(<Paused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Paused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Paused)
                }
                Some(<QuoteUsed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <QuoteUsed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::QuoteUsed)
                }
                Some(<RewardsClaimed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RewardsClaimed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RewardsClaimed)
                }
                Some(<RoleAdminChanged as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleAdminChanged as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleAdminChanged)
                }
                Some(<RoleGranted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleGranted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleGranted)
                }
                Some(<RoleRevoked as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <RoleRevoked as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::RoleRevoked)
                }
                Some(<ServiceActivated as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ServiceActivated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ServiceActivated)
                }
                Some(<ServiceApproved as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ServiceApproved as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ServiceApproved)
                }
                Some(<ServiceRejected as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ServiceRejected as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ServiceRejected)
                }
                Some(<ServiceRequested as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <ServiceRequested as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ServiceRequested)
                }
                Some(
                    <ServiceRequestedWithSecurity as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ServiceRequestedWithSecurity as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ServiceRequestedWithSecurity)
                }
                Some(
                    <ServiceTerminated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <ServiceTerminated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::ServiceTerminated)
                }
                Some(<SlashCancelled as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SlashCancelled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SlashCancelled)
                }
                Some(
                    <SlashConfigUpdated as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SlashConfigUpdated as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SlashConfigUpdated)
                }
                Some(<SlashDisputed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SlashDisputed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SlashDisputed)
                }
                Some(<SlashExecuted as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SlashExecuted as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SlashExecuted)
                }
                Some(<SlashProposed as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <SlashProposed as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SlashProposed)
                }
                Some(
                    <SubscriptionBilled as alloy_sol_types::SolEvent>::SIGNATURE_HASH,
                ) => {
                    <SubscriptionBilled as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::SubscriptionBilled)
                }
                Some(<Unpaused as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Unpaused as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Unpaused)
                }
                Some(<Upgraded as alloy_sol_types::SolEvent>::SIGNATURE_HASH) => {
                    <Upgraded as alloy_sol_types::SolEvent>::decode_raw_log(
                            topics,
                            data,
                            validate,
                        )
                        .map(Self::Upgraded)
                }
                _ => {
                    alloy_sol_types::private::Err(alloy_sol_types::Error::InvalidLog {
                        name: <Self as alloy_sol_types::SolEventInterface>::NAME,
                        log: alloy_sol_types::private::Box::new(
                            alloy_sol_types::private::LogData::new_unchecked(
                                topics.to_vec(),
                                data.to_vec().into(),
                            ),
                        ),
                    })
                }
            }
        }
    }
    #[automatically_derived]
    impl alloy_sol_types::private::IntoLogData for TangleEvents {
        fn to_log_data(&self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AggregatedResultSubmitted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlueprintCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlueprintDeactivated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlueprintTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::BlueprintUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::EscrowFunded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::JobCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::JobResultSubmitted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::JobSubmitted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorJoinedService(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorLeftService(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorPreRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorPreferencesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorRpcAddressUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::OperatorUnregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::QuoteUsed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RewardsClaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ServiceActivated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ServiceApproved(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ServiceRejected(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ServiceRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ServiceRequestedWithSecurity(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::ServiceTerminated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SlashCancelled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SlashConfigUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SlashDisputed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SlashExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SlashProposed(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::SubscriptionBilled(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::to_log_data(inner)
                }
            }
        }
        fn into_log_data(self) -> alloy_sol_types::private::LogData {
            match self {
                Self::AggregatedResultSubmitted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlueprintCreated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlueprintDeactivated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlueprintTransferred(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::BlueprintUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::EscrowFunded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Initialized(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::JobCompleted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::JobResultSubmitted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::JobSubmitted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorJoinedService(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorLeftService(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorPreRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorPreferencesUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorRegistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorRpcAddressUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::OperatorUnregistered(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Paused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::QuoteUsed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RewardsClaimed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleAdminChanged(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleGranted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::RoleRevoked(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ServiceActivated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ServiceApproved(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ServiceRejected(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ServiceRequested(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ServiceRequestedWithSecurity(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::ServiceTerminated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SlashCancelled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SlashConfigUpdated(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SlashDisputed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SlashExecuted(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SlashProposed(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::SubscriptionBilled(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Unpaused(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
                Self::Upgraded(inner) => {
                    alloy_sol_types::private::IntoLogData::into_log_data(inner)
                }
            }
        }
    }
    use alloy::contract as alloy_contract;
    /**Creates a new wrapper around an on-chain [`Tangle`](self) contract instance.

See the [wrapper's documentation](`TangleInstance`) for more details.*/
    #[inline]
    pub const fn new<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        address: alloy_sol_types::private::Address,
        provider: P,
    ) -> TangleInstance<T, P, N> {
        TangleInstance::<T, P, N>::new(address, provider)
    }
    /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
    #[inline]
    pub fn deploy<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(
        provider: P,
    ) -> impl ::core::future::Future<
        Output = alloy_contract::Result<TangleInstance<T, P, N>>,
    > {
        TangleInstance::<T, P, N>::deploy(provider)
    }
    /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
    #[inline]
    pub fn deploy_builder<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    >(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
        TangleInstance::<T, P, N>::deploy_builder(provider)
    }
    /**A [`Tangle`](self) instance.

Contains type-safe methods for interacting with an on-chain instance of the
[`Tangle`](self) contract located at a given `address`, using a given
provider `P`.

If the contract bytecode is available (see the [`sol!`](alloy_sol_types::sol!)
documentation on how to provide it), the `deploy` and `deploy_builder` methods can
be used to deploy a new instance of the contract.

See the [module-level documentation](self) for all the available methods.*/
    #[derive(Clone)]
    pub struct TangleInstance<T, P, N = alloy_contract::private::Ethereum> {
        address: alloy_sol_types::private::Address,
        provider: P,
        _network_transport: ::core::marker::PhantomData<(N, T)>,
    }
    #[automatically_derived]
    impl<T, P, N> ::core::fmt::Debug for TangleInstance<T, P, N> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
            f.debug_tuple("TangleInstance").field(&self.address).finish()
        }
    }
    /// Instantiation and getters/setters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TangleInstance<T, P, N> {
        /**Creates a new wrapper around an on-chain [`Tangle`](self) contract instance.

See the [wrapper's documentation](`TangleInstance`) for more details.*/
        #[inline]
        pub const fn new(
            address: alloy_sol_types::private::Address,
            provider: P,
        ) -> Self {
            Self {
                address,
                provider,
                _network_transport: ::core::marker::PhantomData,
            }
        }
        /**Deploys this contract using the given `provider` and constructor arguments, if any.

Returns a new instance of the contract, if the deployment was successful.

For more fine-grained control over the deployment process, use [`deploy_builder`] instead.*/
        #[inline]
        pub async fn deploy(
            provider: P,
        ) -> alloy_contract::Result<TangleInstance<T, P, N>> {
            let call_builder = Self::deploy_builder(provider);
            let contract_address = call_builder.deploy().await?;
            Ok(Self::new(contract_address, call_builder.provider))
        }
        /**Creates a `RawCallBuilder` for deploying this contract using the given `provider`
and constructor arguments, if any.

This is a simple wrapper around creating a `RawCallBuilder` with the data set to
the bytecode concatenated with the constructor's ABI-encoded arguments.*/
        #[inline]
        pub fn deploy_builder(provider: P) -> alloy_contract::RawCallBuilder<T, P, N> {
            alloy_contract::RawCallBuilder::new_raw_deploy(
                provider,
                ::core::clone::Clone::clone(&BYTECODE),
            )
        }
        /// Returns a reference to the address.
        #[inline]
        pub const fn address(&self) -> &alloy_sol_types::private::Address {
            &self.address
        }
        /// Sets the address.
        #[inline]
        pub fn set_address(&mut self, address: alloy_sol_types::private::Address) {
            self.address = address;
        }
        /// Sets the address and returns `self`.
        pub fn at(mut self, address: alloy_sol_types::private::Address) -> Self {
            self.set_address(address);
            self
        }
        /// Returns a reference to the provider.
        #[inline]
        pub const fn provider(&self) -> &P {
            &self.provider
        }
    }
    impl<T, P: ::core::clone::Clone, N> TangleInstance<T, &P, N> {
        /// Clones the provider and returns a new instance with the cloned provider.
        #[inline]
        pub fn with_cloned_provider(self) -> TangleInstance<T, P, N> {
            TangleInstance {
                address: self.address,
                provider: ::core::clone::Clone::clone(&self.provider),
                _network_transport: ::core::marker::PhantomData,
            }
        }
    }
    /// Function calls.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TangleInstance<T, P, N> {
        /// Creates a new call builder using this contract instance's provider and address.
        ///
        /// Note that the call can be any function call, not just those defined in this
        /// contract. Prefer using the other methods for building type-safe contract calls.
        pub fn call_builder<C: alloy_sol_types::SolCall>(
            &self,
            call: &C,
        ) -> alloy_contract::SolCallBuilder<T, &P, C, N> {
            alloy_contract::SolCallBuilder::new_sol(&self.provider, &self.address, call)
        }
        ///Creates a new call builder for the [`ADMIN_ROLE`] function.
        pub fn ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, ADMIN_ROLECall, N> {
            self.call_builder(&ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`DEFAULT_ADMIN_ROLE`] function.
        pub fn DEFAULT_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, DEFAULT_ADMIN_ROLECall, N> {
            self.call_builder(&DEFAULT_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`PAUSER_ROLE`] function.
        pub fn PAUSER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, PAUSER_ROLECall, N> {
            self.call_builder(&PAUSER_ROLECall {})
        }
        ///Creates a new call builder for the [`SLASH_ADMIN_ROLE`] function.
        pub fn SLASH_ADMIN_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, SLASH_ADMIN_ROLECall, N> {
            self.call_builder(&SLASH_ADMIN_ROLECall {})
        }
        ///Creates a new call builder for the [`UPGRADER_ROLE`] function.
        pub fn UPGRADER_ROLE(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UPGRADER_ROLECall, N> {
            self.call_builder(&UPGRADER_ROLECall {})
        }
        ///Creates a new call builder for the [`UPGRADE_INTERFACE_VERSION`] function.
        pub fn UPGRADE_INTERFACE_VERSION(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, UPGRADE_INTERFACE_VERSIONCall, N> {
            self.call_builder(&UPGRADE_INTERFACE_VERSIONCall {})
        }
        ///Creates a new call builder for the [`addPermittedCaller`] function.
        pub fn addPermittedCaller(
            &self,
            serviceId: u64,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, addPermittedCallerCall, N> {
            self.call_builder(
                &addPermittedCallerCall {
                    serviceId,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`approveService`] function.
        pub fn approveService(
            &self,
            requestId: u64,
            restakingPercent: u8,
        ) -> alloy_contract::SolCallBuilder<T, &P, approveServiceCall, N> {
            self.call_builder(
                &approveServiceCall {
                    requestId,
                    restakingPercent,
                },
            )
        }
        ///Creates a new call builder for the [`approveServiceWithCommitments`] function.
        pub fn approveServiceWithCommitments(
            &self,
            requestId: u64,
            commitments: alloy::sol_types::private::Vec<
                <Types::AssetSecurityCommitment as alloy::sol_types::SolType>::RustType,
            >,
        ) -> alloy_contract::SolCallBuilder<
            T,
            &P,
            approveServiceWithCommitmentsCall,
            N,
        > {
            self.call_builder(
                &approveServiceWithCommitmentsCall {
                    requestId,
                    commitments,
                },
            )
        }
        ///Creates a new call builder for the [`billSubscription`] function.
        pub fn billSubscription(
            &self,
            serviceId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, billSubscriptionCall, N> {
            self.call_builder(&billSubscriptionCall { serviceId })
        }
        ///Creates a new call builder for the [`billSubscriptionBatch`] function.
        pub fn billSubscriptionBatch(
            &self,
            serviceIds: alloy::sol_types::private::Vec<u64>,
        ) -> alloy_contract::SolCallBuilder<T, &P, billSubscriptionBatchCall, N> {
            self.call_builder(
                &billSubscriptionBatchCall {
                    serviceIds,
                },
            )
        }
        ///Creates a new call builder for the [`blueprintCount`] function.
        pub fn blueprintCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, blueprintCountCall, N> {
            self.call_builder(&blueprintCountCall {})
        }
        ///Creates a new call builder for the [`blueprintOperatorCount`] function.
        pub fn blueprintOperatorCount(
            &self,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, blueprintOperatorCountCall, N> {
            self.call_builder(
                &blueprintOperatorCountCall {
                    blueprintId,
                },
            )
        }
        ///Creates a new call builder for the [`cancelSlash`] function.
        pub fn cancelSlash(
            &self,
            slashId: u64,
            reason: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, cancelSlashCall, N> {
            self.call_builder(&cancelSlashCall { slashId, reason })
        }
        ///Creates a new call builder for the [`claimRewards_0`] function.
        pub fn claimRewards_0(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimRewards_0Call, N> {
            self.call_builder(&claimRewards_0Call {})
        }
        ///Creates a new call builder for the [`claimRewards_1`] function.
        pub fn claimRewards_1(
            &self,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, claimRewards_1Call, N> {
            self.call_builder(&claimRewards_1Call { token })
        }
        ///Creates a new call builder for the [`createBlueprint`] function.
        pub fn createBlueprint(
            &self,
            metadataUri: alloy::sol_types::private::String,
            manager: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, createBlueprintCall, N> {
            self.call_builder(
                &createBlueprintCall {
                    metadataUri,
                    manager,
                },
            )
        }
        ///Creates a new call builder for the [`createBlueprintWithConfig`] function.
        pub fn createBlueprintWithConfig(
            &self,
            metadataUri: alloy::sol_types::private::String,
            manager: alloy::sol_types::private::Address,
            config: <Types::BlueprintConfig as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, createBlueprintWithConfigCall, N> {
            self.call_builder(
                &createBlueprintWithConfigCall {
                    metadataUri,
                    manager,
                    config,
                },
            )
        }
        ///Creates a new call builder for the [`createServiceFromQuotes`] function.
        pub fn createServiceFromQuotes(
            &self,
            blueprintId: u64,
            quotes: alloy::sol_types::private::Vec<
                <Types::SignedQuote as alloy::sol_types::SolType>::RustType,
            >,
            config: alloy::sol_types::private::Bytes,
            permittedCallers: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            ttl: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, createServiceFromQuotesCall, N> {
            self.call_builder(
                &createServiceFromQuotesCall {
                    blueprintId,
                    quotes,
                    config,
                    permittedCallers,
                    ttl,
                },
            )
        }
        ///Creates a new call builder for the [`deactivateBlueprint`] function.
        pub fn deactivateBlueprint(
            &self,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, deactivateBlueprintCall, N> {
            self.call_builder(
                &deactivateBlueprintCall {
                    blueprintId,
                },
            )
        }
        ///Creates a new call builder for the [`disputeSlash`] function.
        pub fn disputeSlash(
            &self,
            slashId: u64,
            reason: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, disputeSlashCall, N> {
            self.call_builder(
                &disputeSlashCall {
                    slashId,
                    reason,
                },
            )
        }
        ///Creates a new call builder for the [`executeSlash`] function.
        pub fn executeSlash(
            &self,
            slashId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, executeSlashCall, N> {
            self.call_builder(&executeSlashCall { slashId })
        }
        ///Creates a new call builder for the [`executeSlashBatch`] function.
        pub fn executeSlashBatch(
            &self,
            slashIds: alloy::sol_types::private::Vec<u64>,
        ) -> alloy_contract::SolCallBuilder<T, &P, executeSlashBatchCall, N> {
            self.call_builder(&executeSlashBatchCall { slashIds })
        }
        ///Creates a new call builder for the [`fundService`] function.
        pub fn fundService(
            &self,
            serviceId: u64,
            amount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, fundServiceCall, N> {
            self.call_builder(
                &fundServiceCall {
                    serviceId,
                    amount,
                },
            )
        }
        ///Creates a new call builder for the [`getBillableServices`] function.
        pub fn getBillableServices(
            &self,
            serviceIds: alloy::sol_types::private::Vec<u64>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBillableServicesCall, N> {
            self.call_builder(
                &getBillableServicesCall {
                    serviceIds,
                },
            )
        }
        ///Creates a new call builder for the [`getBlueprint`] function.
        pub fn getBlueprint(
            &self,
            id: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBlueprintCall, N> {
            self.call_builder(&getBlueprintCall { id })
        }
        ///Creates a new call builder for the [`getBlueprintConfig`] function.
        pub fn getBlueprintConfig(
            &self,
            id: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getBlueprintConfigCall, N> {
            self.call_builder(&getBlueprintConfigCall { id })
        }
        ///Creates a new call builder for the [`getExecutableSlashes`] function.
        pub fn getExecutableSlashes(
            &self,
            fromId: u64,
            toId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getExecutableSlashesCall, N> {
            self.call_builder(
                &getExecutableSlashesCall {
                    fromId,
                    toId,
                },
            )
        }
        ///Creates a new call builder for the [`getJobCall`] function.
        pub fn getJobCall(
            &self,
            serviceId: u64,
            callId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getJobCallCall, N> {
            self.call_builder(
                &getJobCallCall {
                    serviceId,
                    callId,
                },
            )
        }
        ///Creates a new call builder for the [`getOperatorRegistration`] function.
        pub fn getOperatorRegistration(
            &self,
            blueprintId: u64,
            op: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getOperatorRegistrationCall, N> {
            self.call_builder(
                &getOperatorRegistrationCall {
                    blueprintId,
                    op,
                },
            )
        }
        ///Creates a new call builder for the [`getRoleAdmin`] function.
        pub fn getRoleAdmin(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, getRoleAdminCall, N> {
            self.call_builder(&getRoleAdminCall { role })
        }
        ///Creates a new call builder for the [`getService`] function.
        pub fn getService(
            &self,
            id: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getServiceCall, N> {
            self.call_builder(&getServiceCall { id })
        }
        ///Creates a new call builder for the [`getServiceEscrow`] function.
        pub fn getServiceEscrow(
            &self,
            serviceId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getServiceEscrowCall, N> {
            self.call_builder(&getServiceEscrowCall { serviceId })
        }
        ///Creates a new call builder for the [`getServiceOperator`] function.
        pub fn getServiceOperator(
            &self,
            serviceId: u64,
            op: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, getServiceOperatorCall, N> {
            self.call_builder(
                &getServiceOperatorCall {
                    serviceId,
                    op,
                },
            )
        }
        ///Creates a new call builder for the [`getServiceOperators`] function.
        pub fn getServiceOperators(
            &self,
            serviceId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getServiceOperatorsCall, N> {
            self.call_builder(
                &getServiceOperatorsCall {
                    serviceId,
                },
            )
        }
        ///Creates a new call builder for the [`getServiceRequest`] function.
        pub fn getServiceRequest(
            &self,
            id: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getServiceRequestCall, N> {
            self.call_builder(&getServiceRequestCall { id })
        }
        ///Creates a new call builder for the [`getSlashProposal`] function.
        pub fn getSlashProposal(
            &self,
            slashId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, getSlashProposalCall, N> {
            self.call_builder(&getSlashProposalCall { slashId })
        }
        ///Creates a new call builder for the [`grantRole`] function.
        pub fn grantRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, grantRoleCall, N> {
            self.call_builder(&grantRoleCall { role, account })
        }
        ///Creates a new call builder for the [`hasRole`] function.
        pub fn hasRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, hasRoleCall, N> {
            self.call_builder(&hasRoleCall { role, account })
        }
        ///Creates a new call builder for the [`initialize`] function.
        pub fn initialize(
            &self,
            admin: alloy::sol_types::private::Address,
            restaking_: alloy::sol_types::private::Address,
            treasury_: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, initializeCall, N> {
            self.call_builder(
                &initializeCall {
                    admin,
                    restaking_,
                    treasury_,
                },
            )
        }
        ///Creates a new call builder for the [`isOperatorRegistered`] function.
        pub fn isOperatorRegistered(
            &self,
            blueprintId: u64,
            op: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isOperatorRegisteredCall, N> {
            self.call_builder(
                &isOperatorRegisteredCall {
                    blueprintId,
                    op,
                },
            )
        }
        ///Creates a new call builder for the [`isPermittedCaller`] function.
        pub fn isPermittedCaller(
            &self,
            serviceId: u64,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isPermittedCallerCall, N> {
            self.call_builder(
                &isPermittedCallerCall {
                    serviceId,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`isServiceActive`] function.
        pub fn isServiceActive(
            &self,
            serviceId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, isServiceActiveCall, N> {
            self.call_builder(&isServiceActiveCall { serviceId })
        }
        ///Creates a new call builder for the [`isServiceOperator`] function.
        pub fn isServiceOperator(
            &self,
            serviceId: u64,
            op: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, isServiceOperatorCall, N> {
            self.call_builder(
                &isServiceOperatorCall {
                    serviceId,
                    op,
                },
            )
        }
        ///Creates a new call builder for the [`joinService`] function.
        pub fn joinService(
            &self,
            serviceId: u64,
            exposureBps: u16,
        ) -> alloy_contract::SolCallBuilder<T, &P, joinServiceCall, N> {
            self.call_builder(
                &joinServiceCall {
                    serviceId,
                    exposureBps,
                },
            )
        }
        ///Creates a new call builder for the [`leaveService`] function.
        pub fn leaveService(
            &self,
            serviceId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, leaveServiceCall, N> {
            self.call_builder(&leaveServiceCall { serviceId })
        }
        ///Creates a new call builder for the [`metricsRecorder`] function.
        pub fn metricsRecorder(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, metricsRecorderCall, N> {
            self.call_builder(&metricsRecorderCall {})
        }
        ///Creates a new call builder for the [`operatorStatusRegistry`] function.
        pub fn operatorStatusRegistry(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, operatorStatusRegistryCall, N> {
            self.call_builder(&operatorStatusRegistryCall {})
        }
        ///Creates a new call builder for the [`pause`] function.
        pub fn pause(&self) -> alloy_contract::SolCallBuilder<T, &P, pauseCall, N> {
            self.call_builder(&pauseCall {})
        }
        ///Creates a new call builder for the [`paused`] function.
        pub fn paused(&self) -> alloy_contract::SolCallBuilder<T, &P, pausedCall, N> {
            self.call_builder(&pausedCall {})
        }
        ///Creates a new call builder for the [`paymentSplit`] function.
        pub fn paymentSplit(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, paymentSplitCall, N> {
            self.call_builder(&paymentSplitCall {})
        }
        ///Creates a new call builder for the [`pendingRewards_0`] function.
        pub fn pendingRewards_0(
            &self,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingRewards_0Call, N> {
            self.call_builder(&pendingRewards_0Call { account })
        }
        ///Creates a new call builder for the [`pendingRewards_1`] function.
        pub fn pendingRewards_1(
            &self,
            account: alloy::sol_types::private::Address,
            token: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, pendingRewards_1Call, N> {
            self.call_builder(
                &pendingRewards_1Call {
                    account,
                    token,
                },
            )
        }
        ///Creates a new call builder for the [`preRegister`] function.
        pub fn preRegister(
            &self,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, preRegisterCall, N> {
            self.call_builder(&preRegisterCall { blueprintId })
        }
        ///Creates a new call builder for the [`proposeSlash`] function.
        pub fn proposeSlash(
            &self,
            serviceId: u64,
            operator: alloy::sol_types::private::Address,
            amount: alloy::sol_types::private::primitives::aliases::U256,
            evidence: alloy::sol_types::private::FixedBytes<32>,
        ) -> alloy_contract::SolCallBuilder<T, &P, proposeSlashCall, N> {
            self.call_builder(
                &proposeSlashCall {
                    serviceId,
                    operator,
                    amount,
                    evidence,
                },
            )
        }
        ///Creates a new call builder for the [`proxiableUUID`] function.
        pub fn proxiableUUID(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, proxiableUUIDCall, N> {
            self.call_builder(&proxiableUUIDCall {})
        }
        ///Creates a new call builder for the [`registerOperator`] function.
        pub fn registerOperator(
            &self,
            blueprintId: u64,
            preferences: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, registerOperatorCall, N> {
            self.call_builder(
                &registerOperatorCall {
                    blueprintId,
                    preferences,
                },
            )
        }
        ///Creates a new call builder for the [`rejectService`] function.
        pub fn rejectService(
            &self,
            requestId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, rejectServiceCall, N> {
            self.call_builder(&rejectServiceCall { requestId })
        }
        ///Creates a new call builder for the [`removePermittedCaller`] function.
        pub fn removePermittedCaller(
            &self,
            serviceId: u64,
            caller: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, removePermittedCallerCall, N> {
            self.call_builder(
                &removePermittedCallerCall {
                    serviceId,
                    caller,
                },
            )
        }
        ///Creates a new call builder for the [`renounceRole`] function.
        pub fn renounceRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            callerConfirmation: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, renounceRoleCall, N> {
            self.call_builder(
                &renounceRoleCall {
                    role,
                    callerConfirmation,
                },
            )
        }
        ///Creates a new call builder for the [`requestService`] function.
        pub fn requestService(
            &self,
            blueprintId: u64,
            operators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            config: alloy::sol_types::private::Bytes,
            permittedCallers: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            ttl: u64,
            paymentToken: alloy::sol_types::private::Address,
            paymentAmount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, requestServiceCall, N> {
            self.call_builder(
                &requestServiceCall {
                    blueprintId,
                    operators,
                    config,
                    permittedCallers,
                    ttl,
                    paymentToken,
                    paymentAmount,
                },
            )
        }
        ///Creates a new call builder for the [`requestServiceWithExposure`] function.
        pub fn requestServiceWithExposure(
            &self,
            blueprintId: u64,
            operators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            exposures: alloy::sol_types::private::Vec<u16>,
            config: alloy::sol_types::private::Bytes,
            permittedCallers: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            ttl: u64,
            paymentToken: alloy::sol_types::private::Address,
            paymentAmount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, requestServiceWithExposureCall, N> {
            self.call_builder(
                &requestServiceWithExposureCall {
                    blueprintId,
                    operators,
                    exposures,
                    config,
                    permittedCallers,
                    ttl,
                    paymentToken,
                    paymentAmount,
                },
            )
        }
        ///Creates a new call builder for the [`requestServiceWithSecurity`] function.
        pub fn requestServiceWithSecurity(
            &self,
            blueprintId: u64,
            operators: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            securityRequirements: alloy::sol_types::private::Vec<
                <Types::AssetSecurityRequirement as alloy::sol_types::SolType>::RustType,
            >,
            config: alloy::sol_types::private::Bytes,
            permittedCallers: alloy::sol_types::private::Vec<
                alloy::sol_types::private::Address,
            >,
            ttl: u64,
            paymentToken: alloy::sol_types::private::Address,
            paymentAmount: alloy::sol_types::private::primitives::aliases::U256,
        ) -> alloy_contract::SolCallBuilder<T, &P, requestServiceWithSecurityCall, N> {
            self.call_builder(
                &requestServiceWithSecurityCall {
                    blueprintId,
                    operators,
                    securityRequirements,
                    config,
                    permittedCallers,
                    ttl,
                    paymentToken,
                    paymentAmount,
                },
            )
        }
        ///Creates a new call builder for the [`revokeRole`] function.
        pub fn revokeRole(
            &self,
            role: alloy::sol_types::private::FixedBytes<32>,
            account: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, revokeRoleCall, N> {
            self.call_builder(&revokeRoleCall { role, account })
        }
        ///Creates a new call builder for the [`serviceCount`] function.
        pub fn serviceCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, serviceCountCall, N> {
            self.call_builder(&serviceCountCall {})
        }
        ///Creates a new call builder for the [`serviceRequestCount`] function.
        pub fn serviceRequestCount(
            &self,
        ) -> alloy_contract::SolCallBuilder<T, &P, serviceRequestCountCall, N> {
            self.call_builder(&serviceRequestCountCall {})
        }
        ///Creates a new call builder for the [`setMetricsRecorder`] function.
        pub fn setMetricsRecorder(
            &self,
            recorder: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setMetricsRecorderCall, N> {
            self.call_builder(&setMetricsRecorderCall { recorder })
        }
        ///Creates a new call builder for the [`setOperatorStatusRegistry`] function.
        pub fn setOperatorStatusRegistry(
            &self,
            registry: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setOperatorStatusRegistryCall, N> {
            self.call_builder(
                &setOperatorStatusRegistryCall {
                    registry,
                },
            )
        }
        ///Creates a new call builder for the [`setPaymentSplit`] function.
        pub fn setPaymentSplit(
            &self,
            split: <Types::PaymentSplit as alloy::sol_types::SolType>::RustType,
        ) -> alloy_contract::SolCallBuilder<T, &P, setPaymentSplitCall, N> {
            self.call_builder(&setPaymentSplitCall { split })
        }
        ///Creates a new call builder for the [`setSlashConfig`] function.
        pub fn setSlashConfig(
            &self,
            disputeWindow: u64,
            instantSlashEnabled: bool,
            maxSlashBps: u16,
        ) -> alloy_contract::SolCallBuilder<T, &P, setSlashConfigCall, N> {
            self.call_builder(
                &setSlashConfigCall {
                    disputeWindow,
                    instantSlashEnabled,
                    maxSlashBps,
                },
            )
        }
        ///Creates a new call builder for the [`setTreasury`] function.
        pub fn setTreasury(
            &self,
            treasury_: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, setTreasuryCall, N> {
            self.call_builder(&setTreasuryCall { treasury_ })
        }
        ///Creates a new call builder for the [`submitAggregatedResult`] function.
        pub fn submitAggregatedResult(
            &self,
            serviceId: u64,
            callId: u64,
            output: alloy::sol_types::private::Bytes,
            signerBitmap: alloy::sol_types::private::primitives::aliases::U256,
            aggregatedSignature: [alloy::sol_types::private::primitives::aliases::U256; 2usize],
            aggregatedPubkey: [alloy::sol_types::private::primitives::aliases::U256; 4usize],
        ) -> alloy_contract::SolCallBuilder<T, &P, submitAggregatedResultCall, N> {
            self.call_builder(
                &submitAggregatedResultCall {
                    serviceId,
                    callId,
                    output,
                    signerBitmap,
                    aggregatedSignature,
                    aggregatedPubkey,
                },
            )
        }
        ///Creates a new call builder for the [`submitJob`] function.
        pub fn submitJob(
            &self,
            serviceId: u64,
            jobIndex: u8,
            inputs: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitJobCall, N> {
            self.call_builder(
                &submitJobCall {
                    serviceId,
                    jobIndex,
                    inputs,
                },
            )
        }
        ///Creates a new call builder for the [`submitResult`] function.
        pub fn submitResult(
            &self,
            serviceId: u64,
            callId: u64,
            output: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitResultCall, N> {
            self.call_builder(
                &submitResultCall {
                    serviceId,
                    callId,
                    output,
                },
            )
        }
        ///Creates a new call builder for the [`submitResults`] function.
        pub fn submitResults(
            &self,
            serviceId: u64,
            callIds: alloy::sol_types::private::Vec<u64>,
            outputs: alloy::sol_types::private::Vec<alloy::sol_types::private::Bytes>,
        ) -> alloy_contract::SolCallBuilder<T, &P, submitResultsCall, N> {
            self.call_builder(
                &submitResultsCall {
                    serviceId,
                    callIds,
                    outputs,
                },
            )
        }
        ///Creates a new call builder for the [`supportsInterface`] function.
        pub fn supportsInterface(
            &self,
            interfaceId: alloy::sol_types::private::FixedBytes<4>,
        ) -> alloy_contract::SolCallBuilder<T, &P, supportsInterfaceCall, N> {
            self.call_builder(
                &supportsInterfaceCall {
                    interfaceId,
                },
            )
        }
        ///Creates a new call builder for the [`terminateService`] function.
        pub fn terminateService(
            &self,
            serviceId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, terminateServiceCall, N> {
            self.call_builder(&terminateServiceCall { serviceId })
        }
        ///Creates a new call builder for the [`transferBlueprint`] function.
        pub fn transferBlueprint(
            &self,
            blueprintId: u64,
            newOwner: alloy::sol_types::private::Address,
        ) -> alloy_contract::SolCallBuilder<T, &P, transferBlueprintCall, N> {
            self.call_builder(
                &transferBlueprintCall {
                    blueprintId,
                    newOwner,
                },
            )
        }
        ///Creates a new call builder for the [`unpause`] function.
        pub fn unpause(&self) -> alloy_contract::SolCallBuilder<T, &P, unpauseCall, N> {
            self.call_builder(&unpauseCall {})
        }
        ///Creates a new call builder for the [`unregisterOperator`] function.
        pub fn unregisterOperator(
            &self,
            blueprintId: u64,
        ) -> alloy_contract::SolCallBuilder<T, &P, unregisterOperatorCall, N> {
            self.call_builder(
                &unregisterOperatorCall {
                    blueprintId,
                },
            )
        }
        ///Creates a new call builder for the [`updateBlueprint`] function.
        pub fn updateBlueprint(
            &self,
            blueprintId: u64,
            metadataUri: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateBlueprintCall, N> {
            self.call_builder(
                &updateBlueprintCall {
                    blueprintId,
                    metadataUri,
                },
            )
        }
        ///Creates a new call builder for the [`updateOperatorPreferences`] function.
        pub fn updateOperatorPreferences(
            &self,
            blueprintId: u64,
            preferences: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateOperatorPreferencesCall, N> {
            self.call_builder(
                &updateOperatorPreferencesCall {
                    blueprintId,
                    preferences,
                },
            )
        }
        ///Creates a new call builder for the [`updateRpcAddress`] function.
        pub fn updateRpcAddress(
            &self,
            blueprintId: u64,
            rpcAddress: alloy::sol_types::private::String,
        ) -> alloy_contract::SolCallBuilder<T, &P, updateRpcAddressCall, N> {
            self.call_builder(
                &updateRpcAddressCall {
                    blueprintId,
                    rpcAddress,
                },
            )
        }
        ///Creates a new call builder for the [`upgradeToAndCall`] function.
        pub fn upgradeToAndCall(
            &self,
            newImplementation: alloy::sol_types::private::Address,
            data: alloy::sol_types::private::Bytes,
        ) -> alloy_contract::SolCallBuilder<T, &P, upgradeToAndCallCall, N> {
            self.call_builder(
                &upgradeToAndCallCall {
                    newImplementation,
                    data,
                },
            )
        }
    }
    /// Event filters.
    #[automatically_derived]
    impl<
        T: alloy_contract::private::Transport + ::core::clone::Clone,
        P: alloy_contract::private::Provider<T, N>,
        N: alloy_contract::private::Network,
    > TangleInstance<T, P, N> {
        /// Creates a new event filter using this contract instance's provider and address.
        ///
        /// Note that the type can be any event, not just those defined in this contract.
        /// Prefer using the other methods for building type-safe event filters.
        pub fn event_filter<E: alloy_sol_types::SolEvent>(
            &self,
        ) -> alloy_contract::Event<T, &P, E, N> {
            alloy_contract::Event::new_sol(&self.provider, &self.address)
        }
        ///Creates a new event filter for the [`AggregatedResultSubmitted`] event.
        pub fn AggregatedResultSubmitted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, AggregatedResultSubmitted, N> {
            self.event_filter::<AggregatedResultSubmitted>()
        }
        ///Creates a new event filter for the [`BlueprintCreated`] event.
        pub fn BlueprintCreated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BlueprintCreated, N> {
            self.event_filter::<BlueprintCreated>()
        }
        ///Creates a new event filter for the [`BlueprintDeactivated`] event.
        pub fn BlueprintDeactivated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BlueprintDeactivated, N> {
            self.event_filter::<BlueprintDeactivated>()
        }
        ///Creates a new event filter for the [`BlueprintTransferred`] event.
        pub fn BlueprintTransferred_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BlueprintTransferred, N> {
            self.event_filter::<BlueprintTransferred>()
        }
        ///Creates a new event filter for the [`BlueprintUpdated`] event.
        pub fn BlueprintUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, BlueprintUpdated, N> {
            self.event_filter::<BlueprintUpdated>()
        }
        ///Creates a new event filter for the [`EscrowFunded`] event.
        pub fn EscrowFunded_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, EscrowFunded, N> {
            self.event_filter::<EscrowFunded>()
        }
        ///Creates a new event filter for the [`Initialized`] event.
        pub fn Initialized_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, Initialized, N> {
            self.event_filter::<Initialized>()
        }
        ///Creates a new event filter for the [`JobCompleted`] event.
        pub fn JobCompleted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, JobCompleted, N> {
            self.event_filter::<JobCompleted>()
        }
        ///Creates a new event filter for the [`JobResultSubmitted`] event.
        pub fn JobResultSubmitted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, JobResultSubmitted, N> {
            self.event_filter::<JobResultSubmitted>()
        }
        ///Creates a new event filter for the [`JobSubmitted`] event.
        pub fn JobSubmitted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, JobSubmitted, N> {
            self.event_filter::<JobSubmitted>()
        }
        ///Creates a new event filter for the [`OperatorJoinedService`] event.
        pub fn OperatorJoinedService_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorJoinedService, N> {
            self.event_filter::<OperatorJoinedService>()
        }
        ///Creates a new event filter for the [`OperatorLeftService`] event.
        pub fn OperatorLeftService_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorLeftService, N> {
            self.event_filter::<OperatorLeftService>()
        }
        ///Creates a new event filter for the [`OperatorPreRegistered`] event.
        pub fn OperatorPreRegistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorPreRegistered, N> {
            self.event_filter::<OperatorPreRegistered>()
        }
        ///Creates a new event filter for the [`OperatorPreferencesUpdated`] event.
        pub fn OperatorPreferencesUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorPreferencesUpdated, N> {
            self.event_filter::<OperatorPreferencesUpdated>()
        }
        ///Creates a new event filter for the [`OperatorRegistered`] event.
        pub fn OperatorRegistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorRegistered, N> {
            self.event_filter::<OperatorRegistered>()
        }
        ///Creates a new event filter for the [`OperatorRpcAddressUpdated`] event.
        pub fn OperatorRpcAddressUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorRpcAddressUpdated, N> {
            self.event_filter::<OperatorRpcAddressUpdated>()
        }
        ///Creates a new event filter for the [`OperatorUnregistered`] event.
        pub fn OperatorUnregistered_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, OperatorUnregistered, N> {
            self.event_filter::<OperatorUnregistered>()
        }
        ///Creates a new event filter for the [`Paused`] event.
        pub fn Paused_filter(&self) -> alloy_contract::Event<T, &P, Paused, N> {
            self.event_filter::<Paused>()
        }
        ///Creates a new event filter for the [`QuoteUsed`] event.
        pub fn QuoteUsed_filter(&self) -> alloy_contract::Event<T, &P, QuoteUsed, N> {
            self.event_filter::<QuoteUsed>()
        }
        ///Creates a new event filter for the [`RewardsClaimed`] event.
        pub fn RewardsClaimed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RewardsClaimed, N> {
            self.event_filter::<RewardsClaimed>()
        }
        ///Creates a new event filter for the [`RoleAdminChanged`] event.
        pub fn RoleAdminChanged_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleAdminChanged, N> {
            self.event_filter::<RoleAdminChanged>()
        }
        ///Creates a new event filter for the [`RoleGranted`] event.
        pub fn RoleGranted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleGranted, N> {
            self.event_filter::<RoleGranted>()
        }
        ///Creates a new event filter for the [`RoleRevoked`] event.
        pub fn RoleRevoked_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, RoleRevoked, N> {
            self.event_filter::<RoleRevoked>()
        }
        ///Creates a new event filter for the [`ServiceActivated`] event.
        pub fn ServiceActivated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ServiceActivated, N> {
            self.event_filter::<ServiceActivated>()
        }
        ///Creates a new event filter for the [`ServiceApproved`] event.
        pub fn ServiceApproved_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ServiceApproved, N> {
            self.event_filter::<ServiceApproved>()
        }
        ///Creates a new event filter for the [`ServiceRejected`] event.
        pub fn ServiceRejected_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ServiceRejected, N> {
            self.event_filter::<ServiceRejected>()
        }
        ///Creates a new event filter for the [`ServiceRequested`] event.
        pub fn ServiceRequested_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ServiceRequested, N> {
            self.event_filter::<ServiceRequested>()
        }
        ///Creates a new event filter for the [`ServiceRequestedWithSecurity`] event.
        pub fn ServiceRequestedWithSecurity_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ServiceRequestedWithSecurity, N> {
            self.event_filter::<ServiceRequestedWithSecurity>()
        }
        ///Creates a new event filter for the [`ServiceTerminated`] event.
        pub fn ServiceTerminated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, ServiceTerminated, N> {
            self.event_filter::<ServiceTerminated>()
        }
        ///Creates a new event filter for the [`SlashCancelled`] event.
        pub fn SlashCancelled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SlashCancelled, N> {
            self.event_filter::<SlashCancelled>()
        }
        ///Creates a new event filter for the [`SlashConfigUpdated`] event.
        pub fn SlashConfigUpdated_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SlashConfigUpdated, N> {
            self.event_filter::<SlashConfigUpdated>()
        }
        ///Creates a new event filter for the [`SlashDisputed`] event.
        pub fn SlashDisputed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SlashDisputed, N> {
            self.event_filter::<SlashDisputed>()
        }
        ///Creates a new event filter for the [`SlashExecuted`] event.
        pub fn SlashExecuted_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SlashExecuted, N> {
            self.event_filter::<SlashExecuted>()
        }
        ///Creates a new event filter for the [`SlashProposed`] event.
        pub fn SlashProposed_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SlashProposed, N> {
            self.event_filter::<SlashProposed>()
        }
        ///Creates a new event filter for the [`SubscriptionBilled`] event.
        pub fn SubscriptionBilled_filter(
            &self,
        ) -> alloy_contract::Event<T, &P, SubscriptionBilled, N> {
            self.event_filter::<SubscriptionBilled>()
        }
        ///Creates a new event filter for the [`Unpaused`] event.
        pub fn Unpaused_filter(&self) -> alloy_contract::Event<T, &P, Unpaused, N> {
            self.event_filter::<Unpaused>()
        }
        ///Creates a new event filter for the [`Upgraded`] event.
        pub fn Upgraded_filter(&self) -> alloy_contract::Event<T, &P, Upgraded, N> {
            self.event_filter::<Upgraded>()
        }
    }
}
